
AVRASM ver. 2.1.2  Coding.asm Thu Jun 29 20:40:34 2006

Coding.asm(939): Including file 'Coding.vec'
Coding.asm(940): Including file 'Coding.inc'
Coding.inc(15): warning: Register r4 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(18): warning: Register r6 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(21): warning: Register r8 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(30): warning: Register r10 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(31): warning: Register r11 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(34): warning: Register r12 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(35): warning: Register r13 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(36): warning: Register r14 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
                 
                 
                 ;(C) Copyright 1998-2005 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Chip type              : ATmega128
                 ;Program type           : Application
                 ;Clock frequency        : 8,000000 MHz
                 ;Memory model           : Small
                 ;Optimize for           : Speed
                 ;(s)printf features     : int, width
                 ;(s)scanf features      : int, width
                 ;External SRAM size     : 0
                 ;Data Stack size        : 1024 byte(s)
                 ;Heap size              : 1112 byte(s)
                 ;Promote char to int    : No
                 ;char is unsigned       : Yes
                 ;8 bit enums            : No
                 ;Word align FLASH struct: No
                 ;Enhanced core instructions    : On
                 ;Automatic register allocation : On
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega128
                 	#pragma AVRPART MEMORY PROG_FLASH 131072
                 	#pragma AVRPART MEMORY EEPROM 4096
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU USR=0xB
                 	.EQU UDR=0xC
                 	.EQU SPSR=0xE
                 	.EQU SPDR=0xF
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU EECR=0x1C
                 	.EQU EEDR=0x1D
                 	.EQU EEARL=0x1E
                 	.EQU EEARH=0x1F
                 	.EQU WDTCR=0x21
                 	.EQU MCUCR=0x35
                 	.EQU RAMPZ=0x3B
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU XMCRA=0x6D
                 	.EQU XMCRB=0x6C
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __se_bit=0x20
                 	.EQU __sm_mask=0x1C
                 	.EQU __sm_adc_noise_red=0x08
                 	.EQU __sm_powerdown=0x10
                 	.EQU __sm_powersave=0x18
                 	.EQU __sm_standby=0x14
                 	.EQU __sm_ext_standby=0x1C
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	LDI  R30,0
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+@1)
                 	LDI  R31,HIGH(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+@1)
                 	LDI  R31,HIGH(2*@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+@1)
                 	LDI  R31,HIGH(2*@0+@1)
                 	LDI  R22,BYTE3(2*@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+@1)
                 	LDI  R27,HIGH(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+@2)
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+@3)
                 	LDI  R@1,HIGH(@2+@3)
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+@3)
                 	LDI  R@1,HIGH(@2*2+@3)
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+@1
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+@1
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+@1
                 	LDS  R31,@0+@1+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+@1
                 	LDS  R31,@0+@1+1
                 	LDS  R22,@0+@1+2
                 	LDS  R23,@0+@1+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+@2
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+@3
                 	LDS  R@1,@2+@3+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+@1
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+@1
                 	LDS  R27,@0+@1+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+@1
                 	LDS  R27,@0+@1+1
                 	LDS  R24,@0+@1+2
                 	LDS  R25,@0+@1+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+@1,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+@1,R30
                 	STS  @0+@1+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+@1,R30
                 	STS  @0+@1+1,R31
                 	STS  @0+@1+2,R22
                 	STS  @0+@1+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+@1,R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+@1,R@2
                 	STS  @0+@1+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+@1
                 	LDS  R31,@0+@1+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+@1)
                 	LDI  R31,HIGH(2*@0+@1)
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	LDI  R26,LOW(@0+@1)
                 	LDI  R27,HIGH(@0+@1)
                 	CALL __EEPROMRDW
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R26,SPL
                 	IN   R27,SPH
                 	ADIW R26,@0+1
                 	LD   R30,X+
                 	LD   R31,X
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	CLR  R0
                 	ST   Z+,R0
                 	ST   Z,R0
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	CLR  R0
                 	ST   Z+,R0
                 	ST   Z+,R0
                 	ST   Z+,R0
                 	ST   Z,R0
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.CSEG
                 	.ORG 0
                 
                 	.INCLUDE "Coding.vec"
                 
                 ;INTERRUPT VECTORS
000000 940c 010f 	JMP  __RESET
000002 940c 0000 	JMP  0x00
000004 940c 0000 	JMP  0x00
000006 940c 0000 	JMP  0x00
000008 940c 0000 	JMP  0x00
00000a 940c 0000 	JMP  0x00
00000c 940c 0000 	JMP  0x00
00000e 940c 0000 	JMP  0x00
000010 940c 0000 	JMP  0x00
000012 940c 0000 	JMP  0x00
000014 940c 0000 	JMP  0x00
000016 940c 0000 	JMP  0x00
000018 940c 032c 	JMP  _timer1_comp_a_isr
00001a 940c 0422 	JMP  _timer1_comp_b_isr
00001c 940c 0000 	JMP  0x00
00001e 940c 0000 	JMP  0x00
000020 940c 04ed 	JMP  _timer0_ovf_isr
000022 940c 0000 	JMP  0x00
000024 940c 02bf 	JMP  _uart_rx_isr
000026 940c 0000 	JMP  0x00
000028 940c 0000 	JMP  0x00
00002a 940c 0000 	JMP  0x00
00002c 940c 0000 	JMP  0x00
00002e 940c 0000 	JMP  0x00
000030 940c 0000 	JMP  0x00
000032 940c 0000 	JMP  0x00
000034 940c 0000 	JMP  0x00
000036 940c 0000 	JMP  0x00
000038 940c 0000 	JMP  0x00
00003a 940c 0000 	JMP  0x00
00003c 940c 0000 	JMP  0x00
00003e 940c 0000 	JMP  0x00
000040 940c 0000 	JMP  0x00
000042 940c 0000 	JMP  0x00
000044 940c 0000 	JMP  0x00
                 
                 	.INCLUDE "Coding.inc"
                 
                 _device_name:
000046 6f50
000047 7472
000048 4420
000049 7665      	.DB  0x50,0x6F,0x72,0x74,0x20,0x44,0x65,0x76
00004a 6369
00004b 2065
00004c 3176
00004d 302e      	.DB  0x69,0x63,0x65,0x20,0x76,0x31,0x2E,0x30
Coding.inc(5): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00004e 0000      	.DB  0x0
00004f 0000      	.DW  0x0
000050 0000      	.DW  0x0
000051 0000      	.DW  0x0
000052 0000      	.DW  0x0
000053 0000      	.DW  0x0
000054 0000      	.DW  0x0
000055 0000      	.DW  0x0
                 _my_version:
000056 0100      	.DB  0x0,0x1
                 	.DEF _str=R4
                 _3:
000057 0785      	.DW  _rx0buf
                 	.DEF _str1=R6
                 _4:
000058 0785      	.DW  _rx0buf
                 	.DEF _pntr1=R8
                 _5:
Coding.inc(23): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
000059 0001      	.DB  0x1
                 _6:
Coding.inc(25): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005a 0002      	.DB  0x2
                 _7:
Coding.inc(27): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005b 0003      	.DB  0x3
                 _8:
Coding.inc(29): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005c 0004      	.DB  0x4
                 	.DEF _tx0crc=R10
                 	.DEF _rx0state=R11
                 _58:
Coding.inc(33): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005d 0001      	.DB  0x1
                 	.DEF _rx0crc=R12
                 	.DEF _rx0len=R13
                 	.DEF _rx0type=R14
                 _132:
Coding.inc(38): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005e 000a      	.DB  0xA
                 _sd_cmd:
00005f 0000      	.DB  0x0,0x0
000060 0040      	.DB  0x40,0x0
000061 0000      	.DB  0x0,0x0
000062 0000      	.DB  0x0,0x0
000063 0001      	.DB  0x1,0x0
000064 0041      	.DB  0x41,0x0
000065 0000      	.DB  0x0,0x0
000066 0000      	.DB  0x0,0x0
000067 0002      	.DB  0x2,0x0
000068 0049      	.DB  0x49,0x0
000069 0000      	.DB  0x0,0x0
00006a 0000      	.DB  0x0,0x0
00006b 0003      	.DB  0x3,0x0
00006c 004a      	.DB  0x4A,0x0
00006d 0000      	.DB  0x0,0x0
00006e 0000      	.DB  0x0,0x0
00006f 0004      	.DB  0x4,0x0
000070 004c      	.DB  0x4C,0x0
000071 0000      	.DB  0x0,0x0
000072 0000      	.DB  0x0,0x0
000073 0005      	.DB  0x5,0x0
000074 004d      	.DB  0x4D,0x0
000075 0000      	.DB  0x0,0x0
000076 0002      	.DB  0x2,0x0
000077 0006      	.DB  0x6,0x0
000078 0050      	.DB  0x50,0x0
000079 0001      	.DB  0x1,0x0
00007a 0000      	.DB  0x0,0x0
00007b 0007      	.DB  0x7,0x0
00007c 0051      	.DB  0x51,0x0
00007d 0002      	.DB  0x2,0x0
00007e 0000      	.DB  0x0,0x0
00007f 0008      	.DB  0x8,0x0
000080 0052      	.DB  0x52,0x0
000081 0002      	.DB  0x2,0x0
000082 0000      	.DB  0x0,0x0
000083 0009      	.DB  0x9,0x0
000084 0058      	.DB  0x58,0x0
000085 0002      	.DB  0x2,0x0
000086 0000      	.DB  0x0,0x0
000087 000a      	.DB  0xA,0x0
000088 0059      	.DB  0x59,0x0
000089 0002      	.DB  0x2,0x0
00008a 0000      	.DB  0x0,0x0
00008b 000b      	.DB  0xB,0x0
00008c 005b      	.DB  0x5B,0x0
00008d 0000      	.DB  0x0,0x0
00008e 0000      	.DB  0x0,0x0
00008f 000c      	.DB  0xC,0x0
000090 005c      	.DB  0x5C,0x0
000091 0002      	.DB  0x2,0x0
000092 0001      	.DB  0x1,0x0
000093 000d      	.DB  0xD,0x0
000094 005d      	.DB  0x5D,0x0
000095 0002      	.DB  0x2,0x0
000096 0001      	.DB  0x1,0x0
000097 000e      	.DB  0xE,0x0
000098 005e      	.DB  0x5E,0x0
000099 0002      	.DB  0x2,0x0
00009a 0000      	.DB  0x0,0x0
00009b 000f      	.DB  0xF,0x0
00009c 0060      	.DB  0x60,0x0
00009d 0002      	.DB  0x2,0x0
00009e 0000      	.DB  0x0,0x0
00009f 0010      	.DB  0x10,0x0
0000a0 0061      	.DB  0x61,0x0
0000a1 0002      	.DB  0x2,0x0
0000a2 0000      	.DB  0x0,0x0
0000a3 0011      	.DB  0x11,0x0
0000a4 0062      	.DB  0x62,0x0
0000a5 0002      	.DB  0x2,0x0
0000a6 0000      	.DB  0x0,0x0
0000a7 0012      	.DB  0x12,0x0
0000a8 0063      	.DB  0x63,0x0
0000a9 0002      	.DB  0x2,0x0
0000aa 0000      	.DB  0x0,0x0
0000ab 0013      	.DB  0x13,0x0
0000ac 0064      	.DB  0x64,0x0
0000ad 0002      	.DB  0x2,0x0
0000ae 0000      	.DB  0x0,0x0
0000af 0014      	.DB  0x14,0x0
0000b0 0065      	.DB  0x65,0x0
0000b1 0002      	.DB  0x2,0x0
0000b2 0000      	.DB  0x0,0x0
0000b3 0015      	.DB  0x15,0x0
0000b4 0066      	.DB  0x66,0x0
0000b5 0003      	.DB  0x3,0x0
0000b6 0001      	.DB  0x1,0x0
0000b7 0016      	.DB  0x16,0x0
0000b8 006a      	.DB  0x6A,0x0
0000b9 0003      	.DB  0x3,0x0
0000ba 0001      	.DB  0x1,0x0
0000bb 0017      	.DB  0x17,0x0
0000bc 007a      	.DB  0x7A,0x0
0000bd 0000      	.DB  0x0,0x0
0000be 0003      	.DB  0x3,0x0
0000bf 0018      	.DB  0x18,0x0
0000c0 007b      	.DB  0x7B,0x0
0000c1 0003      	.DB  0x3,0x0
0000c2 0000      	.DB  0x0,0x0
0000c3 0019      	.DB  0x19,0x0
0000c4 0069      	.DB  0x69,0x0
0000c5 0000      	.DB  0x0,0x0
0000c6 0000      	.DB  0x0,0x0
                 _tbl10_G8:
0000c7 2710
0000c8 03e8
0000c9 0064
0000ca 000a      	.DB  0x10,0x27,0xE8,0x3,0x64,0x0,0xA,0x0
0000cb 0001      	.DB  0x1,0x0
                 _tbl16_G8:
0000cc 1000
0000cd 0100
0000ce 0010
0000cf 0001      	.DB  0x0,0x10,0x0,0x1,0x10,0x0,0x1,0x0
                 _0:
0000d0 eecf
0000d1 f2f0
0000d2 3120
0000d3 cf00      	.DB  0xCF,0xEE,0xF0,0xF2,0x20,0x31,0x0,0xCF
0000d4 f0ee
0000d5 20f2
0000d6 0032
0000d7 eecf      	.DB  0xEE,0xF0,0xF2,0x20,0x32,0x0,0xCF,0xEE
0000d8 f2f0
0000d9 3320
0000da cf00
0000db f0ee      	.DB  0xF0,0xF2,0x20,0x33,0x0,0xCF,0xEE,0xF0
0000dc 20f2
0000dd 0034
0000de 0d0a
0000df 2500      	.DB  0xF2,0x20,0x34,0x0,0xA,0xD,0x0,0x25
0000e0 2058
0000e1 2500
0000e2 3230
0000e3 2058      	.DB  0x58,0x20,0x0,0x25,0x30,0x32,0x58,0x20
Coding.inc(155): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
0000e4 0000      	.DB  0x0
                 
                 ;HEAP START MARKER INITIALIZATION
                 __HEAP_START_MARKER:
0000e5 0000
0000e6 0000      	.DW  0,0
                 
                 __GLOBAL_INI_TBL:
0000e7 0004      	.DW  0x04
0000e8 0ca8      	.DW  0xCA8
0000e9 01ca      	.DW  __HEAP_START_MARKER*2
                 
0000ea 0002      	.DW  0x02
0000eb 0004      	.DW  0x04
0000ec 00ae      	.DW  _3*2
                 
0000ed 0002      	.DW  0x02
0000ee 0006      	.DW  0x06
0000ef 00b0      	.DW  _4*2
                 
0000f0 0007      	.DW  0x07
0000f1 0740      	.DW  _0cp
0000f2 01a0      	.DW  _0*2
                 
0000f3 0001      	.DW  0x01
0000f4 0750      	.DW  _1cp
0000f5 00b2      	.DW  _5*2
                 
0000f6 0007      	.DW  0x07
0000f7 0751      	.DW  _2cp
0000f8 01a7      	.DW  _0*2+0x07
                 
0000f9 0001      	.DW  0x01
0000fa 0761      	.DW  _3cp
0000fb 00b4      	.DW  _6*2
                 
0000fc 0007      	.DW  0x07
0000fd 0762      	.DW  _4cp
0000fe 01ae      	.DW  _0*2+0x0E
                 
0000ff 0001      	.DW  0x01
000100 0772      	.DW  _5cp
000101 00b6      	.DW  _7*2
                 
000102 0007      	.DW  0x07
000103 0773      	.DW  _6cp
000104 01b5      	.DW  _0*2+0x15
                 
000105 0001      	.DW  0x01
000106 0783      	.DW  _7cp
000107 00b8      	.DW  _8*2
                 
000108 0001      	.DW  0x01
000109 000b      	.DW  0x0B
00010a 00ba      	.DW  _58*2
                 
00010b 0001      	.DW  0x01
00010c 0886      	.DW  _rx1state
00010d 00bc      	.DW  _132*2
                 
00010e 0000      	.DW  0
                 _0x439:
                 
                 __RESET:
00010f 94f8      	CLI
000110 27ee      	CLR  R30
000111 bbec      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF FLASH
000112 e0f1      	LDI  R31,1
000113 bff5      	OUT  MCUCR,R31
000114 bfe5      	OUT  MCUCR,R30
000115 93e0 006c 	STS  XMCRB,R30
000117 bfeb      	OUT  RAMPZ,R30
                 
                 ;DISABLE WATCHDOG
000118 e1f8      	LDI  R31,0x18
000119 bdf1      	OUT  WDTCR,R31
00011a bde1      	OUT  WDTCR,R30
                 
                 ;CLEAR R2-R14
00011b e08d      	LDI  R24,13
00011c e0a2      	LDI  R26,2
00011d 27bb      	CLR  R27
                 __CLEAR_REG:
00011e 93ed      	ST   X+,R30
00011f 958a      	DEC  R24
000120 f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
000121 ea88      	LDI  R24,LOW(0xBA8)
000122 e09b      	LDI  R25,HIGH(0xBA8)
000123 e0a0      	LDI  R26,LOW(0x100)
000124 e0b1      	LDI  R27,HIGH(0x100)
                 __CLEAR_SRAM:
000125 93ed      	ST   X+,R30
000126 9701      	SBIW R24,1
000127 f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GLOBAL VARIABLES INITIALIZATION
000128 ecee      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
000129 e0f1      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
                 __GLOBAL_INI_NEXT:
00012a 9185      	LPM  R24,Z+
00012b 9195      	LPM  R25,Z+
00012c 9700      	SBIW R24,0
00012d f061      	BREQ __GLOBAL_INI_END
00012e 91a5      	LPM  R26,Z+
00012f 91b5      	LPM  R27,Z+
000130 9005      	LPM  R0,Z+
000131 9015      	LPM  R1,Z+
000132 01bf      	MOVW R22,R30
000133 01f0      	MOVW R30,R0
                 __GLOBAL_INI_LOOP:
000134 9005      	LPM  R0,Z+
000135 920d      	ST   X+,R0
000136 9701      	SBIW R24,1
000137 f7e1      	BRNE __GLOBAL_INI_LOOP
000138 01fb      	MOVW R30,R22
000139 cff0      	RJMP __GLOBAL_INI_NEXT
                 __GLOBAL_INI_END:
                 
                 ;STACK POINTER INITIALIZATION
00013a eae7      	LDI  R30,LOW(0xCA7)
00013b bfed      	OUT  SPL,R30
00013c e0ec      	LDI  R30,HIGH(0xCA7)
00013d bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
00013e e0c0      	LDI  R28,LOW(0x500)
00013f e0d5      	LDI  R29,HIGH(0x500)
                 
000140 940c 023d 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x500
                 ;       1 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                 ;       2 // Управляющая программа КОДЕРА
                 ;       3 
                 ;       4 #include "Coding.h"
                 ;       5 
                 ;       6 flash unsigned char device_name[32] =					// Имя устройства
                 
                 	.CSEG
                 ;       7 		"Port Device v1.0";
                 ;       8 eeprom unsigned long my_ser_num = 0;					// Серийный номер устройства
                 
                 	.ESEG
                 _my_ser_num:
000000 00 00     	.DW  0x0
000002 00 00     	.DW  0x0
                 ;       9 const flash unsigned short my_version = 0x0100;			// Версия софта 
                 
                 	.CSEG
                 ;      10 eeprom unsigned char my_addr = TO_MON;					// Мой адрес - изначально TO_MON
                 
                 	.ESEG
                 _my_addr:
000004 fe        	.DB  0xFE
                 ;      11 
                 ;      12 unsigned char txBuffer [256];		//буффер передатчика
                 
                 	.DSEG
                 _txBuffer:
000500           	.BYTE 0x100
                 ;      13 unsigned char rxBuffer [256];		//буер приемника
                 _rxBuffer:
000600           	.BYTE 0x100
                 ;      14 unsigned char lAddrDevice	[64];	// храним лог. адреса подключенных устройств
                 _lAddrDevice:
000700           	.BYTE 0x40
                 ;      15 															// 0 ячейка - кол-во портов 232 .1 ячейка содержит лог. адрес порта 1, 2-лог.
                 ;      16 															// адрес порта 2 и т. д.
                 ;      17 // Переменные для работы с CF Card
                 ;      18 /*
                 ;      19 typedef struct 				// структура приемного пакета при передаче имени файла
                 ;      20 {
                 ;      21 	char Ptype;               // тип принятого пакета
                 ;      22 	char fname[13];        // имя файла
                 ;      23 } strInPack; */
                 ;      24 
                 ;      25 strInPack * str = (strInPack *)(rx0buf);
                 ;      26 strDataPack * str1 = (strDataPack *)(rx0buf);
                 ;      27 
                 ;      28 FILE *pntr1; 
                 ;      29 
                 ;      30 
                 ;      31 typedef struct _chip_port
                 ;      32 {
                 ;      33 	flash char name[16];
                 ;      34 	flash unsigned char addr;
                 ;      35 } CHIPPORT;
                 ;      36 
                 ;      37 CHIPPORT cp[] = {
                 _cp:
                 ;      38 	{"Порт 1", 1},
                 _0cp:
000740           	.BYTE 0x10
                 _1cp:
000750           	.BYTE 0x1
                 ;      39 	{"Порт 2", 2},
                 _2cp:
000751           	.BYTE 0x10
                 _3cp:
000761           	.BYTE 0x1
                 ;      40 	{"Порт 3", 3},
                 _4cp:
000762           	.BYTE 0x10
                 _5cp:
000772           	.BYTE 0x1
                 ;      41 	{"Порт 4", 4}
                 _6cp:
000773           	.BYTE 0x10
                 _7cp:
000783           	.BYTE 0x1
                 ;      42 };
                 ;      43 
                 ;      44 //-----------------------------------------------------------------------------------------------------------------
                 ;      45 // Возвращаю состояние устройства
                 ;      46 static void GetState(void)
                 ;      47 {
                 
                 	.CSEG
                 _GetState_G1:
                 ;      48 	register unsigned char i, n, b;
                 ;      49 	
                 ;      50 	#define strq  ((RQ_GETSTATE *)rx0buf)
                 ;      51 
                 ;      52 	switch(strq->page)
000142 940e 1f33 	CALL __SAVELOCR3
                 ;	i -> R16
                 ;	n -> R17
                 ;	b -> R18
000144 91e0 0785 	LDS  R30,_rx0buf
                 ;      53 	{
                 ;      54 	case 0:
000146 30e0      	CPI  R30,0
000147 f011      	BREQ PC+3
000148 940c 0188 	JMP _0xC
                 ;      55 		StartReply(2 + 16*(sizeof(cp) / sizeof(CHIPPORT)) + 1);
00014a e4e3      	LDI  R30,LOW(67)
00014b 93ea      	ST   -Y,R30
00014c d164      	RCALL _StartReply
                 ;      56 
                 ;      57 		putchar0(2);               						 // число доступных страниц, включая эту
00014d e0e2      	LDI  R30,LOW(2)
00014e 93ea      	ST   -Y,R30
00014f d15b      	RCALL _putchar0
                 ;      58 		putchar0(0);										// зарезервирован
000150 e0e0      	LDI  R30,LOW(0)
000151 93ea      	ST   -Y,R30
000152 d158      	RCALL _putchar0
                 ;      59 		
                 ;      60 		for (n = 0; n < (sizeof(cp) / sizeof(CHIPPORT)); n ++)
000153 e010      	LDI  R17,LOW(0)
                 _0xE:
000154 3014      	CPI  R17,4
000155 f568      	BRSH _0xF
                 ;      61 		{
                 ;      62 			for (i = 0; i < 15; i ++)
000156 e000      	LDI  R16,LOW(0)
                 _0x11:
000157 300f      	CPI  R16,15
000158 f4a0      	BRSH _0x12
                 ;      63 			{
                 ;      64 				b = cp[n].name[i];
000159 2fe1      	MOV  R30,R17
00015a e0f0      	LDI  R31,0
00015b e1a1      	LDI  R26,LOW(17)
00015c e0b0      	LDI  R27,HIGH(17)
00015d 940e 1e2c 	CALL __MULW12U
00015f 5ce0      	SUBI R30,LOW(-_cp)
000160 4ff8      	SBCI R31,HIGH(-_cp)
000161 01df      	MOVW R26,R30
000162 2fe0      	MOV  R30,R16
000163 e0f0      	LDI  R31,0
000164 0fae      	ADD  R26,R30
000165 1fbf      	ADC  R27,R31
000166 912c      	LD   R18,X
                 ;      65 				if (!b)
000167 3020      	CPI  R18,0
000168 f021      	BREQ _0x12
                 ;      66 				{
                 ;      67 					break;
                 ;      68 				}
                 ;      69 				putchar0(b);
000169 932a      	ST   -Y,R18
00016a d140      	RCALL _putchar0
                 ;      70 			}
00016b 5f0f      	SUBI R16,-1
00016c cfea      	RJMP _0x11
                 _0x12:
                 ;      71 			while(i < 15)
                 _0x14:
00016d 300f      	CPI  R16,15
00016e f428      	BRSH _0x16
                 ;      72 			{
                 ;      73 				putchar0(' ');
00016f e2e0      	LDI  R30,LOW(32)
000170 93ea      	ST   -Y,R30
000171 d139      	RCALL _putchar0
                 ;      74 				i++;
000172 5f0f      	SUBI R16,-1
                 ;      75 			}
000173 cff9      	RJMP _0x14
                 _0x16:
                 ;      76 			
                 ;      77 			putchar0(cp[n].addr);
000174 2fa1      	MOV  R26,R17
000175 27bb      	CLR  R27
000176 e1e1      	LDI  R30,LOW(17)
000177 e0f0      	LDI  R31,HIGH(17)
000178 940e 1e2c 	CALL __MULW12U
00017a e5a0
00017b e0b7      	__POINTW2MN _cp,16
00017c 0fae      	ADD  R26,R30
00017d 1fbf      	ADC  R27,R31
00017e 91ec      	LD   R30,X
00017f 93ea      	ST   -Y,R30
000180 d12a      	RCALL _putchar0
                 ;      78 		}
000181 5f1f      	SUBI R17,-1
000182 cfd1      	RJMP _0xE
                 _0xF:
                 ;      79 		
                 ;      80 		putchar0(255);
000183 efef      	LDI  R30,LOW(255)
000184 93ea      	ST   -Y,R30
000185 d125      	RCALL _putchar0
                 ;      81 
                 ;      82 		EndReply();
000186 d132      	RCALL _EndReply
                 ;      83 		return;
000187 c02e      	RJMP _0x42F
                 ;      84 
                 ;      85 	case 1:
                 _0xC:
000188 30e1      	CPI  R30,LOW(0x1)
000189 f561      	BRNE _0xB
                 ;      86 	
                 ;      87 		StartReply(3 * (sizeof(cp) / sizeof(CHIPPORT)) + 1);
00018a e0ed      	LDI  R30,LOW(13)
00018b 93ea      	ST   -Y,R30
00018c d124      	RCALL _StartReply
                 ;      88 		
                 ;      89 		for (n = 0; n < (sizeof(cp) / sizeof(CHIPPORT)); n++)
00018d e010      	LDI  R17,LOW(0)
                 _0x19:
00018e 3014      	CPI  R17,4
00018f f510      	BRSH _0x1A
                 ;      90 		{
                 ;      91 			putchar0(n);
000190 931a      	ST   -Y,R17
000191 d119      	RCALL _putchar0
                 ;      92 			putchar0(cp[n].addr);
000192 2fa1      	MOV  R26,R17
000193 27bb      	CLR  R27
000194 e1e1      	LDI  R30,LOW(17)
000195 e0f0      	LDI  R31,HIGH(17)
000196 940e 1e2c 	CALL __MULW12U
000198 e5a0
000199 e0b7      	__POINTW2MN _cp,16
00019a 0fae      	ADD  R26,R30
00019b 1fbf      	ADC  R27,R31
00019c 91ec      	LD   R30,X
00019d 93ea      	ST   -Y,R30
00019e d10c      	RCALL _putchar0
                 ;      93 			putchar0(lAddrDevice [cp[n].addr]);
00019f 2fa1      	MOV  R26,R17
0001a0 27bb      	CLR  R27
0001a1 e1e1      	LDI  R30,LOW(17)
0001a2 e0f0      	LDI  R31,HIGH(17)
0001a3 940e 1e2c 	CALL __MULW12U
0001a5 e5a0
0001a6 e0b7      	__POINTW2MN _cp,16
0001a7 0fae      	ADD  R26,R30
0001a8 1fbf      	ADC  R27,R31
0001a9 91ec      	LD   R30,X
0001aa e0f0      	LDI  R31,0
0001ab 50e0      	SUBI R30,LOW(-_lAddrDevice)
0001ac 4ff9      	SBCI R31,HIGH(-_lAddrDevice)
0001ad 81e0      	LD   R30,Z
0001ae 93ea      	ST   -Y,R30
0001af d0fb      	RCALL _putchar0
                 ;      94 		}
0001b0 5f1f      	SUBI R17,-1
0001b1 cfdc      	RJMP _0x19
                 _0x1A:
                 ;      95 
                 ;      96 		putchar0(255);
0001b2 efef      	LDI  R30,LOW(255)
0001b3 93ea      	ST   -Y,R30
0001b4 d0f6      	RCALL _putchar0
                 ;      97 
                 ;      98 		EndReply();
0001b5 d103      	RCALL _EndReply
                 ;      99 		return;
                 ;     100 	}
                 _0xB:
                 ;     101 }
                 _0x42F:
0001b6 940e 1f3a 	CALL __LOADLOCR3
0001b8 9623      	ADIW R28,3
0001b9 9508      	RET
                 ;     102 
                 ;     103 //-----------------------------------------------------------------------------------------------------------------
                 ;     104 // Информация об устройстве
                 ;     105 static void GetInfo(void)
                 ;     106 {
                 _GetInfo_G1:
                 ;     107 	register unsigned char i;
                 ;     108 	
                 ;     109 	// 	Начинаю передачу ответа
                 ;     110 	StartReply(40);
0001ba 930a      	ST   -Y,R16
                 ;	i -> R16
0001bb e2e8      	LDI  R30,LOW(40)
0001bc 93ea      	ST   -Y,R30
0001bd d0f3      	RCALL _StartReply
                 ;     111 	
                 ;     112 	for (i = 0; i < 32; i ++)	// Имя устройства
0001be e000      	LDI  R16,LOW(0)
                 _0x1C:
0001bf 3200      	CPI  R16,32
0001c0 f448      	BRSH _0x1D
                 ;     113 	{
                 ;     114 		putchar0(device_name[i]);
0001c1 2fe0      	MOV  R30,R16
0001c2 e0f0      	LDI  R31,0
0001c3 57e4      	SUBI R30,LOW(-_device_name*2)
0001c4 4fff      	SBCI R31,HIGH(-_device_name*2)
0001c5 91e4      	LPM  R30,Z
0001c6 93ea      	ST   -Y,R30
0001c7 d0e3      	RCALL _putchar0
                 ;     115 	}
0001c8 5f0f      	SUBI R16,-1
0001c9 cff5      	RJMP _0x1C
                 _0x1D:
                 ;     116 
                 ;     117 	putword0(my_ser_num);		// Серийный номер
0001ca e0a0      	LDI  R26,LOW(_my_ser_num)
0001cb e0b0      	LDI  R27,HIGH(_my_ser_num)
0001cc 940e 1ee1 	CALL __EEPROMRDD
0001ce 93fa      	ST   -Y,R31
0001cf 93ea      	ST   -Y,R30
0001d0 d183      	RCALL _putword0
                 ;     118 	putword0(my_ser_num >> 16);	
0001d1 e0a0      	LDI  R26,LOW(_my_ser_num)
0001d2 e0b0      	LDI  R27,HIGH(_my_ser_num)
0001d3 940e 1ee1 	CALL __EEPROMRDD
0001d5 940e 1e1d 	CALL __LSRD16
0001d7 93fa      	ST   -Y,R31
0001d8 93ea      	ST   -Y,R30
0001d9 d17a      	RCALL _putword0
                 ;     119 	
                 ;     120 	putchar0(my_addr);			// Адрес устройстав
0001da e0a4      	LDI  R26,LOW(_my_addr)
0001db e0b0      	LDI  R27,HIGH(_my_addr)
0001dc 940e 1eea 	CALL __EEPROMRDB
0001de 93ea      	ST   -Y,R30
0001df d0cb      	RCALL _putchar0
                 ;     121 
                 ;     122 	putchar0(0);				// Зарезервированный байт
0001e0 e0e0      	LDI  R30,LOW(0)
0001e1 93ea      	ST   -Y,R30
0001e2 d0c8      	RCALL _putchar0
                 ;     123 	
                 ;     124 	putword0(my_version);		// Версия
0001e3 eaec      	LDI  R30,LOW(_my_version*2)
0001e4 e0f0      	LDI  R31,HIGH(_my_version*2)
0001e5 940e 1ed3 	CALL __GETW1PF
0001e7 93fa      	ST   -Y,R31
0001e8 93ea      	ST   -Y,R30
0001e9 d16a      	RCALL _putword0
                 ;     125 	
                 ;     126 	EndReply();					// Завершаю ответ
0001ea d0ce      	RCALL _EndReply
                 ;     127 }
0001eb 9109      	LD   R16,Y+
0001ec 9508      	RET
                 ;     128 
                 ;     129 //-----------------------------------------------------------------------------------------------------------------
                 ;     130 // Смена адреса устройства
                 ;     131 static void SetAddr(void)
                 ;     132 {
                 _SetAddr_G1:
                 ;     133 	#define sap ((RQ_SETADDR *)rx0buf)
                 ;     134 	
                 ;     135 	my_addr = sap->addr;
0001ed 91e0 0785 	LDS  R30,_rx0buf
0001ef e0a4      	LDI  R26,LOW(_my_addr)
0001f0 e0b0      	LDI  R27,HIGH(_my_addr)
0001f1 940e 1f09 	CALL __EEPROMWRB
                 ;     136 	
                 ;     137 	StartReply(1);
0001f3 e0e1      	LDI  R30,LOW(1)
0001f4 93ea      	ST   -Y,R30
0001f5 d0bb      	RCALL _StartReply
                 ;     138 	putchar0(RES_OK);
0001f6 e0e1      	LDI  R30,LOW(1)
0001f7 93ea      	ST   -Y,R30
0001f8 d0b2      	RCALL _putchar0
                 ;     139 	EndReply();
0001f9 d0bf      	RCALL _EndReply
                 ;     140 }
0001fa 9508      	RET
                 ;     141 
                 ;     142 //-----------------------------------------------------------------------------------------------------------------
                 ;     143 // Назначение серийного номера устройства
                 ;     144 static void SetSerial(void)
                 ;     145 {
                 _SetSerial_G1:
                 ;     146 	#define ssp ((RQ_SETSERIAL *)rx0buf)
                 ;     147 	
                 ;     148 	if (my_ser_num)
0001fb e0a0      	LDI  R26,LOW(_my_ser_num)
0001fc e0b0      	LDI  R27,HIGH(_my_ser_num)
0001fd 940e 1ee1 	CALL __EEPROMRDD
0001ff 940e 1f18 	CALL __CPD10
000201 f041      	BREQ _0x1E
                 ;     149 	{
                 ;     150 		StartReply(1);
000202 e0e1      	LDI  R30,LOW(1)
000203 93ea      	ST   -Y,R30
000204 d0ac      	RCALL _StartReply
                 ;     151 		putchar0(RES_ERR);
000205 e0e0      	LDI  R30,LOW(0)
000206 93ea      	ST   -Y,R30
000207 d0a3      	RCALL _putchar0
                 ;     152 		EndReply();
000208 d0b0      	RCALL _EndReply
                 ;     153 		return;
000209 9508      	RET
                 ;     154 	}
                 ;     155 	
                 ;     156 	my_ser_num = ssp->num;
                 _0x1E:
00020a 91e0 0785 	LDS  R30,_rx0buf
00020c 91f0 0786 	LDS  R31,_rx0buf+1
00020e 9160 0787 	LDS  R22,_rx0buf+2
000210 9170 0788 	LDS  R23,_rx0buf+3
000212 e0a0      	LDI  R26,LOW(_my_ser_num)
000213 e0b0      	LDI  R27,HIGH(_my_ser_num)
000214 940e 1ef6 	CALL __EEPROMWRD
                 ;     157 	
                 ;     158 	StartReply(1);
000216 e0e1      	LDI  R30,LOW(1)
000217 93ea      	ST   -Y,R30
000218 d098      	RCALL _StartReply
                 ;     159 	putchar0(RES_OK);
000219 e0e1      	LDI  R30,LOW(1)
00021a 93ea      	ST   -Y,R30
00021b d08f      	RCALL _putchar0
                 ;     160 	EndReply();
00021c d09c      	RCALL _EndReply
                 ;     161 }
00021d 9508      	RET
                 ;     162 
                 ;     163 //-----------------------------------------------------------------------------------------------------------------
                 ;     164 // Перезагрузка в режим программирования
                 ;     165 static void ToProg(void)
                 ;     166 {
                 _ToProg_G1:
                 ;     167 	// Отправляю ответ
                 ;     168 	StartReply(0);
00021e e0e0      	LDI  R30,LOW(0)
00021f 93ea      	ST   -Y,R30
000220 d090      	RCALL _StartReply
                 ;     169 	EndReply();
000221 d097      	RCALL _EndReply
                 ;     170 
                 ;     171 	// На перезагрузку в монитор
                 ;     172 	MCUCR = 1 << IVCE;
000222 e0e1      	LDI  R30,LOW(1)
000223 bfe5      	OUT  0x35,R30
                 ;     173 	MCUCR = 1 << IVSEL;
000224 e0e2      	LDI  R30,LOW(2)
000225 bfe5      	OUT  0x35,R30
                 ;     174 
                 ;     175 	#asm("jmp 0xFC00");
000226 940c fc00 	jmp 0xFC00
                 ;     176 }
000228 9508      	RET
                 ;     177 
                 ;     178 //-----------------------------------------------------------------------------------------------------------------
                 ;     179 // Железо процессора в исходное состояние
                 ;     180 static void HardwareInit(void)
                 ;     181 {         
                 _HardwareInit_G1:
                 ;     182         twi_init ();      
000229 d15f      	RCALL _twi_init
                 ;     183 		CommInit();				// Инициализация  COM-порта
00022a d11a      	RCALL _CommInit
                 ;     184 		timer_0_Init ();			// Инициализируем таймер 0 (таймаут)
00022b d2ac      	RCALL _timer_0_Init
                 ;     185 		portInit();					// Выводы - в исходное состояние
00022c d2a8      	RCALL _portInit
                 ;     186         
                 ;     187 }
00022d 9508      	RET
                 ;     188 
                 ;     189 //-----------------------------------------------------------------------------------------------------------------
                 ;     190 // Сброс периферии
                 ;     191 void ResetPeripherial(void)
                 ;     192 {
                 _ResetPeripherial:
                 ;     193         CRST = 0;
00022e 98da      	CBI  0x1B,2
                 ;     194         delay_ms(10);
00022f e0ea      	LDI  R30,LOW(10)
000230 e0f0      	LDI  R31,HIGH(10)
000231 93fa      	ST   -Y,R31
000232 93ea      	ST   -Y,R30
000233 940e 1dca 	CALL _delay_ms
                 ;     195         CRST = 1;
000235 9ada      	SBI  0x1B,2
                 ;     196         delay_ms(500);     //Ждем пока отработают сброс
000236 efe4      	LDI  R30,LOW(500)
000237 e0f1      	LDI  R31,HIGH(500)
000238 93fa      	ST   -Y,R31
000239 93ea      	ST   -Y,R30
00023a 940e 1dca 	CALL _delay_ms
                 ;     197 }
00023c 9508      	RET
                 ;     198 
                 ;     199 //-----------------------------------------------------------------------------------------------------------------
                 ;     200 // Точка входа в программу
                 ;     201 void main(void)
                 ;     202 {
                 _main:
                 ;     203 unsigned char a;   
                 ;     204 
                 ;     205 //	Пока происходят внутренние работы светодиод - красный. По окончании - зеленый.
                 ;     206 
                 ;     207     LedRed();               
                 ;	a -> R16
00023d 9ad0      	SBI  0x1A,0
00023e 9ad1      	SBI  0x1A,1
00023f 98d8      	CBI  0x1B,0
000240 9ad9      	SBI  0x1B,1
                 ;     208 	HardwareInit();				// Железо процессора
000241 940e 0229 	CALL _HardwareInit_G1
                 ;     209 	ResetPeripherial();		// Сбрасываю периферию 
000243 940e 022e 	CALL _ResetPeripherial
                 ;     210 
                 ;     211 	#asm("sei")
000245 9478      	sei
                 ;     212 
                 ;     213 	UCSR0B.3 = 1;		 				// Разрешаю передатчик UART
000246 9a53      	SBI  0xA,3
                 ;     214 	delay_ms (3000);					// даем время отработать сброс
000247 ebe8      	LDI  R30,LOW(3000)
000248 e0fb      	LDI  R31,HIGH(3000)
000249 93fa      	ST   -Y,R31
00024a 93ea      	ST   -Y,R30
00024b 940e 1dca 	CALL _delay_ms
                 ;     215 	verIntDev();							// Считаем	 количество подчиненных устройств 
00024d d2ad      	RCALL _verIntDev
                 ;     216 
                 ;     217 // работаем с карточкой...
                 ;     218 	while (!(initialize_media()));		// инициализация CF Card   
                 _0x1F:
00024e d546      	RCALL _initialize_media
00024f 30e0      	CPI  R30,0
000250 f3e9      	BREQ _0x1F
                 ;     219 
                 ;     220 	while (1)
                 _0x22:
                 ;     221 	{
                 ;     222 
                 ;     223 
                 ;     224 		LedGreen();
000251 9ad0      	SBI  0x1A,0
000252 9ad1      	SBI  0x1A,1
000253 9ad8      	SBI  0x1B,0
000254 98d9      	CBI  0x1B,1
                 ;     225 		ReadLogAddr ();				// Вычитываем лог. адреса
000255 d2d8      	RCALL _ReadLogAddr
                 ;     226 
                 ;     227 //		for (a=1; a<= int_Devices; a++) pingPack (a);	
                 ;     228 	
                 ;     229 
                 ;     230 		// Проверяю, нет ли пакета и принимаю меры, если есть
                 ;     231 		if (HaveIncomingPack())
000256 d0e1      	RCALL _HaveIncomingPack
000257 30e0      	CPI  R30,0
000258 f411      	BRNE PC+3
000259 940c 02a9 	JMP _0x25
                 ;     232 		{
                 ;     233 		if ((rx0addr == my_addr) || (rx0addr == TO_ALL))				// адрес мой 
00025b e0a4      	LDI  R26,LOW(_my_addr)
00025c e0b0      	LDI  R27,HIGH(_my_addr)
00025d 940e 1eea 	CALL __EEPROMRDB
00025f 91a0 0784 	LDS  R26,_rx0addr
000261 17ea      	CP   R30,R26
000262 f011      	BREQ _0x27
000263 3faf      	CPI  R26,LOW(0xFF)
000264 f521      	BRNE _0x26
                 _0x27:
                 ;     234 			{
                 ;     235 				switch(IncomingPackType())
000265 d0da      	RCALL _IncomingPackType
                 ;     236 					{
                 ;     237 						case PT_GETSTATE:
000266 30e1      	CPI  R30,LOW(0x1)
000267 f419      	BRNE _0x2C
                 ;     238 								GetState();
000268 940e 0142 	CALL _GetState_G1
                 ;     239 								break;
00026a c01d      	RJMP _0x2B
                 ;     240 				
                 ;     241 						case PT_GETINFO:
                 _0x2C:
00026b 30e3      	CPI  R30,LOW(0x3)
00026c f419      	BRNE _0x2D
                 ;     242 								GetInfo();
00026d 940e 01ba 	CALL _GetInfo_G1
                 ;     243 								break;
00026f c018      	RJMP _0x2B
                 ;     244 				
                 ;     245 						case PT_SETADDR:
                 _0x2D:
000270 30e4      	CPI  R30,LOW(0x4)
000271 f419      	BRNE _0x2E
                 ;     246 								SetAddr();
000272 940e 01ed 	CALL _SetAddr_G1
                 ;     247 								break;
000274 c013      	RJMP _0x2B
                 ;     248 				
                 ;     249 						case PT_SETSERIAL:
                 _0x2E:
000275 30e5      	CPI  R30,LOW(0x5)
000276 f419      	BRNE _0x2F
                 ;     250 								SetSerial();
000277 940e 01fb 	CALL _SetSerial_G1
                 ;     251 								break;
000279 c00e      	RJMP _0x2B
                 ;     252 				
                 ;     253 						case PT_TOPROG:
                 _0x2F:
00027a 30e7      	CPI  R30,LOW(0x7)
00027b f419      	BRNE _0x30
                 ;     254 								ToProg();
00027c 940e 021e 	CALL _ToProg_G1
                 ;     255 								break;      
00027e c009      	RJMP _0x2B
                 ;     256 
                 ;     257 						case PT_RELAY:           			// ретрансляция пакета при программировании
                 _0x30:
00027f 30e6      	CPI  R30,LOW(0x6)
000280 f411      	BRNE _0x31
                 ;     258 							    RelayPack();	
000281 d0dc      	RCALL _RelayPack
                 ;     259                 				break;
000282 c005      	RJMP _0x2B
                 ;     260 
                 ;     261 						case PT_FLASH:								// пакеты для работы с CF Flash
                 _0x31:
000283 3be4      	CPI  R30,LOW(0xB4)
000284 f411      	BRNE _0x33
                 ;     262 							    flash_Work();	
000285 d335      	RCALL _flash_Work
                 ;     263                 				break;
000286 c001      	RJMP _0x2B
                 ;     264                 			
                 ;     265 						default:
                 _0x33:
                 ;     266 								DiscardIncomingPack();
000287 d0ba      	RCALL _DiscardIncomingPack
                 ;     267 								break;
                 ;     268 					}
                 _0x2B:
                 ;     269 		   }
                 ;     270 		else																	// ретранслируем
000288 c020      	RJMP _0x34
                 _0x26:
                 ;     271 				{                                                                      
                 ;     272 					for (a=1; a<= int_Devices; a++)				// ищем порт по адресу
000289 e001      	LDI  R16,LOW(1)
                 _0x36:
00028a 91e0 098b 	LDS  R30,_int_Devices
00028c 17e0      	CP   R30,R16
00028d f0d8      	BRLO _0x37
                 ;     273 						{
                 ;     274 						 	if (lAddrDevice [a]	== rx0addr)
00028e 2fe0      	MOV  R30,R16
00028f e0f0      	LDI  R31,0
000290 50e0      	SUBI R30,LOW(-_lAddrDevice)
000291 4ff9      	SBCI R31,HIGH(-_lAddrDevice)
000292 81e0      	LD   R30,Z
000293 91a0 0784 	LDS  R26,_rx0addr
000295 17ea      	CP   R30,R26
000296 f481      	BRNE _0x38
                 ;     275 						 		{
                 ;     276 									LedRed();
000297 9ad0      	SBI  0x1A,0
000298 9ad1      	SBI  0x1A,1
000299 98d8      	CBI  0x1B,0
00029a 9ad9      	SBI  0x1B,1
                 ;     277 									recompPack (a);		
00029b 930a      	ST   -Y,R16
00029c d2bc      	RCALL _recompPack
                 ;     278 									DiscardIncomingPack();        // разрешаем принимать след. пакет
00029d d0a4      	RCALL _DiscardIncomingPack
                 ;     279 									delay_ms (50);
00029e e3e2      	LDI  R30,LOW(50)
00029f e0f0      	LDI  R31,HIGH(50)
0002a0 93fa      	ST   -Y,R31
0002a1 93ea      	ST   -Y,R30
0002a2 940e 1dca 	CALL _delay_ms
                 ;     280 									pingPack (a);	
0002a4 930a      	ST   -Y,R16
0002a5 d2de      	RCALL _pingPack
                 ;     281 									break;
0002a6 c002      	RJMP _0x37
                 ;     282 						 		}
                 ;     283 						}
                 _0x38:
0002a7 5f0f      	SUBI R16,-1
0002a8 cfe1      	RJMP _0x36
                 _0x37:
                 ;     284 				}
                 _0x34:
                 ;     285 		}
                 ;     286 	}
                 _0x25:
0002a9 cfa7      	RJMP _0x22
                 ;     287 }    	
                 _0x39:
0002aa cfff      	RJMP _0x39
                 ;     288 
                 ;     289 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                 ;     290 // Управляющая программа КОДЕРА
                 ;     291 // Связь с внешним миром
                 ;     292 
                 ;     293 #include "Coding.h"
                 ;     294 
                 ;     295 #define BAUD 38400
                 ;     296 
                 ;     297 /*
                 ;     298 ////////////////////////////////////////////////////////////////////////////////
                 ;     299 // Фазы работы приемопередатчиков
                 ;     300 #define RX_HDR	 1		// Принятый байт - заголовок
                 ;     301 #define RX_LEN   2		// Принятый байт - длина
                 ;     302 #define RX_ADDR  3		// Принятый байт - адрес
                 ;     303 #define RX_TYPE  4		// Принятый байт - тип пакета
                 ;     304 #define RX_DATA  5		// Принятый байт - байт данных
                 ;     305 #define RX_CRC   6		// Принятый байт - CRC
                 ;     306 #define RX_OK    7		// Пакет успешно принят и адресован мне
                 ;     307 #define RX_TIME  8		// Во время приема произошел тайм-аут
                 ;     308 #define RX_ERR   9		// Ошибка CRC приема
                 ;     309 #define RX_BUSY 10		// Запрос прочитан, а ответ еще не сформирован
                 ;     310 */
                 ;     311 #define UDRE 5
                 ;     312 #define DATA_REGISTER_EMPTY (1<<UDRE)
                 ;     313 
                 ;     314 #define RXTIMEOUT 4000	// Тайм-аут приема наружного канала
                 ;     315 
                 ;     316 ////////////////////////////////////////////////////////////////////////////////
                 ;     317 // Работа с наружным каналом
                 ;     318 
                 ;     319 unsigned char tx0crc;
                 ;     320 unsigned char rx0state = RX_HDR;
                 
                 	.DSEG
                 ;     321 unsigned char rx0crc;
                 ;     322 unsigned char rx0len;
                 ;     323 unsigned char rx0addr;
                 _rx0addr:
000784           	.BYTE 0x1
                 ;     324 unsigned char rx0type;
                 ;     325 
                 ;     326 #define COMBUFSIZ 255
                 ;     327 
                 ;     328 unsigned char rx0buf[COMBUFSIZ];
                 _rx0buf:
000785           	.BYTE 0xFF
                 ;     329 unsigned char rx0ptr;
                 _rx0ptr:
000884           	.BYTE 0x1
                 ;     330 
                 ;     331 // Передача байта во "внешний" канал
                 ;     332 void putchar0(char byt)
                 ;     333 {
                 
                 	.CSEG
                 _putchar0:
                 ;     334 	while ((UCSR0A & DATA_REGISTER_EMPTY)==0);
                 _0x3B:
0002ab 9b5d      	SBIS 0xB,5
0002ac cffe      	RJMP _0x3B
                 ;     335 	UDR0 = byt;
0002ad 81e8      	LD   R30,Y
0002ae b9ec      	OUT  0xC,R30
                 ;     336 	tx0crc += byt;
0002af 0eae      	ADD  R10,R30
                 ;     337 }
0002b0 c167      	RJMP _0x42E
                 ;     338 
                 ;     339 // Начало ответа на запрос по внешнему каналу
                 ;     340 void StartReply(unsigned char dlen) 
                 ;     341 {
                 _StartReply:
                 ;     342 //	rx0state = RX_BUSY;					// Запрос обработан
                 ;     343 	tx0crc = 0;										// Готовлю CRC
0002b1 24aa      	CLR  R10
                 ;     344 	
                 ;     345 	UCSR0B.3 = 1;								// Разрешаю передатчик
0002b2 9a53      	SBI  0xA,3
                 ;     346 	
                 ;     347 	putchar0(dlen+1);							// Передаю длину
0002b3 81e8      	LD   R30,Y
0002b4 5fef      	SUBI R30,-LOW(1)
0002b5 93ea      	ST   -Y,R30
0002b6 940e 02ab 	CALL _putchar0
                 ;     348 }
0002b8 c15f      	RJMP _0x42E
                 ;     349 
                 ;     350 void EndReply(void)
                 ;     351 {
                 _EndReply:
                 ;     352 	putchar0(tx0crc);							// Контрольная сумма
0002b9 92aa      	ST   -Y,R10
0002ba 940e 02ab 	CALL _putchar0
                 ;     353 //	UCSR0B.3 = 0;								// Запрещаю передатчик
                 ;     354 	rx0state = RX_HDR;						// Разрешаю прием след. запроса
0002bc e0e1      	LDI  R30,LOW(1)
0002bd 2ebe      	MOV  R11,R30
                 ;     355 }
0002be 9508      	RET
                 ;     356 
                 ;     357 // Прерывание по приему байта из "наружного" канала
                 ;     358 interrupt [USART0_RXC] void uart_rx_isr(void)
                 ;     359 {
                 _uart_rx_isr:
0002bf 93aa      	ST   -Y,R26
0002c0 93ea      	ST   -Y,R30
0002c1 93fa      	ST   -Y,R31
0002c2 b7ef      	IN   R30,SREG
0002c3 93ea      	ST   -Y,R30
                 ;     360 	register unsigned char byt;
                 ;     361 
                 ;     362 	byt = UDR0;									// Принятый байт
0002c4 930a      	ST   -Y,R16
                 ;	byt -> R16
0002c5 b10c      	IN   R16,12
                 ;     363 
                 ;     364 	
                 ;     365 	switch (rx0state)
0002c6 2deb      	MOV  R30,R11
                 ;     366 	{
                 ;     367 	case RX_HDR:								// Должен быть заголовок
0002c7 30e1      	CPI  R30,LOW(0x1)
0002c8 f491      	BRNE _0x41
                 ;     368 		if (byt != PACKHDR)					// Отбрасываю не заголовок
0002c9 3701      	CPI  R16,113
0002ca f009      	BREQ _0x42
                 ;     369 		{
                 ;     370 			break;
0002cb c058      	RJMP _0x40
                 ;     371 		}
                 ;     372 
                 ;     373 
                 ;     374 		rx0state = RX_LEN;					// Перехожу к ожиданию длины
                 _0x42:
0002cc e0e2      	LDI  R30,LOW(2)
0002cd 2ebe      	MOV  R11,R30
                 ;     375 		rx0crc = 0;								// Готовлю подсчет CRC
0002ce 24cc      	CLR  R12
                 ;     376 		
                 ;     377 		OCR1A = TCNT1+RXTIMEOUT;	// Взвожу тайм-аут
0002cf b5ec      	IN   R30,0x2C
0002d0 b5fd      	IN   R31,0x2C+1
0002d1 56e0      	SUBI R30,LOW(-4000)
0002d2 4ff0      	SBCI R31,HIGH(-4000)
0002d3 bdfb      	OUT  0x2A+1,R31
0002d4 bdea      	OUT  0x2A,R30
                 ;     378 		TIFR = 0x10;								// Предотвращаю ложное срабатывание
0002d5 e1e0      	LDI  R30,LOW(16)
0002d6 bfe6      	OUT  0x36,R30
                 ;     379 		TIMSK |= 0x10;							// Разрешение прерывания по тайм-ауту
0002d7 b7e7      	IN   R30,0x37
0002d8 61e0      	ORI  R30,0x10
0002d9 bfe7      	OUT  0x37,R30
                 ;     380 		break;
0002da c049      	RJMP _0x40
                 ;     381 		
                 ;     382 	case RX_LEN:
                 _0x41:
0002db 30e2      	CPI  R30,LOW(0x2)
0002dc f429      	BRNE _0x43
                 ;     383 		rx0len = byt - 3;							// Длина содержимого
0002dd 2fe0      	MOV  R30,R16
0002de 50e3      	SUBI R30,LOW(3)
0002df 2ede      	MOV  R13,R30
                 ;     384 		rx0state = RX_ADDR;					// К приему адреса
0002e0 e0e3      	LDI  R30,LOW(3)
0002e1 c041      	RJMP _0x430
                 ;     385 		break;
                 ;     386 
                 ;     387 	case RX_ADDR:
                 _0x43:
0002e2 30e3      	CPI  R30,LOW(0x3)
0002e3 f421      	BRNE _0x44
                 ;     388 		rx0addr = byt;							// Адрес
0002e4 9300 0784 	STS  _rx0addr,R16
                 ;     389 		rx0state = RX_TYPE;					// К приему типа
0002e6 e0e4      	LDI  R30,LOW(4)
0002e7 c03b      	RJMP _0x430
                 ;     390 		break;
                 ;     391 
                 ;     392 	case RX_TYPE:
                 _0x44:
0002e8 30e4      	CPI  R30,LOW(0x4)
0002e9 f459      	BRNE _0x45
                 ;     393 		rx0type = byt;							// Тип
0002ea 2ee0      	MOV  R14,R16
                 ;     394 		rx0ptr = 0;									// Указатель на начало данных
0002eb e0e0      	LDI  R30,LOW(0)
0002ec 93e0 0884 	STS  _rx0ptr,R30
                 ;     395 		if (rx0len)
0002ee 20dd      	TST  R13
0002ef f011      	BREQ _0x46
                 ;     396 		{
                 ;     397 			rx0state = RX_DATA;				// К приему данных
0002f0 e0e5      	LDI  R30,LOW(5)
0002f1 c001      	RJMP _0x431
                 ;     398 		}
                 ;     399 		else
                 _0x46:
                 ;     400 		{
                 ;     401 			rx0state = RX_CRC; 				// К приему контрольной суммы
0002f2 e0e6      	LDI  R30,LOW(6)
                 _0x431:
0002f3 2ebe      	MOV  R11,R30
                 ;     402 		}
                 ;     403 		break;
0002f4 c02f      	RJMP _0x40
                 ;     404 
                 ;     405 	case RX_DATA:
                 _0x45:
0002f5 30e5      	CPI  R30,LOW(0x5)
0002f6 f4a9      	BRNE _0x48
                 ;     406 		if (rx0ptr > (COMBUFSIZ-1))
0002f7 91a0 0884 	LDS  R26,_rx0ptr
0002f9 3faf      	CPI  R26,LOW(0xFF)
0002fa f008      	BRLO _0x49
                 ;     407 		{
                 ;     408 			rx0state = RX_HDR;				// Если пакет слишком длинный - отвергаю и иду в начало
0002fb c026      	RJMP _0x432
                 ;     409 			break;
                 ;     410 		}
                 ;     411 		rx0buf[rx0ptr++] = byt;				// Данные
                 _0x49:
0002fc 91e0 0884 	LDS  R30,_rx0ptr
0002fe 5fef      	SUBI R30,-LOW(1)
0002ff 93e0 0884 	STS  _rx0ptr,R30
000301 50e1      	SUBI R30,LOW(1)
000302 e0f0      	LDI  R31,0
000303 57eb      	SUBI R30,LOW(-_rx0buf)
000304 4ff8      	SBCI R31,HIGH(-_rx0buf)
000305 8300      	ST   Z,R16
                 ;     412 		if (rx0ptr < rx0len)						// Еще не все ?
000306 91a0 0884 	LDS  R26,_rx0ptr
000308 15ad      	CP   R26,R13
000309 f0d0      	BRLO _0x40
                 ;     413 		{
                 ;     414 			break;
                 ;     415 		}
                 ;     416 		rx0state = RX_CRC;					// К приему контрольной суммы
00030a e0e6      	LDI  R30,LOW(6)
00030b c017      	RJMP _0x430
                 ;     417 		break;
                 ;     418 
                 ;     419 	case RX_CRC:
                 _0x48:
00030c 30e6      	CPI  R30,LOW(0x6)
00030d f4a1      	BRNE _0x4E
                 ;     420 		if (byt != rx0crc)
00030e 16c0      	CP   R12,R16
00030f f011      	BREQ _0x4C
                 ;     421 		{
                 ;     422 			rx0state = RX_HDR;				// Не сошлась CRC - игнорирую пакет и жду следующий
000310 e0e1      	LDI  R30,LOW(1)
000311 c00b      	RJMP _0x433
                 ;     423 		}
                 ;     424 // убрал фильтр адреса
                 ;     425 else
                 _0x4C:
                 ;     426 {
                 ;     427 rx0buf[rx0ptr++] = byt;						// Данные
000312 91e0 0884 	LDS  R30,_rx0ptr
000314 5fef      	SUBI R30,-LOW(1)
000315 93e0 0884 	STS  _rx0ptr,R30
000317 50e1      	SUBI R30,LOW(1)
000318 e0f0      	LDI  R31,0
000319 57eb      	SUBI R30,LOW(-_rx0buf)
00031a 4ff8      	SBCI R31,HIGH(-_rx0buf)
00031b 8300      	ST   Z,R16
                 ;     428 rx0state = RX_OK;								// Принят пакет, на который нужно ответить
00031c e0e7      	LDI  R30,LOW(7)
                 _0x433:
00031d 2ebe      	MOV  R11,R30
                 ;     429 }
                 ;     430 /*		else if ((rx0addr == my_addr) || (rx0addr == TO_ALL))
                 ;     431 		{
                 ;     432  			rx0buf[rx0ptr++] = byt;			// Данные
                 ;     433     		rx0state = RX_OK;				// Принят пакет, на который нужно ответить
                 ;     434 		}
                 ;     435 		else
                 ;     436 		{
                 ;     437 			rx0state = RX_HDR;				// Принят пакет, адресованный не мне - жду следующего
                 ;     438 		}*/
                 ;     439 		TIMSK &= 0x10 ^ 0xFF;				// Запретить прерывание по тайм-ауту
00031e b7e7      	IN   R30,0x37
00031f 7eef      	ANDI R30,0xEF
000320 bfe7      	OUT  0x37,R30
                 ;     440 		break;
000321 c002      	RJMP _0x40
                 ;     441 		
                 ;     442 //	case RX_BUSY:							// Запрос принят, но ответ еще не готов
                 ;     443 		break;
                 ;     444 		
                 ;     445 	default:											// Ошибочное состояние
                 _0x4E:
                 ;     446 		rx0state = RX_HDR;					// Перехожу на начало
                 _0x432:
000322 e0e1      	LDI  R30,LOW(1)
                 _0x430:
000323 2ebe      	MOV  R11,R30
                 ;     447 		break;
                 ;     448 	}
                 _0x40:
                 ;     449 
                 ;     450 	rx0crc += byt;								// Подсчитываю контрольную сумму
000324 0ec0      	ADD  R12,R16
                 ;     451 }
000325 9109      	LD   R16,Y+
000326 91e9      	LD   R30,Y+
000327 bfef      	OUT  SREG,R30
000328 91f9      	LD   R31,Y+
000329 91e9      	LD   R30,Y+
00032a 91a9      	LD   R26,Y+
00032b 9518      	RETI
                 ;     452 
                 ;     453 // Прерывание по сравнению A таймера 1 для подсчета тайм-аута приема "внешнего" канала
                 ;     454 interrupt [TIM1_COMPA] void timer1_comp_a_isr(void)
                 ;     455 {
                 _timer1_comp_a_isr:
00032c 93ea      	ST   -Y,R30
00032d b7ef      	IN   R30,SREG
00032e 93ea      	ST   -Y,R30
                 ;     456 	rx0state = RX_HDR;						// По тайм-ауту перехожу к началу приема нового пакета
00032f e0e1      	LDI  R30,LOW(1)
000330 2ebe      	MOV  R11,R30
                 ;     457 	TIMSK &= 0x10 ^ 0xFF;					// Больше не генерировать прерываний
000331 b7e7      	IN   R30,0x37
000332 7eef      	ANDI R30,0xEF
000333 bfe7      	OUT  0x37,R30
                 ;     458 }
000334 91e9      	LD   R30,Y+
000335 bfef      	OUT  SREG,R30
000336 91e9      	LD   R30,Y+
000337 9518      	RETI
                 ;     459 
                 ;     460 unsigned char HaveIncomingPack(void)
                 ;     461 {
                 _HaveIncomingPack:
                 ;     462 	if (rx0state == RX_OK)	return 255;
000338 e0e7      	LDI  R30,LOW(7)
000339 15eb      	CP   R30,R11
00033a f411      	BRNE _0x4F
00033b efef      	LDI  R30,LOW(255)
00033c 9508      	RET
                 ;     463 	else					return 0;
                 _0x4F:
00033d e0e0      	LDI  R30,LOW(0)
00033e 9508      	RET
                 ;     464 }
00033f 9508      	RET
                 ;     465 
                 ;     466 unsigned char IncomingPackType(void)
                 ;     467 {
                 _IncomingPackType:
                 ;     468 	return rx0type;
000340 2dee      	MOV  R30,R14
000341 9508      	RET
                 ;     469 }
                 ;     470 
                 ;     471 void DiscardIncomingPack(void)
                 ;     472 {
                 _DiscardIncomingPack:
                 ;     473 	rx0state = RX_HDR;						// Разрешаю прием следующего пакета
000342 e0e1      	LDI  R30,LOW(1)
000343 2ebe      	MOV  R11,R30
                 ;     474 }
000344 9508      	RET
                 ;     475 
                 ;     476 // Настройка приемопередатчика
                 ;     477 void CommInit(void)
                 ;     478 {
                 _CommInit:
                 ;     479 	// Подтяжка на TXD
                 ;     480 //	DDRD.1 = 0;
                 ;     481 //	PORTD.1 = 1;
                 ;     482 /*	
                 ;     483 // USART0 initialization
                 ;     484 // Communication Parameters: 8 Data, 1 Stop, No Parity
                 ;     485 // USART0 Receiver: On
                 ;     486 // USART0 Transmitter: On
                 ;     487 // USART0 Mode: Asynchronous
                 ;     488 // USART0 Baud rate: 38400
                 ;     489 UCSR0A=0x00;
                 ;     490 UCSR0B=0x18;
                 ;     491 UCSR0C=0x06;
                 ;     492 UBRR0H=0x00;
                 ;     493 UBRR0L=0x0C;
                 ;     494 */
                 ;     495 
                 ;     496 
                 ;     497 	// Настраиваю UART
                 ;     498 	UCSR0A = 0b00000000;
000345 e0e0      	LDI  R30,LOW(0)
000346 b9eb      	OUT  0xB,R30
                 ;     499 	UCSR0B = 0b10010000;	//0b10011000;
000347 e9e0      	LDI  R30,LOW(144)
000348 b9ea      	OUT  0xA,R30
                 ;     500 	UCSR0C = 0x86;
000349 e8e6      	LDI  R30,LOW(134)
00034a 93e0 0095 	STS  149,R30
                 ;     501 	UBRR0L = ((_MCU_CLOCK_FREQUENCY_ / (16 * BAUD)) - 1) & 0xFF;
00034c e0ec      	LDI  R30,LOW(12)
00034d b9e9      	OUT  0x9,R30
                 ;     502 	UBRR0H = (((_MCU_CLOCK_FREQUENCY_ / (16 * BAUD)) - 1) >> 8) & 0xFF;
00034e e0e0      	LDI  R30,LOW(0)
00034f 93e0 0090 	STS  144,R30
                 ;     503 	
                 ;     504 	// Таймер 1 для подсчета тайм-аутов приема
                 ;     505 	TCCR1B  = 0b00000101;
000351 e0e5      	LDI  R30,LOW(5)
000352 bdee      	OUT  0x2E,R30
                 ;     506 }
000353 9508      	RET
                 ;     507 
                 ;     508 void putword0(unsigned short wd)
                 ;     509 {
                 _putword0:
                 ;     510 	putchar0(wd);
000354 81e8      	LD   R30,Y
000355 93ea      	ST   -Y,R30
000356 940e 02ab 	CALL _putchar0
                 ;     511 	putchar0(wd >> 8);
000358 81e9      	LDD  R30,Y+1
000359 70f0      	ANDI R31,HIGH(0x0)
00035a 93ea      	ST   -Y,R30
00035b 940e 02ab 	CALL _putchar0
                 ;     512 }                                  
00035d c0f5      	RJMP _0x42D
                 ;     513 
                 ;     514 
                 ;     515 // Ретрансляция цикла обмена из внешнего во внутр. канал и обратно
                 ;     516 // "Внутренний" канал должен быть свободен
                 ;     517 
                 ;     518 void RelayPack(void)
                 ;     519 {
                 _RelayPack:
                 ;     520 	register unsigned char i,a;
                 ;     521  LedRed();	
00035e 931a      	ST   -Y,R17
00035f 930a      	ST   -Y,R16
                 ;	i -> R16
                 ;	a -> R17
000360 9ad0      	SBI  0x1A,0
000361 9ad1      	SBI  0x1A,1
000362 98d8      	CBI  0x1B,0
000363 9ad9      	SBI  0x1B,1
                 ;     522 	// Передаю запрос
                 ;     523 	StartIntReq(rx0len);
000364 92da      	ST   -Y,R13
000365 d08a      	RCALL _StartIntReq
                 ;     524 	
                 ;     525 	// Тело пакета
                 ;     526 	for (i = 0; i < rx0len; i ++)
000366 e000      	LDI  R16,LOW(0)
                 _0x52:
000367 150d      	CP   R16,R13
000368 f498      	BRSH _0x53
                 ;     527 	{
                 ;     528 		twi_byte(rx0buf[i]);   
000369 2fe0      	MOV  R30,R16
00036a e0f0      	LDI  R31,0
00036b 57eb      	SUBI R30,LOW(-_rx0buf)
00036c 4ff8      	SBCI R31,HIGH(-_rx0buf)
00036d 81e0      	LD   R30,Z
00036e 93ea      	ST   -Y,R30
00036f d05d      	RCALL _twi_byte
                 ;     529 		tx1crc +=(rx0buf[i]);
000370 2fe0      	MOV  R30,R16
000371 e0f0      	LDI  R31,0
000372 57eb      	SUBI R30,LOW(-_rx0buf)
000373 4ff8      	SBCI R31,HIGH(-_rx0buf)
000374 81e0      	LD   R30,Z
000375 91a0 0885 	LDS  R26,_tx1crc
000377 0fea      	ADD  R30,R26
000378 93e0 0885 	STS  _tx1crc,R30
                 ;     530 	}
00037a 5f0f      	SUBI R16,-1
00037b cfeb      	RJMP _0x52
                 _0x53:
                 ;     531 	
                 ;     532 	// Окончание запроса
                 ;     533 	EndIntReq();
00037c d09d      	RCALL _EndIntReq
                 ;     534 	DiscardIncomingPack();        // разрешаем принимать след. пакет
00037d 940e 0342 	CALL _DiscardIncomingPack
                 ;     535 
                 ;     536 	delay_ms (10);						// принимаем ответ
00037f e0ea      	LDI  R30,LOW(10)
000380 e0f0      	LDI  R31,HIGH(10)
000381 93fa      	ST   -Y,R31
000382 93ea      	ST   -Y,R30
000383 940e 1dca 	CALL _delay_ms
                 ;     537 
                 ;     538 /*	if ((rx0buf[0] == TO_MON) || (rx0buf[0] == TO_MON))       // если пакет послан всем - принимаем ответ по очереди
                 ;     539 		{
                 ;     540 			for (a=1; a<= int_Devices; a++) pingPack (a);	
                 ;     541 		}
                 ;     542 	else	pingPack (rx0buf[0]);*/
                 ;     543 
                 ;     544 	pingPack (4);	
000385 e0e4      	LDI  R30,LOW(4)
000386 93ea      	ST   -Y,R30
000387 d1fc      	RCALL _pingPack
                 ;     545 
                 ;     546 } 
000388 c1a2      	RJMP _0x42C
                 ;     547   
                 ;     548 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                 ;     549 // 
                 ;     550 // Связь с внешним миром
                 ;     551 
                 ;     552 #include <Coding.h>
                 ;     553 
                 ;     554 // Биты TWCR
                 ;     555 #define TWINT 7
                 ;     556 #define TWEA  6
                 ;     557 #define TWSTA 5
                 ;     558 #define TWSTO 4
                 ;     559 #define TWWC  3
                 ;     560 #define TWEN  2
                 ;     561 #define TWIE  0
                 ;     562 
                 ;     563 // Состояния
                 ;     564 #define START		0x08
                 ;     565 #define	REP_START	0x10
                 ;     566 
                 ;     567 // Коды статуса
                 ;     568 #define	MTX_ADR_ACK		0x18
                 ;     569 #define	MRX_ADR_ACK		0x40
                 ;     570 #define	MTX_DATA_ACK	0x28
                 ;     571 #define	MRX_DATA_NACK	0x58
                 ;     572 #define	MRX_DATA_ACK	0x50
                 ;     573 
                 ;     574 // Подготовка аппаратного мастера I2C
                 ;     575 void twi_init (void)
                 ;     576 {
                 _twi_init:
                 ;     577 	TWSR=0x00;
000389 e0e0      	LDI  R30,LOW(0)
00038a 93e0 0071 	STS  113,R30
                 ;     578 	TWBR=0x20;
00038c e2e0      	LDI  R30,LOW(32)
00038d 93e0 0070 	STS  112,R30
                 ;     579 	TWAR=0x00;
00038f e0e0      	LDI  R30,LOW(0)
000390 93e0 0072 	STS  114,R30
                 ;     580 	TWCR=0x04;
000392 e0e4      	LDI  R30,LOW(4)
000393 93e0 0074 	STS  116,R30
                 ;     581 }
000395 9508      	RET
                 ;     582 
                 ;     583 // Жду флажка окончания текущей операции
                 ;     584 static void twi_wait_int (void)
                 ;     585 {
                 _twi_wait_int_G3:
                 ;     586 
                 ;     587 	while (!(TWCR & (1<<TWINT)))
                 _0x54:
000396 91e0 0074 	LDS  R30,116
000398 78e0      	ANDI R30,LOW(0x80)
000399 f429      	BRNE _0x56
                 ;     588 		{
                 ;     589 			   if ( flagTWI & ( 1<< time_is_Out))  break;  // выходим по тайм - ауту
00039a 91e0 098a 	LDS  R30,_flagTWI
00039c 70e1      	ANDI R30,LOW(0x1)
00039d f409      	BRNE _0x56
                 ;     590 		}; 
00039e cff7      	RJMP _0x54
                 _0x56:
                 ;     591 }
00039f 9508      	RET
                 ;     592 
                 ;     593 // Стартовое условие
                 ;     594 // Возвращает не 0, если все в порядке
                 ;     595 unsigned char twi_start (void)
                 ;     596 {
                 _twi_start:
                 ;     597 	TWCR = ((1<<TWINT)+(1<<TWSTA)+(1<<TWEN));
0003a0 eae4      	LDI  R30,LOW(164)
0003a1 93e0 0074 	STS  116,R30
                 ;     598 	
                 ;     599 	twi_wait_int();
0003a3 940e 0396 	CALL _twi_wait_int_G3
                 ;     600 
                 ;     601     if((TWSR != START)&&(TWSR != REP_START))
0003a5 91a0 0071 	LDS  R26,113
0003a7 30a8      	CPI  R26,LOW(0x8)
0003a8 f021      	BREQ _0x59
0003a9 91a0 0071 	LDS  R26,113
0003ab 31a0      	CPI  R26,LOW(0x10)
0003ac f409      	BRNE _0x5A
                 _0x59:
0003ad c002      	RJMP _0x58
                 _0x5A:
                 ;     602     {
                 ;     603 		return 0;
0003ae e0e0      	LDI  R30,LOW(0)
0003af 9508      	RET
                 ;     604 	}
                 ;     605 	
                 ;     606 	return 255;
                 _0x58:
0003b0 efef      	LDI  R30,LOW(255)
0003b1 9508      	RET
                 ;     607 }
                 ;     608 
                 ;     609 // Стоповое условие
                 ;     610 void twi_stop (void)
                 ;     611 {
                 _twi_stop:
                 ;     612 	TWCR = ((1<<TWEN)+(1<<TWINT)+(1<<TWSTO));
0003b2 e9e4      	LDI  R30,LOW(148)
0003b3 93e0 0074 	STS  116,R30
                 ;     613 }
0003b5 9508      	RET
                 ;     614 
                 ;     615 // Передача адреса
                 ;     616 // Возвращает не 0, если все в порядке
                 ;     617 unsigned char twi_addr (unsigned char addr)
                 ;     618 {
                 _twi_addr:
                 ;     619 	twi_wait_int();
0003b6 940e 0396 	CALL _twi_wait_int_G3
                 ;     620 
                 ;     621 	TWDR = addr;
0003b8 81e8      	LD   R30,Y
0003b9 93e0 0073 	STS  115,R30
                 ;     622 	TWCR = ((1<<TWINT)+(1<<TWEN));
0003bb e8e4      	LDI  R30,LOW(132)
0003bc 93e0 0074 	STS  116,R30
                 ;     623 
                 ;     624 	twi_wait_int();                 		// Ждем отклик 
0003be 940e 0396 	CALL _twi_wait_int_G3
                 ;     625 
                 ;     626 	if((TWSR != MTX_ADR_ACK)&&(TWSR != MRX_ADR_ACK))
0003c0 91a0 0071 	LDS  R26,113
0003c2 31a8      	CPI  R26,LOW(0x18)
0003c3 f021      	BREQ _0x5C
0003c4 91a0 0071 	LDS  R26,113
0003c6 34a0      	CPI  R26,LOW(0x40)
0003c7 f409      	BRNE _0x5D
                 _0x5C:
0003c8 c002      	RJMP _0x5B
                 _0x5D:
                 ;     627 	{
                 ;     628 		return 0;
0003c9 e0e0      	LDI  R30,LOW(0)
0003ca c04d      	RJMP _0x42E
                 ;     629 	}
                 ;     630 	return 255;
                 _0x5B:
0003cb efef      	LDI  R30,LOW(255)
0003cc c04b      	RJMP _0x42E
                 ;     631 }
                 ;     632 
                 ;     633 // Передача байта данных
                 ;     634 // Возвращает не 0, если все в порядке
                 ;     635 unsigned char twi_byte (unsigned char data)
                 ;     636 {
                 _twi_byte:
                 ;     637 	twi_wait_int();
0003cd 940e 0396 	CALL _twi_wait_int_G3
                 ;     638 
                 ;     639 	TWDR = data;
0003cf 81e8      	LD   R30,Y
0003d0 93e0 0073 	STS  115,R30
                 ;     640  	TWCR = ((1<<TWINT)+(1<<TWEN));
0003d2 e8e4      	LDI  R30,LOW(132)
0003d3 93e0 0074 	STS  116,R30
                 ;     641 
                 ;     642 	twi_wait_int();
0003d5 940e 0396 	CALL _twi_wait_int_G3
                 ;     643 
                 ;     644 	if(TWSR != MTX_DATA_ACK)
0003d7 91a0 0071 	LDS  R26,113
0003d9 32a8      	CPI  R26,LOW(0x28)
0003da f011      	BREQ _0x5E
                 ;     645 	{
                 ;     646 		return 0;
0003db e0e0      	LDI  R30,LOW(0)
0003dc c03b      	RJMP _0x42E
                 ;     647 	}
                 ;     648 		
                 ;     649 	return 255;
                 _0x5E:
0003dd efef      	LDI  R30,LOW(255)
0003de c039      	RJMP _0x42E
                 ;     650 }
                 ;     651 
                 ;     652 // Чтение байта 
                 ;     653 // Возвращает не 0, если все в порядке
                 ;     654 unsigned char  twi_read (unsigned char notlast)
                 ;     655 {
                 _twi_read:
                 ;     656 	timeOut ();									// запускаем тайм аут
0003df d105      	RCALL _timeOut
                 ;     657 
                 ;     658 	twi_wait_int();   
0003e0 940e 0396 	CALL _twi_wait_int_G3
                 ;     659 
                 ;     660 	if(notlast)     // формируем подтверждение приема
0003e2 81e8      	LD   R30,Y
0003e3 30e0      	CPI  R30,0
0003e4 f011      	BREQ _0x5F
                 ;     661 		{
                 ;     662 			TWCR = ((1<<TWINT)+(1<<TWEA)+(1<<TWEN));
0003e5 ece4      	LDI  R30,LOW(196)
0003e6 c001      	RJMP _0x434
                 ;     663 		}
                 ;     664 		else            // НЕ формируем подтверждение приема
                 _0x5F:
                 ;     665 		{
                 ;     666 			TWCR = ((1<<TWINT)+(1<<TWEN));
0003e7 e8e4      	LDI  R30,LOW(132)
                 _0x434:
0003e8 93e0 0074 	STS  116,R30
                 ;     667 		}
                 ;     668  	twi_wait_int();    
0003ea 940e 0396 	CALL _twi_wait_int_G3
                 ;     669 
                 ;     670  	timeOutStop ();							// останов таймера таймаута   
0003ec d0fd      	RCALL _timeOutStop
                 ;     671 
                 ;     672 		return TWDR;
0003ed 91e0 0073 	LDS  R30,115
0003ef c028      	RJMP _0x42E
                 ;     673 }
                 ;     674 
                 ;     675 // Изменение значения бита порта
                 ;     676 static inline void PortBitChange(unsigned char port, unsigned char bnum, unsigned char set)
                 ;     677 {
                 ;     678 	register unsigned char mask;
                 ;     679 	#asm("cli");
                 ;	port -> Y+3
                 ;	bnum -> Y+2
                 ;	set -> Y+1
                 ;	mask -> R16
                 ;     680 
                 ;     681 	mask = 1 << bnum;		// Маска
                 ;     682 	if (!set)
                 ;     683 	{
                 ;     684 		mask ^= 0xFF;
                 ;     685 	}
                 ;     686 		
                 ;     687 	switch(port)
                 ;     688 	{
                 ;     689 	case 'B':
                 ;     690 		if (set) PORTB |= mask; else PORTB &= mask;
                 ;     691 		break;
                 ;     692 	case 'C':
                 ;     693 		if (set) PORTC |= mask; else PORTC &= mask;
                 ;     694 		break;
                 ;     695 	case 'D':
                 ;     696 		if (set) PORTD |= mask; else PORTD &= mask;
                 ;     697 		break;
                 ;     698 	}
                 ;     699 	
                 ;     700 	#asm("sei");
                 ;     701 }
                 ;     702 
                 ;     703 // Передача таблицы из FLASH в I2C
                 ;     704 void i2c_tab (flash unsigned char * tbl, void (* rwfunc)(void))
                 ;     705 {
                 ;     706 	register unsigned char n, p;
                 ;     707 	register flash unsigned char * ptr;
                 ;     708 	
                 ;     709 	while(1)
                 ;	*tbl -> Y+6
                 ;	*rwfunc -> Y+4
                 ;	n -> R16
                 ;	p -> R17
                 ;	*ptr -> R18,R19
                 ;     710 	{
                 ;     711 		if (rwfunc)			// Если нужно, запускаю ожидание готовности
                 ;     712 		{
                 ;     713 			(*rwfunc)();
                 ;     714 		}
                 ;     715 		
                 ;     716 		n = *tbl++;
                 ;     717 		
                 ;     718 		if (!n)				// Если больше нечего передавать ...
                 ;     719 		{
                 ;     720 			return;
                 ;     721 		}
                 ;     722 
                 ;     723 		if (n == 255)		// Если признак бита порта процессора ...
                 ;     724 		{
                 ;     725 			p = *tbl++;						// Порт B, C или D
                 ;     726 			n = *tbl++;						// Номер бита
                 ;     727 			PortBitChange(p, n, *tbl++);	// Взвести или сбросить
                 ;     728 			continue;						// К следующей строке
                 ;     729 		}
                 ;     730 
                 ;     731 		n = n - 2;
                 ;     732 		
                 ;     733 		ptr = tbl;
                 ;     734 		while(1)
                 ;     735 		{
                 ;     736 			if (!twi_start())
                 ;     737 			{
                 ;     738 				twi_stop();
                 ;     739 				continue;
                 ;     740 			}
                 ;     741 	
                 ;     742 			if (!twi_addr(*tbl++))
                 ;     743 			{
                 ;     744 				twi_stop();
                 ;     745 				tbl = ptr;
                 ;     746 				continue;
                 ;     747 			}
                 ;     748 		
                 ;     749 			break;
                 ;     750 		}
                 ;     751 		
                 ;     752 		twi_byte(*tbl++);
                 ;     753 		
                 ;     754 		while(n--)
                 ;     755 		{
                 ;     756 			twi_byte(*tbl++);
                 ;     757 		}
                 ;     758 		
                 ;     759 		twi_stop();
                 ;     760 	}
                 ;     761 }
                 ;     762 
                 ;     763 /*
                 ;     764 // Передача в заданный адрес I2C nbytes байт
                 ;     765 void i2c_bytes (unsigned char addr, unsigned char sbaddr, unsigned char nbytes, ...)
                 ;     766 {
                 ;     767 	va_list argptr;
                 ;     768 	char byt;
                 ;     769 	
                 ;     770 	va_start(argptr, nbytes);
                 ;     771 	
                 ;     772 	while(1)
                 ;     773 	{
                 ;     774 		if (!twi_start())
                 ;     775 		{
                 ;     776 			twi_stop();
                 ;     777 			continue;
                 ;     778 		}
                 ;     779 	
                 ;     780 		if (!twi_addr(addr))
                 ;     781 		{
                 ;     782 			twi_stop();
                 ;     783 			continue;
                 ;     784 		}
                 ;     785 		
                 ;     786 		break;
                 ;     787 	}
                 ;     788 	
                 ;     789 	twi_byte(sbaddr);
                 ;     790 
                 ;     791 	while(nbytes--)
                 ;     792 	{
                 ;     793 		byt = va_arg(argptr, char);
                 ;     794 		twi_byte(byt);
                 ;     795 	}		
                 ;     796 	va_end(argptr);
                 ;     797 		
                 ;     798 	twi_stop();
                 ;     799 }
                 ;     800 */
                 ;     801 
                 ;     802 // Передача в заданный адрес I2C таблицы PSI
                 ;     803 void i2c_psi_table (
                 ;     804 		unsigned char addr,
                 ;     805 		unsigned char sbaddr,
                 ;     806 		unsigned char tblnum,
                 ;     807 		unsigned short pid,
                 ;     808 		unsigned char * buf)
                 ;     809 {
                 ;     810 	unsigned char n;
                 ;     811 	
                 ;     812 	pid &= 0x1FFF;
                 ;	addr -> Y+7
                 ;	sbaddr -> Y+6
                 ;	tblnum -> Y+5
                 ;	pid -> Y+3
                 ;	*buf -> Y+1
                 ;	n -> R16
                 ;     813 	pid |= 0x4000;
                 ;     814 
                 ;     815 	while(1)
                 ;     816 	{	
                 ;     817 		if (!twi_start())
                 ;     818 		{
                 ;     819 			twi_stop();
                 ;     820 			continue;
                 ;     821 		}
                 ;     822 		
                 ;     823 		if (!twi_addr(addr))
                 ;     824 		{
                 ;     825 			twi_stop();
                 ;     826 			continue;
                 ;     827 		}
                 ;     828 		
                 ;     829 		break;
                 ;     830 	}
                 ;     831 		
                 ;     832 	twi_byte(sbaddr);
                 ;     833 	
                 ;     834 	twi_byte(tblnum);
                 ;     835 
                 ;     836 	twi_byte(0x47);			// Заголовок пакета
                 ;     837 	twi_byte(pid >> 8);	
                 ;     838 	twi_byte(pid & 0xFF);	
                 ;     839 	twi_byte(0x10);	
                 ;     840 	twi_byte(0x00);	
                 ;     841 	
                 ;     842 	for (n = buf[2] + 3; n != 0; n --)
                 ;     843 	{
                 ;     844 		twi_byte(*buf++);
                 ;     845 	}
                 ;     846 	
                 ;     847 	twi_stop();
                 ;     848 }
                 ;     849      
                 ;     850 ////////////////////////////////////////////////////////////////////////////////
                 ;     851 // Работа с внутренним каналом
                 ;     852 
                 ;     853 unsigned char tx1crc;
                 
                 	.DSEG
                 _tx1crc:
000885           	.BYTE 0x1
                 ;     854 unsigned char rx1state = RX_IDLE;
                 _rx1state:
000886           	.BYTE 0x1
                 ;     855 unsigned char rx1crc;
                 _rx1crc:
000887           	.BYTE 0x1
                 ;     856 unsigned char rx1len;
                 _rx1len:
000888           	.BYTE 0x1
                 ;     857 unsigned char rx1buf[256];
                 _rx1buf:
000889           	.BYTE 0x100
                 ;     858 unsigned char rx1ptr;
                 _rx1ptr:
000989           	.BYTE 0x1
                 ;     859 
                 ;     860 /*// Передача байта во "внутренний" канал
                 ;     861 void putword1(unsigned int wd)
                 ;     862 {
                 ;     863 	putchar1(wd);
                 ;     864 	putchar1(wd >> 8);
                 ;     865 } */
                 ;     866 
                 ;     867 // Начало запроса во внутренний канал
                 ;     868 void StartIntReq(unsigned char dlen) 
                 ;     869 {
                 
                 	.CSEG
                 _StartIntReq:
                 ;     870 	while(1)
                 _0x85:
                 ;     871 	{	
                 ;     872 		if (!twi_start())       // Cтарт пакета
0003f0 940e 03a0 	CALL _twi_start
0003f2 30e0      	CPI  R30,0
0003f3 f419      	BRNE _0x88
                 ;     873 		{
                 ;     874 			twi_stop();
0003f4 940e 03b2 	CALL _twi_stop
                 ;     875 			continue;
0003f6 cff9      	RJMP _0x85
                 ;     876 		}
                 ;     877 
                 ;     878 		
                 ;     879 		if (!twi_addr(0))       // Передача всем подчиненным
                 _0x88:
0003f7 e0e0      	LDI  R30,LOW(0)
0003f8 93ea      	ST   -Y,R30
0003f9 940e 03b6 	CALL _twi_addr
0003fb 30e0      	CPI  R30,0
0003fc f419      	BRNE _0x89
                 ;     880 		{
                 ;     881 			twi_stop();
0003fd 940e 03b2 	CALL _twi_stop
                 ;     882 			continue;
0003ff cff0      	RJMP _0x85
                 ;     883 		}
                 ;     884 		
                 ;     885 		break;
                 _0x89:
                 ;     886 	}
                 ;     887 
                 ;     888 
                 ;     889 	tx1crc = 0;					// Готовлю CRC
000400 e0e0      	LDI  R30,LOW(0)
000401 93e0 0885 	STS  _tx1crc,R30
                 ;     890 
                 ;     891 	twi_byte(PACKHDR);		    // Передаю заголовок
000403 e7e1      	LDI  R30,LOW(113)
000404 93ea      	ST   -Y,R30
000405 940e 03cd 	CALL _twi_byte
                 ;     892 	tx1crc+=(PACKHDR);
000407 91e0 0885 	LDS  R30,_tx1crc
000409 58ef      	SUBI R30,-LOW(113)
00040a 93e0 0885 	STS  _tx1crc,R30
                 ;     893 
                 ;     894 	twi_byte(dlen+1);			// Передаю длину
00040c 81e8      	LD   R30,Y
00040d 5fef      	SUBI R30,-LOW(1)
00040e 93ea      	ST   -Y,R30
00040f 940e 03cd 	CALL _twi_byte
                 ;     895 	tx1crc+=(dlen+1);
000411 81e8      	LD   R30,Y
000412 5fef      	SUBI R30,-LOW(1)
000413 91a0 0885 	LDS  R26,_tx1crc
000415 0fea      	ADD  R30,R26
000416 93e0 0885 	STS  _tx1crc,R30
                 ;     896 }
                 _0x42E:
000418 9621      	ADIW R28,1
000419 9508      	RET
                 ;     897 
                 ;     898 // Завершение запроса во внутренний канал
                 ;     899 void EndIntReq(void)
                 ;     900 {
                 _EndIntReq:
                 ;     901 	twi_byte(tx1crc);			// Контрольная сумма
00041a 91e0 0885 	LDS  R30,_tx1crc
00041c 93ea      	ST   -Y,R30
00041d 940e 03cd 	CALL _twi_byte
                 ;     902 	twi_stop();                 // Cтоп
00041f 940e 03b2 	CALL _twi_stop
                 ;     903 
                 ;     904 	
                 ;     905 //	rx1state = RX_LEN;			// Приемнику начать прием пакета
                 ;     906 
                 ;     907 //	OCR1B = TCNT1+RX1TIMEOUT;	// Взвожу тайм-аут
                 ;     908 //	TIFR = 0x08;				// Предотвращаю ложное срабатывание
                 ;     909 //	TIMSK |= 0x08;				// Разрешение прерывания по тайм-ауту
                 ;     910 }
000421 9508      	RET
                 ;     911 
                 ;     912 // Прием байта из "внутреннего" канала TWI
                 ;     913 void TWI_rx_isr(void)
                 ;     914 {
                 ;     915 	register unsigned char byt;
                 ;     916 	twi_start();                //Запрашиваю байт ответа
                 ;	byt -> R16
                 ;     917     	
                 ;     918     
                 ;     919 	byt = UDR1;
                 ;     920 	
                 ;     921 	switch (rx1state)
                 ;     922 	{
                 ;     923 	case RX_LEN:				// Принята длина пакета
                 ;     924 		rx1crc = 0;
                 ;     925 		rx1ptr = 0;
                 ;     926 		rx1len = byt - 1;
                 ;     927 		if (rx1len)
                 ;     928 		{
                 ;     929 			rx1state = RX_DATA;
                 ;     930 		}
                 ;     931 		else
                 ;     932 		{
                 ;     933 			rx1state = RX_CRC;
                 ;     934 		}
                 ;     935 //printf("L%d", rx1len);
                 ;     936 		break;
                 ;     937 
                 ;     938 	case RX_DATA:				// Принят байт данных пакета
                 ;     939 //printf("D");
                 ;     940 		rx1buf[rx1ptr++] = byt;
                 ;     941 		if (rx1ptr < rx1len)	// Уже все ?
                 ;     942 		{
                 ;     943 			break;
                 ;     944 		}
                 ;     945 		rx1state = RX_CRC;
                 ;     946 		break;
                 ;     947 		
                 ;     948 	case RX_CRC:				// Принята контрольная сумма пакета
                 ;     949 		if (byt != rx1crc)
                 ;     950 		{
                 ;     951 			rx1state = RX_ERR;	// Не сошлась CRC
                 ;     952 //printf("C");
                 ;     953 		}
                 ;     954 		else
                 ;     955 		{
                 ;     956 			rx1state = RX_OK;	// Пакет успешно принят
                 ;     957 //printf("+");
                 ;     958 		}
                 ;     959 
                 ;     960 		TIMSK &= 0x08 ^ 0xFF;	// Запретить прерывание по тайм-ауту
                 ;     961 		break;
                 ;     962 
                 ;     963 	default:					// В остальных состояниях - ничего не делать
                 ;     964 		break;
                 ;     965 	}
                 ;     966 
                 ;     967 	rx1crc += byt;				// Подсчитываю контрольную сумму
                 ;     968 } 
                 ;     969 
                 ;     970 // Прерывание по сравнению B таймера 1 для подсчета тайм-аута приема "внутреннего" канала
                 ;     971 interrupt [TIM1_COMPB] void timer1_comp_b_isr(void)
                 ;     972 {
                 _timer1_comp_b_isr:
000422 93ea      	ST   -Y,R30
000423 b7ef      	IN   R30,SREG
000424 93ea      	ST   -Y,R30
                 ;     973 	rx1state = RX_TIME;		// Был тайм-аут
000425 e0e8      	LDI  R30,LOW(8)
000426 93e0 0886 	STS  _rx1state,R30
                 ;     974 	TIMSK &= 0x08 ^ 0xFF;	// Запретить прерывание по тайм-ауту
000428 b7e7      	IN   R30,0x37
000429 7fe7      	ANDI R30,0XF7
00042a bfe7      	OUT  0x37,R30
                 ;     975 //printf("T");
                 ;     976 }
00042b 91e9      	LD   R30,Y+
00042c bfef      	OUT  SREG,R30
00042d 91e9      	LD   R30,Y+
00042e 9518      	RETI
                 ;     977 
                 ;     978 // Проверка занятости "внутреннего" канала
                 ;     979 unsigned char InternalComBusy(void)
                 ;     980 {
                 ;     981 	if (rx1state != RX_IDLE)	return 1;
                 ;     982 	else						return 0;
                 ;     983 }
                 ;     984 
                 ;     985 // Признак завершения цикла обмена во внутрю канале
                 ;     986 unsigned char HaveInternalReply(void)
                 ;     987 {
                 ;     988 	switch(rx1state)
                 ;     989 	{
                 ;     990 	case RX_OK:
                 ;     991 	case RX_TIME:
                 ;     992 	case RX_ERR:
                 ;     993 		return rx1state;
                 ;     994 	default:
                 ;     995 		return 0;
                 ;     996 	}
                 ;     997 }
                 ;     998 
                 ;     999 // Необходимо вызвать после завершения обработки принятого по "внутреннему" каналу пакета
                 ;    1000 void FreeInternalCom(void)
                 ;    1001 {
                 ;    1002 	rx1state = RX_IDLE;
                 ;    1003 }
                 ;    1004 
                 ;    1005 // Передача байта byte по pAddr
                 ;    1006 unsigned char txTWIbyte (unsigned char pAddr, unsigned char byte)
                 ;    1007 	{  
                 _txTWIbyte:
                 ;    1008 
                 ;    1009 		timeOut ();									// запускаем тайм аут
00042f d0b5      	RCALL _timeOut
                 ;    1010 
                 ;    1011 		if (!twi_start())     		  				// Cтарт пакета
000430 940e 03a0 	CALL _twi_start
000432 30e0      	CPI  R30,0
000433 f411      	BRNE _0xA1
                 ;    1012 			{
                 ;    1013 				twi_stop();
000434 940e 03b2 	CALL _twi_stop
                 ;    1014 			}
                 ;    1015 		
                 ;    1016 		if (!twi_addr((pAddr<<1)+0))       // Передача  по адресу pAddr (мл 0 - запись)
                 _0xA1:
000436 81e9      	LDD  R30,Y+1
000437 0fee      	LSL  R30
000438 93ea      	ST   -Y,R30
000439 940e 03b6 	CALL _twi_addr
00043b 30e0      	CPI  R30,0
00043c f411      	BRNE _0xA2
                 ;    1017 			{
                 ;    1018 				twi_stop();
00043d 940e 03b2 	CALL _twi_stop
                 ;    1019 			}            
                 ;    1020 			
                 ;    1021 		twi_byte(byte);								// передаем байт
                 _0xA2:
00043f 81e8      	LD   R30,Y
000440 93ea      	ST   -Y,R30
000441 940e 03cd 	CALL _twi_byte
                 ;    1022 		twi_stop();									// стоп пакета
000443 940e 03b2 	CALL _twi_stop
                 ;    1023 
                 ;    1024 		timeOutStop ();							// останов таймера таймаута   
000445 d0a4      	RCALL _timeOutStop
                 ;    1025 		
                 ;    1026 	    if ( ! ( flagTWI & ( 1 << time_is_Out))) return 255;
000446 91e0 098a 	LDS  R30,_flagTWI
000448 70e1      	ANDI R30,LOW(0x1)
000449 f411      	BRNE _0xA3
00044a efef      	LDI  R30,LOW(255)
00044b c007      	RJMP _0x42D
                 ;    1027 	    	else 
                 _0xA3:
                 ;    1028 	    		{
                 ;    1029 					flagTWI  = flagTWI  ^ (1 << time_is_Out);	//сбрасываем  признак
00044c 91a0 098a 	LDS  R26,_flagTWI
00044e e0e1      	LDI  R30,LOW(1)
00044f 27ea      	EOR  R30,R26
000450 93e0 098a 	STS  _flagTWI,R30
                 ;    1030 					return 0;
000452 e0e0      	LDI  R30,LOW(0)
                 ;    1031 	    		}
                 ;    1032 	}
                 _0x42D:
000453 9622      	ADIW R28,2
000454 9508      	RET
                 ;    1033 
                 ;    1034 unsigned char txTWIbuff (unsigned char pAddr)
                 ;    1035 	{                                                                           
                 _txTWIbuff:
                 ;    1036 		unsigned char a ;
                 ;    1037 		
                 ;    1038 		timeOut ();									// запускаем тайм аут
000455 930a      	ST   -Y,R16
                 ;	pAddr -> Y+1
                 ;	a -> R16
000456 d08e      	RCALL _timeOut
                 ;    1039 		if (!twi_start())     		  				// Cтарт пакета
000457 940e 03a0 	CALL _twi_start
000459 30e0      	CPI  R30,0
00045a f411      	BRNE _0xA5
                 ;    1040 			{
                 ;    1041 				twi_stop();
00045b 940e 03b2 	CALL _twi_stop
                 ;    1042 			}
                 ;    1043 
                 ;    1044 		if (!twi_addr((pAddr<<1)+0))       // Передача  по адресу pAddr (мл 0 - запись)
                 _0xA5:
00045d 81e9      	LDD  R30,Y+1
00045e 0fee      	LSL  R30
00045f 93ea      	ST   -Y,R30
000460 940e 03b6 	CALL _twi_addr
000462 30e0      	CPI  R30,0
000463 f411      	BRNE _0xA6
                 ;    1045 			{
                 ;    1046 				twi_stop();
000464 940e 03b2 	CALL _twi_stop
                 ;    1047 			}            
                 ;    1048 
                 ;    1049 	twi_wait_int(); 					// ждем отклик на адрес
                 _0xA6:
000466 940e 0396 	CALL _twi_wait_int_G3
                 ;    1050 
                 ;    1051 		for (a=0;a<=txBuffer[1]+1;a++)     //длина+заголовок
000468 e000      	LDI  R16,LOW(0)
                 _0xA8:
000469 91e0 0501 	__GETB1MN _txBuffer,1
00046b 5fef      	SUBI R30,-LOW(1)
00046c 17e0      	CP   R30,R16
00046d f050      	BRLO _0xA9
                 ;    1052 			{		                         
                 ;    1053 				twi_byte(txBuffer[a]);				// передаем байт
00046e 2fe0      	MOV  R30,R16
00046f e0f0      	LDI  R31,0
000470 50e0      	SUBI R30,LOW(-_txBuffer)
000471 4ffb      	SBCI R31,HIGH(-_txBuffer)
000472 81e0      	LD   R30,Z
000473 93ea      	ST   -Y,R30
000474 940e 03cd 	CALL _twi_byte
                 ;    1054 			}		
000476 5f0f      	SUBI R16,-1
000477 cff1      	RJMP _0xA8
                 _0xA9:
                 ;    1055 
                 ;    1056 			twi_stop();									// стоп пакета
000478 940e 03b2 	CALL _twi_stop
                 ;    1057 			timeOutStop ();							// останов таймера таймаута   
00047a d06f      	RCALL _timeOutStop
                 ;    1058 		
                 ;    1059 	    	if ( ! ( flagTWI & ( 1 << time_is_Out))) return 255;
00047b 91e0 098a 	LDS  R30,_flagTWI
00047d 70e1      	ANDI R30,LOW(0x1)
00047e f411      	BRNE _0xAA
00047f efef      	LDI  R30,LOW(255)
000480 c137      	RJMP _0x42B
                 ;    1060 	    		else 
                 _0xAA:
                 ;    1061 	    			{
                 ;    1062 						flagTWI  = flagTWI  ^ (1 << time_is_Out);	//сбрасываем  признак
000481 91a0 098a 	LDS  R26,_flagTWI
000483 e0e1      	LDI  R30,LOW(1)
000484 27ea      	EOR  R30,R26
000485 93e0 098a 	STS  _flagTWI,R30
                 ;    1063 						return 0;
000487 e0e0      	LDI  R30,LOW(0)
000488 c12f      	RJMP _0x42B
                 ;    1064 		    		}
                 ;    1065 	}
                 ;    1066 	
                 ;    1067 
                 ;    1068 // Вычитываем в буффер
                 ;    1069 unsigned char rxTWIbuff (unsigned char pAddr)
                 ;    1070 		{                                                         
                 _rxTWIbuff:
                 ;    1071 		unsigned char a;
                 ;    1072 
                 ;    1073 		if (!twi_start())     		  				// Cтарт пакета
000489 930a      	ST   -Y,R16
                 ;	pAddr -> Y+1
                 ;	a -> R16
00048a 940e 03a0 	CALL _twi_start
00048c 30e0      	CPI  R30,0
00048d f411      	BRNE _0xAC
                 ;    1074 			{
                 ;    1075 				twi_stop();
00048e 940e 03b2 	CALL _twi_stop
                 ;    1076 			}
                 ;    1077 
                 ;    1078 		if (!twi_addr((pAddr<<1)+1))       // Передача  по адресу pAddr (мл 1 - чтение)
                 _0xAC:
000490 81e9      	LDD  R30,Y+1
000491 0fee      	LSL  R30
000492 5fef      	SUBI R30,-LOW(1)
000493 93ea      	ST   -Y,R30
000494 940e 03b6 	CALL _twi_addr
000496 30e0      	CPI  R30,0
000497 f411      	BRNE _0xAD
                 ;    1079 			{
                 ;    1080 				twi_stop();
000498 940e 03b2 	CALL _twi_stop
                 ;    1081 			}            
                 ;    1082 
                 ;    1083 		rxBuffer[0] = twi_read(1);				// читаем  и запоминаем  длину принимаемого пакета
                 _0xAD:
00049a e0e1      	LDI  R30,LOW(1)
00049b 93ea      	ST   -Y,R30
00049c 940e 03df 	CALL _twi_read
00049e 93e0 0600 	STS  _rxBuffer,R30
                 ;    1084 
                 ;    1085 		for (a=1; a<rxBuffer[0];  a++)
0004a0 e001      	LDI  R16,LOW(1)
                 _0xAF:
0004a1 91e0 0600 	LDS  R30,_rxBuffer
0004a3 170e      	CP   R16,R30
0004a4 f478      	BRSH _0xB0
                 ;    1086 			{
                 ;    1087 				rxBuffer[a] = twi_read(1);			// не посл. байт - формируем ACK
0004a5 2fe0      	MOV  R30,R16
0004a6 e0f0      	LDI  R31,0
0004a7 50e0      	SUBI R30,LOW(-_rxBuffer)
0004a8 4ffa      	SBCI R31,HIGH(-_rxBuffer)
0004a9 93ff      	PUSH R31
0004aa 93ef      	PUSH R30
0004ab e0e1      	LDI  R30,LOW(1)
0004ac 93ea      	ST   -Y,R30
0004ad 940e 03df 	CALL _twi_read
0004af 91af      	POP  R26
0004b0 91bf      	POP  R27
0004b1 93ec      	ST   X,R30
                 ;    1088 			}              
0004b2 5f0f      	SUBI R16,-1
0004b3 cfed      	RJMP _0xAF
                 _0xB0:
                 ;    1089 
                 ;    1090 				rxBuffer[a] = twi_read(0);			// посл. байт -  не формируем ACK
0004b4 2fe0      	MOV  R30,R16
0004b5 e0f0      	LDI  R31,0
0004b6 50e0      	SUBI R30,LOW(-_rxBuffer)
0004b7 4ffa      	SBCI R31,HIGH(-_rxBuffer)
0004b8 93ff      	PUSH R31
0004b9 93ef      	PUSH R30
0004ba e0e0      	LDI  R30,LOW(0)
0004bb 93ea      	ST   -Y,R30
0004bc 940e 03df 	CALL _twi_read
0004be 91af      	POP  R26
0004bf 91bf      	POP  R27
0004c0 93ec      	ST   X,R30
                 ;    1091 
                 ;    1092 			twi_stop();									// стоп пакета               
0004c1 940e 03b2 	CALL _twi_stop
                 ;    1093 			
                 ;    1094 						// Проверяем таймаут и CRC
                 ;    1095 	    	if ( (! ( flagTWI & ( 1 << time_is_Out))) && (rxCRC())) return 255;	//Ok
0004c3 91e0 098a 	LDS  R30,_flagTWI
0004c5 70e1      	ANDI R30,LOW(0x1)
0004c6 f419      	BRNE _0xB2
0004c7 d049      	RCALL _rxCRC
0004c8 30e0      	CPI  R30,0
0004c9 f409      	BRNE _0xB3
                 _0xB2:
0004ca c002      	RJMP _0xB1
                 _0xB3:
0004cb efef      	LDI  R30,LOW(255)
0004cc c0eb      	RJMP _0x42B
                 ;    1096     		else 
                 _0xB1:
                 ;    1097 	    			{
                 ;    1098 						flagTWI  = flagTWI  ^ (1 << time_is_Out);		//сбрасываем  признак
0004cd 91a0 098a 	LDS  R26,_flagTWI
0004cf e0e1      	LDI  R30,LOW(1)
0004d0 27ea      	EOR  R30,R26
0004d1 93e0 098a 	STS  _flagTWI,R30
                 ;    1099 						return 0;                                                          // Time Out
0004d3 e0e0      	LDI  R30,LOW(0)
0004d4 c0e3      	RJMP _0x42B
                 ;    1100 		    		}
                 ;    1101 		}
                 ;    1102 #include "Coding.h"
                 ;    1103 
                 ;    1104 unsigned char flagTWI				=	0;
                 
                 	.DSEG
                 _flagTWI:
00098a           	.BYTE 0x1
                 ;    1105 unsigned char int_Devices		=	0;			// количество подчиненных устройств
                 _int_Devices:
00098b           	.BYTE 0x1
                 ;    1106 
                 ;    1107 
                 ;    1108 
                 ;    1109 // Инициализация выводов
                 ;    1110 void portInit (void)
                 ;    1111 		{
                 
                 	.CSEG
                 _portInit:
                 ;    1112 			DDRB.7 = 1;		// testpin
0004d5 9abf      	SBI  0x17,7
                 ;    1113 			CS_DDR_SET();	// для CF Card
0004d6 9abc      	SBI  0x17,4
                 ;    1114 		}
0004d7 9508      	RET
                 ;    1115 
                 ;    1116 
                 ;    1117 
                 ;    1118 // -------------------- Функции работы с таймером 0 -------------------------------
                 ;    1119 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;    1120 // Timer/Counter 0 initialization ; Clock source: System Clock
                 ;    1121 // Clock value: 31,250 kHz ;  Mode: Normal top=FFh
                 ;    1122 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;    1123 void timer_0_Init  (void)
                 ;    1124 	{
                 _timer_0_Init:
                 ;    1125 		ASSR=0x00;
0004d8 e0e0      	LDI  R30,LOW(0)
0004d9 bfe0      	OUT  0x30,R30
                 ;    1126 		TCCR0=0x0;        //0x06 -start
0004da bfe3      	OUT  0x33,R30
                 ;    1127 		TCNT0=0x01;
0004db e0e1      	LDI  R30,LOW(1)
0004dc bfe2      	OUT  0x32,R30
                 ;    1128 		OCR0=0x00;
0004dd e0e0      	LDI  R30,LOW(0)
0004de bfe1      	OUT  0x31,R30
                 ;    1129 
                 ;    1130 		TIMSK=0x01;			// Timer(s)/Counter(s) Interrupt(s) initialization
0004df e0e1      	LDI  R30,LOW(1)
0004e0 bfe7      	OUT  0x37,R30
                 ;    1131 		ETIMSK=0x00;
0004e1 e0e0      	LDI  R30,LOW(0)
0004e2 93e0 007d 	STS  125,R30
                 ;    1132 
                 ;    1133 	}
0004e4 9508      	RET
                 ;    1134 
                 ;    1135 // запускаем таймер для таймаута
                 ;    1136 void timeOut (void)
                 ;    1137 	{
                 _timeOut:
                 ;    1138 //		flagTWI  = (flagTWI  ^ (1 << time_is_Out));		// сброс признака
                 ;    1139 		TCNT0=0x0	;														// обнуляем счетчик
0004e5 e0e0      	LDI  R30,LOW(0)
0004e6 bfe2      	OUT  0x32,R30
                 ;    1140 		TCCR0 = 0x06;													// пускаем таймер (около 10 мс)
0004e7 e0e6      	LDI  R30,LOW(6)
0004e8 bfe3      	OUT  0x33,R30
                 ;    1141 	}
0004e9 9508      	RET
                 ;    1142 
                 ;    1143 // остановка таймера для таймаута
                 ;    1144 void timeOutStop (void)
                 ;    1145 	{
                 _timeOutStop:
                 ;    1146 		TCCR0 = 0x0; 						// осттанов таймера (около 10 мс)
0004ea e0e0      	LDI  R30,LOW(0)
0004eb bfe3      	OUT  0x33,R30
                 ;    1147 	}
0004ec 9508      	RET
                 ;    1148 
                 ;    1149 
                 ;    1150 // Timer 0 overflow interrupt service routine
                 ;    1151 interrupt [TIM0_OVF] void timer0_ovf_isr(void)
                 ;    1152 {
                 _timer0_ovf_isr:
0004ed 93ea      	ST   -Y,R30
0004ee b7ef      	IN   R30,SREG
0004ef 93ea      	ST   -Y,R30
                 ;    1153 		TCCR0 = 0x0;						//останавливаем таймер
0004f0 e0e0      	LDI  R30,LOW(0)
0004f1 bfe3      	OUT  0x33,R30
                 ;    1154 		flagTWI  = flagTWI  | (1 << time_is_Out);	 //взводим признак    
0004f2 91e0 098a 	LDS  R30,_flagTWI
0004f4 60e1      	ORI  R30,1
0004f5 93e0 098a 	STS  _flagTWI,R30
                 ;    1155 
                 ;    1156 }
0004f7 91e9      	LD   R30,Y+
0004f8 bfef      	OUT  SREG,R30
0004f9 91e9      	LD   R30,Y+
0004fa 9518      	RETI
                 ;    1157                                                                                              
                 ;    1158 // Проверяем количество подчиненных устройств
                 ;    1159 void verIntDev (void)
                 ;    1160 	{
                 _verIntDev:
                 ;    1161 		unsigned char a;
                 ;    1162 		for (a=1; a<10;a++)				// сканируем количество подчиненных устройств 
0004fb 930a      	ST   -Y,R16
                 ;	a -> R16
0004fc e001      	LDI  R16,LOW(1)
                 _0xB6:
0004fd 300a      	CPI  R16,10
0004fe f448      	BRSH _0xB7
                 ;    1163 			{											//  адреса начинаются с 1
                 ;    1164 				if (!(txTWIbyte ( a, 0xaa))) break;   
0004ff 930a      	ST   -Y,R16
000500 eaea      	LDI  R30,LOW(170)
000501 93ea      	ST   -Y,R30
000502 940e 042f 	CALL _txTWIbyte
000504 30e0      	CPI  R30,0
000505 f011      	BREQ _0xB7
                 ;    1165 			}
000506 5f0f      	SUBI R16,-1
000507 cff5      	RJMP _0xB6
                 _0xB7:
                 ;    1166         int_Devices = a-1;
000508 2fe0      	MOV  R30,R16
000509 50e1      	SUBI R30,LOW(1)
00050a 93e0 098b 	STS  _int_Devices,R30
                 ;    1167 		lAddrDevice[0] = lAddrDevice;	// запоминаем кол-во портов 232
00050c e0e0      	LDI  R30,LOW(_lAddrDevice)
00050d e0f7      	LDI  R31,HIGH(_lAddrDevice)
00050e 93e0 0700 	STS  _lAddrDevice,R30
                 ;    1168 	}     
000510 c0fc      	RJMP _0x42A
                 ;    1169 	
                 ;    1170 // считаем КС принятого пакета
                 ;    1171 unsigned char rxCRC (void)
                 ;    1172 	{                    
                 _rxCRC:
                 ;    1173 		unsigned char KS = 0, a;		
                 ;    1174 			for (a=0; a< rxBuffer [0] ;a++)
000511 931a      	ST   -Y,R17
000512 930a      	ST   -Y,R16
                 ;	KS -> R16
                 ;	a -> R17
000513 e000      	LDI  R16,0
000514 e010      	LDI  R17,LOW(0)
                 _0xBA:
000515 91e0 0600 	LDS  R30,_rxBuffer
000517 171e      	CP   R17,R30
000518 f440      	BRSH _0xBB
                 ;    1175 				{
                 ;    1176 					KS =KS+rxBuffer [a];
000519 2fe1      	MOV  R30,R17
00051a e0f0      	LDI  R31,0
00051b 50e0      	SUBI R30,LOW(-_rxBuffer)
00051c 4ffa      	SBCI R31,HIGH(-_rxBuffer)
00051d 81e0      	LD   R30,Z
00051e 0f0e      	ADD  R16,R30
                 ;    1177 				}                                     
00051f 5f1f      	SUBI R17,-1
000520 cff4      	RJMP _0xBA
                 _0xBB:
                 ;    1178 			if (KS == rxBuffer [a]) return 255; 	//Ok
000521 2fe1      	MOV  R30,R17
000522 e0f0      	LDI  R31,0
000523 50e0      	SUBI R30,LOW(-_rxBuffer)
000524 4ffa      	SBCI R31,HIGH(-_rxBuffer)
000525 81e0      	LD   R30,Z
000526 17e0      	CP   R30,R16
000527 f411      	BRNE _0xBC
000528 efef      	LDI  R30,LOW(255)
000529 c001      	RJMP _0x42C
                 ;    1179 			else return 0;                                         // Error
                 _0xBC:
00052a e0e0      	LDI  R30,LOW(0)
                 ;    1180 		
                 ;    1181 	}	        
                 _0x42C:
00052b 9109      	LD   R16,Y+
00052c 9119      	LD   R17,Y+
00052d 9508      	RET
                 ;    1182 
                 ;    1183 // вычитываем логические адреса устройств
                 ;    1184 void ReadLogAddr (void)
                 ;    1185 		{          
                 _ReadLogAddr:
                 ;    1186 		unsigned char b;
                 ;    1187 		
                 ;    1188 					txBuffer[0] = 'q';								// заголовок
00052e 930a      	ST   -Y,R16
                 ;	b -> R16
00052f e7e1      	LDI  R30,LOW(113)
000530 93e0 0500 	STS  _txBuffer,R30
                 ;    1189 					txBuffer[1] = 3;		                 		// длина
000532 e0e3      	LDI  R30,LOW(3)
000533 93e0 0501 	__PUTB1MN _txBuffer,1
                 ;    1190 					txBuffer[2] = 0;                   		// адрес
000535 e0e0      	LDI  R30,LOW(0)
000536 93e0 0502 	__PUTB1MN _txBuffer,2
                 ;    1191 					txBuffer[3] = GetLogAddr;       		// тип
000538 e0e1      	LDI  R30,LOW(1)
000539 93e0 0503 	__PUTB1MN _txBuffer,3
                 ;    1192 					txBuffer[4] = 'q'+3+0+GetLogAddr; 		//KC
00053b e7e5      	LDI  R30,LOW(117)
00053c 93e0 0504 	__PUTB1MN _txBuffer,4
                 ;    1193 
                 ;    1194 for (b=1; b<= int_Devices; b++)
00053e e001      	LDI  R16,LOW(1)
                 _0xBF:
00053f 91e0 098b 	LDS  R30,_int_Devices
000541 17e0      	CP   R30,R16
000542 f0a8      	BRLO _0xC0
                 ;    1195 	{
                 ;    1196 					txTWIbuff (b);		//передаем 
000543 930a      	ST   -Y,R16
000544 940e 0455 	CALL _txTWIbuff
                 ;    1197 					delay_ms (20);          
000546 e1e4      	LDI  R30,LOW(20)
000547 e0f0      	LDI  R31,HIGH(20)
000548 93fa      	ST   -Y,R31
000549 93ea      	ST   -Y,R30
00054a 940e 1dca 	CALL _delay_ms
                 ;    1198 					rxTWIbuff (b);
00054c 930a      	ST   -Y,R16
00054d 940e 0489 	CALL _rxTWIbuff
                 ;    1199 //putchar (b);
                 ;    1200 //putchar (rxBuffer[1]);					
                 ;    1201 					lAddrDevice [b] = rxBuffer[1];		// запоминаем лог. адреса портов       
00054f 2fa0      	MOV  R26,R16
000550 e0b0      	LDI  R27,0
000551 50a0      	SUBI R26,LOW(-_lAddrDevice)
000552 4fb9      	SBCI R27,HIGH(-_lAddrDevice)
000553 91e0 0601 	__GETB1MN _rxBuffer,1
000555 93ec      	ST   X,R30
                 ;    1202      }
000556 5f0f      	SUBI R16,-1
000557 cfe7      	RJMP _0xBF
                 _0xC0:
                 ;    1203 				
                 ;    1204 }  
000558 c0b4      	RJMP _0x42A
                 ;    1205 
                 ;    1206 // ретранслируем пакет
                 ;    1207 void		recompPack (unsigned char device)
                 ;    1208 	{
                 _recompPack:
                 ;    1209 		unsigned char a, b=0;
                 ;    1210 					txBuffer[0] = PACKHDR;				// заголовок
000559 931a      	ST   -Y,R17
00055a 930a      	ST   -Y,R16
                 ;	device -> Y+2
                 ;	a -> R16
                 ;	b -> R17
00055b e010      	LDI  R17,0
00055c e7e1      	LDI  R30,LOW(113)
00055d 93e0 0500 	STS  _txBuffer,R30
                 ;    1211 					txBuffer[1] = rx0len+3;            		// длина (+3 - тк. вычлось при приеме)
00055f 2ded      	MOV  R30,R13
000560 5fed      	SUBI R30,-LOW(3)
000561 93e0 0501 	__PUTB1MN _txBuffer,1
                 ;    1212 					txBuffer[2] = rx0addr;                 	// адрес
000563 e0a2
000564 e0b5      	__POINTW2MN _txBuffer,2
000565 91e0 0784 	LDS  R30,_rx0addr
000567 93ec      	ST   X,R30
                 ;    1213 					txBuffer[3] = rx0type;					// тип
000568 92e0 0503 	__PUTBMRN _txBuffer,3,14
                 ;    1214 
                 ;    1215 					for (a=4; a<=(rx0len+4); a++)
00056a e004      	LDI  R16,LOW(4)
                 _0xC2:
00056b 2ded      	MOV  R30,R13
00056c 5fec      	SUBI R30,-LOW(4)
00056d 17e0      	CP   R30,R16
00056e f068      	BRLO _0xC3
                 ;    1216 						{
                 ;    1217 							txBuffer[a] = rx0buf 	[b++];				
00056f 2fa0      	MOV  R26,R16
000570 e0b0      	LDI  R27,0
000571 50a0      	SUBI R26,LOW(-_txBuffer)
000572 4fbb      	SBCI R27,HIGH(-_txBuffer)
000573 2fe1      	MOV  R30,R17
000574 5f1f      	SUBI R17,-1
000575 e0f0      	LDI  R31,0
000576 57eb      	SUBI R30,LOW(-_rx0buf)
000577 4ff8      	SBCI R31,HIGH(-_rx0buf)
000578 81e0      	LD   R30,Z
000579 93ec      	ST   X,R30
                 ;    1218 						}                   
00057a 5f0f      	SUBI R16,-1
00057b cfef      	RJMP _0xC2
                 _0xC3:
                 ;    1219 
                 ;    1220 					txTWIbuff (device);								//передаем 
00057c 81ea      	LDD  R30,Y+2
00057d 93ea      	ST   -Y,R30
00057e 940e 0455 	CALL _txTWIbuff
                 ;    1221 
                 ;    1222 
                 ;    1223 	}
000580 8119      	LDD  R17,Y+1
000581 8108      	LDD  R16,Y+0
000582 9623      	ADIW R28,3
000583 9508      	RET
                 ;    1224 	
                 ;    1225 // пингуем подчиненное для проверки информации
                 ;    1226 void pingPack (unsigned char device)
                 ;    1227 	{
                 _pingPack:
                 ;    1228 	unsigned char a;
                 ;    1229 			
                 ;    1230 					txBuffer[0] = 'q';									// заголовок
000584 930a      	ST   -Y,R16
                 ;	device -> Y+1
                 ;	a -> R16
000585 e7e1      	LDI  R30,LOW(113)
000586 93e0 0500 	STS  _txBuffer,R30
                 ;    1231 					txBuffer[1] = 3;                 					// длина
000588 e0e3      	LDI  R30,LOW(3)
000589 93e0 0501 	__PUTB1MN _txBuffer,1
                 ;    1232 					txBuffer[2] = 0;                   				// адрес
00058b e0e0      	LDI  R30,LOW(0)
00058c 93e0 0502 	__PUTB1MN _txBuffer,2
                 ;    1233 					txBuffer[3] = pingPacket;       				// тип
00058e e0e2      	LDI  R30,LOW(2)
00058f 93e0 0503 	__PUTB1MN _txBuffer,3
                 ;    1234 					txBuffer[4] = 'q'+3+0+pingPacket; 		// KC
000591 e7e6      	LDI  R30,LOW(118)
000592 93e0 0504 	__PUTB1MN _txBuffer,4
                 ;    1235 
                 ;    1236 					txTWIbuff (device);								// передаем 
000594 81e9      	LDD  R30,Y+1
000595 93ea      	ST   -Y,R30
000596 940e 0455 	CALL _txTWIbuff
                 ;    1237 					delay_ms (20);          
000598 e1e4      	LDI  R30,LOW(20)
000599 e0f0      	LDI  R31,HIGH(20)
00059a 93fa      	ST   -Y,R31
00059b 93ea      	ST   -Y,R30
00059c 940e 1dca 	CALL _delay_ms
                 ;    1238 					rxTWIbuff (device);                  			// принимаем
00059e 81e9      	LDD  R30,Y+1
00059f 93ea      	ST   -Y,R30
0005a0 940e 0489 	CALL _rxTWIbuff
                 ;    1239 
                 ;    1240 					if (rxBuffer[0] )
0005a2 91e0 0600 	LDS  R30,_rxBuffer
0005a4 30e0      	CPI  R30,0
0005a5 f091      	BREQ _0xC4
                 ;    1241 						{
                 ;    1242 						UCSR0B.3 = 1;								// Разрешаю передатчик
0005a6 9a53      	SBI  0xA,3
                 ;    1243                             	for (a=0;a<=rxBuffer[0];a++)
0005a7 e000      	LDI  R16,LOW(0)
                 _0xC6:
0005a8 91e0 0600 	LDS  R30,_rxBuffer
0005aa 17e0      	CP   R30,R16
0005ab f050      	BRLO _0xC7
                 ;    1244 									{
                 ;    1245 										putchar0 (rxBuffer [a]);
0005ac 2fe0      	MOV  R30,R16
0005ad e0f0      	LDI  R31,0
0005ae 50e0      	SUBI R30,LOW(-_rxBuffer)
0005af 4ffa      	SBCI R31,HIGH(-_rxBuffer)
0005b0 81e0      	LD   R30,Z
0005b1 93ea      	ST   -Y,R30
0005b2 940e 02ab 	CALL _putchar0
                 ;    1246 									}     
0005b4 5f0f      	SUBI R16,-1
0005b5 cff2      	RJMP _0xC6
                 _0xC7:
                 ;    1247 						rx0state = RX_HDR;					// Разрешаю прием след. запроса
0005b6 e0e1      	LDI  R30,LOW(1)
0005b7 2ebe      	MOV  R11,R30
                 ;    1248 						
                 ;    1249 						}          
                 ;    1250 	
                 ;    1251 	
                 ;    1252 	}
                 _0xC4:
                 _0x42B:
0005b8 8108      	LDD  R16,Y+0
0005b9 9622      	ADIW R28,2
0005ba 9508      	RET
                 ;    1253 	
                 ;    1254 
                 ;    1255 	
                 ;    1256 	
                 ;    1257 
                 ;    1258 
                 ;    1259 #include "Coding.h"
                 ;    1260 
                 ;    1261 void flash_Work (void)
                 ;    1262 	{  
                 _flash_Work:
                 ;    1263 		unsigned char a;
                 ;    1264 		switch(rx0buf[0])
0005bb 930a      	ST   -Y,R16
                 ;	a -> R16
0005bc 91e0 0785 	LDS  R30,_rx0buf
                 ;    1265 			{
                 ;    1266 				case PT_Fcreate: 		// создать и открыть файл
0005be 30e1      	CPI  R30,LOW(0x1)
0005bf f4b9      	BRNE _0xCB
                 ;    1267 					{       
                 ;    1268 LedRed();
0005c0 9ad0      	SBI  0x1A,0
0005c1 9ad1      	SBI  0x1A,1
0005c2 98d8      	CBI  0x1B,0
0005c3 9ad9      	SBI  0x1B,1
                 ;    1269 
                 ;    1270 						pntr1 = fcreate(str->fname, 0); 
0005c4 01f2      	MOVW R30,R4
0005c5 9631      	ADIW R30,1
0005c6 93fa      	ST   -Y,R31
0005c7 93ea      	ST   -Y,R30
0005c8 e0e0      	LDI  R30,LOW(0)
0005c9 93ea      	ST   -Y,R30
0005ca 940e 1845 	CALL _fcreate
0005cc 014f      	MOVW R8,R30
                 ;    1271 
                 ;    1272 						if (!(pntr1)) putchar (0); 						// если не могу создать файл то возращаем 0
0005cd 2c08      	MOV  R0,R8
0005ce 2809      	OR   R0,R9
0005cf f411      	BRNE _0xCC
0005d0 e0e0      	LDI  R30,LOW(0)
0005d1 c001      	RJMP _0x435
                 ;    1273 						else putchar (0x255);
                 _0xCC:
0005d2 e5e5      	LDI  R30,LOW(597)
                 _0x435:
0005d3 93ea      	ST   -Y,R30
0005d4 940e 1c80 	CALL _putchar
                 ;    1274 
                 ;    1275 //						fputc('S', pntr1);      // write an ‘S’ to the file, increment file pointer */ 
                 ;    1276 //						fputs(str->fname, pntr1);    // add “Hello World!\r\n” to the end of the file 
                 ;    1277  
                 ;    1278 						break;
0005d6 c034      	RJMP _0xCA
                 ;    1279 					}
                 ;    1280 				case PT_Fopen: 		// открыть файл
                 _0xCB:
0005d7 30e2      	CPI  R30,LOW(0x2)
0005d8 f191      	BREQ _0xCA
                 ;    1281 					{       
                 ;    1282 					
                 ;    1283 						break;
                 ;    1284 					}
                 ;    1285 
                 ;    1286 				case PT_Fclose:
0005d9 30e3      	CPI  R30,LOW(0x3)
0005da f491      	BRNE _0xCF
                 ;    1287 					{
                 ;    1288 LedRed();
0005db 9ad0      	SBI  0x1A,0
0005dc 9ad1      	SBI  0x1A,1
0005dd 98d8      	CBI  0x1B,0
0005de 9ad9      	SBI  0x1B,1
                 ;    1289 					    fclose(pntr1);     							   	// Close          
0005df 929a      	ST   -Y,R9
0005e0 928a      	ST   -Y,R8
0005e1 940e 1a99 	CALL _fclose
                 ;    1290 
                 ;    1291 						if (!(pntr1)) putchar (0); 						// если не могу создать файл то возращаем 0
0005e3 2c08      	MOV  R0,R8
0005e4 2809      	OR   R0,R9
0005e5 f411      	BRNE _0xD0
0005e6 e0e0      	LDI  R30,LOW(0)
0005e7 c001      	RJMP _0x436
                 ;    1292 						else putchar (0x255);
                 _0xD0:
0005e8 e5e5      	LDI  R30,LOW(597)
                 _0x436:
0005e9 93ea      	ST   -Y,R30
0005ea 940e 1c80 	CALL _putchar
                 ;    1293 						break;
0005ec c01e      	RJMP _0xCA
                 ;    1294 					}
                 ;    1295 
                 ;    1296 				case PT_Fremove:
                 _0xCF:
0005ed 30e4      	CPI  R30,LOW(0x4)
0005ee f0e1      	BREQ _0xCA
                 ;    1297 					{
                 ;    1298 						break;
                 ;    1299 					}
                 ;    1300 
                 ;    1301 				case PT_Frename:
0005ef 30e5      	CPI  R30,LOW(0x5)
0005f0 f0d1      	BREQ _0xCA
                 ;    1302 					{
                 ;    1303 						break;
                 ;    1304 					}
                 ;    1305 
                 ;    1306 				case PT_Ffseek:
0005f1 30e6      	CPI  R30,LOW(0x6)
0005f2 f0c1      	BREQ _0xCA
                 ;    1307 					{
                 ;    1308 						break;
                 ;    1309 					}
                 ;    1310 
                 ;    1311 				case PT_Fformat:
0005f3 30e7      	CPI  R30,LOW(0x7)
0005f4 f419      	BRNE _0xD5
                 ;    1312 					{
                 ;    1313 						fquickformat();    			// Delete all information on the card 
0005f5 940e 130a 	CALL _fquickformat
                 ;    1314 						break;
0005f7 c013      	RJMP _0xCA
                 ;    1315 					}
                 ;    1316 
                 ;    1317 				case PT_Fadd:
                 _0xD5:
0005f8 30e8      	CPI  R30,LOW(0x8)
0005f9 f489      	BRNE _0xCA
                 ;    1318 					{
                 ;    1319 LedRed();
0005fa 9ad0      	SBI  0x1A,0
0005fb 9ad1      	SBI  0x1A,1
0005fc 98d8      	CBI  0x1B,0
0005fd 9ad9      	SBI  0x1B,1
                 ;    1320 //						fputs(str1->dataFlash, pntr1);    // add “Hello World!\r\n” to the end of the file 
                 ;    1321 //						fprintf(pntr1, "%x",11);  			// output the string to the file
                 ;    1322 
                 ;    1323 //						strcpyf (a,0x31);
                 ;    1324 						fflush (pntr1);
0005fe 929a      	ST   -Y,R9
0005ff 928a      	ST   -Y,R8
000600 940e 1a22 	CALL _fflush
                 ;    1325 
                 ;    1326 						if (!(pntr1)) putchar (0); 						// если не могу создать файл то возращаем 0
000602 2c08      	MOV  R0,R8
000603 2809      	OR   R0,R9
000604 f411      	BRNE _0xD7
000605 e0e0      	LDI  R30,LOW(0)
000606 c001      	RJMP _0x437
                 ;    1327 						else putchar (0x255);
                 _0xD7:
000607 e5e5      	LDI  R30,LOW(597)
                 _0x437:
000608 93ea      	ST   -Y,R30
000609 940e 1c80 	CALL _putchar
                 ;    1328 						break;
                 ;    1329 					}
                 ;    1330 
                 ;    1331     		}
                 _0xCA:
                 ;    1332 	rx0state = RX_HDR;						// Разрешаю прием след. запроса
00060b e0e1      	LDI  R30,LOW(1)
00060c 2ebe      	MOV  R11,R30
                 ;    1333 	}
                 _0x42A:
00060d 9109      	LD   R16,Y+
00060e 9508      	RET
                 ;    1334 
                 ;    1335 
                 ;    1336 
                 ;    1337 	
                 ;    1338 /*
                 ;    1339 	Progressive Resources LLC
                 ;    1340                                     
                 ;    1341 			FlashFile
                 ;    1342 	
                 ;    1343 	Version : 	1.32
                 ;    1344 	Date: 		12/31/2003
                 ;    1345 	Author: 	Erick M. Higa
                 ;    1346                                            
                 ;    1347 	Software License
                 ;    1348 	The use of Progressive Resources LLC FlashFile Source Package indicates 
                 ;    1349 	your understanding and acceptance of the following terms and conditions. 
                 ;    1350 	This license shall supersede any verbal or prior verbal or written, statement 
                 ;    1351 	or agreement to the contrary. If you do not understand or accept these terms, 
                 ;    1352 	or your local regulations prohibit "after sale" license agreements or limited 
                 ;    1353 	disclaimers, you must cease and desist using this product immediately.
                 ;    1354 	This product is © Copyright 2003 by Progressive Resources LLC, all rights 
                 ;    1355 	reserved. International copyright laws, international treaties and all other 
                 ;    1356 	applicable national or international laws protect this product. This software 
                 ;    1357 	product and documentation may not, in whole or in part, be copied, photocopied, 
                 ;    1358 	translated, or reduced to any electronic medium or machine readable form, without 
                 ;    1359 	prior consent in writing, from Progressive Resources LLC and according to all 
                 ;    1360 	applicable laws. The sole owner of this product is Progressive Resources LLC.
                 ;    1361 
                 ;    1362 	Operating License
                 ;    1363 	You have the non-exclusive right to use any enclosed product but have no right 
                 ;    1364 	to distribute it as a source code product without the express written permission 
                 ;    1365 	of Progressive Resources LLC. Use over a "local area network" (within the same 
                 ;    1366 	locale) is permitted provided that only a single person, on a single computer 
                 ;    1367 	uses the product at a time. Use over a "wide area network" (outside the same 
                 ;    1368 	locale) is strictly prohibited under any and all circumstances.
                 ;    1369                                            
                 ;    1370 	Liability Disclaimer
                 ;    1371 	This product and/or license is provided as is, without any representation or 
                 ;    1372 	warranty of any kind, either express or implied, including without limitation 
                 ;    1373 	any representations or endorsements regarding the use of, the results of, or 
                 ;    1374 	performance of the product, Its appropriateness, accuracy, reliability, or 
                 ;    1375 	correctness. The user and/or licensee assume the entire risk as to the use of 
                 ;    1376 	this product. Progressive Resources LLC does not assume liability for the use 
                 ;    1377 	of this product beyond the original purchase price of the software. In no event 
                 ;    1378 	will Progressive Resources LLC be liable for additional direct or indirect 
                 ;    1379 	damages including any lost profits, lost savings, or other incidental or 
                 ;    1380 	consequential damages arising from any defects, or the use or inability to 
                 ;    1381 	use these products, even if Progressive Resources LLC have been advised of 
                 ;    1382 	the possibility of such damages.
                 ;    1383 */                                 
                 ;    1384 
                 ;    1385 /*
                 ;    1386 #include _AVR_LIB_
                 ;    1387 #include <stdio.h>
                 ;    1388 
                 ;    1389 #ifndef _file_sys_h_
                 ;    1390 	#include "..\flash\file_sys.h"
                 ;    1391 #endif
                 ;    1392 */
                 ;    1393 	#include <coding.h>
                 ;    1394 
                 ;    1395 unsigned long OCR_REG;
                 
                 	.DSEG
                 _OCR_REG:
00098c           	.BYTE 0x4
                 ;    1396 unsigned char _FF_buff[512];
                 __FF_buff:
000990           	.BYTE 0x200
                 ;    1397 unsigned int PT_SecStart;
                 _PT_SecStart:
000b90           	.BYTE 0x2
                 ;    1398 unsigned long BS_jmpBoot;
                 _BS_jmpBoot:
000b92           	.BYTE 0x4
                 ;    1399 unsigned int BPB_BytsPerSec;
                 _BPB_BytsPerSec:
000b96           	.BYTE 0x2
                 ;    1400 unsigned char BPB_SecPerClus;
                 _BPB_SecPerClus:
000b98           	.BYTE 0x1
                 ;    1401 unsigned int BPB_RsvdSecCnt;
                 _BPB_RsvdSecCnt:
000b99           	.BYTE 0x2
                 ;    1402 unsigned char BPB_NumFATs;
                 _BPB_NumFATs:
000b9b           	.BYTE 0x1
                 ;    1403 unsigned int BPB_RootEntCnt;
                 _BPB_RootEntCnt:
000b9c           	.BYTE 0x2
                 ;    1404 unsigned int BPB_FATSz16;
                 _BPB_FATSz16:
000b9e           	.BYTE 0x2
                 ;    1405 unsigned char BPB_FATType;
                 _BPB_FATType:
000ba0           	.BYTE 0x1
                 ;    1406 unsigned long BPB_TotSec;
                 _BPB_TotSec:
000ba1           	.BYTE 0x4
                 ;    1407 unsigned long BS_VolSerial;
                 _BS_VolSerial:
000ba5           	.BYTE 0x4
                 ;    1408 unsigned char BS_VolLab[12];
                 _BS_VolLab:
000ba9           	.BYTE 0xC
                 ;    1409 unsigned long _FF_PART_ADDR, _FF_ROOT_ADDR, _FF_DIR_ADDR;
                 __FF_PART_ADDR:
000bb5           	.BYTE 0x4
                 __FF_ROOT_ADDR:
000bb9           	.BYTE 0x4
                 __FF_DIR_ADDR:
000bbd           	.BYTE 0x4
                 ;    1410 unsigned long _FF_FAT1_ADDR, _FF_FAT2_ADDR;
                 __FF_FAT1_ADDR:
000bc1           	.BYTE 0x4
                 __FF_FAT2_ADDR:
000bc5           	.BYTE 0x4
                 ;    1411 unsigned long _FF_RootDirSectors;
                 __FF_RootDirSectors:
000bc9           	.BYTE 0x4
                 ;    1412 unsigned int FirstDataSector;
                 _FirstDataSector:
000bcd           	.BYTE 0x2
                 ;    1413 unsigned long FirstSectorofCluster;
                 _FirstSectorofCluster:
000bcf           	.BYTE 0x4
                 ;    1414 unsigned char _FF_error;
                 __FF_error:
000bd3           	.BYTE 0x1
                 ;    1415 unsigned long _FF_buff_addr;
                 __FF_buff_addr:
000bd4           	.BYTE 0x4
                 ;    1416 extern unsigned long clus_0_addr, _FF_n_temp;
                 ;    1417 extern unsigned int c_counter;
                 ;    1418 //extern unsigned char _FF_FULL_PATH[_FF_PATH_LENGTH];
                 ;    1419 
                 ;    1420 unsigned long DataClusTot;
                 _DataClusTot:
000bd8           	.BYTE 0x4
                 ;    1421 
                 ;    1422 flash struct CMD
                 ;    1423 {
                 ;    1424 	unsigned int index;
                 ;    1425 	unsigned int tx_data;
                 ;    1426 	unsigned int arg;
                 ;    1427 	unsigned int resp;
                 ;    1428 };
                 ;    1429 
                 ;    1430 flash struct CMD sd_cmd[CMD_TOT] =
                 
                 	.CSEG
                 ;    1431 {
                 ;    1432 	{CMD0,	0x40,	NO_ARG,		RESP_1},		// GO_IDLE_STATE
                 ;    1433 	{CMD1,	0x41,	NO_ARG,		RESP_1},		// SEND_OP_COND (ACMD41 = 0x69)
                 ;    1434 	{CMD9,	0x49,	NO_ARG,		RESP_1},		// SEND_CSD
                 ;    1435 	{CMD10,	0x4A,	NO_ARG,		RESP_1},		// SEND_CID
                 ;    1436 	{CMD12,	0x4C,	NO_ARG,		RESP_1},		// STOP_TRANSMISSION
                 ;    1437 	{CMD13,	0x4D,	NO_ARG,		RESP_2},		// SEND_STATUS
                 ;    1438 	{CMD16,	0x50,	BLOCK_LEN,	RESP_1},		// SET_BLOCKLEN
                 ;    1439 	{CMD17, 0x51,	DATA_ADDR,	RESP_1},		// READ_SINGLE_BLOCK
                 ;    1440 	{CMD18, 0x52,	DATA_ADDR,	RESP_1},		// READ_MULTIPLE_BLOCK
                 ;    1441 	{CMD24, 0x58,	DATA_ADDR,	RESP_1},		// WRITE_BLOCK
                 ;    1442 	{CMD25, 0x59,	DATA_ADDR,	RESP_1},		// WRITE_MULTIPLE_BLOCK
                 ;    1443 	{CMD27,	0x5B,	NO_ARG,		RESP_1},		// PROGRAM_CSD
                 ;    1444 	{CMD28, 0x5C,	DATA_ADDR,	RESP_1b},		// SET_WRITE_PROT
                 ;    1445 	{CMD29, 0x5D,	DATA_ADDR,	RESP_1b},		// CLR_WRITE_PROT
                 ;    1446 	{CMD30, 0x5E,	DATA_ADDR,	RESP_1},		// SEND_WRITE_PROT
                 ;    1447 	{CMD32,	0x60,	DATA_ADDR,	RESP_1},		// TAG_SECTOR_START
                 ;    1448 	{CMD33,	0x61,	DATA_ADDR,	RESP_1},		// TAG_SECTOR_END
                 ;    1449 	{CMD34,	0x62,	DATA_ADDR,	RESP_1},		// UNTAG_SECTOR
                 ;    1450 	{CMD35,	0x63,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP_START
                 ;    1451 	{CMD36,	0x64,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP_END
                 ;    1452 	{CMD37,	0x65,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP
                 ;    1453 	{CMD38,	0x66,	STUFF_BITS,	RESP_1b},		// ERASE
                 ;    1454 	{CMD42,	0x6A,	STUFF_BITS,	RESP_1b},		// LOCK_UNLOCK
                 ;    1455 	{CMD58,	0x7A,	NO_ARG,		RESP_3},		// READ_OCR
                 ;    1456 	{CMD59,	0x7B,	STUFF_BITS,	RESP_1},		// CRC_ON_OFF
                 ;    1457 	{ACMD41, 0x69,	NO_ARG,		RESP_1}
                 ;    1458 };
                 ;    1459 
                 ;    1460 unsigned char _FF_spi(unsigned char mydata)
                 ;    1461 {
                 __FF_spi:
                 ;    1462     SPDR = mydata;          //byte 1
00060f 81e8      	LD   R30,Y
000610 b9ef      	OUT  0xF,R30
                 ;    1463     while ((SPSR&0x80) == 0); 
                 _0xD9:
000611 9b77      	SBIS 0xE,7
000612 cffe      	RJMP _0xD9
                 ;    1464     return SPDR;
000613 b1ef      	IN   R30,0xF
000614 c6a5      	RJMP _0x424
                 ;    1465 }
                 ;    1466 	
                 ;    1467 unsigned int send_cmd(unsigned char command, unsigned long argument)
                 ;    1468 {
                 _send_cmd:
                 ;    1469 	unsigned char spi_data_out;
                 ;    1470 	unsigned char response_1;
                 ;    1471 	unsigned long response_2;
                 ;    1472 	unsigned int c, i;
                 ;    1473 	
                 ;    1474 	SD_CS_ON();			// select chip
000615 9724      	SBIW R28,4
000616 940e 1f30 	CALL __SAVELOCR6
                 ;	command -> Y+14
                 ;	argument -> Y+10
                 ;	spi_data_out -> R16
                 ;	response_1 -> R17
                 ;	response_2 -> Y+6
                 ;	c -> R18,R19
                 ;	i -> R20,R21
000618 98c4      	CBI  0x18,4
                 ;    1475 	
                 ;    1476 	spi_data_out = sd_cmd[command].tx_data;
000619 85ae      	LDD  R26,Y+14
00061a 27bb      	CLR  R27
00061b ec60
00061c e070      	__POINTWRFN 22,23,_sd_cmd,2
00061d e0e8      	LDI  R30,LOW(8)
00061e e0f0      	LDI  R31,HIGH(8)
00061f 940e 1e2c 	CALL __MULW12U
000621 0fe6      	ADD  R30,R22
000622 1ff7      	ADC  R31,R23
000623 9104      	LPM  R16,Z
                 ;    1477 	_FF_spi(spi_data_out);
000624 930a      	ST   -Y,R16
000625 940e 060f 	CALL __FF_spi
                 ;    1478 	
                 ;    1479 	c = sd_cmd[command].arg;
000627 85ae      	LDD  R26,Y+14
000628 27bb      	CLR  R27
000629 ec62
00062a e070      	__POINTWRFN 22,23,_sd_cmd,4
00062b e0e8      	LDI  R30,LOW(8)
00062c e0f0      	LDI  R31,HIGH(8)
00062d 940e 1e2c 	CALL __MULW12U
00062f 0fe6      	ADD  R30,R22
000630 1ff7      	ADC  R31,R23
000631 940e 1ed3 	CALL __GETW1PF
000633 019f      	MOVW R18,R30
                 ;    1480 	if (c == NO_ARG)
000634 2e02      	MOV  R0,R18
000635 2a03      	OR   R0,R19
000636 f471      	BRNE _0xDC
                 ;    1481 		for (i=0; i<4; i++)
000637 e040
000638 e050      	__GETWRN 20,21,0
                 _0xDE:
000639 3044
00063a e0e0
00063b 075e      	__CPWRN 20,21,4
00063c f438      	BRSH _0xDF
                 ;    1482 			_FF_spi(0);
00063d e0e0      	LDI  R30,LOW(0)
00063e 93ea      	ST   -Y,R30
00063f 940e 060f 	CALL __FF_spi
                 ;    1483 	else
000641 5f4f
000642 4f5f      	__ADDWRN 20,21,1
000643 cff5      	RJMP _0xDE
                 _0xDF:
000644 c03c      	RJMP _0xE0
                 _0xDC:
                 ;    1484 	{
                 ;    1485 		spi_data_out = (argument & 0xFF000000) >> 24;
000645 85ea
000646 85fb
000647 856c
000648 857d      	__GETD1S 10
000649 70e0
00064a 70f0
00064b 7060
00064c 7f7f      	__ANDD1N 0xFF000000
00064d 01df      	MOVW R26,R30
00064e 01cb      	MOVW R24,R22
00064f e1e8      	LDI  R30,LOW(24)
000650 940e 1e08 	CALL __LSRD12
000652 2f0e      	MOV  R16,R30
                 ;    1486 		_FF_spi(spi_data_out);
000653 930a      	ST   -Y,R16
000654 940e 060f 	CALL __FF_spi
                 ;    1487 		spi_data_out = (argument & 0x00FF0000) >> 16;
000656 85ea
000657 85fb
000658 856c
000659 857d      	__GETD1S 10
00065a 70e0
00065b 70f0
00065c 7f6f
00065d 7070      	__ANDD1N 0xFF0000
00065e 940e 1e1d 	CALL __LSRD16
000660 2f0e      	MOV  R16,R30
                 ;    1488 		_FF_spi(spi_data_out);
000661 930a      	ST   -Y,R16
000662 940e 060f 	CALL __FF_spi
                 ;    1489 		spi_data_out = (argument & 0x0000FF00) >> 8;
000664 85ea
000665 85fb
000666 856c
000667 857d      	__GETD1S 10
000668 70e0
000669 7fff
00066a 7060
00066b 7070      	__ANDD1N 0xFF00
00066c 01df      	MOVW R26,R30
00066d 01cb      	MOVW R24,R22
00066e e0e8      	LDI  R30,LOW(8)
00066f 940e 1e08 	CALL __LSRD12
000671 2f0e      	MOV  R16,R30
                 ;    1490 		_FF_spi(spi_data_out);
000672 930a      	ST   -Y,R16
000673 940e 060f 	CALL __FF_spi
                 ;    1491 		spi_data_out = (argument & 0x000000FF);
000675 85ea
000676 85fb
000677 856c
000678 857d      	__GETD1S 10
000679 7fef
00067a 70f0
00067b 7060
00067c 7070      	__ANDD1N 0xFF
00067d 2f0e      	MOV  R16,R30
                 ;    1492 		_FF_spi(spi_data_out);
00067e 930a      	ST   -Y,R16
00067f 940e 060f 	CALL __FF_spi
                 ;    1493 	}
                 _0xE0:
                 ;    1494 	if (command == CMD0)
000681 85ee      	LDD  R30,Y+14
000682 30e0      	CPI  R30,0
000683 f411      	BRNE _0xE1
                 ;    1495 		spi_data_out = 0x95;		// CRC byte, don't care except for first signal=0x95
000684 e905      	LDI  R16,LOW(149)
                 ;    1496 	else
000685 c001      	RJMP _0xE2
                 _0xE1:
                 ;    1497 		spi_data_out = 0xFF;
000686 ef0f      	LDI  R16,LOW(255)
                 ;    1498 	_FF_spi(spi_data_out);
                 _0xE2:
000687 930a      	ST   -Y,R16
000688 940e 060f 	CALL __FF_spi
                 ;    1499 	_FF_spi(0xff);	
00068a efef      	LDI  R30,LOW(255)
00068b 93ea      	ST   -Y,R30
00068c 940e 060f 	CALL __FF_spi
                 ;    1500 	c = sd_cmd[command].resp;
00068e 85ae      	LDD  R26,Y+14
00068f 27bb      	CLR  R27
000690 ec64
000691 e070      	__POINTWRFN 22,23,_sd_cmd,6
000692 e0e8      	LDI  R30,LOW(8)
000693 e0f0      	LDI  R31,HIGH(8)
000694 940e 1e2c 	CALL __MULW12U
000696 0fe6      	ADD  R30,R22
000697 1ff7      	ADC  R31,R23
000698 940e 1ed3 	CALL __GETW1PF
00069a 019f      	MOVW R18,R30
                 ;    1501 	switch(c)
00069b 01f9      	MOVW R30,R18
                 ;    1502 	{
                 ;    1503 		case RESP_1:
00069c 9730      	SBIW R30,0
00069d f431      	BRNE _0xE6
                 ;    1504 			return (_FF_spi(0xFF));
00069e efef      	LDI  R30,LOW(255)
00069f 93ea      	ST   -Y,R30
0006a0 940e 060f 	CALL __FF_spi
0006a2 e0f0      	LDI  R31,0
0006a3 c0e3      	RJMP _0x429
                 ;    1505 			break;
                 ;    1506 		case RESP_1b:
                 _0xE6:
0006a4 30e1      	CPI  R30,LOW(0x1)
0006a5 e0a0      	LDI  R26,HIGH(0x1)
0006a6 07fa      	CPC  R31,R26
0006a7 f501      	BRNE _0xE7
                 ;    1507 			response_1 = _FF_spi(0xFF);
0006a8 efef      	LDI  R30,LOW(255)
0006a9 93ea      	ST   -Y,R30
0006aa 940e 060f 	CALL __FF_spi
0006ac 2f1e      	MOV  R17,R30
                 ;    1508 			response_2 = 0;
0006ad e0e0
0006ae 83ee
0006af 83ef
0006b0 87e8
0006b1 87e9      	__CLRD1S 6
                 ;    1509 			while (response_2 == 0)
                 _0xE8:
0006b2 81ee
0006b3 81ff
0006b4 8568
0006b5 8579      	__GETD1S 6
0006b6 940e 1f18 	CALL __CPD10
0006b8 f461      	BRNE _0xEA
                 ;    1510 				response_2 = _FF_spi(0xFF);
0006b9 efef      	LDI  R30,LOW(255)
0006ba 93ea      	ST   -Y,R30
0006bb 940e 060f 	CALL __FF_spi
0006bd 27ff      	CLR  R31
0006be 2766      	CLR  R22
0006bf 2777      	CLR  R23
0006c0 83ee
0006c1 83ff
0006c2 8768
0006c3 8779      	__PUTD1S 6
                 ;    1511 			return (response_1);
0006c4 cfed      	RJMP _0xE8
                 _0xEA:
0006c5 2fe1      	MOV  R30,R17
0006c6 e0f0      	LDI  R31,0
0006c7 c0bf      	RJMP _0x429
                 ;    1512 			break;
                 ;    1513 		case RESP_2:
                 _0xE7:
0006c8 30e2      	CPI  R30,LOW(0x2)
0006c9 e0a0      	LDI  R26,HIGH(0x2)
0006ca 07fa      	CPC  R31,R26
0006cb f541      	BRNE _0xEB
                 ;    1514 			response_2 = _FF_spi(0xFF);
0006cc efef      	LDI  R30,LOW(255)
0006cd 93ea      	ST   -Y,R30
0006ce 940e 060f 	CALL __FF_spi
0006d0 27ff      	CLR  R31
0006d1 2766      	CLR  R22
0006d2 2777      	CLR  R23
0006d3 83ee
0006d4 83ff
0006d5 8768
0006d6 8779      	__PUTD1S 6
                 ;    1515 			response_2 = (response_2 << 8) | _FF_spi(0xFF);
0006d7 81ae
0006d8 81bf
0006d9 8588
0006da 8599      	__GETD2S 6
0006db e0e8      	LDI  R30,LOW(8)
0006dc 940e 1dfc 	CALL __LSLD12
0006de 937f      	PUSH R23
0006df 936f      	PUSH R22
0006e0 93ff      	PUSH R31
0006e1 93ef      	PUSH R30
0006e2 efef      	LDI  R30,LOW(255)
0006e3 93ea      	ST   -Y,R30
0006e4 940e 060f 	CALL __FF_spi
0006e6 91af      	POP  R26
0006e7 91bf      	POP  R27
0006e8 918f      	POP  R24
0006e9 919f      	POP  R25
0006ea 27ff      	CLR  R31
0006eb 2766      	CLR  R22
0006ec 2777      	CLR  R23
0006ed 940e 1dea 	CALL __ORD12
0006ef 83ee
0006f0 83ff
0006f1 8768
0006f2 8779      	__PUTD1S 6
                 ;    1516 			return (response_2);
0006f3 c093      	RJMP _0x429
                 ;    1517 			break;
                 ;    1518 		case RESP_3:
                 _0xEB:
0006f4 30e3      	CPI  R30,LOW(0x3)
0006f5 e0a0      	LDI  R26,HIGH(0x3)
0006f6 07fa      	CPC  R31,R26
0006f7 f011      	BREQ PC+3
0006f8 940c 0785 	JMP _0xE5
                 ;    1519 			response_1 = _FF_spi(0xFF);
0006fa efef      	LDI  R30,LOW(255)
0006fb 93ea      	ST   -Y,R30
0006fc 940e 060f 	CALL __FF_spi
0006fe 2f1e      	MOV  R17,R30
                 ;    1520 			OCR_REG = 0;
0006ff e0e0      	LDI  R30,0
000700 93e0 098c 	STS  _OCR_REG,R30
000702 93e0 098d 	STS  _OCR_REG+1,R30
000704 93e0 098e 	STS  _OCR_REG+2,R30
000706 93e0 098f 	STS  _OCR_REG+3,R30
                 ;    1521 			response_2 = _FF_spi(0xFF);
000708 efef      	LDI  R30,LOW(255)
000709 93ea      	ST   -Y,R30
00070a 940e 060f 	CALL __FF_spi
00070c 27ff      	CLR  R31
00070d 2766      	CLR  R22
00070e 2777      	CLR  R23
00070f 83ee
000710 83ff
000711 8768
000712 8779      	__PUTD1S 6
                 ;    1522 			OCR_REG = response_2 << 24;
000713 81ae
000714 81bf
000715 8588
000716 8599      	__GETD2S 6
000717 e1e8      	LDI  R30,LOW(24)
000718 940e 1dfc 	CALL __LSLD12
00071a 93e0 098c 	STS  _OCR_REG,R30
00071c 93f0 098d 	STS  _OCR_REG+1,R31
00071e 9360 098e 	STS  _OCR_REG+2,R22
000720 9370 098f 	STS  _OCR_REG+3,R23
                 ;    1523 			response_2 = _FF_spi(0xFF);
000722 efef      	LDI  R30,LOW(255)
000723 93ea      	ST   -Y,R30
000724 940e 060f 	CALL __FF_spi
000726 27ff      	CLR  R31
000727 2766      	CLR  R22
000728 2777      	CLR  R23
000729 83ee
00072a 83ff
00072b 8768
00072c 8779      	__PUTD1S 6
                 ;    1524 			OCR_REG |= (response_2 << 16);
00072d 940e 1e22 	CALL __LSLD16
00072f 91a0 098c 	LDS  R26,_OCR_REG
000731 91b0 098d 	LDS  R27,_OCR_REG+1
000733 9180 098e 	LDS  R24,_OCR_REG+2
000735 9190 098f 	LDS  R25,_OCR_REG+3
000737 940e 1dea 	CALL __ORD12
000739 93e0 098c 	STS  _OCR_REG,R30
00073b 93f0 098d 	STS  _OCR_REG+1,R31
00073d 9360 098e 	STS  _OCR_REG+2,R22
00073f 9370 098f 	STS  _OCR_REG+3,R23
                 ;    1525 			response_2 = _FF_spi(0xFF);
000741 efef      	LDI  R30,LOW(255)
000742 93ea      	ST   -Y,R30
000743 940e 060f 	CALL __FF_spi
000745 27ff      	CLR  R31
000746 2766      	CLR  R22
000747 2777      	CLR  R23
000748 83ee
000749 83ff
00074a 8768
00074b 8779      	__PUTD1S 6
                 ;    1526 			OCR_REG |= (response_2 << 8);
00074c 81ae
00074d 81bf
00074e 8588
00074f 8599      	__GETD2S 6
000750 e0e8      	LDI  R30,LOW(8)
000751 940e 1dfc 	CALL __LSLD12
000753 91a0 098c 	LDS  R26,_OCR_REG
000755 91b0 098d 	LDS  R27,_OCR_REG+1
000757 9180 098e 	LDS  R24,_OCR_REG+2
000759 9190 098f 	LDS  R25,_OCR_REG+3
00075b 940e 1dea 	CALL __ORD12
00075d 93e0 098c 	STS  _OCR_REG,R30
00075f 93f0 098d 	STS  _OCR_REG+1,R31
000761 9360 098e 	STS  _OCR_REG+2,R22
000763 9370 098f 	STS  _OCR_REG+3,R23
                 ;    1527 			response_2 = _FF_spi(0xFF);
000765 efef      	LDI  R30,LOW(255)
000766 93ea      	ST   -Y,R30
000767 940e 060f 	CALL __FF_spi
000769 27ff      	CLR  R31
00076a 2766      	CLR  R22
00076b 2777      	CLR  R23
00076c 83ee
00076d 83ff
00076e 8768
00076f 8779      	__PUTD1S 6
                 ;    1528 			OCR_REG |= (response_2);
000770 91a0 098c 	LDS  R26,_OCR_REG
000772 91b0 098d 	LDS  R27,_OCR_REG+1
000774 9180 098e 	LDS  R24,_OCR_REG+2
000776 9190 098f 	LDS  R25,_OCR_REG+3
000778 940e 1dea 	CALL __ORD12
00077a 93e0 098c 	STS  _OCR_REG,R30
00077c 93f0 098d 	STS  _OCR_REG+1,R31
00077e 9360 098e 	STS  _OCR_REG+2,R22
000780 9370 098f 	STS  _OCR_REG+3,R23
                 ;    1529 			return (response_1);
000782 2fe1      	MOV  R30,R17
000783 e0f0      	LDI  R31,0
000784 c002      	RJMP _0x429
                 ;    1530 			break;
                 ;    1531 	}
                 _0xE5:
                 ;    1532 	return (0);
000785 e0e0      	LDI  R30,LOW(0)
000786 e0f0      	LDI  R31,HIGH(0)
                 _0x429:
000787 940e 1f37 	CALL __LOADLOCR6
000789 962f      	ADIW R28,15
00078a 9508      	RET
                 ;    1533 }
                 ;    1534 
                 ;    1535 void clear_sd_buff(void)
                 ;    1536 {
                 _clear_sd_buff:
                 ;    1537 	SD_CS_OFF();
00078b 9ac4      	SBI  0x18,4
                 ;    1538 	_FF_spi(0xFF);
00078c efef      	LDI  R30,LOW(255)
00078d 93ea      	ST   -Y,R30
00078e 940e 060f 	CALL __FF_spi
                 ;    1539 	_FF_spi(0xFF);
000790 efef      	LDI  R30,LOW(255)
000791 93ea      	ST   -Y,R30
000792 940e 060f 	CALL __FF_spi
                 ;    1540 }	
000794 9508      	RET
                 ;    1541 
                 ;    1542 unsigned char initialize_media(void)
                 ;    1543 {
                 _initialize_media:
                 ;    1544 	unsigned char data_temp;
                 ;    1545 	unsigned long n;
                 ;    1546 	
                 ;    1547 	// SPI BUS SETUP
                 ;    1548 	// SPI initialization
                 ;    1549 	// SPI Type: Master
                 ;    1550 	// SPI Clock Rate: 921.600 kHz
                 ;    1551 	// SPI Clock Phase: Cycle Half
                 ;    1552 	// SPI Clock Polarity: Low
                 ;    1553 	// SPI Data Order: MSB First
                 ;    1554 	DDRB |= 0x07;		// Set SS, SCK, and MOSI to Output (If not output, processor will be a slave)
000795 9724      	SBIW R28,4
000796 930a      	ST   -Y,R16
                 ;	data_temp -> R16
                 ;	n -> Y+1
000797 b3e7      	IN   R30,0x17
000798 60e7      	ORI  R30,LOW(0x7)
000799 bbe7      	OUT  0x17,R30
                 ;    1555 	DDRB &= 0xF7;		// Set MISO to Input
00079a 98bb      	CBI  0x17,3
                 ;    1556 	CS_DDR_SET();		// Set CS to Output
00079b 9abc      	SBI  0x17,4
                 ;    1557 	SPCR=0x50;
00079c e5e0      	LDI  R30,LOW(80)
00079d b9ed      	OUT  0xD,R30
                 ;    1558 	SPSR=0x00;
00079e e0e0      	LDI  R30,LOW(0)
00079f b9ee      	OUT  0xE,R30
                 ;    1559 		
                 ;    1560 	BPB_BytsPerSec = 512;	// Initialize sector size to 512 (all SD cards have a 512 sector size)
0007a0 e0e0      	LDI  R30,LOW(512)
0007a1 e0f2      	LDI  R31,HIGH(512)
0007a2 93e0 0b96 	STS  _BPB_BytsPerSec,R30
0007a4 93f0 0b97 	STS  _BPB_BytsPerSec+1,R31
                 ;    1561     _FF_n_temp = 0;
0007a6 e0e0      	LDI  R30,0
0007a7 93e0 0be7 	STS  __FF_n_temp,R30
0007a9 93e0 0be8 	STS  __FF_n_temp+1,R30
0007ab 93e0 0be9 	STS  __FF_n_temp+2,R30
0007ad 93e0 0bea 	STS  __FF_n_temp+3,R30
                 ;    1562 	if (reset_sd()==0)
0007af d347      	RCALL _reset_sd
0007b0 30e0      	CPI  R30,0
0007b1 f411      	BRNE _0xED
                 ;    1563 		return (0);
0007b2 e0e0      	LDI  R30,LOW(0)
0007b3 c328      	RJMP _0x428
                 ;    1564 	// delay_ms(50);
                 ;    1565 	for (n=0; ((n<100)||(data_temp==0)) ; n++)
                 _0xED:
0007b4 e0e0
0007b5 83e9
0007b6 83ea
0007b7 83eb
0007b8 83ec      	__CLRD1S 1
                 _0xEF:
0007b9 81a9
0007ba 81ba
0007bb 818b
0007bc 819c      	__GETD2S 1
0007bd 36a4
0007be e0e0
0007bf 07be
0007c0 e0e0
0007c1 078e
0007c2 e0e0
0007c3 079e      	__CPD2N 0x64
0007c4 f010      	BRLO _0xF1
0007c5 3000      	CPI  R16,0
0007c6 f4a1      	BRNE _0xF0
                 _0xF1:
                 ;    1566 	{
                 ;    1567 		SD_CS_ON();
0007c7 98c4      	CBI  0x18,4
                 ;    1568 		data_temp = _FF_spi(0xFF);
0007c8 efef      	LDI  R30,LOW(255)
0007c9 93ea      	ST   -Y,R30
0007ca 940e 060f 	CALL __FF_spi
0007cc 2f0e      	MOV  R16,R30
                 ;    1569 		SD_CS_OFF();
0007cd 9ac4      	SBI  0x18,4
                 ;    1570 	}
0007ce 81e9
0007cf 81fa
0007d0 816b
0007d1 817c      	__GETD1S 1
0007d2 5fef
0007d3 4fff
0007d4 4f6f
0007d5 4f7f      	__SUBD1N -1
0007d6 83e9
0007d7 83fa
0007d8 836b
0007d9 837c      	__PUTD1S 1
0007da cfde      	RJMP _0xEF
                 _0xF0:
                 ;    1571 	// delay_ms(50);
                 ;    1572 	for (n=0; n<100; n++)
0007db e0e0
0007dc 83e9
0007dd 83ea
0007de 83eb
0007df 83ec      	__CLRD1S 1
                 _0xF4:
0007e0 81a9
0007e1 81ba
0007e2 818b
0007e3 819c      	__GETD2S 1
0007e4 36a4
0007e5 e0e0
0007e6 07be
0007e7 e0e0
0007e8 078e
0007e9 e0e0
0007ea 079e      	__CPD2N 0x64
0007eb f4f0      	BRSH _0xF5
                 ;    1573 	{
                 ;    1574 		if (init_sd())		// Initialization Succeeded
0007ec d340      	RCALL _init_sd
0007ed 30e0      	CPI  R30,0
0007ee f4d9      	BRNE _0xF5
                 ;    1575 			break;
                 ;    1576 		if (n==99)
0007ef 81a9
0007f0 81ba
0007f1 818b
0007f2 819c      	__GETD2S 1
0007f3 36a3
0007f4 e0e0
0007f5 07be
0007f6 e0e0
0007f7 078e
0007f8 e0e0
0007f9 079e      	__CPD2N 0x63
0007fa f411      	BRNE _0xF7
                 ;    1577 			return (0);
0007fb e0e0      	LDI  R30,LOW(0)
0007fc c2df      	RJMP _0x428
                 ;    1578 	}
                 _0xF7:
0007fd 81e9
0007fe 81fa
0007ff 816b
000800 817c      	__GETD1S 1
000801 5fef
000802 4fff
000803 4f6f
000804 4f7f      	__SUBD1N -1
000805 83e9
000806 83fa
000807 836b
000808 837c      	__PUTD1S 1
000809 cfd6      	RJMP _0xF4
                 _0xF5:
                 ;    1579 
                 ;    1580 	if (_FF_read(0x0)==0)
00080a e0e0
00080b e0f0
00080c e060
00080d e070      	__GETD1N 0x0
00080e 940e 1ed7 	CALL __PUTPARD1
000810 d34d      	RCALL __FF_read
000811 30e0      	CPI  R30,0
000812 f429      	BRNE _0xF8
                 ;    1581 	{
                 ;    1582 		#ifdef _DEBUG_ON_
                 ;    1583 			printf("\n\rREAD_ERR"); 		
                 ;    1584 		#endif
                 ;    1585 		_FF_error = INIT_ERR;
000813 e0e1      	LDI  R30,LOW(1)
000814 93e0 0bd3 	STS  __FF_error,R30
                 ;    1586 		return (0);
000816 e0e0      	LDI  R30,LOW(0)
000817 c2c4      	RJMP _0x428
                 ;    1587 	}
                 ;    1588 	PT_SecStart = ((int) _FF_buff[0x1c7] << 8) | (int) _FF_buff[0x1c6];
                 _0xF8:
000818 91b0 0b57 	__GETBRMN 27,__FF_buff,455
00081a e0a0      	LDI  R26,LOW(0)
00081b 91e0 0b56 	__GETB1MN __FF_buff,454
00081d e0f0      	LDI  R31,0
00081e 2bea      	OR   R30,R26
00081f 2bfb      	OR   R31,R27
000820 93e0 0b90 	STS  _PT_SecStart,R30
000822 93f0 0b91 	STS  _PT_SecStart+1,R31
                 ;    1589 	
                 ;    1590 	if ((((_FF_buff[0]==0xEB)&&(_FF_buff[2]==0x90))||(_FF_buff[0]==0xE9)) && ((_FF_buff[510]==0x55)&&(_FF_buff[511]==0xAA)))
000824 91a0 0990 	LDS  R26,__FF_buff
000826 3eab      	CPI  R26,LOW(0xEB)
000827 f421      	BRNE _0xFA
000828 91e0 0992 	__GETB1MN __FF_buff,2
00082a 39e0      	CPI  R30,LOW(0x90)
00082b f021      	BREQ _0xFC
                 _0xFA:
00082c 91a0 0990 	LDS  R26,__FF_buff
00082e 3ea9      	CPI  R26,LOW(0xE9)
00082f f451      	BRNE _0xFE
                 _0xFC:
000830 91e0 0b8e 	__GETB1MN __FF_buff,510
000832 35e5      	CPI  R30,LOW(0x55)
000833 f421      	BRNE _0xFF
000834 91e0 0b8f 	__GETB1MN __FF_buff,511
000836 3aea      	CPI  R30,LOW(0xAA)
000837 f009      	BREQ _0x100
                 _0xFF:
000838 c001      	RJMP _0xFE
                 _0x100:
000839 c001      	RJMP _0x101
                 _0xFE:
00083a c005      	RJMP _0xF9
                 _0x101:
                 ;    1591     	PT_SecStart = 0;
00083b e0e0      	LDI  R30,0
00083c 93e0 0b90 	STS  _PT_SecStart,R30
00083e 93e0 0b91 	STS  _PT_SecStart+1,R30
                 ;    1592  
                 ;    1593 	_FF_PART_ADDR = (long) PT_SecStart * (long) BPB_BytsPerSec;
                 _0xF9:
000840 91e0 0b90 	LDS  R30,_PT_SecStart
000842 91f0 0b91 	LDS  R31,_PT_SecStart+1
000844 2766      	CLR  R22
000845 2777      	CLR  R23
000846 01df      	MOVW R26,R30
000847 01cb      	MOVW R24,R22
000848 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
00084a 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
00084c 2766      	CLR  R22
00084d 2777      	CLR  R23
00084e 940e 1e59 	CALL __MULD12
000850 93e0 0bb5 	STS  __FF_PART_ADDR,R30
000852 93f0 0bb6 	STS  __FF_PART_ADDR+1,R31
000854 9360 0bb7 	STS  __FF_PART_ADDR+2,R22
000856 9370 0bb8 	STS  __FF_PART_ADDR+3,R23
                 ;    1594 
                 ;    1595 	if (PT_SecStart)
000858 91e0 0b90 	LDS  R30,_PT_SecStart
00085a 91f0 0b91 	LDS  R31,_PT_SecStart+1
00085c 9730      	SBIW R30,0
00085d f091      	BREQ _0x102
                 ;    1596 	{
                 ;    1597 		if (_FF_read(_FF_PART_ADDR)==0)
00085e 91e0 0bb5 	LDS  R30,__FF_PART_ADDR
000860 91f0 0bb6 	LDS  R31,__FF_PART_ADDR+1
000862 9160 0bb7 	LDS  R22,__FF_PART_ADDR+2
000864 9170 0bb8 	LDS  R23,__FF_PART_ADDR+3
000866 940e 1ed7 	CALL __PUTPARD1
000868 d2f5      	RCALL __FF_read
000869 30e0      	CPI  R30,0
00086a f429      	BRNE _0x103
                 ;    1598 		{
                 ;    1599 		   	#ifdef _DEBUG_ON_
                 ;    1600 				printf("\n\rREAD_ERR");
                 ;    1601 			#endif
                 ;    1602 			_FF_error = INIT_ERR;
00086b e0e1      	LDI  R30,LOW(1)
00086c 93e0 0bd3 	STS  __FF_error,R30
                 ;    1603 			return (0);
00086e e0e0      	LDI  R30,LOW(0)
00086f c26c      	RJMP _0x428
                 ;    1604 		}
                 ;    1605 	}
                 _0x103:
                 ;    1606 
                 ;    1607  	#ifdef _DEBUG_ON_
                 ;    1608 		printf("\n\rBoot_Sec: [0x%X %X %X] [0x%X] [0x%X]", _FF_buff[0],_FF_buff[1],_FF_buff[2],_FF_buff[510],_FF_buff[511]); 		
                 ;    1609 	#endif
                 ;    1610    	
                 ;    1611     BS_jmpBoot = (((long) _FF_buff[0] << 16) | ((int) _FF_buff[1] << 8) | (int) _FF_buff[2]);    		
                 _0x102:
000870 91e0 0990 	LDS  R30,__FF_buff
000872 27ff      	CLR  R31
000873 2766      	CLR  R22
000874 2777      	CLR  R23
000875 940e 1e22 	CALL __LSLD16
000877 01df      	MOVW R26,R30
000878 01cb      	MOVW R24,R22
000879 91f0 0991 	__GETBRMN 31,__FF_buff,1
00087b e0e0      	LDI  R30,LOW(0)
00087c 940e 1e27 	CALL __CWD1
00087e 940e 1dea 	CALL __ORD12
000880 01df      	MOVW R26,R30
000881 01cb      	MOVW R24,R22
000882 91e0 0992 	__GETB1MN __FF_buff,2
000884 e0f0      	LDI  R31,0
000885 940e 1e27 	CALL __CWD1
000887 940e 1dea 	CALL __ORD12
000889 93e0 0b92 	STS  _BS_jmpBoot,R30
00088b 93f0 0b93 	STS  _BS_jmpBoot+1,R31
00088d 9360 0b94 	STS  _BS_jmpBoot+2,R22
00088f 9370 0b95 	STS  _BS_jmpBoot+3,R23
                 ;    1612 	BPB_BytsPerSec = ((int) _FF_buff[0xC] << 8) | (int) _FF_buff[0xB];
000891 91b0 099c 	__GETBRMN 27,__FF_buff,12
000893 e0a0      	LDI  R26,LOW(0)
000894 91e0 099b 	__GETB1MN __FF_buff,11
000896 e0f0      	LDI  R31,0
000897 2bea      	OR   R30,R26
000898 2bfb      	OR   R31,R27
000899 93e0 0b96 	STS  _BPB_BytsPerSec,R30
00089b 93f0 0b97 	STS  _BPB_BytsPerSec+1,R31
                 ;    1613     BPB_SecPerClus = _FF_buff[0xD];
00089d 91e0 099d 	__GETB1MN __FF_buff,13
00089f 93e0 0b98 	STS  _BPB_SecPerClus,R30
                 ;    1614 	BPB_RsvdSecCnt = ((int) _FF_buff[0xF] << 8) | (int) _FF_buff[0xE];	
0008a1 91b0 099f 	__GETBRMN 27,__FF_buff,15
0008a3 e0a0      	LDI  R26,LOW(0)
0008a4 91e0 099e 	__GETB1MN __FF_buff,14
0008a6 e0f0      	LDI  R31,0
0008a7 2bea      	OR   R30,R26
0008a8 2bfb      	OR   R31,R27
0008a9 93e0 0b99 	STS  _BPB_RsvdSecCnt,R30
0008ab 93f0 0b9a 	STS  _BPB_RsvdSecCnt+1,R31
                 ;    1615 	BPB_NumFATs = _FF_buff[0x10];
0008ad 91e0 09a0 	__GETB1MN __FF_buff,16
0008af 93e0 0b9b 	STS  _BPB_NumFATs,R30
                 ;    1616 	BPB_RootEntCnt = ((int) _FF_buff[0x12] << 8) | (int) _FF_buff[0x11];	
0008b1 91b0 09a2 	__GETBRMN 27,__FF_buff,18
0008b3 e0a0      	LDI  R26,LOW(0)
0008b4 91e0 09a1 	__GETB1MN __FF_buff,17
0008b6 e0f0      	LDI  R31,0
0008b7 2bea      	OR   R30,R26
0008b8 2bfb      	OR   R31,R27
0008b9 93e0 0b9c 	STS  _BPB_RootEntCnt,R30
0008bb 93f0 0b9d 	STS  _BPB_RootEntCnt+1,R31
                 ;    1617 	BPB_FATSz16 = ((int) _FF_buff[0x17] << 8) | (int) _FF_buff[0x16];
0008bd 91b0 09a7 	__GETBRMN 27,__FF_buff,23
0008bf e0a0      	LDI  R26,LOW(0)
0008c0 91e0 09a6 	__GETB1MN __FF_buff,22
0008c2 e0f0      	LDI  R31,0
0008c3 2bea      	OR   R30,R26
0008c4 2bfb      	OR   R31,R27
0008c5 93e0 0b9e 	STS  _BPB_FATSz16,R30
0008c7 93f0 0b9f 	STS  _BPB_FATSz16+1,R31
                 ;    1618 	BPB_TotSec = ((unsigned int) _FF_buff[0x14] << 8) | (unsigned int) _FF_buff[0x13];
0008c9 91b0 09a4 	__GETBRMN 27,__FF_buff,20
0008cb e0a0      	LDI  R26,LOW(0)
0008cc 91e0 09a3 	__GETB1MN __FF_buff,19
0008ce e0f0      	LDI  R31,0
0008cf 2bea      	OR   R30,R26
0008d0 2bfb      	OR   R31,R27
0008d1 2766      	CLR  R22
0008d2 2777      	CLR  R23
0008d3 93e0 0ba1 	STS  _BPB_TotSec,R30
0008d5 93f0 0ba2 	STS  _BPB_TotSec+1,R31
0008d7 9360 0ba3 	STS  _BPB_TotSec+2,R22
0008d9 9370 0ba4 	STS  _BPB_TotSec+3,R23
                 ;    1619 	if (BPB_TotSec==0)
0008db 940e 1f18 	CALL __CPD10
0008dd f5d1      	BRNE _0x104
                 ;    1620 		BPB_TotSec = ((unsigned long) _FF_buff[0x23] << 24) | ((unsigned long) _FF_buff[0x22] << 16)
                 ;    1621 					| ((unsigned long) _FF_buff[0x21] << 8) | ((unsigned long) _FF_buff[0x20]);
0008de 91e0 09b3 	__GETB1MN __FF_buff,35
0008e0 27ff      	CLR  R31
0008e1 2766      	CLR  R22
0008e2 2777      	CLR  R23
0008e3 01df      	MOVW R26,R30
0008e4 01cb      	MOVW R24,R22
0008e5 e1e8      	LDI  R30,LOW(24)
0008e6 940e 1dfc 	CALL __LSLD12
0008e8 01df      	MOVW R26,R30
0008e9 01cb      	MOVW R24,R22
0008ea 91e0 09b2 	__GETB1MN __FF_buff,34
0008ec 27ff      	CLR  R31
0008ed 2766      	CLR  R22
0008ee 2777      	CLR  R23
0008ef 940e 1e22 	CALL __LSLD16
0008f1 940e 1dea 	CALL __ORD12
0008f3 937f      	PUSH R23
0008f4 936f      	PUSH R22
0008f5 93ff      	PUSH R31
0008f6 93ef      	PUSH R30
0008f7 91e0 09b1 	__GETB1MN __FF_buff,33
0008f9 27ff      	CLR  R31
0008fa 2766      	CLR  R22
0008fb 2777      	CLR  R23
0008fc 01df      	MOVW R26,R30
0008fd 01cb      	MOVW R24,R22
0008fe e0e8      	LDI  R30,LOW(8)
0008ff 940e 1dfc 	CALL __LSLD12
000901 91af      	POP  R26
000902 91bf      	POP  R27
000903 918f      	POP  R24
000904 919f      	POP  R25
000905 940e 1dea 	CALL __ORD12
000907 01df      	MOVW R26,R30
000908 01cb      	MOVW R24,R22
000909 91e0 09b0 	__GETB1MN __FF_buff,32
00090b 27ff      	CLR  R31
00090c 2766      	CLR  R22
00090d 2777      	CLR  R23
00090e 940e 1dea 	CALL __ORD12
000910 93e0 0ba1 	STS  _BPB_TotSec,R30
000912 93f0 0ba2 	STS  _BPB_TotSec+1,R31
000914 9360 0ba3 	STS  _BPB_TotSec+2,R22
000916 9370 0ba4 	STS  _BPB_TotSec+3,R23
                 ;    1622 	BS_VolSerial = ((unsigned long) _FF_buff[0x2A] << 24) | ((unsigned long) _FF_buff[0x29] << 16)
                 _0x104:
                 ;    1623 				| ((unsigned long) _FF_buff[0x28] << 8) | ((unsigned long) _FF_buff[0x27]);
000918 91e0 09ba 	__GETB1MN __FF_buff,42
00091a 27ff      	CLR  R31
00091b 2766      	CLR  R22
00091c 2777      	CLR  R23
00091d 01df      	MOVW R26,R30
00091e 01cb      	MOVW R24,R22
00091f e1e8      	LDI  R30,LOW(24)
000920 940e 1dfc 	CALL __LSLD12
000922 01df      	MOVW R26,R30
000923 01cb      	MOVW R24,R22
000924 91e0 09b9 	__GETB1MN __FF_buff,41
000926 27ff      	CLR  R31
000927 2766      	CLR  R22
000928 2777      	CLR  R23
000929 940e 1e22 	CALL __LSLD16
00092b 940e 1dea 	CALL __ORD12
00092d 937f      	PUSH R23
00092e 936f      	PUSH R22
00092f 93ff      	PUSH R31
000930 93ef      	PUSH R30
000931 91e0 09b8 	__GETB1MN __FF_buff,40
000933 27ff      	CLR  R31
000934 2766      	CLR  R22
000935 2777      	CLR  R23
000936 01df      	MOVW R26,R30
000937 01cb      	MOVW R24,R22
000938 e0e8      	LDI  R30,LOW(8)
000939 940e 1dfc 	CALL __LSLD12
00093b 91af      	POP  R26
00093c 91bf      	POP  R27
00093d 918f      	POP  R24
00093e 919f      	POP  R25
00093f 940e 1dea 	CALL __ORD12
000941 01df      	MOVW R26,R30
000942 01cb      	MOVW R24,R22
000943 91e0 09b7 	__GETB1MN __FF_buff,39
000945 27ff      	CLR  R31
000946 2766      	CLR  R22
000947 2777      	CLR  R23
000948 940e 1dea 	CALL __ORD12
00094a 93e0 0ba5 	STS  _BS_VolSerial,R30
00094c 93f0 0ba6 	STS  _BS_VolSerial+1,R31
00094e 9360 0ba7 	STS  _BS_VolSerial+2,R22
000950 9370 0ba8 	STS  _BS_VolSerial+3,R23
                 ;    1624 	for (n=0; n<11; n++)
000952 e0e0
000953 83e9
000954 83ea
000955 83eb
000956 83ec      	__CLRD1S 1
                 _0x106:
000957 81a9
000958 81ba
000959 818b
00095a 819c      	__GETD2S 1
00095b 30ab
00095c e0e0
00095d 07be
00095e e0e0
00095f 078e
000960 e0e0
000961 079e      	__CPD2N 0xB
000962 f500      	BRSH _0x107
                 ;    1625 		BS_VolLab[n] = _FF_buff[0x2B+n];
000963 81e9
000964 81fa
000965 816b
000966 817c      	__GETD1S 1
000967 55e7      	SUBI R30,LOW(-_BS_VolLab)
000968 4ff4      	SBCI R31,HIGH(-_BS_VolLab)
000969 01df      	MOVW R26,R30
00096a 81e9
00096b 81fa
00096c 816b
00096d 817c      	__GETD1S 1
00096e 5de5
00096f 4fff
000970 4f6f
000971 4f7f      	__ADDD1N 43
000972 57e0      	SUBI R30,LOW(-__FF_buff)
000973 4ff6      	SBCI R31,HIGH(-__FF_buff)
000974 81e0      	LD   R30,Z
000975 93ec      	ST   X,R30
                 ;    1626 	BS_VolLab[11] = 0;		// Terminate the string
000976 81e9
000977 81fa
000978 816b
000979 817c      	__GETD1S 1
00097a 5fef
00097b 4fff
00097c 4f6f
00097d 4f7f      	__SUBD1N -1
00097e 83e9
00097f 83fa
000980 836b
000981 837c      	__PUTD1S 1
000982 cfd4      	RJMP _0x106
                 _0x107:
000983 e0e0      	LDI  R30,LOW(0)
000984 93e0 0bb4 	__PUTB1MN _BS_VolLab,11
                 ;    1627 	_FF_FAT1_ADDR = _FF_PART_ADDR + ((long) BPB_RsvdSecCnt * (long) BPB_BytsPerSec); 
000986 91e0 0b99 	LDS  R30,_BPB_RsvdSecCnt
000988 91f0 0b9a 	LDS  R31,_BPB_RsvdSecCnt+1
00098a 2766      	CLR  R22
00098b 2777      	CLR  R23
00098c 01df      	MOVW R26,R30
00098d 01cb      	MOVW R24,R22
00098e 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000990 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000992 2766      	CLR  R22
000993 2777      	CLR  R23
000994 940e 1e59 	CALL __MULD12
000996 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
000998 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
00099a 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
00099c 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
00099e 940e 1dd6 	CALL __ADDD12
0009a0 93e0 0bc1 	STS  __FF_FAT1_ADDR,R30
0009a2 93f0 0bc2 	STS  __FF_FAT1_ADDR+1,R31
0009a4 9360 0bc3 	STS  __FF_FAT1_ADDR+2,R22
0009a6 9370 0bc4 	STS  __FF_FAT1_ADDR+3,R23
                 ;    1628 	_FF_FAT2_ADDR = _FF_FAT1_ADDR + ((long) BPB_FATSz16 * (long) BPB_BytsPerSec);
0009a8 91e0 0b9e 	LDS  R30,_BPB_FATSz16
0009aa 91f0 0b9f 	LDS  R31,_BPB_FATSz16+1
0009ac 2766      	CLR  R22
0009ad 2777      	CLR  R23
0009ae 01df      	MOVW R26,R30
0009af 01cb      	MOVW R24,R22
0009b0 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0009b2 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0009b4 2766      	CLR  R22
0009b5 2777      	CLR  R23
0009b6 940e 1e59 	CALL __MULD12
0009b8 91a0 0bc1 	LDS  R26,__FF_FAT1_ADDR
0009ba 91b0 0bc2 	LDS  R27,__FF_FAT1_ADDR+1
0009bc 9180 0bc3 	LDS  R24,__FF_FAT1_ADDR+2
0009be 9190 0bc4 	LDS  R25,__FF_FAT1_ADDR+3
0009c0 940e 1dd6 	CALL __ADDD12
0009c2 93e0 0bc5 	STS  __FF_FAT2_ADDR,R30
0009c4 93f0 0bc6 	STS  __FF_FAT2_ADDR+1,R31
0009c6 9360 0bc7 	STS  __FF_FAT2_ADDR+2,R22
0009c8 9370 0bc8 	STS  __FF_FAT2_ADDR+3,R23
                 ;    1629 	_FF_ROOT_ADDR = ((long) BPB_NumFATs * (long) BPB_FATSz16) + (long) BPB_RsvdSecCnt;
0009ca 91e0 0b9b 	LDS  R30,_BPB_NumFATs
0009cc 27ff      	CLR  R31
0009cd 2766      	CLR  R22
0009ce 2777      	CLR  R23
0009cf 01df      	MOVW R26,R30
0009d0 01cb      	MOVW R24,R22
0009d1 91e0 0b9e 	LDS  R30,_BPB_FATSz16
0009d3 91f0 0b9f 	LDS  R31,_BPB_FATSz16+1
0009d5 2766      	CLR  R22
0009d6 2777      	CLR  R23
0009d7 940e 1e59 	CALL __MULD12
0009d9 01df      	MOVW R26,R30
0009da 01cb      	MOVW R24,R22
0009db 91e0 0b99 	LDS  R30,_BPB_RsvdSecCnt
0009dd 91f0 0b9a 	LDS  R31,_BPB_RsvdSecCnt+1
0009df 2766      	CLR  R22
0009e0 2777      	CLR  R23
0009e1 940e 1dd6 	CALL __ADDD12
0009e3 93e0 0bb9 	STS  __FF_ROOT_ADDR,R30
0009e5 93f0 0bba 	STS  __FF_ROOT_ADDR+1,R31
0009e7 9360 0bbb 	STS  __FF_ROOT_ADDR+2,R22
0009e9 9370 0bbc 	STS  __FF_ROOT_ADDR+3,R23
                 ;    1630 	_FF_ROOT_ADDR *= BPB_BytsPerSec;
0009eb 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0009ed 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0009ef 91a0 0bb9 	LDS  R26,__FF_ROOT_ADDR
0009f1 91b0 0bba 	LDS  R27,__FF_ROOT_ADDR+1
0009f3 9180 0bbb 	LDS  R24,__FF_ROOT_ADDR+2
0009f5 9190 0bbc 	LDS  R25,__FF_ROOT_ADDR+3
0009f7 2766      	CLR  R22
0009f8 2777      	CLR  R23
0009f9 940e 1e34 	CALL __MULD12U
0009fb 93e0 0bb9 	STS  __FF_ROOT_ADDR,R30
0009fd 93f0 0bba 	STS  __FF_ROOT_ADDR+1,R31
0009ff 9360 0bbb 	STS  __FF_ROOT_ADDR+2,R22
000a01 9370 0bbc 	STS  __FF_ROOT_ADDR+3,R23
                 ;    1631 	_FF_ROOT_ADDR += _FF_PART_ADDR;
000a03 91e0 0bb5 	LDS  R30,__FF_PART_ADDR
000a05 91f0 0bb6 	LDS  R31,__FF_PART_ADDR+1
000a07 9160 0bb7 	LDS  R22,__FF_PART_ADDR+2
000a09 9170 0bb8 	LDS  R23,__FF_PART_ADDR+3
000a0b 91a0 0bb9 	LDS  R26,__FF_ROOT_ADDR
000a0d 91b0 0bba 	LDS  R27,__FF_ROOT_ADDR+1
000a0f 9180 0bbb 	LDS  R24,__FF_ROOT_ADDR+2
000a11 9190 0bbc 	LDS  R25,__FF_ROOT_ADDR+3
000a13 940e 1dd6 	CALL __ADDD12
000a15 93e0 0bb9 	STS  __FF_ROOT_ADDR,R30
000a17 93f0 0bba 	STS  __FF_ROOT_ADDR+1,R31
000a19 9360 0bbb 	STS  __FF_ROOT_ADDR+2,R22
000a1b 9370 0bbc 	STS  __FF_ROOT_ADDR+3,R23
                 ;    1632 	
                 ;    1633 	_FF_RootDirSectors = ((BPB_RootEntCnt * 32) + BPB_BytsPerSec - 1) / BPB_BytsPerSec;
000a1d 91e0 0b9c 	LDS  R30,_BPB_RootEntCnt
000a1f 91f0 0b9d 	LDS  R31,_BPB_RootEntCnt+1
000a21 0fee      	LSL  R30
000a22 1fff      	ROL  R31
000a23 940e 1e14 	CALL __LSLW4
000a25 91a0 0b96 	LDS  R26,_BPB_BytsPerSec
000a27 91b0 0b97 	LDS  R27,_BPB_BytsPerSec+1
000a29 0fae      	ADD  R26,R30
000a2a 1fbf      	ADC  R27,R31
000a2b 9711      	SBIW R26,1
000a2c 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000a2e 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000a30 940e 1e5e 	CALL __DIVW21U
000a32 2766      	CLR  R22
000a33 2777      	CLR  R23
000a34 93e0 0bc9 	STS  __FF_RootDirSectors,R30
000a36 93f0 0bca 	STS  __FF_RootDirSectors+1,R31
000a38 9360 0bcb 	STS  __FF_RootDirSectors+2,R22
000a3a 9370 0bcc 	STS  __FF_RootDirSectors+3,R23
                 ;    1634 	FirstDataSector = (BPB_NumFATs * BPB_FATSz16) + BPB_RsvdSecCnt + _FF_RootDirSectors; 
000a3c 91e0 0b9e 	LDS  R30,_BPB_FATSz16
000a3e 91f0 0b9f 	LDS  R31,_BPB_FATSz16+1
000a40 91a0 0b9b 	LDS  R26,_BPB_NumFATs
000a42 e0b0      	LDI  R27,0
000a43 940e 1e2c 	CALL __MULW12U
000a45 91a0 0b99 	LDS  R26,_BPB_RsvdSecCnt
000a47 91b0 0b9a 	LDS  R27,_BPB_RsvdSecCnt+1
000a49 0fae      	ADD  R26,R30
000a4a 1fbf      	ADC  R27,R31
000a4b 91e0 0bc9 	LDS  R30,__FF_RootDirSectors
000a4d 91f0 0bca 	LDS  R31,__FF_RootDirSectors+1
000a4f 9160 0bcb 	LDS  R22,__FF_RootDirSectors+2
000a51 9170 0bcc 	LDS  R23,__FF_RootDirSectors+3
000a53 2788      	CLR  R24
000a54 2799      	CLR  R25
000a55 940e 1dd6 	CALL __ADDD12
000a57 93e0 0bcd 	STS  _FirstDataSector,R30
000a59 93f0 0bce 	STS  _FirstDataSector+1,R31
                 ;    1635 	
                 ;    1636 	DataClusTot = BPB_TotSec - FirstDataSector;
000a5b 91a0 0ba1 	LDS  R26,_BPB_TotSec
000a5d 91b0 0ba2 	LDS  R27,_BPB_TotSec+1
000a5f 9180 0ba3 	LDS  R24,_BPB_TotSec+2
000a61 9190 0ba4 	LDS  R25,_BPB_TotSec+3
000a63 2766      	CLR  R22
000a64 2777      	CLR  R23
000a65 940e 1de5 	CALL __SUBD21
000a67 93a0 0bd8 	STS  _DataClusTot,R26
000a69 93b0 0bd9 	STS  _DataClusTot+1,R27
000a6b 9380 0bda 	STS  _DataClusTot+2,R24
000a6d 9390 0bdb 	STS  _DataClusTot+3,R25
                 ;    1637 	DataClusTot /= BPB_SecPerClus;
000a6f 91e0 0b98 	LDS  R30,_BPB_SecPerClus
000a71 91a0 0bd8 	LDS  R26,_DataClusTot
000a73 91b0 0bd9 	LDS  R27,_DataClusTot+1
000a75 9180 0bda 	LDS  R24,_DataClusTot+2
000a77 9190 0bdb 	LDS  R25,_DataClusTot+3
000a79 27ff      	CLR  R31
000a7a 2766      	CLR  R22
000a7b 2777      	CLR  R23
000a7c 940e 1e71 	CALL __DIVD21U
000a7e 93e0 0bd8 	STS  _DataClusTot,R30
000a80 93f0 0bd9 	STS  _DataClusTot+1,R31
000a82 9360 0bda 	STS  _DataClusTot+2,R22
000a84 9370 0bdb 	STS  _DataClusTot+3,R23
                 ;    1638 	clus_0_addr = 0;		// Reset Empty Cluster table location
000a86 e0e0      	LDI  R30,0
000a87 93e0 0be3 	STS  _clus_0_addr,R30
000a89 93e0 0be4 	STS  _clus_0_addr+1,R30
000a8b 93e0 0be5 	STS  _clus_0_addr+2,R30
000a8d 93e0 0be6 	STS  _clus_0_addr+3,R30
                 ;    1639 	c_counter = 1;
000a8f e0e1      	LDI  R30,LOW(1)
000a90 e0f0      	LDI  R31,HIGH(1)
000a91 93e0 0beb 	STS  _c_counter,R30
000a93 93f0 0bec 	STS  _c_counter+1,R31
                 ;    1640 	
                 ;    1641 	if (DataClusTot < 4085)				// FAT12
000a95 91a0 0bd8 	LDS  R26,_DataClusTot
000a97 91b0 0bd9 	LDS  R27,_DataClusTot+1
000a99 9180 0bda 	LDS  R24,_DataClusTot+2
000a9b 9190 0bdb 	LDS  R25,_DataClusTot+3
000a9d 3fa5
000a9e e0ef
000a9f 07be
000aa0 e0e0
000aa1 078e
000aa2 e0e0
000aa3 079e      	__CPD2N 0xFF5
000aa4 f420      	BRSH _0x108
                 ;    1642 		BPB_FATType = 0x32;
000aa5 e3e2      	LDI  R30,LOW(50)
000aa6 93e0 0ba0 	STS  _BPB_FATType,R30
                 ;    1643 	else if (DataClusTot < 65525)		// FAT16
000aa8 c01c      	RJMP _0x109
                 _0x108:
000aa9 91a0 0bd8 	LDS  R26,_DataClusTot
000aab 91b0 0bd9 	LDS  R27,_DataClusTot+1
000aad 9180 0bda 	LDS  R24,_DataClusTot+2
000aaf 9190 0bdb 	LDS  R25,_DataClusTot+3
000ab1 3fa5
000ab2 efef
000ab3 07be
000ab4 e0e0
000ab5 078e
000ab6 e0e0
000ab7 079e      	__CPD2N 0xFFF5
000ab8 f420      	BRSH _0x10A
                 ;    1644 		BPB_FATType = 0x36;
000ab9 e3e6      	LDI  R30,LOW(54)
000aba 93e0 0ba0 	STS  _BPB_FATType,R30
                 ;    1645 	else
000abc c008      	RJMP _0x10B
                 _0x10A:
                 ;    1646 	{
                 ;    1647 		BPB_FATType = 0;
000abd e0e0      	LDI  R30,LOW(0)
000abe 93e0 0ba0 	STS  _BPB_FATType,R30
                 ;    1648 		_FF_error = FAT_ERR;
000ac0 e0ec      	LDI  R30,LOW(12)
000ac1 93e0 0bd3 	STS  __FF_error,R30
                 ;    1649 		return (0);
000ac3 e0e0      	LDI  R30,LOW(0)
000ac4 c017      	RJMP _0x428
                 ;    1650 	}
                 _0x10B:
                 _0x109:
                 ;    1651     
                 ;    1652 	_FF_DIR_ADDR = _FF_ROOT_ADDR;		// Set current directory to root address
000ac5 91e0 0bb9 	LDS  R30,__FF_ROOT_ADDR
000ac7 91f0 0bba 	LDS  R31,__FF_ROOT_ADDR+1
000ac9 9160 0bbb 	LDS  R22,__FF_ROOT_ADDR+2
000acb 9170 0bbc 	LDS  R23,__FF_ROOT_ADDR+3
000acd 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
000acf 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
000ad1 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
000ad3 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    1653 
                 ;    1654 	_FF_FULL_PATH[0] = 0x5C;	// a '\'
000ad5 e5ec      	LDI  R30,LOW(92)
000ad6 93e0 0bed 	STS  __FF_FULL_PATH,R30
                 ;    1655 	_FF_FULL_PATH[1] = 0;
000ad8 e0e0      	LDI  R30,LOW(0)
000ad9 93e0 0bee 	__PUTB1MN __FF_FULL_PATH,1
                 ;    1656 	
                 ;    1657 	#ifdef _DEBUG_ON_
                 ;    1658 		printf("\n\rPart Address:  %lX", _FF_PART_ADDR);
                 ;    1659 		printf("\n\rBS_jmpBoot:  %lX", BS_jmpBoot);
                 ;    1660 		printf("\n\rBPB_BytsPerSec:  %X", BPB_BytsPerSec);
                 ;    1661 		printf("\n\rBPB_SecPerClus:  %X", BPB_SecPerClus);
                 ;    1662 		printf("\n\rBPB_RsvdSecCnt:  %X", BPB_RsvdSecCnt);
                 ;    1663 		printf("\n\rBPB_NumFATs:  %X", BPB_NumFATs);
                 ;    1664 		printf("\n\rBPB_RootEntCnt:  %X", BPB_RootEntCnt);
                 ;    1665 		printf("\n\rBPB_FATSz16:  %X", BPB_FATSz16);
                 ;    1666 		printf("\n\rBPB_TotSec16:  %lX", BPB_TotSec);
                 ;    1667 		if (BPB_FATType == 0x32)
                 ;    1668 			printf("\n\rBPB_FATType:  FAT12");
                 ;    1669 		else if (BPB_FATType == 0x36)
                 ;    1670 			printf("\n\rBPB_FATType:  FAT16");
                 ;    1671 		else
                 ;    1672 			printf("\n\rBPB_FATType:  FAT ERROR!!");
                 ;    1673 		printf("\n\rClusterCnt:  %lX", DataClusTot);
                 ;    1674 		printf("\n\rROOT_ADDR:  %lX", _FF_ROOT_ADDR);
                 ;    1675 		printf("\n\rFAT2_ADDR:  %lX", _FF_FAT2_ADDR);
                 ;    1676 		printf("\n\rRootDirSectors:  %X", _FF_RootDirSectors);
                 ;    1677 		printf("\n\rFirstDataSector:  %X", FirstDataSector);
                 ;    1678 	#endif
                 ;    1679 	
                 ;    1680 	return (1);	
000adb e0e1      	LDI  R30,LOW(1)
                 _0x428:
000adc 8108      	LDD  R16,Y+0
000add 9625      	ADIW R28,5
000ade 9508      	RET
                 ;    1681 }
                 ;    1682 
                 ;    1683 unsigned char spi_speedset(void)
                 ;    1684 {
                 _spi_speedset:
                 ;    1685 	if (SPCR == 0x50)
000adf b1ed      	IN   R30,0xD
000ae0 35e0      	CPI  R30,LOW(0x50)
000ae1 f419      	BRNE _0x10C
                 ;    1686 		SPCR = 0x51;
000ae2 e5e1      	LDI  R30,LOW(81)
000ae3 b9ed      	OUT  0xD,R30
                 ;    1687 	else if (SPCR == 0x51)
000ae4 c010      	RJMP _0x10D
                 _0x10C:
000ae5 b1ed      	IN   R30,0xD
000ae6 35e1      	CPI  R30,LOW(0x51)
000ae7 f419      	BRNE _0x10E
                 ;    1688 		SPCR = 0x52;
000ae8 e5e2      	LDI  R30,LOW(82)
000ae9 b9ed      	OUT  0xD,R30
                 ;    1689 	else if (SPCR == 0x52)
000aea c00a      	RJMP _0x10F
                 _0x10E:
000aeb b1ed      	IN   R30,0xD
000aec 35e2      	CPI  R30,LOW(0x52)
000aed f419      	BRNE _0x110
                 ;    1690 		SPCR = 0x53;
000aee e5e3      	LDI  R30,LOW(83)
000aef b9ed      	OUT  0xD,R30
                 ;    1691 	else
000af0 c004      	RJMP _0x111
                 _0x110:
                 ;    1692 	{
                 ;    1693 		SPCR = 0x50;
000af1 e5e0      	LDI  R30,LOW(80)
000af2 b9ed      	OUT  0xD,R30
                 ;    1694 		return (0);
000af3 e0e0      	LDI  R30,LOW(0)
000af4 9508      	RET
                 ;    1695 	}
                 _0x111:
                 _0x10F:
                 _0x10D:
                 ;    1696 	return (1);
000af5 e0e1      	LDI  R30,LOW(1)
000af6 9508      	RET
                 ;    1697 }
                 ;    1698 
                 ;    1699 unsigned char reset_sd(void)
                 ;    1700 {
                 _reset_sd:
                 ;    1701 	unsigned char resp, n, c;
                 ;    1702 
                 ;    1703 	#ifdef _DEBUG_ON_
                 ;    1704 		printf("\n\rReset CMD:  ");	
                 ;    1705 	#endif
                 ;    1706 
                 ;    1707 	for (c=0; c<4; c++)		// try reset command 3 times if needed
000af7 940e 1f33 	CALL __SAVELOCR3
                 ;	resp -> R16
                 ;	n -> R17
                 ;	c -> R18
000af9 e020      	LDI  R18,LOW(0)
                 _0x113:
000afa 3024      	CPI  R18,4
000afb f578      	BRSH _0x114
                 ;    1708 	{
                 ;    1709 		SD_CS_OFF();
000afc 9ac4      	SBI  0x18,4
                 ;    1710 		for (n=0; n<10; n++)	// initialize clk signal to sync card
000afd e010      	LDI  R17,LOW(0)
                 _0x116:
000afe 301a      	CPI  R17,10
000aff f430      	BRSH _0x117
                 ;    1711 			_FF_spi(0xFF);
000b00 efef      	LDI  R30,LOW(255)
000b01 93ea      	ST   -Y,R30
000b02 940e 060f 	CALL __FF_spi
                 ;    1712 		resp = send_cmd(CMD0,0);
000b04 5f1f      	SUBI R17,-1
000b05 cff8      	RJMP _0x116
                 _0x117:
000b06 e0e0      	LDI  R30,LOW(0)
000b07 93ea      	ST   -Y,R30
000b08 e0e0
000b09 e0f0
000b0a e060
000b0b e070      	__GETD1N 0x0
000b0c 940e 1ed7 	CALL __PUTPARD1
000b0e 940e 0615 	CALL _send_cmd
000b10 2f0e      	MOV  R16,R30
                 ;    1713 		for (n=0; n<200; n++)
000b11 e010      	LDI  R17,LOW(0)
                 _0x119:
000b12 3c18      	CPI  R17,200
000b13 f470      	BRSH _0x11A
                 ;    1714 		{
                 ;    1715 			if (resp == 0x1)
000b14 3001      	CPI  R16,1
000b15 f429      	BRNE _0x11B
                 ;    1716 			{
                 ;    1717 				SD_CS_OFF();
000b16 9ac4      	SBI  0x18,4
                 ;    1718     			#ifdef _DEBUG_ON_
                 ;    1719 					printf("OK!!!");
                 ;    1720 				#endif
                 ;    1721 				SPCR = 0x50;
000b17 e5e0      	LDI  R30,LOW(80)
000b18 b9ed      	OUT  0xD,R30
                 ;    1722 				return(1);
000b19 e0e1      	LDI  R30,LOW(1)
000b1a c03f      	RJMP _0x427
                 ;    1723 			}
                 ;    1724 	      	resp = _FF_spi(0xFF);
                 _0x11B:
000b1b efef      	LDI  R30,LOW(255)
000b1c 93ea      	ST   -Y,R30
000b1d 940e 060f 	CALL __FF_spi
000b1f 2f0e      	MOV  R16,R30
                 ;    1725 		}
000b20 5f1f      	SUBI R17,-1
000b21 cff0      	RJMP _0x119
                 _0x11A:
                 ;    1726 		#ifdef _DEBUG_ON_
                 ;    1727 			printf("ERROR!!!");
                 ;    1728 		#endif
                 ;    1729  		if (spi_speedset()==0)
000b22 940e 0adf 	CALL _spi_speedset
000b24 30e0      	CPI  R30,0
000b25 f419      	BRNE _0x11C
                 ;    1730  		{
                 ;    1731 		    SD_CS_OFF();
000b26 9ac4      	SBI  0x18,4
                 ;    1732  			return (0);
000b27 e0e0      	LDI  R30,LOW(0)
000b28 c031      	RJMP _0x427
                 ;    1733  		}
                 ;    1734 	}
                 _0x11C:
000b29 5f2f      	SUBI R18,-1
000b2a cfcf      	RJMP _0x113
                 _0x114:
                 ;    1735 	return (0);
000b2b e0e0      	LDI  R30,LOW(0)
000b2c c02d      	RJMP _0x427
                 ;    1736 }
                 ;    1737 
                 ;    1738 unsigned char init_sd(void)
                 ;    1739 {
                 _init_sd:
                 ;    1740 	unsigned char resp;
                 ;    1741 	unsigned int c;
                 ;    1742 	
                 ;    1743 	clear_sd_buff();
000b2d 940e 1f33 	CALL __SAVELOCR3
                 ;	resp -> R16
                 ;	c -> R17,R18
000b2f 940e 078b 	CALL _clear_sd_buff
                 ;    1744 
                 ;    1745     #ifdef _DEBUG_ON_
                 ;    1746 		printf("\r\nInitialization:  ");
                 ;    1747 	#endif
                 ;    1748     for (c=0; c<1000; c++)
000b31 e010
000b32 e020      	__GETWRN 17,18,0
                 _0x11E:
000b33 3e18
000b34 e0e3
000b35 072e      	__CPWRN 17,18,1000
000b36 f4f0      	BRSH _0x11F
                 ;    1749     {
                 ;    1750     	resp = send_cmd(CMD1, 0);
000b37 e0e1      	LDI  R30,LOW(1)
000b38 93ea      	ST   -Y,R30
000b39 e0e0
000b3a e0f0
000b3b e060
000b3c e070      	__GETD1N 0x0
000b3d 940e 1ed7 	CALL __PUTPARD1
000b3f 940e 0615 	CALL _send_cmd
000b41 2f0e      	MOV  R16,R30
                 ;    1751     	if (resp == 0)
000b42 3000      	CPI  R16,0
000b43 f089      	BREQ _0x11F
                 ;    1752     		break;
                 ;    1753    		resp = _FF_spi(0xFF);
000b44 efef      	LDI  R30,LOW(255)
000b45 93ea      	ST   -Y,R30
000b46 940e 060f 	CALL __FF_spi
000b48 2f0e      	MOV  R16,R30
                 ;    1754    		if (resp == 0)
000b49 3000      	CPI  R16,0
000b4a f051      	BREQ _0x11F
                 ;    1755    			break;
                 ;    1756    		resp = _FF_spi(0xFF);
000b4b efef      	LDI  R30,LOW(255)
000b4c 93ea      	ST   -Y,R30
000b4d 940e 060f 	CALL __FF_spi
000b4f 2f0e      	MOV  R16,R30
                 ;    1757    		if (resp == 0)
000b50 3000      	CPI  R16,0
000b51 f019      	BREQ _0x11F
                 ;    1758    			break;
                 ;    1759 	}
000b52 5f1f
000b53 4f2f      	__ADDWRN 17,18,1
000b54 cfde      	RJMP _0x11E
                 _0x11F:
                 ;    1760    	if (resp == 0)
000b55 3000      	CPI  R16,0
000b56 f411      	BRNE _0x123
                 ;    1761 	{
                 ;    1762 		#ifdef _DEBUG_ON_
                 ;    1763    			printf("OK!");
                 ;    1764 	   	#endif
                 ;    1765 		return (1);
000b57 e0e1      	LDI  R30,LOW(1)
000b58 c001      	RJMP _0x427
                 ;    1766 	}
                 ;    1767 	else
                 _0x123:
                 ;    1768 	{
                 ;    1769 		#ifdef _DEBUG_ON_
                 ;    1770    			printf("ERROR-%x  ", resp);
                 ;    1771 	   	#endif
                 ;    1772 		return (0);
000b59 e0e0      	LDI  R30,LOW(0)
                 ;    1773  	}        		
                 ;    1774 }
                 _0x427:
000b5a 940e 1f3a 	CALL __LOADLOCR3
000b5c 9623      	ADIW R28,3
000b5d 9508      	RET
                 ;    1775 
                 ;    1776 unsigned char _FF_read_disp(unsigned long sd_addr)
                 ;    1777 {
                 ;    1778 	unsigned char resp;
                 ;    1779 	unsigned long n, remainder;
                 ;    1780 	
                 ;    1781 	if (sd_addr % 0x200)
                 ;	sd_addr -> Y+9
                 ;	resp -> R16
                 ;	n -> Y+5
                 ;	remainder -> Y+1
                 ;    1782 	{	// Not a valid read address, return 0
                 ;    1783 		_FF_error = READ_ERR;
                 ;    1784 		return (0);
                 ;    1785 	}
                 ;    1786 
                 ;    1787 	clear_sd_buff();
                 ;    1788 	resp = send_cmd(CMD17, sd_addr);		// Send read request
                 ;    1789 	
                 ;    1790 	while(resp!=0xFE)
                 ;    1791 		resp = _FF_spi(0xFF);
                 ;    1792 	for (n=0; n<512; n++)
                 ;    1793 	{
                 ;    1794 		remainder = n % 0x10;
                 ;    1795 		if (remainder == 0)
                 ;    1796 			printf("\n\r");
                 ;    1797 		_FF_buff[n] = _FF_spi(0xFF);
                 ;    1798 		if (_FF_buff[n]<0x10)
                 ;    1799 			putchar(0x30);
                 ;    1800 		printf("%X ", _FF_buff[n]);
                 ;    1801 	}
                 ;    1802 	_FF_spi(0xFF);
                 ;    1803 	_FF_spi(0xFF);
                 ;    1804 	_FF_spi(0xFF);
                 ;    1805 	SD_CS_OFF();
                 ;    1806 	return (1);
                 ;    1807 }
                 ;    1808 
                 ;    1809 // Read data from a SD card @ address
                 ;    1810 unsigned char _FF_read(unsigned long sd_addr)
                 ;    1811 {
                 __FF_read:
                 ;    1812 	unsigned char resp;
                 ;    1813 	unsigned long n;
                 ;    1814 //printf("\r\nReadin ADDR [0x%lX]", sd_addr);
                 ;    1815 	
                 ;    1816 	if (sd_addr % BPB_BytsPerSec)
000b5e 9724      	SBIW R28,4
000b5f 930a      	ST   -Y,R16
                 ;	sd_addr -> Y+5
                 ;	resp -> R16
                 ;	n -> Y+1
000b60 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000b62 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000b64 81ad
000b65 81be
000b66 818f
000b67 8598      	__GETD2S 5
000b68 2766      	CLR  R22
000b69 2777      	CLR  R23
000b6a 940e 1e9f 	CALL __MODD21U
000b6c 940e 1f18 	CALL __CPD10
000b6e f029      	BREQ _0x12E
                 ;    1817 	{	// Not a valid read address, return 0
                 ;    1818 		_FF_error = READ_ERR;
000b6f e0e4      	LDI  R30,LOW(4)
000b70 93e0 0bd3 	STS  __FF_error,R30
                 ;    1819 		return (0);
000b72 e0e0      	LDI  R30,LOW(0)
000b73 c08e      	RJMP _0x426
                 ;    1820 	}
                 ;    1821 		
                 ;    1822 	for (;;)
                 _0x12E:
                 _0x130:
                 ;    1823 	{
                 ;    1824 		clear_sd_buff();
000b74 940e 078b 	CALL _clear_sd_buff
                 ;    1825 		resp = send_cmd(CMD17, sd_addr);	// read block command
000b76 e0e7      	LDI  R30,LOW(7)
000b77 93ea      	ST   -Y,R30
000b78 81ee
000b79 81ff
000b7a 8568
000b7b 8579      	__GETD1S 6
000b7c 940e 1ed7 	CALL __PUTPARD1
000b7e 940e 0615 	CALL _send_cmd
000b80 2f0e      	MOV  R16,R30
                 ;    1826 		for (n=0; n<1000; n++)
000b81 e0e0
000b82 83e9
000b83 83ea
000b84 83eb
000b85 83ec      	__CLRD1S 1
                 _0x133:
000b86 81a9
000b87 81ba
000b88 818b
000b89 819c      	__GETD2S 1
000b8a 3ea8
000b8b e0e3
000b8c 07be
000b8d e0e0
000b8e 078e
000b8f e0e0
000b90 079e      	__CPD2N 0x3E8
000b91 f4a0      	BRSH _0x134
                 ;    1827 		{
                 ;    1828 			if (resp==0xFE)
000b92 3f0e      	CPI  R16,254
000b93 f091      	BREQ _0x134
                 ;    1829 			{	// waiting for start byte
                 ;    1830 				break;
                 ;    1831 			}
                 ;    1832 			resp = _FF_spi(0xFF);
000b94 efef      	LDI  R30,LOW(255)
000b95 93ea      	ST   -Y,R30
000b96 940e 060f 	CALL __FF_spi
000b98 2f0e      	MOV  R16,R30
                 ;    1833 		}
000b99 81e9
000b9a 81fa
000b9b 816b
000b9c 817c      	__GETD1S 1
000b9d 5fef
000b9e 4fff
000b9f 4f6f
000ba0 4f7f      	__SUBD1N -1
000ba1 83e9
000ba2 83fa
000ba3 836b
000ba4 837c      	__PUTD1S 1
000ba5 cfe0      	RJMP _0x133
                 _0x134:
                 ;    1834 		if (resp==0xFE)
000ba6 3f0e      	CPI  R16,254
000ba7 f011      	BREQ PC+3
000ba8 940c 0bf8 	JMP _0x136
                 ;    1835 		{	// if it is a valid start byte => start reading SD Card
                 ;    1836 			for (n=0; n<BPB_BytsPerSec; n++)
000baa e0e0
000bab 83e9
000bac 83ea
000bad 83eb
000bae 83ec      	__CLRD1S 1
                 _0x138:
000baf 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000bb1 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000bb3 81a9
000bb4 81ba
000bb5 818b
000bb6 819c      	__GETD2S 1
000bb7 2766      	CLR  R22
000bb8 2777      	CLR  R23
000bb9 940e 1f2b 	CALL __CPD21
000bbb f4e0      	BRSH _0x139
                 ;    1837 				_FF_buff[n] = _FF_spi(0xFF);
000bbc 81e9
000bbd 81fa
000bbe 816b
000bbf 817c      	__GETD1S 1
000bc0 57e0      	SUBI R30,LOW(-__FF_buff)
000bc1 4ff6      	SBCI R31,HIGH(-__FF_buff)
000bc2 93ff      	PUSH R31
000bc3 93ef      	PUSH R30
000bc4 efef      	LDI  R30,LOW(255)
000bc5 93ea      	ST   -Y,R30
000bc6 940e 060f 	CALL __FF_spi
000bc8 91af      	POP  R26
000bc9 91bf      	POP  R27
000bca 93ec      	ST   X,R30
                 ;    1838 			_FF_spi(0xFF);
000bcb 81e9
000bcc 81fa
000bcd 816b
000bce 817c      	__GETD1S 1
000bcf 5fef
000bd0 4fff
000bd1 4f6f
000bd2 4f7f      	__SUBD1N -1
000bd3 83e9
000bd4 83fa
000bd5 836b
000bd6 837c      	__PUTD1S 1
000bd7 cfd7      	RJMP _0x138
                 _0x139:
000bd8 efef      	LDI  R30,LOW(255)
000bd9 93ea      	ST   -Y,R30
000bda 940e 060f 	CALL __FF_spi
                 ;    1839 			_FF_spi(0xFF);
000bdc efef      	LDI  R30,LOW(255)
000bdd 93ea      	ST   -Y,R30
000bde 940e 060f 	CALL __FF_spi
                 ;    1840 			_FF_spi(0xFF);
000be0 efef      	LDI  R30,LOW(255)
000be1 93ea      	ST   -Y,R30
000be2 940e 060f 	CALL __FF_spi
                 ;    1841 			SD_CS_OFF();
000be4 9ac4      	SBI  0x18,4
                 ;    1842 			_FF_error = NO_ERR;
000be5 e0e0      	LDI  R30,LOW(0)
000be6 93e0 0bd3 	STS  __FF_error,R30
                 ;    1843 			_FF_buff_addr = sd_addr;
000be8 81ed
000be9 81fe
000bea 816f
000beb 8578      	__GETD1S 5
000bec 93e0 0bd4 	STS  __FF_buff_addr,R30
000bee 93f0 0bd5 	STS  __FF_buff_addr+1,R31
000bf0 9360 0bd6 	STS  __FF_buff_addr+2,R22
000bf2 9370 0bd7 	STS  __FF_buff_addr+3,R23
                 ;    1844 			SPCR = 0x50;
000bf4 e5e0      	LDI  R30,LOW(80)
000bf5 b9ed      	OUT  0xD,R30
                 ;    1845 			return (1);
000bf6 e0e1      	LDI  R30,LOW(1)
000bf7 c00a      	RJMP _0x426
                 ;    1846 		}
                 ;    1847 
                 ;    1848 		SD_CS_OFF();
                 _0x136:
000bf8 9ac4      	SBI  0x18,4
                 ;    1849 
                 ;    1850 		if (spi_speedset()==0)
000bf9 940e 0adf 	CALL _spi_speedset
000bfb 30e0      	CPI  R30,0
000bfc f009      	BREQ _0x131
                 ;    1851 			break;
                 ;    1852 	}	
000bfd cf76      	RJMP _0x130
                 _0x131:
                 ;    1853 	_FF_error = READ_ERR;    
000bfe e0e4      	LDI  R30,LOW(4)
000bff 93e0 0bd3 	STS  __FF_error,R30
                 ;    1854 	return(0);
000c01 e0e0      	LDI  R30,LOW(0)
                 _0x426:
000c02 8108      	LDD  R16,Y+0
000c03 9629      	ADIW R28,9
000c04 9508      	RET
                 ;    1855 }
                 ;    1856 
                 ;    1857 
                 ;    1858 #ifndef _READ_ONLY_
                 ;    1859 unsigned char _FF_write(unsigned long sd_addr)
                 ;    1860 {
                 __FF_write:
                 ;    1861 	unsigned char resp, calc, valid_flag;
                 ;    1862 	unsigned int n;
                 ;    1863 	
                 ;    1864 	if ((sd_addr%BPB_BytsPerSec) || (sd_addr <= _FF_PART_ADDR))
000c05 940e 1f31 	CALL __SAVELOCR5
                 ;	sd_addr -> Y+5
                 ;	resp -> R16
                 ;	calc -> R17
                 ;	valid_flag -> R18
                 ;	n -> R19,R20
000c07 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000c09 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000c0b 81ad
000c0c 81be
000c0d 818f
000c0e 8598      	__GETD2S 5
000c0f 2766      	CLR  R22
000c10 2777      	CLR  R23
000c11 940e 1e9f 	CALL __MODD21U
000c13 940e 1f18 	CALL __CPD10
000c15 f479      	BRNE _0x13C
000c16 91e0 0bb5 	LDS  R30,__FF_PART_ADDR
000c18 91f0 0bb6 	LDS  R31,__FF_PART_ADDR+1
000c1a 9160 0bb7 	LDS  R22,__FF_PART_ADDR+2
000c1c 9170 0bb8 	LDS  R23,__FF_PART_ADDR+3
000c1e 81ad
000c1f 81be
000c20 818f
000c21 8598      	__GETD2S 5
000c22 940e 1f26 	CALL __CPD12
000c24 f028      	BRLO _0x13B
                 _0x13C:
                 ;    1865 	{	// Not a valid write address, return 0
                 ;    1866 		_FF_error = WRITE_ERR;
000c25 e0e3      	LDI  R30,LOW(3)
000c26 93e0 0bd3 	STS  __FF_error,R30
                 ;    1867 		return (0);
000c28 e0e0      	LDI  R30,LOW(0)
000c29 c066      	RJMP _0x425
                 ;    1868 	}
                 ;    1869 
                 ;    1870 //printf("\r\nWriting to address:  %lX", sd_addr);
                 ;    1871 	for (;;)
                 _0x13B:
                 _0x13F:
                 ;    1872 	{
                 ;    1873 		clear_sd_buff();
000c2a 940e 078b 	CALL _clear_sd_buff
                 ;    1874 		resp = send_cmd(CMD24, sd_addr);
000c2c e0e9      	LDI  R30,LOW(9)
000c2d 93ea      	ST   -Y,R30
000c2e 81ee
000c2f 81ff
000c30 8568
000c31 8579      	__GETD1S 6
000c32 940e 1ed7 	CALL __PUTPARD1
000c34 940e 0615 	CALL _send_cmd
000c36 2f0e      	MOV  R16,R30
                 ;    1875 		valid_flag = 0;
000c37 e020      	LDI  R18,LOW(0)
                 ;    1876 		for (n=0; n<1000; n++)
000c38 e030
000c39 e040      	__GETWRN 19,20,0
                 _0x142:
000c3a 3e38
000c3b e0e3
000c3c 074e      	__CPWRN 19,20,1000
000c3d f460      	BRSH _0x143
                 ;    1877 		{
                 ;    1878 			if (resp == 0x00)
000c3e 3000      	CPI  R16,0
000c3f f411      	BRNE _0x144
                 ;    1879 			{
                 ;    1880 				valid_flag = 1;
000c40 e021      	LDI  R18,LOW(1)
                 ;    1881 				break;
000c41 c008      	RJMP _0x143
                 ;    1882 			}
                 ;    1883 			resp = _FF_spi(0xFF);
                 _0x144:
000c42 efef      	LDI  R30,LOW(255)
000c43 93ea      	ST   -Y,R30
000c44 940e 060f 	CALL __FF_spi
000c46 2f0e      	MOV  R16,R30
                 ;    1884 		}
000c47 5f3f
000c48 4f4f      	__ADDWRN 19,20,1
000c49 cff0      	RJMP _0x142
                 _0x143:
                 ;    1885 	
                 ;    1886 		if (valid_flag)
000c4a 3020      	CPI  R18,0
000c4b f1d1      	BREQ _0x145
                 ;    1887 		{
                 ;    1888 			_FF_spi(0xFF);
000c4c efef      	LDI  R30,LOW(255)
000c4d 93ea      	ST   -Y,R30
000c4e 940e 060f 	CALL __FF_spi
                 ;    1889 			_FF_spi(0xFE);					// Start Block Token
000c50 efee      	LDI  R30,LOW(254)
000c51 93ea      	ST   -Y,R30
000c52 940e 060f 	CALL __FF_spi
                 ;    1890 			for (n=0; n<BPB_BytsPerSec; n++)		// Write Data in buffer to card
000c54 e030
000c55 e040      	__GETWRN 19,20,0
                 _0x147:
000c56 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000c58 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000c5a 173e      	CP   R19,R30
000c5b 074f      	CPC  R20,R31
000c5c f458      	BRSH _0x148
                 ;    1891 				_FF_spi(_FF_buff[n]);
000c5d e9a0      	LDI  R26,LOW(__FF_buff)
000c5e e0b9      	LDI  R27,HIGH(__FF_buff)
000c5f 0fa3      	ADD  R26,R19
000c60 1fb4      	ADC  R27,R20
000c61 91ec      	LD   R30,X
000c62 93ea      	ST   -Y,R30
000c63 940e 060f 	CALL __FF_spi
                 ;    1892 			_FF_spi(0xFF);					// Send 2 blank CRC bytes
000c65 5f3f
000c66 4f4f      	__ADDWRN 19,20,1
000c67 cfee      	RJMP _0x147
                 _0x148:
000c68 efef      	LDI  R30,LOW(255)
000c69 93ea      	ST   -Y,R30
000c6a 940e 060f 	CALL __FF_spi
                 ;    1893 			_FF_spi(0xFF);
000c6c efef      	LDI  R30,LOW(255)
000c6d 93ea      	ST   -Y,R30
000c6e 940e 060f 	CALL __FF_spi
                 ;    1894 			resp = _FF_spi(0xFF);			// Response should be 0bXXX00101
000c70 efef      	LDI  R30,LOW(255)
000c71 93ea      	ST   -Y,R30
000c72 940e 060f 	CALL __FF_spi
000c74 2f0e      	MOV  R16,R30
                 ;    1895 			calc = resp | 0xE0;
000c75 2fe0      	MOV  R30,R16
000c76 6ee0      	ORI  R30,LOW(0xE0)
000c77 2f1e      	MOV  R17,R30
                 ;    1896 			if (calc==0xE5)
000c78 3e15      	CPI  R17,229
000c79 f461      	BRNE _0x149
                 ;    1897 			{
                 ;    1898 				while(_FF_spi(0xFF)==0)
                 _0x14A:
000c7a efef      	LDI  R30,LOW(255)
000c7b 93ea      	ST   -Y,R30
000c7c 940e 060f 	CALL __FF_spi
000c7e 30e0      	CPI  R30,0
000c7f f3d1      	BREQ _0x14A
                 ;    1899 					;	// Clear Buffer before returning 'OK'
                 ;    1900 				SD_CS_OFF();
000c80 9ac4      	SBI  0x18,4
                 ;    1901 //				SPCR = 0x50;			// Reset SPI bus Speed
                 ;    1902 				_FF_error = NO_ERR;
000c81 e0e0      	LDI  R30,LOW(0)
000c82 93e0 0bd3 	STS  __FF_error,R30
                 ;    1903 				return(1);
000c84 e0e1      	LDI  R30,LOW(1)
000c85 c00a      	RJMP _0x425
                 ;    1904 			}
                 ;    1905 		}
                 _0x149:
                 ;    1906 		SD_CS_OFF(); 
                 _0x145:
000c86 9ac4      	SBI  0x18,4
                 ;    1907 
                 ;    1908 		if (spi_speedset()==0)
000c87 940e 0adf 	CALL _spi_speedset
000c89 30e0      	CPI  R30,0
000c8a f009      	BREQ _0x140
                 ;    1909 			break;
                 ;    1910 		// delay_ms(100);		
                 ;    1911 	}
000c8b cf9e      	RJMP _0x13F
                 _0x140:
                 ;    1912 	_FF_error = WRITE_ERR;
000c8c e0e3      	LDI  R30,LOW(3)
000c8d 93e0 0bd3 	STS  __FF_error,R30
                 ;    1913 	return(0x0);
000c8f e0e0      	LDI  R30,LOW(0)
                 _0x425:
000c90 940e 1f38 	CALL __LOADLOCR5
000c92 9629      	ADIW R28,9
000c93 9508      	RET
                 ;    1914 }
                 ;    1915 #endif
                 ;    1916 /*
                 ;    1917 	Progressive Resources LLC
                 ;    1918                                     
                 ;    1919 			FlashFile
                 ;    1920 	
                 ;    1921 	Version : 	1.32
                 ;    1922 	Date: 		12/31/2003
                 ;    1923 	Author: 	Erick M. Higa
                 ;    1924 	
                 ;    1925 	Revision History:
                 ;    1926 	12/31/2003 - EMH - v1.00 
                 ;    1927 			   	 	 - Initial Release
                 ;    1928 	01/19/2004 - EMH - v1.10
                 ;    1929 			   	 	 - fixed FAT access errors by allowing both FAT tables to be updated
                 ;    1930 					 - fixed erase_cluster chain to stop if chain goes to '0'
                 ;    1931 					 - fixed #include's so other non m128 processors could be used
                 ;    1932 					 - fixed fcreate to match 'C' standard for function "creat"
                 ;    1933 					 - fixed fseek so it would not error when in "READ" mode
                 ;    1934 					 - modified SPI interface to use _FF_spi() so it is more universal
                 ;    1935 					   (see the "sd_cmd.c" file for the function used)
                 ;    1936 					 - redifined global variables and #defines for more unique names
                 ;    1937 					 - added string functions fputs, fputsc, & fgets
                 ;    1938 					 - added functions fquickformat, fgetfileinfo, & GetVolID()
                 ;    1939 					 - added directory support
                 ;    1940 					 - modified delays in "sd_cmd.c" to increase transfer speed to max
                 ;    1941 					 - updated "options.h" to include additions, and to make #defines 
                 ;    1942 					   more universal to multiple platforms
                 ;    1943 	01/21/2004 - EMH - v1.20
                 ;    1944 			   	 	 - Added ICC Support to the FlashFileSD
                 ;    1945 					 - fixed card initialization error for MMC/SD's that have only a boot 
                 ;    1946 			   	 	   sector and no partition table
                 ;    1947 					 - Fixed intermittant error on fcreate when creating existing file
                 ;    1948 					 - changed "options.h" to #include all required files
                 ;    1949 	02/19/2004 - EMH - v1.21
                 ;    1950 					 - Replaced all "const" refrances to "flash" to support CodeVision 1.24.1b
                 ;    1951 	03/02/2004 - EMH - v1.22 (unofficial release)
                 ;    1952 					 - Changed Directory Functions to allow for multi-cluster directory entries
                 ;    1953 					 - Added function addr_to_clust() to support long directories
                 ;    1954 					 - Fixed FAT table address calculation to support multiple reserved sectors
                 ;    1955 					   (previously) assumed one reserved sector, if XP formats card sometimes 
                 ;    1956 					   multiple reserved sectors - thanks YW
                 ;    1957 	03/10/2004 - EMH - v1.30
                 ;    1958 					 - Added support for a Compact Flash package
                 ;    1959 					 - Renamed read and write to flash function names for multiple media support	
                 ;    1960 	03/26/2004 - EMH - v1.31
                 ;    1961 					 - Added define for easy MEGA128Dev board setup
                 ;    1962 					 - Changed demo projects so "option.h" is in the project directory	
                 ;    1963 	04/01/2004 - EMH - v1.32
                 ;    1964 					 - Fixed bug in "prev_cluster()" that didn't use updated FAT table address
                 ;    1965 					   calculations.  (effects XP formatted cards see v1.22 notes)
                 ;    1966                                            
                 ;    1967 	Software License
                 ;    1968 	The use of Progressive Resources LLC FlashFile Source Package indicates 
                 ;    1969 	your understanding and acceptance of the following terms and conditions. 
                 ;    1970 	This license shall supersede any verbal or prior verbal or written, statement 
                 ;    1971 	or agreement to the contrary. If you do not understand or accept these terms, 
                 ;    1972 	or your local regulations prohibit "after sale" license agreements or limited 
                 ;    1973 	disclaimers, you must cease and desist using this product immediately.
                 ;    1974 	This product is © Copyright 2003 by Progressive Resources LLC, all rights 
                 ;    1975 	reserved. International copyright laws, international treaties and all other 
                 ;    1976 	applicable national or international laws protect this product. This software 
                 ;    1977 	product and documentation may not, in whole or in part, be copied, photocopied, 
                 ;    1978 	translated, or reduced to any electronic medium or machine readable form, without 
                 ;    1979 	prior consent in writing, from Progressive Resources LLC and according to all 
                 ;    1980 	applicable laws. The sole owner of this product is Progressive Resources LLC.
                 ;    1981 
                 ;    1982 	Operating License
                 ;    1983 	You have the non-exclusive right to use any enclosed product but have no right 
                 ;    1984 	to distribute it as a source code product without the express written permission 
                 ;    1985 	of Progressive Resources LLC. Use over a "local area network" (within the same 
                 ;    1986 	locale) is permitted provided that only a single person, on a single computer 
                 ;    1987 	uses the product at a time. Use over a "wide area network" (outside the same 
                 ;    1988 	locale) is strictly prohibited under any and all circumstances.
                 ;    1989                                            
                 ;    1990 	Liability Disclaimer
                 ;    1991 	This product and/or license is provided as is, without any representation or 
                 ;    1992 	warranty of any kind, either express or implied, including without limitation 
                 ;    1993 	any representations or endorsements regarding the use of, the results of, or 
                 ;    1994 	performance of the product, Its appropriateness, accuracy, reliability, or 
                 ;    1995 	correctness. The user and/or licensee assume the entire risk as to the use of 
                 ;    1996 	this product. Progressive Resources LLC does not assume liability for the use 
                 ;    1997 	of this product beyond the original purchase price of the software. In no event 
                 ;    1998 	will Progressive Resources LLC be liable for additional direct or indirect 
                 ;    1999 	damages including any lost profits, lost savings, or other incidental or 
                 ;    2000 	consequential damages arising from any defects, or the use or inability to 
                 ;    2001 	use these products, even if Progressive Resources LLC have been advised of 
                 ;    2002 	the possibility of such damages.
                 ;    2003 */                                 
                 ;    2004 
                 ;    2005 	#include <coding.h>
                 ;    2006 
                 ;    2007 extern unsigned long OCR_REG;
                 ;    2008 extern unsigned char _FF_buff[512];
                 ;    2009 extern unsigned int PT_SecStart;
                 ;    2010 extern unsigned long BS_jmpBoot;
                 ;    2011 extern unsigned int BPB_BytsPerSec;
                 ;    2012 extern unsigned char BPB_SecPerClus;
                 ;    2013 extern unsigned int BPB_RsvdSecCnt;
                 ;    2014 extern unsigned char BPB_NumFATs;
                 ;    2015 extern unsigned int BPB_RootEntCnt;
                 ;    2016 extern unsigned int BPB_FATSz16;
                 ;    2017 extern unsigned char BPB_FATType;
                 ;    2018 extern unsigned long BPB_TotSec;
                 ;    2019 extern unsigned long BS_VolSerial;
                 ;    2020 extern unsigned char BS_VolLab[12];
                 ;    2021 extern unsigned long _FF_PART_ADDR, _FF_ROOT_ADDR, _FF_DIR_ADDR;
                 ;    2022 extern unsigned long _FF_FAT1_ADDR, _FF_FAT2_ADDR;
                 ;    2023 extern unsigned int FirstDataSector;
                 ;    2024 extern unsigned long FirstSectorofCluster;
                 ;    2025 extern unsigned char _FF_error;
                 ;    2026 extern unsigned long _FF_buff_addr;
                 ;    2027 extern unsigned long DataClusTot;
                 ;    2028 unsigned char rtc_hour, rtc_min, rtc_sec;
                 
                 	.DSEG
                 _rtc_hour:
000bdc           	.BYTE 0x1
                 _rtc_min:
000bdd           	.BYTE 0x1
                 _rtc_sec:
000bde           	.BYTE 0x1
                 ;    2029 unsigned char rtc_date, rtc_month;
                 _rtc_date:
000bdf           	.BYTE 0x1
                 _rtc_month:
000be0           	.BYTE 0x1
                 ;    2030 unsigned int rtc_year;
                 _rtc_year:
000be1           	.BYTE 0x2
                 ;    2031 unsigned long clus_0_addr, _FF_n_temp;
                 _clus_0_addr:
000be3           	.BYTE 0x4
                 __FF_n_temp:
000be7           	.BYTE 0x4
                 ;    2032 unsigned int c_counter;
                 _c_counter:
000beb           	.BYTE 0x2
                 ;    2033 unsigned char _FF_FULL_PATH[_FF_PATH_LENGTH];
                 __FF_FULL_PATH:
000bed           	.BYTE 0x64
                 ;    2034 unsigned char FILENAME[12];
                 _FILENAME:
000c51           	.BYTE 0xC
                 ;    2035 
                 ;    2036 // Conversion file to change an ASCII valued character into the calculated value
                 ;    2037 unsigned char ascii_to_char(unsigned char ascii_char)
                 ;    2038 {
                 
                 	.CSEG
                 ;    2039 	unsigned char temp_char;
                 ;    2040 	
                 ;    2041 	if (ascii_char < 0x30)		// invalid, return error
                 ;	ascii_char -> Y+1
                 ;	temp_char -> R16
                 ;    2042 		return (0xFF);
                 ;    2043 	else if (ascii_char < 0x3A)
                 ;    2044 	{	//number, subtract 0x30, retrun value
                 ;    2045 		temp_char = ascii_char - 0x30;
                 ;    2046 		return (temp_char);
                 ;    2047 	}
                 ;    2048 	else if (ascii_char < 0x41)	// invalid, return error
                 ;    2049 		return (0xFF);
                 ;    2050 	else if (ascii_char < 0x47)
                 ;    2051 	{	// lower case a-f, subtract 0x37, return value
                 ;    2052 		temp_char = ascii_char - 0x37;
                 ;    2053 		return (temp_char);
                 ;    2054 	}
                 ;    2055 	else if (ascii_char < 0x61)	// invalid, return error
                 ;    2056 		return (0xFF);
                 ;    2057 	else if (ascii_char < 0x67)
                 ;    2058 	{	// upper case A-F, subtract 0x57, return value
                 ;    2059 		temp_char = ascii_char - 0x57;
                 ;    2060 		return (temp_char);
                 ;    2061 	}
                 ;    2062 	else	// invalid, return error
                 ;    2063 		return (0xFF);
                 ;    2064 }
                 ;    2065 
                 ;    2066 // Function to see if the character is a valid FILENAME character
                 ;    2067 int valid_file_char(unsigned char file_char)
                 ;    2068 {
                 _valid_file_char:
                 ;    2069 	if (file_char < 0x20)
000c94 81a8      	LD   R26,Y
000c95 32a0      	CPI  R26,LOW(0x20)
000c96 f418      	BRSH _0x15A
                 ;    2070 		return (EOF);
000c97 efef      	LDI  R30,LOW(65535)
000c98 efff      	LDI  R31,HIGH(65535)
000c99 c020      	RJMP _0x424
                 ;    2071 	else if ((file_char==0x22) || (file_char==0x2A) || (file_char==0x2B) || (file_char==0x2C) ||
                 _0x15A:
                 ;    2072 			(file_char==0x2E) || (file_char==0x2F) || ((file_char>=0x3A)&&(file_char<=0x3F)) ||
                 ;    2073 			((file_char>=0x5B)&&(file_char<=0x5D)) || (file_char==0x7C) || (file_char==0xE5))
000c9a 81a8      	LD   R26,Y
000c9b 32a2      	CPI  R26,LOW(0x22)
000c9c f0c1      	BREQ _0x15D
000c9d 32aa      	CPI  R26,LOW(0x2A)
000c9e f0b1      	BREQ _0x15D
000c9f 32ab      	CPI  R26,LOW(0x2B)
000ca0 f0a1      	BREQ _0x15D
000ca1 32ac      	CPI  R26,LOW(0x2C)
000ca2 f091      	BREQ _0x15D
000ca3 32ae      	CPI  R26,LOW(0x2E)
000ca4 f081      	BREQ _0x15D
000ca5 32af      	CPI  R26,LOW(0x2F)
000ca6 f071      	BREQ _0x15D
000ca7 33aa      	CPI  R26,LOW(0x3A)
000ca8 f010      	BRLO _0x15E
000ca9 34a0      	CPI  R26,LOW(0x40)
000caa f050      	BRLO _0x15D
                 _0x15E:
000cab 81a8      	LD   R26,Y
000cac 35ab      	CPI  R26,LOW(0x5B)
000cad f010      	BRLO _0x160
000cae 35ae      	CPI  R26,LOW(0x5E)
000caf f028      	BRLO _0x15D
                 _0x160:
000cb0 81a8      	LD   R26,Y
000cb1 37ac      	CPI  R26,LOW(0x7C)
000cb2 f011      	BREQ _0x15D
000cb3 3ea5      	CPI  R26,LOW(0xE5)
000cb4 f419      	BRNE _0x15C
                 _0x15D:
                 ;    2074 		return (EOF);
000cb5 efef      	LDI  R30,LOW(65535)
000cb6 efff      	LDI  R31,HIGH(65535)
000cb7 c002      	RJMP _0x424
                 ;    2075 	else
                 _0x15C:
                 ;    2076 		return (0);
000cb8 e0e0      	LDI  R30,LOW(0)
000cb9 e0f0      	LDI  R31,HIGH(0)
                 ;    2077 }
                 _0x424:
000cba 9621      	ADIW R28,1
000cbb 9508      	RET
                 ;    2078 
                 ;    2079 // Function will scan the directory @VALID_ADDR and return a
                 ;    2080 // '0' if successful (w/ VALID_ADDR changing to location of entry avaliable),
                 ;    2081 // and a '-1' if file or folder exists (w/ VALID_ADDR changing to location of
                 ;    2082 // entry of exisiting file/folder) or if no more entry space (VALID_ADDR would
                 ;    2083 // change to 0).
                 ;    2084 int scan_directory(unsigned long *VALID_ADDR, unsigned char *NAME)
                 ;    2085 {
                 _scan_directory:
                 ;    2086 	unsigned int ent_cntr, ent_max, n, c, dir_clus;
                 ;    2087 	unsigned long temp_addr;
                 ;    2088 	unsigned char *sp, *qp, aval_flag, name_store[14];
                 ;    2089 	
                 ;    2090 	aval_flag = 0;
000cbc 976b      	SBIW R28,27
000cbd 940e 1f30 	CALL __SAVELOCR6
                 ;	*VALID_ADDR -> Y+35
                 ;	*NAME -> Y+33
                 ;	ent_cntr -> R16,R17
                 ;	ent_max -> R18,R19
                 ;	n -> R20,R21
                 ;	c -> Y+31
                 ;	dir_clus -> Y+29
                 ;	temp_addr -> Y+25
                 ;	*sp -> Y+23
                 ;	*qp -> Y+21
                 ;	aval_flag -> Y+20
                 ;	name_store -> Y+6
000cbf e0e0      	LDI  R30,LOW(0)
000cc0 8bec      	STD  Y+20,R30
                 ;    2091 	ent_cntr = 0;	// set to 0
000cc1 e000
000cc2 e010      	__GETWRN 16,17,0
                 ;    2092 	
                 ;    2093 	qp = NAME;
000cc3 a1e9      	LDD  R30,Y+33
000cc4 a1fa      	LDD  R31,Y+33+1
000cc5 8bed      	STD  Y+21,R30
000cc6 8bfe      	STD  Y+21+1,R31
                 ;    2094 	for (c=0; c<11; c++)
000cc7 e0e0      	LDI  R30,0
000cc8 8fef      	STD  Y+31,R30
000cc9 a3e8      	STD  Y+31+1,R30
                 _0x165:
000cca 8daf      	LDD  R26,Y+31
000ccb a1b8      	LDD  R27,Y+31+1
000ccc 971b      	SBIW R26,11
000ccd f010      	BRLO PC+3
000cce 940c 0d38 	JMP _0x166
                 ;    2095 	{
                 ;    2096 		if (valid_file_char(*qp)==0)
000cd0 89ad      	LDD  R26,Y+21
000cd1 89be      	LDD  R27,Y+21+1
000cd2 91ec      	LD   R30,X
000cd3 93ea      	ST   -Y,R30
000cd4 940e 0c94 	CALL _valid_file_char
000cd6 9730      	SBIW R30,0
000cd7 f4a1      	BRNE _0x167
                 ;    2097 			name_store[c] = toupper(*qp++);
000cd8 8def      	LDD  R30,Y+31
000cd9 a1f8      	LDD  R31,Y+31+1
000cda 01de      	MOVW R26,R28
000cdb 9616      	ADIW R26,6
000cdc 0fea      	ADD  R30,R26
000cdd 1ffb      	ADC  R31,R27
000cde 93ff      	PUSH R31
000cdf 93ef      	PUSH R30
000ce0 89ad      	LDD  R26,Y+21
000ce1 89be      	LDD  R27,Y+21+1
000ce2 91ed      	LD   R30,X+
000ce3 8bad      	STD  Y+21,R26
000ce4 8bbe      	STD  Y+21+1,R27
000ce5 93ea      	ST   -Y,R30
000ce6 940e 1dc3 	CALL _toupper
000ce8 91af      	POP  R26
000ce9 91bf      	POP  R27
000cea 93ec      	ST   X,R30
                 ;    2098 		else if (*qp == '.')
000ceb c046      	RJMP _0x168
                 _0x167:
000cec 89ad      	LDD  R26,Y+21
000ced 89be      	LDD  R27,Y+21+1
000cee 91ac      	LD   R26,X
000cef 32ae      	CPI  R26,LOW(0x2E)
000cf0 f4f9      	BRNE _0x169
                 ;    2099 		{
                 ;    2100 			while (c<8)
                 _0x16A:
000cf1 8daf      	LDD  R26,Y+31
000cf2 a1b8      	LDD  R27,Y+31+1
000cf3 9718      	SBIW R26,8
000cf4 f468      	BRSH _0x16C
                 ;    2101 				name_store[c++] = 0x20;
000cf5 8def      	LDD  R30,Y+31
000cf6 a1f8      	LDD  R31,Y+31+1
000cf7 9631      	ADIW R30,1
000cf8 8fef      	STD  Y+31,R30
000cf9 a3f8      	STD  Y+31+1,R31
000cfa 9731      	SBIW R30,1
000cfb 01de      	MOVW R26,R28
000cfc 9616      	ADIW R26,6
000cfd 0fae      	ADD  R26,R30
000cfe 1fbf      	ADC  R27,R31
000cff e2e0      	LDI  R30,LOW(32)
000d00 93ec      	ST   X,R30
                 ;    2102 			c--;
000d01 cfef      	RJMP _0x16A
                 _0x16C:
000d02 8def      	LDD  R30,Y+31
000d03 a1f8      	LDD  R31,Y+31+1
000d04 9731      	SBIW R30,1
000d05 8fef      	STD  Y+31,R30
000d06 a3f8      	STD  Y+31+1,R31
                 ;    2103 			
                 ;    2104 			qp++;
000d07 89ed      	LDD  R30,Y+21
000d08 89fe      	LDD  R31,Y+21+1
000d09 9631      	ADIW R30,1
000d0a 8bed      	STD  Y+21,R30
000d0b 8bfe      	STD  Y+21+1,R31
                 ;    2105 			aval_flag |= 1;
000d0c 89ec      	LDD  R30,Y+20
000d0d 60e1      	ORI  R30,1
000d0e 8bec      	STD  Y+20,R30
                 ;    2106 		}
                 ;    2107 		else if (*qp == 0)
000d0f c022      	RJMP _0x16D
                 _0x169:
000d10 89ad      	LDD  R26,Y+21
000d11 89be      	LDD  R27,Y+21+1
000d12 91ec      	LD   R30,X
000d13 30e0      	CPI  R30,0
000d14 f491      	BRNE _0x16E
                 ;    2108 		{
                 ;    2109 			while (c<11)
                 _0x16F:
000d15 8daf      	LDD  R26,Y+31
000d16 a1b8      	LDD  R27,Y+31+1
000d17 971b      	SBIW R26,11
000d18 f468      	BRSH _0x171
                 ;    2110 				name_store[c++] = 0x20;
000d19 8def      	LDD  R30,Y+31
000d1a a1f8      	LDD  R31,Y+31+1
000d1b 9631      	ADIW R30,1
000d1c 8fef      	STD  Y+31,R30
000d1d a3f8      	STD  Y+31+1,R31
000d1e 9731      	SBIW R30,1
000d1f 01de      	MOVW R26,R28
000d20 9616      	ADIW R26,6
000d21 0fae      	ADD  R26,R30
000d22 1fbf      	ADC  R27,R31
000d23 e2e0      	LDI  R30,LOW(32)
000d24 93ec      	ST   X,R30
                 ;    2111 		}
000d25 cfef      	RJMP _0x16F
                 _0x171:
                 ;    2112 		else
000d26 c00b      	RJMP _0x172
                 _0x16E:
                 ;    2113 		{
                 ;    2114 			*VALID_ADDR = 0;
000d27 a1ab      	LDD  R26,Y+35
000d28 a1bc      	LDD  R27,Y+35+1
000d29 e0e0
000d2a e0f0
000d2b e060
000d2c e070      	__GETD1N 0x0
000d2d 940e 1ece 	CALL __PUTDP1
                 ;    2115 			return (EOF);
000d2f efef      	LDI  R30,LOW(65535)
000d30 efff      	LDI  R31,HIGH(65535)
000d31 c1b5      	RJMP _0x423
                 ;    2116 		}
                 _0x172:
                 _0x16D:
                 _0x168:
                 ;    2117 	}
000d32 8def      	LDD  R30,Y+31
000d33 a1f8      	LDD  R31,Y+31+1
000d34 9631      	ADIW R30,1
000d35 8fef      	STD  Y+31,R30
000d36 a3f8      	STD  Y+31+1,R31
000d37 cf92      	RJMP _0x165
                 _0x166:
                 ;    2118 	name_store[11] = 0;
000d38 e0e0      	LDI  R30,LOW(0)
000d39 8be9      	STD  Y+17,R30
                 ;    2119 	
                 ;    2120 	if (*VALID_ADDR == _FF_ROOT_ADDR)
000d3a a1ab      	LDD  R26,Y+35
000d3b a1bc      	LDD  R27,Y+35+1
000d3c 940e 1ec8 	CALL __GETD1P
000d3e 91a0 0bb9 	LDS  R26,__FF_ROOT_ADDR
000d40 91b0 0bba 	LDS  R27,__FF_ROOT_ADDR+1
000d42 9180 0bbb 	LDS  R24,__FF_ROOT_ADDR+2
000d44 9190 0bbc 	LDS  R25,__FF_ROOT_ADDR+3
000d46 940e 1f26 	CALL __CPD12
000d48 f429      	BRNE _0x173
                 ;    2121 		ent_max = BPB_RootEntCnt;
000d49 9120 0b9c
000d4b 9130 0b9d 	__GETWRMN 18,19,0,_BPB_RootEntCnt
                 ;    2122 	else
000d4d c026      	RJMP _0x174
                 _0x173:
                 ;    2123 	{
                 ;    2124 		dir_clus = addr_to_clust(*VALID_ADDR);
000d4e a1ab      	LDD  R26,Y+35
000d4f a1bc      	LDD  R27,Y+35+1
000d50 940e 1ec8 	CALL __GETD1P
000d52 940e 1ed7 	CALL __PUTPARD1
000d54 d1d5      	RCALL _addr_to_clust
000d55 8fed      	STD  Y+29,R30
000d56 8ffe      	STD  Y+29+1,R31
                 ;    2125 		if (dir_clus != 0)
000d57 9730      	SBIW R30,0
000d58 f019      	BREQ _0x175
                 ;    2126 			aval_flag |= 0x80;
000d59 89ec      	LDD  R30,Y+20
000d5a 68e0      	ORI  R30,0x80
000d5b 8bec      	STD  Y+20,R30
                 ;    2127 		ent_max = ((long) BPB_BytsPerSec * (long) BPB_SecPerClus) / 0x20;
                 _0x175:
000d5c 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000d5e 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000d60 2766      	CLR  R22
000d61 2777      	CLR  R23
000d62 01df      	MOVW R26,R30
000d63 01cb      	MOVW R24,R22
000d64 91e0 0b98 	LDS  R30,_BPB_SecPerClus
000d66 27ff      	CLR  R31
000d67 2766      	CLR  R22
000d68 2777      	CLR  R23
000d69 940e 1e59 	CALL __MULD12
000d6b 01df      	MOVW R26,R30
000d6c 01cb      	MOVW R24,R22
000d6d e2e0
000d6e e0f0
000d6f e060
000d70 e070      	__GETD1N 0x20
000d71 940e 1e97 	CALL __DIVD21
000d73 019f      	MOVW R18,R30
                 ;    2128     }
                 _0x174:
                 ;    2129 	c = 0;
000d74 e0e0      	LDI  R30,0
000d75 8fef      	STD  Y+31,R30
000d76 a3e8      	STD  Y+31+1,R30
                 ;    2130 	while (ent_cntr < ent_max)	
                 _0x176:
000d77 1702
000d78 0713      	__CPWRR 16,17,18,19
000d79 f010      	BRLO PC+3
000d7a 940c 0edd 	JMP _0x178
                 ;    2131 	{
                 ;    2132 		if (_FF_read(*VALID_ADDR+((long)c*BPB_BytsPerSec))==0)
000d7c a1ab      	LDD  R26,Y+35
000d7d a1bc      	LDD  R27,Y+35+1
000d7e 940e 1ec8 	CALL __GETD1P
000d80 937f      	PUSH R23
000d81 936f      	PUSH R22
000d82 93ff      	PUSH R31
000d83 93ef      	PUSH R30
000d84 8def      	LDD  R30,Y+31
000d85 a1f8      	LDD  R31,Y+31+1
000d86 2766      	CLR  R22
000d87 2777      	CLR  R23
000d88 01df      	MOVW R26,R30
000d89 01cb      	MOVW R24,R22
000d8a 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000d8c 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000d8e 2766      	CLR  R22
000d8f 2777      	CLR  R23
000d90 940e 1e59 	CALL __MULD12
000d92 91af      	POP  R26
000d93 91bf      	POP  R27
000d94 918f      	POP  R24
000d95 919f      	POP  R25
000d96 940e 1dd6 	CALL __ADDD12
000d98 940e 1ed7 	CALL __PUTPARD1
000d9a 940e 0b5e 	CALL __FF_read
000d9c 30e0      	CPI  R30,0
000d9d f409      	BRNE _0x179
                 ;    2133 			break;
000d9e c13e      	RJMP _0x178
                 ;    2134 		for (n=0; n<16; n++)
                 _0x179:
000d9f e040
000da0 e050      	__GETWRN 20,21,0
                 _0x17B:
000da1 3140
000da2 e0e0
000da3 075e      	__CPWRN 20,21,16
000da4 f010      	BRLO PC+3
000da5 940c 0eb0 	JMP _0x17C
                 ;    2135 		{
                 ;    2136 			sp = &_FF_buff[n*0x20];
000da7 01fa      	MOVW R30,R20
000da8 0fee      	LSL  R30
000da9 1fff      	ROL  R31
000daa 940e 1e14 	CALL __LSLW4
000dac 57e0      	SUBI R30,LOW(-__FF_buff)
000dad 4ff6      	SBCI R31,HIGH(-__FF_buff)
000dae 8bef      	STD  Y+23,R30
000daf 8ff8      	STD  Y+23+1,R31
                 ;    2137 			qp = name_store;
000db0 01fe      	MOVW R30,R28
000db1 9636      	ADIW R30,6
000db2 8bed      	STD  Y+21,R30
000db3 8bfe      	STD  Y+21+1,R31
                 ;    2138 			if (*sp==0)
000db4 89af      	LDD  R26,Y+23
000db5 8db8      	LDD  R27,Y+23+1
000db6 91ec      	LD   R30,X
000db7 30e0      	CPI  R30,0
000db8 f5b9      	BRNE _0x17D
                 ;    2139 			{
                 ;    2140 				if ((aval_flag&0x10)==0)
000db9 89ec      	LDD  R30,Y+20
000dba 71e0      	ANDI R30,LOW(0x10)
000dbb f549      	BRNE _0x17E
                 ;    2141 					temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000dbc a1ab      	LDD  R26,Y+35
000dbd a1bc      	LDD  R27,Y+35+1
000dbe 940e 1ec8 	CALL __GETD1P
000dc0 937f      	PUSH R23
000dc1 936f      	PUSH R22
000dc2 93ff      	PUSH R31
000dc3 93ef      	PUSH R30
000dc4 8def      	LDD  R30,Y+31
000dc5 a1f8      	LDD  R31,Y+31+1
000dc6 2766      	CLR  R22
000dc7 2777      	CLR  R23
000dc8 01df      	MOVW R26,R30
000dc9 01cb      	MOVW R24,R22
000dca 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000dcc 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000dce 2766      	CLR  R22
000dcf 2777      	CLR  R23
000dd0 940e 1e59 	CALL __MULD12
000dd2 91af      	POP  R26
000dd3 91bf      	POP  R27
000dd4 918f      	POP  R24
000dd5 919f      	POP  R25
000dd6 940e 1ddb 	CALL __ADDD21
000dd8 01fa      	MOVW R30,R20
000dd9 0fee      	LSL  R30
000dda 1fff      	ROL  R31
000ddb 940e 1e14 	CALL __LSLW4
000ddd 2766      	CLR  R22
000dde 2777      	CLR  R23
000ddf 940e 1dd6 	CALL __ADDD12
000de1 8fe9
000de2 8ffa
000de3 8f6b
000de4 8f7c      	__PUTD1S 25
                 ;    2142 				*VALID_ADDR = temp_addr;
                 _0x17E:
000de5 8de9
000de6 8dfa
000de7 8d6b
000de8 8d7c      	__GETD1S 25
000de9 a1ab      	LDD  R26,Y+35
000dea a1bc      	LDD  R27,Y+35+1
000deb 940e 1ece 	CALL __PUTDP1
                 ;    2143 				return (0);
000ded e0e0      	LDI  R30,LOW(0)
000dee e0f0      	LDI  R31,HIGH(0)
000def c0f7      	RJMP _0x423
                 ;    2144 			}
                 ;    2145 			else if (*sp==0xE5)
                 _0x17D:
000df0 89af      	LDD  R26,Y+23
000df1 8db8      	LDD  R27,Y+23+1
000df2 91ac      	LD   R26,X
000df3 3ea5      	CPI  R26,LOW(0xE5)
000df4 f569      	BRNE _0x180
                 ;    2146 			{
                 ;    2147 				temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000df5 a1ab      	LDD  R26,Y+35
000df6 a1bc      	LDD  R27,Y+35+1
000df7 940e 1ec8 	CALL __GETD1P
000df9 937f      	PUSH R23
000dfa 936f      	PUSH R22
000dfb 93ff      	PUSH R31
000dfc 93ef      	PUSH R30
000dfd 8def      	LDD  R30,Y+31
000dfe a1f8      	LDD  R31,Y+31+1
000dff 2766      	CLR  R22
000e00 2777      	CLR  R23
000e01 01df      	MOVW R26,R30
000e02 01cb      	MOVW R24,R22
000e03 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000e05 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000e07 2766      	CLR  R22
000e08 2777      	CLR  R23
000e09 940e 1e59 	CALL __MULD12
000e0b 91af      	POP  R26
000e0c 91bf      	POP  R27
000e0d 918f      	POP  R24
000e0e 919f      	POP  R25
000e0f 940e 1ddb 	CALL __ADDD21
000e11 01fa      	MOVW R30,R20
000e12 0fee      	LSL  R30
000e13 1fff      	ROL  R31
000e14 940e 1e14 	CALL __LSLW4
000e16 2766      	CLR  R22
000e17 2777      	CLR  R23
000e18 940e 1dd6 	CALL __ADDD12
000e1a 8fe9
000e1b 8ffa
000e1c 8f6b
000e1d 8f7c      	__PUTD1S 25
                 ;    2148 				aval_flag |= 0x10;
000e1e 89ec      	LDD  R30,Y+20
000e1f 61e0      	ORI  R30,0x10
000e20 8bec      	STD  Y+20,R30
                 ;    2149 			}
                 ;    2150 			else
000e21 c089      	RJMP _0x181
                 _0x180:
                 ;    2151 			{
                 ;    2152 				if (aval_flag & 0x01)	// file
000e22 89ec      	LDD  R30,Y+20
000e23 70e1      	ANDI R30,LOW(0x1)
000e24 f411      	BRNE PC+3
000e25 940c 0e66 	JMP _0x182
                 ;    2153 				{
                 ;    2154 					if (strncmp(qp, sp, 11)==0)
000e27 89ed      	LDD  R30,Y+21
000e28 89fe      	LDD  R31,Y+21+1
000e29 93fa      	ST   -Y,R31
000e2a 93ea      	ST   -Y,R30
000e2b 8de9      	LDD  R30,Y+25
000e2c 8dfa      	LDD  R31,Y+25+1
000e2d 93fa      	ST   -Y,R31
000e2e 93ea      	ST   -Y,R30
000e2f e0eb      	LDI  R30,LOW(11)
000e30 93ea      	ST   -Y,R30
000e31 940e 1d9e 	CALL _strncmp
000e33 30e0      	CPI  R30,0
000e34 f581      	BRNE _0x183
                 ;    2155 					{
                 ;    2156 						temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000e35 a1ab      	LDD  R26,Y+35
000e36 a1bc      	LDD  R27,Y+35+1
000e37 940e 1ec8 	CALL __GETD1P
000e39 937f      	PUSH R23
000e3a 936f      	PUSH R22
000e3b 93ff      	PUSH R31
000e3c 93ef      	PUSH R30
000e3d 8def      	LDD  R30,Y+31
000e3e a1f8      	LDD  R31,Y+31+1
000e3f 2766      	CLR  R22
000e40 2777      	CLR  R23
000e41 01df      	MOVW R26,R30
000e42 01cb      	MOVW R24,R22
000e43 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000e45 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000e47 2766      	CLR  R22
000e48 2777      	CLR  R23
000e49 940e 1e59 	CALL __MULD12
000e4b 91af      	POP  R26
000e4c 91bf      	POP  R27
000e4d 918f      	POP  R24
000e4e 919f      	POP  R25
000e4f 940e 1ddb 	CALL __ADDD21
000e51 01fa      	MOVW R30,R20
000e52 0fee      	LSL  R30
000e53 1fff      	ROL  R31
000e54 940e 1e14 	CALL __LSLW4
000e56 2766      	CLR  R22
000e57 2777      	CLR  R23
000e58 940e 1dd6 	CALL __ADDD12
000e5a 8fe9
000e5b 8ffa
000e5c 8f6b
000e5d 8f7c      	__PUTD1S 25
                 ;    2157 						*VALID_ADDR = temp_addr;
000e5e a1ab      	LDD  R26,Y+35
000e5f a1bc      	LDD  R27,Y+35+1
000e60 940e 1ece 	CALL __PUTDP1
                 ;    2158 						return (EOF);	// file exists @ temp_addr
000e62 efef      	LDI  R30,LOW(65535)
000e63 efff      	LDI  R31,HIGH(65535)
000e64 c082      	RJMP _0x423
                 ;    2159 					}
                 ;    2160 				}
                 _0x183:
                 ;    2161 				else					// folder
000e65 c045      	RJMP _0x184
                 _0x182:
                 ;    2162 				{
                 ;    2163 					if ((strncmp(qp, sp, 11)==0)&&(*(sp+11)&0x10))
000e66 89ed      	LDD  R30,Y+21
000e67 89fe      	LDD  R31,Y+21+1
000e68 93fa      	ST   -Y,R31
000e69 93ea      	ST   -Y,R30
000e6a 8de9      	LDD  R30,Y+25
000e6b 8dfa      	LDD  R31,Y+25+1
000e6c 93fa      	ST   -Y,R31
000e6d 93ea      	ST   -Y,R30
000e6e e0eb      	LDI  R30,LOW(11)
000e6f 93ea      	ST   -Y,R30
000e70 940e 1d9e 	CALL _strncmp
000e72 30e0      	CPI  R30,0
000e73 f431      	BRNE _0x186
000e74 89af      	LDD  R26,Y+23
000e75 8db8      	LDD  R27,Y+23+1
000e76 961b      	ADIW R26,11
000e77 91ec      	LD   R30,X
000e78 71e0      	ANDI R30,LOW(0x10)
000e79 f409      	BRNE _0x187
                 _0x186:
000e7a c030      	RJMP _0x185
                 _0x187:
                 ;    2164 					{
                 ;    2165 						temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000e7b a1ab      	LDD  R26,Y+35
000e7c a1bc      	LDD  R27,Y+35+1
000e7d 940e 1ec8 	CALL __GETD1P
000e7f 937f      	PUSH R23
000e80 936f      	PUSH R22
000e81 93ff      	PUSH R31
000e82 93ef      	PUSH R30
000e83 8def      	LDD  R30,Y+31
000e84 a1f8      	LDD  R31,Y+31+1
000e85 2766      	CLR  R22
000e86 2777      	CLR  R23
000e87 01df      	MOVW R26,R30
000e88 01cb      	MOVW R24,R22
000e89 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000e8b 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000e8d 2766      	CLR  R22
000e8e 2777      	CLR  R23
000e8f 940e 1e59 	CALL __MULD12
000e91 91af      	POP  R26
000e92 91bf      	POP  R27
000e93 918f      	POP  R24
000e94 919f      	POP  R25
000e95 940e 1ddb 	CALL __ADDD21
000e97 01fa      	MOVW R30,R20
000e98 0fee      	LSL  R30
000e99 1fff      	ROL  R31
000e9a 940e 1e14 	CALL __LSLW4
000e9c 2766      	CLR  R22
000e9d 2777      	CLR  R23
000e9e 940e 1dd6 	CALL __ADDD12
000ea0 8fe9
000ea1 8ffa
000ea2 8f6b
000ea3 8f7c      	__PUTD1S 25
                 ;    2166 						*VALID_ADDR = temp_addr;
000ea4 a1ab      	LDD  R26,Y+35
000ea5 a1bc      	LDD  R27,Y+35+1
000ea6 940e 1ece 	CALL __PUTDP1
                 ;    2167 						return (EOF);	// file exists @ temp_addr
000ea8 efef      	LDI  R30,LOW(65535)
000ea9 efff      	LDI  R31,HIGH(65535)
000eaa c03c      	RJMP _0x423
                 ;    2168 					}
                 ;    2169 				}
                 _0x185:
                 _0x184:
                 ;    2170 			}
                 _0x181:
                 ;    2171 			ent_cntr++;
000eab 5f0f
000eac 4f1f      	__ADDWRN 16,17,1
                 ;    2172 		}
000ead 5f4f
000eae 4f5f      	__ADDWRN 20,21,1
000eaf cef1      	RJMP _0x17B
                 _0x17C:
                 ;    2173 		c++;
000eb0 8def      	LDD  R30,Y+31
000eb1 a1f8      	LDD  R31,Y+31+1
000eb2 9631      	ADIW R30,1
000eb3 8fef      	STD  Y+31,R30
000eb4 a3f8      	STD  Y+31+1,R31
                 ;    2174 		if (ent_cntr == ent_max)
000eb5 1720
000eb6 0731      	__CPWRR 18,19,16,17
000eb7 f521      	BRNE _0x188
                 ;    2175 		{
                 ;    2176 			if (aval_flag & 0x80)		// a folder @ a valid cluster
000eb8 89ec      	LDD  R30,Y+20
000eb9 78e0      	ANDI R30,LOW(0x80)
000eba f109      	BREQ _0x189
                 ;    2177 			{
                 ;    2178 				c = next_cluster(dir_clus, SINGLE);
000ebb 8ded      	LDD  R30,Y+29
000ebc 8dfe      	LDD  R31,Y+29+1
000ebd 93fa      	ST   -Y,R31
000ebe 93ea      	ST   -Y,R30
000ebf e0e1      	LDI  R30,LOW(1)
000ec0 93ea      	ST   -Y,R30
000ec1 d0e5      	RCALL _next_cluster
000ec2 8fef      	STD  Y+31,R30
000ec3 a3f8      	STD  Y+31+1,R31
                 ;    2179 				if (c != EOF)
000ec4 8daf      	LDD  R26,Y+31
000ec5 a1b8      	LDD  R27,Y+31+1
000ec6 3faf      	CPI  R26,LOW(0xFFFF)
000ec7 efef      	LDI  R30,HIGH(0xFFFF)
000ec8 07be      	CPC  R27,R30
000ec9 f091      	BREQ _0x18A
                 ;    2180 				{	// another dir cluster exists
                 ;    2181 					*VALID_ADDR = clust_to_addr(c);
000eca 8def      	LDD  R30,Y+31
000ecb a1f8      	LDD  R31,Y+31+1
000ecc 93fa      	ST   -Y,R31
000ecd 93ea      	ST   -Y,R30
000ece d01c      	RCALL _clust_to_addr
000ecf a1ab      	LDD  R26,Y+35
000ed0 a1bc      	LDD  R27,Y+35+1
000ed1 940e 1ece 	CALL __PUTDP1
                 ;    2182 					dir_clus = c;
000ed3 8def      	LDD  R30,Y+31
000ed4 a1f8      	LDD  R31,Y+31+1
000ed5 8fed      	STD  Y+29,R30
000ed6 8ffe      	STD  Y+29+1,R31
                 ;    2183 					ent_cntr = 0;
000ed7 e000
000ed8 e010      	__GETWRN 16,17,0
                 ;    2184 					c = 0;
000ed9 e0e0      	LDI  R30,0
000eda 8fef      	STD  Y+31,R30
000edb a3e8      	STD  Y+31+1,R30
                 ;    2185 				}
                 ;    2186 			}
                 _0x18A:
                 ;    2187 		}
                 _0x189:
                 ;    2188 	}
                 _0x188:
000edc ce9a      	RJMP _0x176
                 _0x178:
                 ;    2189 	*VALID_ADDR = 0;
000edd a1ab      	LDD  R26,Y+35
000ede a1bc      	LDD  R27,Y+35+1
000edf e0e0
000ee0 e0f0
000ee1 e060
000ee2 e070      	__GETD1N 0x0
000ee3 940e 1ece 	CALL __PUTDP1
                 ;    2190 	return (EOF);	
000ee5 efef      	LDI  R30,LOW(65535)
000ee6 efff      	LDI  R31,HIGH(65535)
                 _0x423:
000ee7 940e 1f37 	CALL __LOADLOCR6
000ee9 96a5      	ADIW R28,37
000eea 9508      	RET
                 ;    2191 }
                 ;    2192 
                 ;    2193 #ifdef _DEBUG_ON_
                 ;    2194 // Function to display all files and folders in the root directory, 
                 ;    2195 // with the size of the file in bytes within the [brakets]
                 ;    2196 void read_directory(void)
                 ;    2197 {
                 ;    2198 	unsigned char valid_flag, attribute_temp;
                 ;    2199 	unsigned int c, n, d, m, dir_clus;
                 ;    2200 	unsigned long calc, calc_clus, dir_addr;
                 ;    2201 	
                 ;    2202 	if (_FF_DIR_ADDR != _FF_ROOT_ADDR)
                 ;    2203 	{
                 ;    2204 		dir_clus = addr_to_clust(_FF_DIR_ADDR);
                 ;    2205 		if (dir_clus == 0)
                 ;    2206 			return;
                 ;    2207 	}
                 ;    2208 
                 ;    2209 	printf("\r\nFile Listing for:  ROOT\\");
                 ;    2210 	for (d=0; d<_FF_PATH_LENGTH; d++)
                 ;    2211 	{
                 ;    2212 		if (_FF_FULL_PATH[d])
                 ;    2213 			putchar(_FF_FULL_PATH[d]);
                 ;    2214 		else
                 ;    2215 			break;
                 ;    2216 	}
                 ;    2217 	
                 ;    2218     
                 ;    2219     dir_addr = _FF_DIR_ADDR;
                 ;    2220 	d = 0;
                 ;    2221 	m = 0;
                 ;    2222 	while (d<BPB_RootEntCnt)
                 ;    2223 	{
                 ;    2224     	if (_FF_read(dir_addr+(m*0x200))==0)
                 ;    2225     		break;
                 ;    2226 		for (n=0; n<16; n++)
                 ;    2227 		{
                 ;    2228 			for (c=0; c<11; c++)
                 ;    2229 			{
                 ;    2230 				if (_FF_buff[(n*0x20)]==0)
                 ;    2231 				{
                 ;    2232 					n=16;
                 ;    2233 					d=BPB_RootEntCnt;
                 ;    2234 					valid_flag = 0;
                 ;    2235 					break;
                 ;    2236 				}
                 ;    2237 				valid_flag = 1;
                 ;    2238 				if (valid_file_char(_FF_buff[(n*0x20)+c]))
                 ;    2239 				{
                 ;    2240 					valid_flag = 0;
                 ;    2241 					break;
                 ;    2242 				}
                 ;    2243 		    }   
                 ;    2244 		    if (valid_flag)
                 ;    2245 	  		{
                 ;    2246 		  		calc = (n * 0x20) + 0xB;
                 ;    2247 		  		attribute_temp = _FF_buff[calc];
                 ;    2248 		  		putchar('\n');
                 ;    2249 				putchar('\r');
                 ;    2250 				c = (n * 0x20);
                 ;    2251 			  	calc = ((long) _FF_buff[c+0x1F] << 24) | ((long) _FF_buff[c+0x1E] << 16) |
                 ;    2252 			  			((long) _FF_buff[c+0x1D] << 8) | ((long) _FF_buff[c+0x1C]);
                 ;    2253 			  	calc_clus = ((int) _FF_buff[c+0x1B] << 8) | (int) _FF_buff[c+0x1A];
                 ;    2254 				if (attribute_temp & 0x10)
                 ;    2255 					printf("  [");
                 ;    2256 				else
                 ;    2257 			  		printf("                [%ld] bytes      (%X)\r  ", calc, calc_clus);		  		
                 ;    2258 				for (c=0; c<8; c++)
                 ;    2259 				{
                 ;    2260 					calc = (n * 0x20) + c;
                 ;    2261 					if (_FF_buff[calc]==0x20)
                 ;    2262 						break;
                 ;    2263 					putchar(_FF_buff[calc]);
                 ;    2264 				}
                 ;    2265 				if (attribute_temp & 0x10)
                 ;    2266 				{
                 ;    2267 					printf("]      (%X)", calc_clus);
                 ;    2268 				}
                 ;    2269 				else
                 ;    2270 				{
                 ;    2271 					putchar('.');
                 ;    2272 					for (c=8; c<11; c++)
                 ;    2273 					{
                 ;    2274 						calc = (n * 0x20) + c;
                 ;    2275 						if (_FF_buff[calc]==0x20)
                 ;    2276 							break;
                 ;    2277 						putchar(_FF_buff[calc]);
                 ;    2278 					}
                 ;    2279 				}
                 ;    2280 		  	}
                 ;    2281 		  	d++;		  		
                 ;    2282 		}
                 ;    2283 		m++;
                 ;    2284 		if (_FF_ROOT_ADDR!=_FF_DIR_ADDR)
                 ;    2285 		{
                 ;    2286 		   	if (m==BPB_SecPerClus)
                 ;    2287 		   	{
                 ;    2288 
                 ;    2289 				m = next_cluster(dir_clus, SINGLE);
                 ;    2290 				if (m != EOF)
                 ;    2291 				{	// another dir cluster exists
                 ;    2292 					dir_addr = clust_to_addr(m);
                 ;    2293 					dir_clus = m;
                 ;    2294 					d = 0;
                 ;    2295 					m = 0;
                 ;    2296 				}
                 ;    2297 				else
                 ;    2298 					break;
                 ;    2299 		   		
                 ;    2300 		   	}
                 ;    2301 		}
                 ;    2302 	}
                 ;    2303 	putchar('\n');
                 ;    2304 	putchar('\r');	
                 ;    2305 } 
                 ;    2306 
                 ;    2307 void GetVolID(void)
                 ;    2308 {
                 ;    2309 	printf("\r\n  Volume Serial:  [0x%lX]", BS_VolSerial);
                 ;    2310 	printf("\r\n  Volume Label:  [%s]\r\n", BS_VolLab);
                 ;    2311 }
                 ;    2312 #endif
                 ;    2313 
                 ;    2314 // Convert a cluster number into a read address
                 ;    2315 unsigned long clust_to_addr(unsigned int clust_no)
                 ;    2316 {
                 _clust_to_addr:
                 ;    2317 	unsigned long clust_addr;
                 ;    2318 	
                 ;    2319 	FirstSectorofCluster = ((clust_no - 2) * (long) BPB_SecPerClus) + (long) FirstDataSector;
000eeb 9724      	SBIW R28,4
                 ;	clust_no -> Y+4
                 ;	clust_addr -> Y+0
000eec 81ac      	LDD  R26,Y+4
000eed 81bd      	LDD  R27,Y+4+1
000eee 9712      	SBIW R26,2
000eef 91e0 0b98 	LDS  R30,_BPB_SecPerClus
000ef1 27ff      	CLR  R31
000ef2 2766      	CLR  R22
000ef3 2777      	CLR  R23
000ef4 2788      	CLR  R24
000ef5 2799      	CLR  R25
000ef6 940e 1e59 	CALL __MULD12
000ef8 01df      	MOVW R26,R30
000ef9 01cb      	MOVW R24,R22
000efa 91e0 0bcd 	LDS  R30,_FirstDataSector
000efc 91f0 0bce 	LDS  R31,_FirstDataSector+1
000efe 2766      	CLR  R22
000eff 2777      	CLR  R23
000f00 940e 1dd6 	CALL __ADDD12
000f02 93e0 0bcf 	STS  _FirstSectorofCluster,R30
000f04 93f0 0bd0 	STS  _FirstSectorofCluster+1,R31
000f06 9360 0bd1 	STS  _FirstSectorofCluster+2,R22
000f08 9370 0bd2 	STS  _FirstSectorofCluster+3,R23
                 ;    2320 	clust_addr = (long) FirstSectorofCluster * (long) BPB_BytsPerSec + _FF_PART_ADDR;
000f0a 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000f0c 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000f0e 2766      	CLR  R22
000f0f 2777      	CLR  R23
000f10 91a0 0bcf 	LDS  R26,_FirstSectorofCluster
000f12 91b0 0bd0 	LDS  R27,_FirstSectorofCluster+1
000f14 9180 0bd1 	LDS  R24,_FirstSectorofCluster+2
000f16 9190 0bd2 	LDS  R25,_FirstSectorofCluster+3
000f18 940e 1e59 	CALL __MULD12
000f1a 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
000f1c 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
000f1e 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
000f20 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
000f22 940e 1dd6 	CALL __ADDD12
000f24 83e8
000f25 83f9
000f26 836a
000f27 837b      	__PUTD1S 0
                 ;    2321 
                 ;    2322 	return (clust_addr);
000f28 9626      	ADIW R28,6
000f29 9508      	RET
                 ;    2323 }
                 ;    2324 
                 ;    2325 // Converts an address into a cluster number
                 ;    2326 unsigned int addr_to_clust(unsigned long clus_addr)
                 ;    2327 {
                 _addr_to_clust:
                 ;    2328 	if (clus_addr <= _FF_PART_ADDR)
000f2a 91e0 0bb5 	LDS  R30,__FF_PART_ADDR
000f2c 91f0 0bb6 	LDS  R31,__FF_PART_ADDR+1
000f2e 9160 0bb7 	LDS  R22,__FF_PART_ADDR+2
000f30 9170 0bb8 	LDS  R23,__FF_PART_ADDR+3
000f32 81a8
000f33 81b9
000f34 818a
000f35 819b      	__GETD2S 0
000f36 940e 1f26 	CALL __CPD12
000f38 f018      	BRLO _0x18B
                 ;    2329 		return (0);
000f39 e0e0      	LDI  R30,LOW(0)
000f3a e0f0      	LDI  R31,HIGH(0)
000f3b c470      	RJMP _0x41E
                 ;    2330 	clus_addr -= _FF_PART_ADDR;
                 _0x18B:
000f3c 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
000f3e 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
000f40 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
000f42 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
000f44 81e8
000f45 81f9
000f46 816a
000f47 817b      	__GETD1S 0
000f48 940e 1de0 	CALL __SUBD12
000f4a 83e8
000f4b 83f9
000f4c 836a
000f4d 837b      	__PUTD1S 0
                 ;    2331 	clus_addr /= BPB_BytsPerSec;
000f4e 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000f50 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000f52 81a8
000f53 81b9
000f54 818a
000f55 819b      	__GETD2S 0
000f56 2766      	CLR  R22
000f57 2777      	CLR  R23
000f58 940e 1e71 	CALL __DIVD21U
000f5a 83e8
000f5b 83f9
000f5c 836a
000f5d 837b      	__PUTD1S 0
                 ;    2332 	if (clus_addr <= (unsigned long) FirstDataSector)
000f5e 91e0 0bcd 	LDS  R30,_FirstDataSector
000f60 91f0 0bce 	LDS  R31,_FirstDataSector+1
000f62 2766      	CLR  R22
000f63 2777      	CLR  R23
000f64 81a8
000f65 81b9
000f66 818a
000f67 819b      	__GETD2S 0
000f68 940e 1f26 	CALL __CPD12
000f6a f018      	BRLO _0x18C
                 ;    2333 		return (0);
000f6b e0e0      	LDI  R30,LOW(0)
000f6c e0f0      	LDI  R31,HIGH(0)
000f6d c43e      	RJMP _0x41E
                 ;    2334 	clus_addr -= FirstDataSector;
                 _0x18C:
000f6e 91e0 0bcd 	LDS  R30,_FirstDataSector
000f70 91f0 0bce 	LDS  R31,_FirstDataSector+1
000f72 81a8
000f73 81b9
000f74 818a
000f75 819b      	__GETD2S 0
000f76 2766      	CLR  R22
000f77 2777      	CLR  R23
000f78 940e 1de5 	CALL __SUBD21
000f7a 83a8
000f7b 83b9
000f7c 838a
000f7d 839b      	__PUTD2S 0
                 ;    2335 	clus_addr /= BPB_SecPerClus;
000f7e 91e0 0b98 	LDS  R30,_BPB_SecPerClus
000f80 81a8
000f81 81b9
000f82 818a
000f83 819b      	__GETD2S 0
000f84 27ff      	CLR  R31
000f85 2766      	CLR  R22
000f86 2777      	CLR  R23
000f87 940e 1e71 	CALL __DIVD21U
000f89 83e8
000f8a 83f9
000f8b 836a
000f8c 837b      	__PUTD1S 0
                 ;    2336 	clus_addr += 2;
000f8d 5fee
000f8e 4fff
000f8f 4f6f
000f90 4f7f      	__ADDD1N 2
000f91 83e8
000f92 83f9
000f93 836a
000f94 837b      	__PUTD1S 0
                 ;    2337 	if (clus_addr > 0xFFFF)
000f95 81a8
000f96 81b9
000f97 818a
000f98 819b      	__GETD2S 0
000f99 30a0
000f9a e0e0
000f9b 07be
000f9c e0e1
000f9d 078e
000f9e e0e0
000f9f 079e      	__CPD2N 0x10000
000fa0 f018      	BRLO _0x18D
                 ;    2338 		return (0);
000fa1 e0e0      	LDI  R30,LOW(0)
000fa2 e0f0      	LDI  R31,HIGH(0)
000fa3 c408      	RJMP _0x41E
                 ;    2339 	
                 ;    2340 	return ((int) clus_addr);	
                 _0x18D:
000fa4 81e8      	LD   R30,Y
000fa5 81f9      	LDD  R31,Y+1
000fa6 c405      	RJMP _0x41E
                 ;    2341 }
                 ;    2342 
                 ;    2343 // Find the cluster that the current cluster is pointing to
                 ;    2344 unsigned int next_cluster(unsigned int current_cluster, unsigned char mode)
                 ;    2345 {
                 _next_cluster:
                 ;    2346 	unsigned int calc_sec, calc_offset, calc_remainder, next_clust;
                 ;    2347 	unsigned long addr_temp;
                 ;    2348 	
                 ;    2349 	if (current_cluster<=1)		// If cluster is 0 or 1, its the wrong cluster
000fa7 9726      	SBIW R28,6
000fa8 940e 1f30 	CALL __SAVELOCR6
                 ;	current_cluster -> Y+13
                 ;	mode -> Y+12
                 ;	calc_sec -> R16,R17
                 ;	calc_offset -> R18,R19
                 ;	calc_remainder -> R20,R21
                 ;	next_clust -> Y+10
                 ;	addr_temp -> Y+6
000faa 85ad      	LDD  R26,Y+13
000fab 85be      	LDD  R27,Y+13+1
000fac 9712      	SBIW R26,2
000fad f418      	BRSH _0x18E
                 ;    2350 		return (EOF);
000fae efef      	LDI  R30,LOW(65535)
000faf efff      	LDI  R31,HIGH(65535)
000fb0 c0c7      	RJMP _0x422
                 ;    2351 		
                 ;    2352 	if (BPB_FATType == 0x36)		// if FAT16
                 _0x18E:
000fb1 91a0 0ba0 	LDS  R26,_BPB_FATType
000fb3 33a6      	CPI  R26,LOW(0x36)
000fb4 f011      	BREQ PC+3
000fb5 940c 1073 	JMP _0x18F
                 ;    2353 	{
                 ;    2354 		// FAT16 table address calculations
                 ;    2355 		calc_sec = current_cluster / (BPB_BytsPerSec / 2) + BPB_RsvdSecCnt;
000fb7 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000fb9 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000fbb 95f6      	LSR  R31
000fbc 95e7      	ROR  R30
000fbd 85ad      	LDD  R26,Y+13
000fbe 85be      	LDD  R27,Y+13+1
000fbf 940e 1e5e 	CALL __DIVW21U
000fc1 91a0 0b99 	LDS  R26,_BPB_RsvdSecCnt
000fc3 91b0 0b9a 	LDS  R27,_BPB_RsvdSecCnt+1
000fc5 0fea      	ADD  R30,R26
000fc6 1ffb      	ADC  R31,R27
000fc7 018f      	MOVW R16,R30
                 ;    2356 		calc_offset = 2 * (current_cluster % (BPB_BytsPerSec / 2));
000fc8 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000fca 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000fcc 95f6      	LSR  R31
000fcd 95e7      	ROR  R30
000fce 85ad      	LDD  R26,Y+13
000fcf 85be      	LDD  R27,Y+13+1
000fd0 940e 1e9c 	CALL __MODW21U
000fd2 0fee      	LSL  R30
000fd3 1fff      	ROL  R31
000fd4 019f      	MOVW R18,R30
                 ;    2357 	    
                 ;    2358 	 	addr_temp = _FF_PART_ADDR+(calc_sec*0x200);
000fd5 01f8      	MOVW R30,R16
000fd6 0fee      	LSL  R30
000fd7 1fff      	ROL  R31
000fd8 2ffe      	MOV  R31,R30
000fd9 e0e0      	LDI  R30,0
000fda 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
000fdc 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
000fde 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
000fe0 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
000fe2 2766      	CLR  R22
000fe3 2777      	CLR  R23
000fe4 940e 1dd6 	CALL __ADDD12
000fe6 83ee
000fe7 83ff
000fe8 8768
000fe9 8779      	__PUTD1S 6
                 ;    2359 		if (mode==SINGLE)
000fea 85ac      	LDD  R26,Y+12
000feb 30a1      	CPI  R26,LOW(0x1)
000fec f451      	BRNE _0x190
                 ;    2360 		{	// This is a single cluster lookup
                 ;    2361 			if (_FF_read(addr_temp)==0)
000fed 940e 1ed7 	CALL __PUTPARD1
000fef 940e 0b5e 	CALL __FF_read
000ff1 30e0      	CPI  R30,0
000ff2 f419      	BRNE _0x191
                 ;    2362 				return(EOF);
000ff3 efef      	LDI  R30,LOW(65535)
000ff4 efff      	LDI  R31,HIGH(65535)
000ff5 c082      	RJMP _0x422
                 ;    2363 		}
                 _0x191:
                 ;    2364 		else if ((mode==CHAIN) || (mode==END_CHAIN))
000ff6 c06a      	RJMP _0x192
                 _0x190:
000ff7 85ac      	LDD  R26,Y+12
000ff8 30a0      	CPI  R26,LOW(0x0)
000ff9 f019      	BREQ _0x194
000ffa 30a2      	CPI  R26,LOW(0x2)
000ffb f009      	BREQ _0x194
000ffc c064      	RJMP _0x193
                 _0x194:
                 ;    2365 		{	// Mupltiple clusters to lookup
                 ;    2366 			if (addr_temp!=_FF_buff_addr)
000ffd 91e0 0bd4 	LDS  R30,__FF_buff_addr
000fff 91f0 0bd5 	LDS  R31,__FF_buff_addr+1
001001 9160 0bd6 	LDS  R22,__FF_buff_addr+2
001003 9170 0bd7 	LDS  R23,__FF_buff_addr+3
001005 81ae
001006 81bf
001007 8588
001008 8599      	__GETD2S 6
001009 940e 1f26 	CALL __CPD12
00100b f411      	BRNE PC+3
00100c 940c 1061 	JMP _0x196
                 ;    2367 			{	// Is the address of lookup is different then the current buffere address
                 ;    2368 				#ifndef _READ_ONLY_
                 ;    2369 				if (_FF_buff_addr)	// if the buffer address is 0, don't write
00100e 940e 1f18 	CALL __CPD10
001010 f411      	BRNE PC+3
001011 940c 1054 	JMP _0x197
                 ;    2370 				{
                 ;    2371 					#ifdef _SECOND_FAT_ON_
                 ;    2372 						if (_FF_buff_addr < _FF_FAT2_ADDR)
001013 91e0 0bc5 	LDS  R30,__FF_FAT2_ADDR
001015 91f0 0bc6 	LDS  R31,__FF_FAT2_ADDR+1
001017 9160 0bc7 	LDS  R22,__FF_FAT2_ADDR+2
001019 9170 0bc8 	LDS  R23,__FF_FAT2_ADDR+3
00101b 91a0 0bd4 	LDS  R26,__FF_buff_addr
00101d 91b0 0bd5 	LDS  R27,__FF_buff_addr+1
00101f 9180 0bd6 	LDS  R24,__FF_buff_addr+2
001021 9190 0bd7 	LDS  R25,__FF_buff_addr+3
001023 940e 1f2b 	CALL __CPD21
001025 f4e8      	BRSH _0x198
                 ;    2373 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
001026 91a0 0bc1 	LDS  R26,__FF_FAT1_ADDR
001028 91b0 0bc2 	LDS  R27,__FF_FAT1_ADDR+1
00102a 9180 0bc3 	LDS  R24,__FF_FAT1_ADDR+2
00102c 9190 0bc4 	LDS  R25,__FF_FAT1_ADDR+3
00102e 940e 1de0 	CALL __SUBD12
001030 91a0 0bd4 	LDS  R26,__FF_buff_addr
001032 91b0 0bd5 	LDS  R27,__FF_buff_addr+1
001034 9180 0bd6 	LDS  R24,__FF_buff_addr+2
001036 9190 0bd7 	LDS  R25,__FF_buff_addr+3
001038 940e 1dd6 	CALL __ADDD12
00103a 940e 1ed7 	CALL __PUTPARD1
00103c 940e 0c05 	CALL __FF_write
00103e 30e0      	CPI  R30,0
00103f f419      	BRNE _0x199
                 ;    2374 								return(EOF);
001040 efef      	LDI  R30,LOW(65535)
001041 efff      	LDI  R31,HIGH(65535)
001042 c035      	RJMP _0x422
                 ;    2375 					#endif
                 ;    2376 					if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
                 _0x199:
                 _0x198:
001043 91e0 0bd4 	LDS  R30,__FF_buff_addr
001045 91f0 0bd5 	LDS  R31,__FF_buff_addr+1
001047 9160 0bd6 	LDS  R22,__FF_buff_addr+2
001049 9170 0bd7 	LDS  R23,__FF_buff_addr+3
00104b 940e 1ed7 	CALL __PUTPARD1
00104d 940e 0c05 	CALL __FF_write
00104f 30e0      	CPI  R30,0
001050 f419      	BRNE _0x19A
                 ;    2377 						return(EOF);
001051 efef      	LDI  R30,LOW(65535)
001052 efff      	LDI  R31,HIGH(65535)
001053 c024      	RJMP _0x422
                 ;    2378 				}
                 _0x19A:
                 ;    2379 				#endif
                 ;    2380 				if (_FF_read(addr_temp)==0)	// Read new table info
                 _0x197:
001054 81ee
001055 81ff
001056 8568
001057 8579      	__GETD1S 6
001058 940e 1ed7 	CALL __PUTPARD1
00105a 940e 0b5e 	CALL __FF_read
00105c 30e0      	CPI  R30,0
00105d f419      	BRNE _0x19B
                 ;    2381 					return(EOF);
00105e efef      	LDI  R30,LOW(65535)
00105f efff      	LDI  R31,HIGH(65535)
001060 c017      	RJMP _0x422
                 ;    2382 			}
                 _0x19B:
                 ;    2383 		}
                 _0x196:
                 ;    2384 		next_clust = ((int) _FF_buff[calc_offset+1] << 8) | _FF_buff[calc_offset];
                 _0x193:
                 _0x192:
001061 01f9      	MOVW R30,R18
001062 56ef
001063 4ff6      	__ADDW1MN __FF_buff,1
001064 81f0      	LD   R31,Z
001065 e0e0      	LDI  R30,LOW(0)
001066 010f      	MOVW R0,R30
001067 e9a0      	LDI  R26,LOW(__FF_buff)
001068 e0b9      	LDI  R27,HIGH(__FF_buff)
001069 0fa2      	ADD  R26,R18
00106a 1fb3      	ADC  R27,R19
00106b 91ec      	LD   R30,X
00106c 01d0      	MOVW R26,R0
00106d e0f0      	LDI  R31,0
00106e 2bea      	OR   R30,R26
00106f 2bfb      	OR   R31,R27
001070 87ea      	STD  Y+10,R30
001071 87fb      	STD  Y+10+1,R31
                 ;    2385 	}
                 ;    2386 	#ifdef _FAT12_ON_
                 ;    2387 	else if (BPB_FATType == 0x32)	// if FAT12
                 ;    2388 	{
                 ;    2389 		// FAT12 table address calculations
                 ;    2390 		calc_offset = (current_cluster * 3) / 2;
                 ;    2391 		calc_remainder = (current_cluster * 3) % 2;
                 ;    2392 		calc_sec = (calc_offset / BPB_BytsPerSec) + BPB_RsvdSecCnt;
                 ;    2393 		calc_offset %= BPB_BytsPerSec;
                 ;    2394 
                 ;    2395 	 	addr_temp = _FF_PART_ADDR+(calc_sec*BPB_BytsPerSec);
                 ;    2396 		if (mode==SINGLE)
                 ;    2397 		{	// This is a single cluster lookup
                 ;    2398 			if (_FF_read(addr_temp)==0)
                 ;    2399 				return(EOF);
                 ;    2400 		}
                 ;    2401 		else if ((mode==CHAIN) || (mode==END_CHAIN))
                 ;    2402 		{	// Mupltiple clusters to lookup
                 ;    2403 			if (addr_temp!=_FF_buff_addr)
                 ;    2404 			{	// Is the address of lookup is different then the current buffere address
                 ;    2405 				#ifndef _READ_ONLY_
                 ;    2406 				if (_FF_buff_addr)	// if the buffer address is 0, don't write
                 ;    2407 				{
                 ;    2408 					#ifdef _SECOND_FAT_ON_
                 ;    2409 						if (_FF_buff_addr < _FF_FAT2_ADDR)
                 ;    2410 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2411 								return(EOF);
                 ;    2412 					#endif
                 ;    2413 					if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
                 ;    2414 						return(EOF);
                 ;    2415 				}
                 ;    2416 				#endif
                 ;    2417 				if (_FF_read(addr_temp)==0)	// Read new table info
                 ;    2418 					return(EOF);
                 ;    2419 			}
                 ;    2420 		}
                 ;    2421 		next_clust = _FF_buff[calc_offset];
                 ;    2422 		if (calc_offset == (BPB_BytsPerSec-1))
                 ;    2423 		{	// Is the FAT12 record accross more than one sector?
                 ;    2424 			addr_temp = _FF_PART_ADDR+((calc_sec+1)*0x200);
                 ;    2425 			if ((mode==CHAIN) || (mode==END_CHAIN))
                 ;    2426 			{	// multiple chain lookup
                 ;    2427 				#ifndef _READ_ONLY_
                 ;    2428 					#ifdef _SECOND_FAT_ON_
                 ;    2429 						if (_FF_buff_addr < _FF_FAT2_ADDR)
                 ;    2430 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2431 								return(EOF);
                 ;    2432 					#endif
                 ;    2433 				if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
                 ;    2434 					return(EOF);
                 ;    2435 				#endif
                 ;    2436 				_FF_buff_addr = addr_temp;		// Save new buffer address
                 ;    2437 			}
                 ;    2438 			if (_FF_read(addr_temp)==0)
                 ;    2439 				return(EOF);
                 ;    2440 			next_clust |= ((int) _FF_buff[0] << 8);
                 ;    2441 		}
                 ;    2442 		else
                 ;    2443 			next_clust |= ((int) _FF_buff[calc_offset+1] << 8);
                 ;    2444 
                 ;    2445 		if (calc_remainder)
                 ;    2446 			next_clust >>= 4;
                 ;    2447 		else
                 ;    2448 			next_clust &= 0x0FFF;
                 ;    2449 			
                 ;    2450 		if (next_clust >= 0xFF8)
                 ;    2451 			next_clust |= 0xF000;			
                 ;    2452 	}
                 ;    2453 	#endif
                 ;    2454 	else		// not FAT12 or FAT16, return 0
001072 c003      	RJMP _0x19C
                 _0x18F:
                 ;    2455 		return (EOF);
001073 efef      	LDI  R30,LOW(65535)
001074 efff      	LDI  R31,HIGH(65535)
001075 c002      	RJMP _0x422
                 ;    2456 	return (next_clust);
                 _0x19C:
001076 85ea      	LDD  R30,Y+10
001077 85fb      	LDD  R31,Y+10+1
                 _0x422:
001078 940e 1f37 	CALL __LOADLOCR6
00107a 962f      	ADIW R28,15
00107b 9508      	RET
                 ;    2457 }
                 ;    2458 
                 ;    2459 // Convert a constant string file name into the proper 8.3 FAT format
                 ;    2460 unsigned char *file_name_conversion(unsigned char *current_file)
                 ;    2461 {
                 _file_name_conversion:
                 ;    2462 	unsigned char n, c;
                 ;    2463 		
                 ;    2464 	c = 0;
00107c 931a      	ST   -Y,R17
00107d 930a      	ST   -Y,R16
                 ;	*current_file -> Y+2
                 ;	n -> R16
                 ;	c -> R17
00107e e010      	LDI  R17,LOW(0)
                 ;    2465 	
                 ;    2466 	for (n=0; n<14; n++)
00107f e000      	LDI  R16,LOW(0)
                 _0x19E:
001080 300e      	CPI  R16,14
001081 f010      	BRLO PC+3
001082 940c 10db 	JMP _0x19F
                 ;    2467 	{
                 ;    2468 		if (valid_file_char(current_file[n])==0)
001084 2fe0      	MOV  R30,R16
001085 81aa      	LDD  R26,Y+2
001086 81bb      	LDD  R27,Y+2+1
001087 e0f0      	LDI  R31,0
001088 0fae      	ADD  R26,R30
001089 1fbf      	ADC  R27,R31
00108a 91ec      	LD   R30,X
00108b 93ea      	ST   -Y,R30
00108c 940e 0c94 	CALL _valid_file_char
00108e 9730      	SBIW R30,0
00108f f4a9      	BRNE _0x1A0
                 ;    2469 			// If the character is valid, save in uppercase to file name buffer
                 ;    2470 			FILENAME[c++] = toupper(current_file[n]);
001090 2fe1      	MOV  R30,R17
001091 5f1f      	SUBI R17,-1
001092 e0f0      	LDI  R31,0
001093 5aef      	SUBI R30,LOW(-_FILENAME)
001094 4ff3      	SBCI R31,HIGH(-_FILENAME)
001095 93ff      	PUSH R31
001096 93ef      	PUSH R30
001097 2fe0      	MOV  R30,R16
001098 81aa      	LDD  R26,Y+2
001099 81bb      	LDD  R27,Y+2+1
00109a e0f0      	LDI  R31,0
00109b 0fae      	ADD  R26,R30
00109c 1fbf      	ADC  R27,R31
00109d 91ec      	LD   R30,X
00109e 93ea      	ST   -Y,R30
00109f 940e 1dc3 	CALL _toupper
0010a1 91af      	POP  R26
0010a2 91bf      	POP  R27
0010a3 93ec      	ST   X,R30
                 ;    2471 		else if (current_file[n]=='.')
0010a4 c032      	RJMP _0x1A1
                 _0x1A0:
0010a5 2fe0      	MOV  R30,R16
0010a6 81aa      	LDD  R26,Y+2
0010a7 81bb      	LDD  R27,Y+2+1
0010a8 e0f0      	LDI  R31,0
0010a9 0fae      	ADD  R26,R30
0010aa 1fbf      	ADC  R27,R31
0010ab 91ac      	LD   R26,X
0010ac 32ae      	CPI  R26,LOW(0x2E)
0010ad f461      	BRNE _0x1A2
                 ;    2472 			// If it is a period, back fill buffer with [spaces], till 8 characters deep
                 ;    2473 			while (c<8)
                 _0x1A3:
0010ae 3018      	CPI  R17,8
0010af f448      	BRSH _0x1A5
                 ;    2474 				FILENAME[c++] = 0x20;
0010b0 2fe1      	MOV  R30,R17
0010b1 5f1f      	SUBI R17,-1
0010b2 e0f0      	LDI  R31,0
0010b3 5aef      	SUBI R30,LOW(-_FILENAME)
0010b4 4ff3      	SBCI R31,HIGH(-_FILENAME)
0010b5 01df      	MOVW R26,R30
0010b6 e2e0      	LDI  R30,LOW(32)
0010b7 93ec      	ST   X,R30
                 ;    2475 		else if (current_file[n]==0)
0010b8 cff5      	RJMP _0x1A3
                 _0x1A5:
0010b9 c01d      	RJMP _0x1A6
                 _0x1A2:
0010ba 2fe0      	MOV  R30,R16
0010bb 81aa      	LDD  R26,Y+2
0010bc 81bb      	LDD  R27,Y+2+1
0010bd e0f0      	LDI  R31,0
0010be 0fae      	ADD  R26,R30
0010bf 1fbf      	ADC  R27,R31
0010c0 91ec      	LD   R30,X
0010c1 30e0      	CPI  R30,0
0010c2 f461      	BRNE _0x1A7
                 ;    2476 		{	// If it is NULL, back fill buffer with [spaces], till 11 characters deep
                 ;    2477 			while (c<11)
                 _0x1A8:
0010c3 301b      	CPI  R17,11
0010c4 f448      	BRSH _0x1AA
                 ;    2478 				FILENAME[c++] = 0x20;
0010c5 2fe1      	MOV  R30,R17
0010c6 5f1f      	SUBI R17,-1
0010c7 e0f0      	LDI  R31,0
0010c8 5aef      	SUBI R30,LOW(-_FILENAME)
0010c9 4ff3      	SBCI R31,HIGH(-_FILENAME)
0010ca 01df      	MOVW R26,R30
0010cb e2e0      	LDI  R30,LOW(32)
0010cc 93ec      	ST   X,R30
                 ;    2479 			break;
0010cd cff5      	RJMP _0x1A8
                 _0x1AA:
0010ce c00c      	RJMP _0x19F
                 ;    2480 		}
                 ;    2481 		else
                 _0x1A7:
                 ;    2482 		{
                 ;    2483 			_FF_error = NAME_ERR;
0010cf e0e5      	LDI  R30,LOW(5)
0010d0 93e0 0bd3 	STS  __FF_error,R30
                 ;    2484 			return (0);
0010d2 e0e0      	LDI  R30,LOW(0)
0010d3 e0f0      	LDI  R31,HIGH(0)
0010d4 8119      	LDD  R17,Y+1
0010d5 8108      	LDD  R16,Y+0
0010d6 c2d5      	RJMP _0x41E
                 ;    2485 		}
                 _0x1A6:
                 _0x1A1:
                 ;    2486 		if (c>=11)
0010d7 301b      	CPI  R17,11
0010d8 f410      	BRSH _0x19F
                 ;    2487 			break;
                 ;    2488 	}
0010d9 5f0f      	SUBI R16,-1
0010da cfa5      	RJMP _0x19E
                 _0x19F:
                 ;    2489 	FILENAME[c] = 0;
0010db 2fa1      	MOV  R26,R17
0010dc e0b0      	LDI  R27,0
0010dd 5aaf      	SUBI R26,LOW(-_FILENAME)
0010de 4fb3      	SBCI R27,HIGH(-_FILENAME)
0010df e0e0      	LDI  R30,LOW(0)
0010e0 93ec      	ST   X,R30
                 ;    2490 	// Return the pointer of the filename
                 ;    2491 	return (FILENAME);		
0010e1 e5e1      	LDI  R30,LOW(_FILENAME)
0010e2 e0fc      	LDI  R31,HIGH(_FILENAME)
0010e3 8119      	LDD  R17,Y+1
0010e4 8108      	LDD  R16,Y+0
0010e5 c2c6      	RJMP _0x41E
                 ;    2492 }
                 ;    2493 
                 ;    2494 // Find the first cluster that is pointing to clus_no
                 ;    2495 unsigned int prev_cluster(unsigned int clus_no)
                 ;    2496 {
                 ;    2497 	unsigned char read_flag;
                 ;    2498 	unsigned int calc_temp, n, c, n_temp;
                 ;    2499 	unsigned long calc_clus, addr_temp;
                 ;    2500 	
                 ;    2501 	addr_temp = _FF_FAT1_ADDR;
                 ;	clus_no -> Y+17
                 ;	read_flag -> R16
                 ;	calc_temp -> R17,R18
                 ;	n -> R19,R20
                 ;	c -> Y+15
                 ;	n_temp -> Y+13
                 ;	calc_clus -> Y+9
                 ;	addr_temp -> Y+5
                 ;    2502 	c = 1;
                 ;    2503 	if ((clus_no==0) && (BPB_FATType==0x36))
                 ;    2504 	{
                 ;    2505 		if (clus_0_addr>addr_temp)
                 ;    2506 		{
                 ;    2507 			addr_temp = clus_0_addr;
                 ;    2508 			c = c_counter;
                 ;    2509 		}
                 ;    2510 	}
                 ;    2511 
                 ;    2512 	read_flag = 1;
                 ;    2513 	
                 ;    2514 	while (addr_temp<_FF_FAT2_ADDR)
                 ;    2515 	{
                 ;    2516 		if (BPB_FATType == 0x36)		// if FAT16
                 ;    2517 		{
                 ;    2518 			if (clus_no==0)
                 ;    2519 			{
                 ;    2520 				clus_0_addr = addr_temp;
                 ;    2521 				c_counter = c;
                 ;    2522 			}
                 ;    2523 			if (_FF_read(addr_temp)==0)		// Read error ==> break
                 ;    2524 				return(0);
                 ;    2525 			if (_FF_n_temp)
                 ;    2526 			{
                 ;    2527 				n_temp = _FF_n_temp;
                 ;    2528 				_FF_n_temp = 0;
                 ;    2529 			}
                 ;    2530 			else
                 ;    2531 				n_temp = 0;
                 ;    2532 			for (n=n_temp; n<(BPB_BytsPerSec/2); n++)
                 ;    2533 			{
                 ;    2534 				calc_clus = ((unsigned int) _FF_buff[(n*2)+1] << 8) | ((unsigned int) _FF_buff[n*2]);
                 ;    2535 				calc_temp = (unsigned long) n + (((unsigned long) BPB_BytsPerSec/2) * ((unsigned long) c - 1));
                 ;    2536 				if (calc_clus==clus_no)
                 ;    2537 				{
                 ;    2538 					if (calc_clus==0)
                 ;    2539 						_FF_n_temp = n;
                 ;    2540 					return(calc_temp);
                 ;    2541 				}
                 ;    2542 				else if (calc_temp > DataClusTot)
                 ;    2543 				{
                 ;    2544 					_FF_error = DISK_FULL;
                 ;    2545 					return (0);
                 ;    2546 				}
                 ;    2547 			}
                 ;    2548 			addr_temp += 0x200;
                 ;    2549 			c++;
                 ;    2550 		}
                 ;    2551 		#ifdef _FAT12_ON_
                 ;    2552 		else if (BPB_FATType == 0x32)	// if FAT12
                 ;    2553 		{
                 ;    2554 			if (read_flag)
                 ;    2555 			{
                 ;    2556 				if (_FF_read(addr_temp)==0)
                 ;    2557 					return (0);	// if the read fails return 0
                 ;    2558 				read_flag = 0;
                 ;    2559 			}
                 ;    2560 			calc_temp = ((unsigned long) c * 3) / 2;
                 ;    2561 			calc_temp %= BPB_BytsPerSec;
                 ;    2562 			calc_clus = _FF_buff[calc_temp++];
                 ;    2563 			if (calc_temp == BPB_BytsPerSec)
                 ;    2564 			{	// Is the FAT12 record accross a sector?
                 ;    2565 				addr_temp += 0x200;
                 ;    2566 				if (_FF_read(addr_temp)==0)
                 ;    2567 					return (0);
                 ;    2568 				calc_clus |= ((unsigned int) _FF_buff[0] << 8);
                 ;    2569 				calc_temp = 0;
                 ;    2570 			}
                 ;    2571 			else
                 ;    2572 				calc_clus |= ((unsigned int) _FF_buff[calc_temp++] << 8);
                 ;    2573                           	
                 ;    2574 			if (c % 2)
                 ;    2575 				calc_clus >>= 4;
                 ;    2576 			else
                 ;    2577 				calc_clus &= 0x0FFF;
                 ;    2578 			
                 ;    2579 			if (calc_clus == clus_no)
                 ;    2580 				return (c);
                 ;    2581 			else if (c > DataClusTot)
                 ;    2582 			{
                 ;    2583 				_FF_error = DISK_FULL;
                 ;    2584 				return (0);
                 ;    2585 			}
                 ;    2586 			if ((calc_temp == BPB_BytsPerSec) && (c % 2))
                 ;    2587 			{
                 ;    2588 				addr_temp += 0x200;
                 ;    2589 				read_flag = 1;
                 ;    2590 			}                                                           
                 ;    2591 			
                 ;    2592 			c++;			
                 ;    2593 		}
                 ;    2594 		#endif
                 ;    2595 		else
                 ;    2596 			return (0);
                 ;    2597 	}
                 ;    2598 	_FF_error = DISK_FULL;
                 ;    2599 	return (0);
                 ;    2600 }
                 ;    2601 
                 ;    2602 #ifndef _READ_ONLY_
                 ;    2603 // Update cluster table to point to new cluster
                 ;    2604 unsigned char write_clus_table(unsigned int current_cluster, unsigned int next_value, unsigned char mode)
                 ;    2605 {
                 _write_clus_table:
                 ;    2606 	unsigned long addr_temp;
                 ;    2607 	unsigned int calc_sec, calc_offset, calc_temp, calc_remainder;
                 ;    2608 	unsigned char nibble[3];
                 ;    2609 	
                 ;    2610 	if (current_cluster <=1)		// Should never be writing to cluster 0 or 1
0010e6 9729      	SBIW R28,9
0010e7 940e 1f30 	CALL __SAVELOCR6
                 ;	current_cluster -> Y+18
                 ;	next_value -> Y+16
                 ;	mode -> Y+15
                 ;	addr_temp -> Y+11
                 ;	calc_sec -> R16,R17
                 ;	calc_offset -> R18,R19
                 ;	calc_temp -> R20,R21
                 ;	calc_remainder -> Y+9
                 ;	nibble -> Y+6
0010e9 89aa      	LDD  R26,Y+18
0010ea 89bb      	LDD  R27,Y+18+1
0010eb 9712      	SBIW R26,2
0010ec f410      	BRSH _0x1C1
                 ;    2611 	{
                 ;    2612 		return (0);
0010ed e0e0      	LDI  R30,LOW(0)
0010ee c0f1      	RJMP _0x421
                 ;    2613 	}
                 ;    2614 	if (BPB_FATType == 0x36)		// if FAT16
                 _0x1C1:
0010ef 91a0 0ba0 	LDS  R26,_BPB_FATType
0010f1 33a6      	CPI  R26,LOW(0x36)
0010f2 f011      	BREQ PC+3
0010f3 940c 11dd 	JMP _0x1C2
                 ;    2615 	{
                 ;    2616 		calc_sec = current_cluster / (BPB_BytsPerSec / 2) + BPB_RsvdSecCnt;
0010f5 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0010f7 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0010f9 95f6      	LSR  R31
0010fa 95e7      	ROR  R30
0010fb 89aa      	LDD  R26,Y+18
0010fc 89bb      	LDD  R27,Y+18+1
0010fd 940e 1e5e 	CALL __DIVW21U
0010ff 91a0 0b99 	LDS  R26,_BPB_RsvdSecCnt
001101 91b0 0b9a 	LDS  R27,_BPB_RsvdSecCnt+1
001103 0fea      	ADD  R30,R26
001104 1ffb      	ADC  R31,R27
001105 018f      	MOVW R16,R30
                 ;    2617 		calc_offset = 2 * (current_cluster % (BPB_BytsPerSec / 2));
001106 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001108 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
00110a 95f6      	LSR  R31
00110b 95e7      	ROR  R30
00110c 89aa      	LDD  R26,Y+18
00110d 89bb      	LDD  R27,Y+18+1
00110e 940e 1e9c 	CALL __MODW21U
001110 0fee      	LSL  R30
001111 1fff      	ROL  R31
001112 019f      	MOVW R18,R30
                 ;    2618 		addr_temp = _FF_PART_ADDR + ((long) calc_sec*0x200);
001113 01f8      	MOVW R30,R16
001114 2766      	CLR  R22
001115 2777      	CLR  R23
001116 e0a0
001117 e0b2
001118 e080
001119 e090      	__GETD2N 0x200
00111a 940e 1e59 	CALL __MULD12
00111c 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
00111e 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
001120 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
001122 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
001124 940e 1dd6 	CALL __ADDD12
001126 87eb
001127 87fc
001128 876d
001129 877e      	__PUTD1S 11
                 ;    2619 		if (mode==SINGLE)
00112a 85af      	LDD  R26,Y+15
00112b 30a1      	CPI  R26,LOW(0x1)
00112c f449      	BRNE _0x1C3
                 ;    2620 		{	// Updating a single cluster (like writing or saving a file)
                 ;    2621 			if (_FF_read(addr_temp)==0)
00112d 940e 1ed7 	CALL __PUTPARD1
00112f 940e 0b5e 	CALL __FF_read
001131 30e0      	CPI  R30,0
001132 f411      	BRNE _0x1C4
                 ;    2622 				return(0);
001133 e0e0      	LDI  R30,LOW(0)
001134 c0ab      	RJMP _0x421
                 ;    2623 		}
                 _0x1C4:
                 ;    2624 		else if ((mode==CHAIN) || (mode==END_CHAIN))
001135 c067      	RJMP _0x1C5
                 _0x1C3:
001136 85af      	LDD  R26,Y+15
001137 30a0      	CPI  R26,LOW(0x0)
001138 f019      	BREQ _0x1C7
001139 30a2      	CPI  R26,LOW(0x2)
00113a f009      	BREQ _0x1C7
00113b c061      	RJMP _0x1C6
                 _0x1C7:
                 ;    2625 		{	// Multiple table access operation
                 ;    2626 			if (addr_temp!=_FF_buff_addr)
00113c 91e0 0bd4 	LDS  R30,__FF_buff_addr
00113e 91f0 0bd5 	LDS  R31,__FF_buff_addr+1
001140 9160 0bd6 	LDS  R22,__FF_buff_addr+2
001142 9170 0bd7 	LDS  R23,__FF_buff_addr+3
001144 85ab
001145 85bc
001146 858d
001147 859e      	__GETD2S 11
001148 940e 1f26 	CALL __CPD12
00114a f411      	BRNE PC+3
00114b 940c 119d 	JMP _0x1C9
                 ;    2627 			{	// if the desired address is already in the buffer => skip loading buffer
                 ;    2628 				if (_FF_buff_addr)	// if new table address, write buffered, and load new
00114d 940e 1f18 	CALL __CPD10
00114f f411      	BRNE PC+3
001150 940c 1191 	JMP _0x1CA
                 ;    2629 				{
                 ;    2630 					#ifdef _SECOND_FAT_ON_
                 ;    2631 						if (_FF_buff_addr < _FF_FAT2_ADDR)
001152 91e0 0bc5 	LDS  R30,__FF_FAT2_ADDR
001154 91f0 0bc6 	LDS  R31,__FF_FAT2_ADDR+1
001156 9160 0bc7 	LDS  R22,__FF_FAT2_ADDR+2
001158 9170 0bc8 	LDS  R23,__FF_FAT2_ADDR+3
00115a 91a0 0bd4 	LDS  R26,__FF_buff_addr
00115c 91b0 0bd5 	LDS  R27,__FF_buff_addr+1
00115e 9180 0bd6 	LDS  R24,__FF_buff_addr+2
001160 9190 0bd7 	LDS  R25,__FF_buff_addr+3
001162 940e 1f2b 	CALL __CPD21
001164 f4e0      	BRSH _0x1CB
                 ;    2632 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
001165 91a0 0bc1 	LDS  R26,__FF_FAT1_ADDR
001167 91b0 0bc2 	LDS  R27,__FF_FAT1_ADDR+1
001169 9180 0bc3 	LDS  R24,__FF_FAT1_ADDR+2
00116b 9190 0bc4 	LDS  R25,__FF_FAT1_ADDR+3
00116d 940e 1de0 	CALL __SUBD12
00116f 91a0 0bd4 	LDS  R26,__FF_buff_addr
001171 91b0 0bd5 	LDS  R27,__FF_buff_addr+1
001173 9180 0bd6 	LDS  R24,__FF_buff_addr+2
001175 9190 0bd7 	LDS  R25,__FF_buff_addr+3
001177 940e 1dd6 	CALL __ADDD12
001179 940e 1ed7 	CALL __PUTPARD1
00117b 940e 0c05 	CALL __FF_write
00117d 30e0      	CPI  R30,0
00117e f411      	BRNE _0x1CC
                 ;    2633 								return(0);
00117f e0e0      	LDI  R30,LOW(0)
001180 c05f      	RJMP _0x421
                 ;    2634 					#endif
                 ;    2635 					if (_FF_write(_FF_buff_addr)==0)
                 _0x1CC:
                 _0x1CB:
001181 91e0 0bd4 	LDS  R30,__FF_buff_addr
001183 91f0 0bd5 	LDS  R31,__FF_buff_addr+1
001185 9160 0bd6 	LDS  R22,__FF_buff_addr+2
001187 9170 0bd7 	LDS  R23,__FF_buff_addr+3
001189 940e 1ed7 	CALL __PUTPARD1
00118b 940e 0c05 	CALL __FF_write
00118d 30e0      	CPI  R30,0
00118e f411      	BRNE _0x1CD
                 ;    2636 						return(0);
00118f e0e0      	LDI  R30,LOW(0)
001190 c04f      	RJMP _0x421
                 ;    2637 				}
                 _0x1CD:
                 ;    2638 				if (_FF_read(addr_temp)==0)
                 _0x1CA:
001191 85eb
001192 85fc
001193 856d
001194 857e      	__GETD1S 11
001195 940e 1ed7 	CALL __PUTPARD1
001197 940e 0b5e 	CALL __FF_read
001199 30e0      	CPI  R30,0
00119a f411      	BRNE _0x1CE
                 ;    2639 					return(0);
00119b e0e0      	LDI  R30,LOW(0)
00119c c043      	RJMP _0x421
                 ;    2640 			}
                 _0x1CE:
                 ;    2641 		}
                 _0x1C9:
                 ;    2642 				
                 ;    2643 		_FF_buff[calc_offset+1] = (next_value >> 8); 
                 _0x1C6:
                 _0x1C5:
00119d 01f9      	MOVW R30,R18
00119e 56ef
00119f 4ff6      	__ADDW1MN __FF_buff,1
0011a0 01df      	MOVW R26,R30
0011a1 89e9      	LDD  R30,Y+17
0011a2 70f0      	ANDI R31,HIGH(0x0)
0011a3 93ec      	ST   X,R30
                 ;    2644 		_FF_buff[calc_offset] = (next_value & 0xFF);
0011a4 01d9      	MOVW R26,R18
0011a5 57a0      	SUBI R26,LOW(-__FF_buff)
0011a6 4fb6      	SBCI R27,HIGH(-__FF_buff)
0011a7 89e8      	LDD  R30,Y+16
0011a8 89f9      	LDD  R31,Y+16+1
0011a9 70f0      	ANDI R31,HIGH(0xFF)
0011aa 93ec      	ST   X,R30
                 ;    2645 		if ((mode==SINGLE) || (mode==END_CHAIN))
0011ab 85af      	LDD  R26,Y+15
0011ac 30a1      	CPI  R26,LOW(0x1)
0011ad f011      	BREQ _0x1D0
0011ae 30a2      	CPI  R26,LOW(0x2)
0011af f561      	BRNE _0x1CF
                 _0x1D0:
                 ;    2646 		{
                 ;    2647 			#ifdef _SECOND_FAT_ON_
                 ;    2648 				if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
0011b0 91a0 0bc1 	LDS  R26,__FF_FAT1_ADDR
0011b2 91b0 0bc2 	LDS  R27,__FF_FAT1_ADDR+1
0011b4 9180 0bc3 	LDS  R24,__FF_FAT1_ADDR+2
0011b6 9190 0bc4 	LDS  R25,__FF_FAT1_ADDR+3
0011b8 91e0 0bc5 	LDS  R30,__FF_FAT2_ADDR
0011ba 91f0 0bc6 	LDS  R31,__FF_FAT2_ADDR+1
0011bc 9160 0bc7 	LDS  R22,__FF_FAT2_ADDR+2
0011be 9170 0bc8 	LDS  R23,__FF_FAT2_ADDR+3
0011c0 940e 1de0 	CALL __SUBD12
0011c2 85ab
0011c3 85bc
0011c4 858d
0011c5 859e      	__GETD2S 11
0011c6 940e 1dd6 	CALL __ADDD12
0011c8 940e 1ed7 	CALL __PUTPARD1
0011ca 940e 0c05 	CALL __FF_write
0011cc 30e0      	CPI  R30,0
0011cd f411      	BRNE _0x1D2
                 ;    2649 					return(0);
0011ce e0e0      	LDI  R30,LOW(0)
0011cf c010      	RJMP _0x421
                 ;    2650 			#endif
                 ;    2651 			if (_FF_write(addr_temp)==0)
                 _0x1D2:
0011d0 85eb
0011d1 85fc
0011d2 856d
0011d3 857e      	__GETD1S 11
0011d4 940e 1ed7 	CALL __PUTPARD1
0011d6 940e 0c05 	CALL __FF_write
0011d8 30e0      	CPI  R30,0
0011d9 f411      	BRNE _0x1D3
                 ;    2652 			{
                 ;    2653 				return(0);
0011da e0e0      	LDI  R30,LOW(0)
0011db c004      	RJMP _0x421
                 ;    2654 			}
                 ;    2655 		}
                 _0x1D3:
                 ;    2656 	}
                 _0x1CF:
                 ;    2657 	#ifdef _FAT12_ON_
                 ;    2658 		else if (BPB_FATType == 0x32)		// if FAT12
                 ;    2659 		{
                 ;    2660 			calc_offset = (current_cluster * 3) / 2;
                 ;    2661 			calc_remainder = (current_cluster * 3) % 2;
                 ;    2662 			calc_sec = calc_offset / BPB_BytsPerSec + BPB_RsvdSecCnt;
                 ;    2663 			calc_offset %= BPB_BytsPerSec;
                 ;    2664 			addr_temp = _FF_PART_ADDR + ((long) calc_sec * (long) BPB_BytsPerSec);
                 ;    2665 
                 ;    2666 			if (mode==SINGLE)
                 ;    2667 			{
                 ;    2668 				if (_FF_read(addr_temp)==0)
                 ;    2669 					return(0);
                 ;    2670  			}
                 ;    2671  			else if ((mode==CHAIN) || (mode==END_CHAIN))
                 ;    2672   			{
                 ;    2673 				if (addr_temp!=_FF_buff_addr)
                 ;    2674 				{
                 ;    2675 					if (_FF_buff_addr)
                 ;    2676 					{
                 ;    2677 					#ifdef _SECOND_FAT_ON_
                 ;    2678 						if (_FF_buff_addr < _FF_FAT2_ADDR)
                 ;    2679 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2680 								return(0);
                 ;    2681 					#endif
                 ;    2682 						if (_FF_write(_FF_buff_addr)==0)
                 ;    2683 							return(0);
                 ;    2684 					}
                 ;    2685 					if (_FF_read(addr_temp)==0)
                 ;    2686 						return(0);
                 ;    2687 				}
                 ;    2688 			}
                 ;    2689 			nibble[0] = next_value & 0x00F;
                 ;    2690 			nibble[1] = (next_value >> 4) & 0x00F;
                 ;    2691 			nibble[2] = (next_value >> 8) & 0x00F;
                 ;    2692     	
                 ;    2693 			if (calc_offset == (BPB_BytsPerSec-1))
                 ;    2694 			{	// Is the FAT12 record accross a sector?
                 ;    2695 				if (calc_remainder)
                 ;    2696 				{	// Record table uses 1 nibble of last byte
                 ;    2697 					calc_temp = _FF_buff[calc_offset] & 0x0F;	// Mask to add new value
                 ;    2698 					_FF_buff[calc_offset] = calc_temp | (nibble[0] << 4);	// store nibble in correct location
                 ;    2699 					#ifdef _SECOND_FAT_ON_
                 ;    2700 						if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2701 							return(0);
                 ;    2702 					#endif
                 ;    2703 					if (_FF_write(addr_temp)==0)
                 ;    2704 						return(0);
                 ;    2705 					addr_temp += BPB_BytsPerSec;
                 ;    2706 					if (_FF_read(addr_temp)==0)
                 ;    2707 						return(0);	// if the read fails return 0
                 ;    2708 					_FF_buff[0] = (nibble[2] << 4) | nibble[1];
                 ;    2709 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2710 					{
                 ;    2711 						#ifdef _SECOND_FAT_ON_
                 ;    2712 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2713 								return(0);
                 ;    2714 						#endif
                 ;    2715 						if (_FF_write(addr_temp)==0)
                 ;    2716 							return(0);
                 ;    2717 					}
                 ;    2718 				}
                 ;    2719 				else
                 ;    2720 				{	// Record table uses whole last byte
                 ;    2721 					_FF_buff[calc_offset] = (nibble[1] << 4) | nibble[0];
                 ;    2722 					#ifdef _SECOND_FAT_ON_
                 ;    2723 						if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2724 							return(0);
                 ;    2725 					#endif
                 ;    2726 					if (_FF_write(addr_temp)==0)
                 ;    2727 						return(0);
                 ;    2728 					addr_temp += BPB_BytsPerSec;
                 ;    2729 					if (_FF_read(addr_temp)==0)
                 ;    2730 						return(0);	// if the read fails return 0
                 ;    2731 					calc_temp = _FF_buff[0] & 0xF0;		// Mask to add new value
                 ;    2732 					_FF_buff[0] = calc_temp | nibble[2];	// store nibble in correct location
                 ;    2733 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2734 					{
                 ;    2735 						#ifdef _SECOND_FAT_ON_
                 ;    2736 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2737 								return(0);
                 ;    2738 						#endif
                 ;    2739 						if (_FF_write(addr_temp)==0)
                 ;    2740 							return(0);
                 ;    2741 					}
                 ;    2742 				}
                 ;    2743 			}
                 ;    2744 			else
                 ;    2745 			{
                 ;    2746 				if (calc_remainder)
                 ;    2747 				{	// Record table uses 1 nibble of current byte
                 ;    2748 					calc_temp = _FF_buff[calc_offset] & 0x0F;	// Mask to add new value
                 ;    2749 					_FF_buff[calc_offset] = calc_temp | (nibble[0] << 4);	// store nibble in correct location
                 ;    2750 					_FF_buff[calc_offset+1] = (nibble[2] << 4) | nibble[1];
                 ;    2751 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2752 					{
                 ;    2753 						#ifdef _SECOND_FAT_ON_
                 ;    2754 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2755 								return(0);
                 ;    2756 						#endif
                 ;    2757 						if (_FF_write(addr_temp)==0)
                 ;    2758 							return(0);
                 ;    2759 					}
                 ;    2760 				}
                 ;    2761 				else
                 ;    2762 				{	// Record table uses whole current byte
                 ;    2763 					_FF_buff[calc_offset] = (nibble[1] << 4) | nibble[0];
                 ;    2764 					calc_temp = _FF_buff[calc_offset+1] & 0xF0;		// Mask to add new value
                 ;    2765 					_FF_buff[calc_offset+1] = calc_temp | nibble[2];	// store nibble in correct location
                 ;    2766 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2767 					{
                 ;    2768 						#ifdef _SECOND_FAT_ON_
                 ;    2769 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2770 								return(0);
                 ;    2771 						#endif
                 ;    2772 						if (_FF_write(addr_temp)==0)
                 ;    2773 							return(0);
                 ;    2774 					}
                 ;    2775 				}
                 ;    2776 			}
                 ;    2777 		}
                 ;    2778 	#endif
                 ;    2779 	else		// not FAT12 or FAT16, return 0
0011dc c002      	RJMP _0x1D4
                 _0x1C2:
                 ;    2780 		return (0);
0011dd e0e0      	LDI  R30,LOW(0)
0011de c001      	RJMP _0x421
                 ;    2781 		
                 ;    2782 	return(1);	
                 _0x1D4:
0011df e0e1      	LDI  R30,LOW(1)
                 _0x421:
0011e0 940e 1f37 	CALL __LOADLOCR6
0011e2 9664      	ADIW R28,20
0011e3 9508      	RET
                 ;    2783 }
                 ;    2784 #endif
                 ;    2785 
                 ;    2786 #ifndef _READ_ONLY_
                 ;    2787 // Save new entry data to FAT entry
                 ;    2788 unsigned char append_toc(FILE *rp)
                 ;    2789 {
                 _append_toc:
                 ;    2790 	unsigned long file_data;
                 ;    2791 	unsigned char n;
                 ;    2792 	unsigned char *fp;
                 ;    2793 	unsigned int calc_temp, calc_date;
                 ;    2794 	
                 ;    2795 	if (rp==NULL)
0011e4 9726      	SBIW R28,6
0011e5 940e 1f31 	CALL __SAVELOCR5
                 ;	*rp -> Y+11
                 ;	file_data -> Y+7
                 ;	n -> R16
                 ;	*fp -> R17,R18
                 ;	calc_temp -> R19,R20
                 ;	calc_date -> Y+5
0011e7 85eb      	LDD  R30,Y+11
0011e8 85fc      	LDD  R31,Y+11+1
0011e9 9730      	SBIW R30,0
0011ea f411      	BRNE _0x1D5
                 ;    2796 		return (0);
0011eb e0e0      	LDI  R30,LOW(0)
0011ec c0c1      	RJMP _0x420
                 ;    2797 
                 ;    2798 	file_data = rp->length;
                 _0x1D5:
0011ed 85ab      	LDD  R26,Y+11
0011ee 85bc      	LDD  R27,Y+11+1
0011ef 5ea4      	SUBI R26,LOW(-540)
0011f0 4fbd      	SBCI R27,HIGH(-540)
0011f1 940e 1ec8 	CALL __GETD1P
0011f3 83ef
0011f4 87f8
0011f5 8769
0011f6 877a      	__PUTD1S 7
                 ;    2799 	if (_FF_read(rp->entry_sec_addr)==0)
0011f7 85eb      	LDD  R30,Y+11
0011f8 85fc      	LDD  R31,Y+11+1
0011f9 89a6
0011fa 89b7
0011fb 8d80
0011fc 8d91      	__GETD2Z 22
0011fd 940e 1edc 	CALL __PUTPARD2
0011ff 940e 0b5e 	CALL __FF_read
001201 30e0      	CPI  R30,0
001202 f411      	BRNE _0x1D6
                 ;    2800 		return (0);
001203 e0e0      	LDI  R30,LOW(0)
001204 c0a9      	RJMP _0x420
                 ;    2801 	
                 ;    2802 	// Update Starting Cluster 
                 ;    2803 	fp = &_FF_buff[rp->entry_offset+0x1a];
                 _0x1D6:
001205 85ab      	LDD  R26,Y+11
001206 85bc      	LDD  R27,Y+11+1
001207 965a      	ADIW R26,26
001208 940e 1ec4 	CALL __GETW1P
00120a 55e6
00120b 4ff6      	__ADDW1MN __FF_buff,26
00120c 2f1e
00120d 2f2f      	__PUTW1R 17,18
                 ;    2804 	*fp++ = rp->clus_start & 0xFF;
00120e 932f      	PUSH R18
00120f 931f      	PUSH R17
001210 5f1f
001211 4f2f      	__ADDWRN 17,18,1
001212 85ab      	LDD  R26,Y+11
001213 85bc      	LDD  R27,Y+11+1
001214 961c      	ADIW R26,12
001215 940e 1ec4 	CALL __GETW1P
001217 70f0      	ANDI R31,HIGH(0xFF)
001218 91af      	POP  R26
001219 91bf      	POP  R27
00121a 93ec      	ST   X,R30
                 ;    2805 	*fp++ = rp->clus_start >> 8;
00121b 932f      	PUSH R18
00121c 931f      	PUSH R17
00121d 5f1f
00121e 4f2f      	__ADDWRN 17,18,1
00121f 85ab      	LDD  R26,Y+11
001220 85bc      	LDD  R27,Y+11+1
001221 961c      	ADIW R26,12
001222 940e 1ec4 	CALL __GETW1P
001224 2fef      	MOV  R30,R31
001225 e0f0      	LDI  R31,0
001226 91af      	POP  R26
001227 91bf      	POP  R27
001228 93ec      	ST   X,R30
                 ;    2806 	
                 ;    2807 	// Update the File Size
                 ;    2808 	for (n=0; n<4; n++)
001229 e000      	LDI  R16,LOW(0)
                 _0x1D8:
00122a 3004      	CPI  R16,4
00122b f4d0      	BRSH _0x1D9
                 ;    2809 	{
                 ;    2810 		*fp = file_data & 0xFF;
00122c 81ef
00122d 85f8
00122e 8569
00122f 857a      	__GETD1S 7
001230 7fef
001231 70f0
001232 7060
001233 7070      	__ANDD1N 0xFF
001234 2fa1
001235 2fb2      	__GETW2R 17,18
001236 93ec      	ST   X,R30
                 ;    2811 		file_data >>= 8;
001237 81af
001238 85b8
001239 8589
00123a 859a      	__GETD2S 7
00123b e0e8      	LDI  R30,LOW(8)
00123c 940e 1e08 	CALL __LSRD12
00123e 83ef
00123f 87f8
001240 8769
001241 877a      	__PUTD1S 7
                 ;    2812 		fp++;
001242 5f1f
001243 4f2f      	__ADDWRN 17,18,1
                 ;    2813 	}
001244 5f0f      	SUBI R16,-1
001245 cfe4      	RJMP _0x1D8
                 _0x1D9:
                 ;    2814 	
                 ;    2815 	
                 ;    2816 	fp = &_FF_buff[rp->entry_offset+0x16];
001246 85ab      	LDD  R26,Y+11
001247 85bc      	LDD  R27,Y+11+1
001248 965a      	ADIW R26,26
001249 940e 1ec4 	CALL __GETW1P
00124b 55ea
00124c 4ff6      	__ADDW1MN __FF_buff,22
00124d 2f1e
00124e 2f2f      	__PUTW1R 17,18
                 ;    2817 	#ifdef _RTC_ON_ 	// Date/Time Stamp file w/ RTC
                 ;    2818 		rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
                 ;    2819 		calc_temp = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
                 ;    2820 		*fp++ = calc_temp&0x00FF;	// File create Time 
                 ;    2821 		*fp++ = (calc_temp&0xFF00) >> 8;
                 ;    2822 		calc_date = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
                 ;    2823 		*fp++ = calc_date&0x00FF;	// File create Date
                 ;    2824 		*fp++ = (calc_date&0xFF00) >> 8;
                 ;    2825 	#else		// Increment Date Code, no RTC used 
                 ;    2826 		file_data = 0;
00124f e0e0
001250 83ef
001251 87e8
001252 87e9
001253 87ea      	__CLRD1S 7
                 ;    2827 		for (n=0; n<4; n++)
001254 e000      	LDI  R16,LOW(0)
                 _0x1DB:
001255 3004      	CPI  R16,4
001256 f4f8      	BRSH _0x1DC
                 ;    2828 		{
                 ;    2829 			file_data <<= 8;
001257 81af
001258 85b8
001259 8589
00125a 859a      	__GETD2S 7
00125b e0e8      	LDI  R30,LOW(8)
00125c 940e 1dfc 	CALL __LSLD12
00125e 83ef
00125f 87f8
001260 8769
001261 877a      	__PUTD1S 7
                 ;    2830 			file_data |= *fp;
001262 2fa1
001263 2fb2      	__GETW2R 17,18
001264 91ec      	LD   R30,X
001265 81af
001266 85b8
001267 8589
001268 859a      	__GETD2S 7
001269 27ff      	CLR  R31
00126a 2766      	CLR  R22
00126b 2777      	CLR  R23
00126c 940e 1dea 	CALL __ORD12
00126e 83ef
00126f 87f8
001270 8769
001271 877a      	__PUTD1S 7
                 ;    2831 			fp--;
001272 5011
001273 4020      	__SUBWRN 17,18,1
                 ;    2832 		}
001274 5f0f      	SUBI R16,-1
001275 cfdf      	RJMP _0x1DB
                 _0x1DC:
                 ;    2833 		file_data++;
001276 81ef
001277 85f8
001278 8569
001279 857a      	__GETD1S 7
00127a 5fef
00127b 4fff
00127c 4f6f
00127d 4f7f      	__SUBD1N -1
00127e 83ef
00127f 87f8
001280 8769
001281 877a      	__PUTD1S 7
                 ;    2834 		for (n=0; n<4; n++)
001282 e000      	LDI  R16,LOW(0)
                 _0x1DE:
001283 3004      	CPI  R16,4
001284 f4d0      	BRSH _0x1DF
                 ;    2835 		{
                 ;    2836 			fp++;
001285 5f1f
001286 4f2f      	__ADDWRN 17,18,1
                 ;    2837 			*fp = file_data & 0xFF;
001287 81ef
001288 85f8
001289 8569
00128a 857a      	__GETD1S 7
00128b 7fef
00128c 70f0
00128d 7060
00128e 7070      	__ANDD1N 0xFF
00128f 2fa1
001290 2fb2      	__GETW2R 17,18
001291 93ec      	ST   X,R30
                 ;    2838 			file_data >>=8;
001292 81af
001293 85b8
001294 8589
001295 859a      	__GETD2S 7
001296 e0e8      	LDI  R30,LOW(8)
001297 940e 1e08 	CALL __LSRD12
001299 83ef
00129a 87f8
00129b 8769
00129c 877a      	__PUTD1S 7
                 ;    2839 		}
00129d 5f0f      	SUBI R16,-1
00129e cfe4      	RJMP _0x1DE
                 _0x1DF:
                 ;    2840 	#endif
                 ;    2841 	if (_FF_write(rp->entry_sec_addr)==0)
00129f 85eb      	LDD  R30,Y+11
0012a0 85fc      	LDD  R31,Y+11+1
0012a1 89a6
0012a2 89b7
0012a3 8d80
0012a4 8d91      	__GETD2Z 22
0012a5 940e 1edc 	CALL __PUTPARD2
0012a7 940e 0c05 	CALL __FF_write
0012a9 30e0      	CPI  R30,0
0012aa f411      	BRNE _0x1E0
                 ;    2842 		return(0);
0012ab e0e0      	LDI  R30,LOW(0)
0012ac c001      	RJMP _0x420
                 ;    2843 	
                 ;    2844 	return(1);
                 _0x1E0:
0012ad e0e1      	LDI  R30,LOW(1)
                 _0x420:
0012ae 940e 1f38 	CALL __LOADLOCR5
0012b0 962d      	ADIW R28,13
0012b1 9508      	RET
                 ;    2845 }
                 ;    2846 #endif
                 ;    2847 
                 ;    2848 #ifndef _READ_ONLY_
                 ;    2849 // Erase a chain of clusters (set table entries to 0 for clusters in chain)
                 ;    2850 unsigned char erase_clus_chain(unsigned int start_clus)
                 ;    2851 {
                 _erase_clus_chain:
                 ;    2852 	unsigned int clus_temp, clus_use;
                 ;    2853 	
                 ;    2854 	if (start_clus==0)
0012b2 940e 1f32 	CALL __SAVELOCR4
                 ;	start_clus -> Y+4
                 ;	clus_temp -> R16,R17
                 ;	clus_use -> R18,R19
0012b4 81ec      	LDD  R30,Y+4
0012b5 81fd      	LDD  R31,Y+4+1
0012b6 9730      	SBIW R30,0
0012b7 f411      	BRNE _0x1E1
                 ;    2855 		return (0);
0012b8 e0e0      	LDI  R30,LOW(0)
0012b9 c04c      	RJMP _0x41F
                 ;    2856 	clus_use = start_clus;
                 _0x1E1:
0012ba 812c
0012bb 813d      	__GETWRS 18,19,4
                 ;    2857 	_FF_buff_addr = 0;
0012bc e0e0      	LDI  R30,0
0012bd 93e0 0bd4 	STS  __FF_buff_addr,R30
0012bf 93e0 0bd5 	STS  __FF_buff_addr+1,R30
0012c1 93e0 0bd6 	STS  __FF_buff_addr+2,R30
0012c3 93e0 0bd7 	STS  __FF_buff_addr+3,R30
                 ;    2858 	while(clus_use <= 0xFFF8)
                 _0x1E2:
0012c5 3f29
0012c6 efef
0012c7 073e      	__CPWRN 18,19,65529
0012c8 f500      	BRSH _0x1E4
                 ;    2859 	{
                 ;    2860 		clus_temp = next_cluster(clus_use, CHAIN);
0012c9 933a      	ST   -Y,R19
0012ca 932a      	ST   -Y,R18
0012cb e0e0      	LDI  R30,LOW(0)
0012cc 93ea      	ST   -Y,R30
0012cd 940e 0fa7 	CALL _next_cluster
0012cf 018f      	MOVW R16,R30
                 ;    2861 		if ((clus_temp >= 0xFFF8) || (clus_temp == 0))
0012d0 3f08
0012d1 efef
0012d2 071e      	__CPWRN 16,17,65528
0012d3 f420      	BRSH _0x1E6
0012d4 2400      	CLR  R0
0012d5 1600      	CP   R0,R16
0012d6 0601      	CPC  R0,R17
0012d7 f409      	BRNE _0x1E5
                 _0x1E6:
                 ;    2862 			break;
0012d8 c010      	RJMP _0x1E4
                 ;    2863 		if (write_clus_table(clus_use, 0, CHAIN) == 0)
                 _0x1E5:
0012d9 933a      	ST   -Y,R19
0012da 932a      	ST   -Y,R18
0012db e0e0      	LDI  R30,LOW(0)
0012dc e0f0      	LDI  R31,HIGH(0)
0012dd 93fa      	ST   -Y,R31
0012de 93ea      	ST   -Y,R30
0012df 93ea      	ST   -Y,R30
0012e0 940e 10e6 	CALL _write_clus_table
0012e2 30e0      	CPI  R30,0
0012e3 f411      	BRNE _0x1E8
                 ;    2864 			return (0);
0012e4 e0e0      	LDI  R30,LOW(0)
0012e5 c020      	RJMP _0x41F
                 ;    2865 		clus_use = clus_temp;
                 _0x1E8:
0012e6 2f20
0012e7 2f31      	__MOVEWRR 18,19,16,17
                 ;    2866 	}
0012e8 cfdc      	RJMP _0x1E2
                 _0x1E4:
                 ;    2867 	if (write_clus_table(clus_use, 0, END_CHAIN) == 0)
0012e9 933a      	ST   -Y,R19
0012ea 932a      	ST   -Y,R18
0012eb e0e0      	LDI  R30,LOW(0)
0012ec e0f0      	LDI  R31,HIGH(0)
0012ed 93fa      	ST   -Y,R31
0012ee 93ea      	ST   -Y,R30
0012ef e0e2      	LDI  R30,LOW(2)
0012f0 93ea      	ST   -Y,R30
0012f1 940e 10e6 	CALL _write_clus_table
0012f3 30e0      	CPI  R30,0
0012f4 f411      	BRNE _0x1E9
                 ;    2868 		return (0);
0012f5 e0e0      	LDI  R30,LOW(0)
0012f6 c00f      	RJMP _0x41F
                 ;    2869 	clus_0_addr = 0;
                 _0x1E9:
0012f7 e0e0      	LDI  R30,0
0012f8 93e0 0be3 	STS  _clus_0_addr,R30
0012fa 93e0 0be4 	STS  _clus_0_addr+1,R30
0012fc 93e0 0be5 	STS  _clus_0_addr+2,R30
0012fe 93e0 0be6 	STS  _clus_0_addr+3,R30
                 ;    2870 	c_counter = 0;
001300 e0e0      	LDI  R30,0
001301 93e0 0beb 	STS  _c_counter,R30
001303 93e0 0bec 	STS  _c_counter+1,R30
                 ;    2871 	
                 ;    2872 	return (1);	
001305 e0e1      	LDI  R30,LOW(1)
                 _0x41F:
001306 940e 1f39 	CALL __LOADLOCR4
001308 9626      	ADIW R28,6
001309 9508      	RET
                 ;    2873 }
                 ;    2874 
                 ;    2875 // Quickformat of a card (erase cluster table and root directory
                 ;    2876 int fquickformat(void)
                 ;    2877 {
                 _fquickformat:
                 ;    2878 	long c;
                 ;    2879 	
                 ;    2880 	for (c=0; c<BPB_BytsPerSec; c++)
00130a 9724      	SBIW R28,4
                 ;	c -> Y+0
00130b e0e0
00130c 83e8
00130d 83e9
00130e 83ea
00130f 83eb      	__CLRD1S 0
                 _0x1EB:
001310 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001312 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001314 81a8
001315 81b9
001316 818a
001317 819b      	__GETD2S 0
001318 2766      	CLR  R22
001319 2777      	CLR  R23
00131a 940e 1f2b 	CALL __CPD21
00131c f4b4      	BRGE _0x1EC
                 ;    2881 		_FF_buff[c] = 0;
00131d 81e8
00131e 81f9
00131f 816a
001320 817b      	__GETD1S 0
001321 57e0      	SUBI R30,LOW(-__FF_buff)
001322 4ff6      	SBCI R31,HIGH(-__FF_buff)
001323 01df      	MOVW R26,R30
001324 e0e0      	LDI  R30,LOW(0)
001325 93ec      	ST   X,R30
                 ;    2882 	
                 ;    2883 	c = _FF_FAT1_ADDR + 0x200;
001326 81e8
001327 81f9
001328 816a
001329 817b      	__GETD1S 0
00132a 5fef
00132b 4fff
00132c 4f6f
00132d 4f7f      	__SUBD1N -1
00132e 83e8
00132f 83f9
001330 836a
001331 837b      	__PUTD1S 0
001332 cfdd      	RJMP _0x1EB
                 _0x1EC:
001333 91e0 0bc1 	LDS  R30,__FF_FAT1_ADDR
001335 91f0 0bc2 	LDS  R31,__FF_FAT1_ADDR+1
001337 9160 0bc3 	LDS  R22,__FF_FAT1_ADDR+2
001339 9170 0bc4 	LDS  R23,__FF_FAT1_ADDR+3
00133b 50e0
00133c 4ffe
00133d 4f6f
00133e 4f7f      	__ADDD1N 512
00133f 83e8
001340 83f9
001341 836a
001342 837b      	__PUTD1S 0
                 ;    2884 	while (c < (_FF_ROOT_ADDR + (0x400 * BPB_SecPerClus)))
                 _0x1ED:
001343 91e0 0b98 	LDS  R30,_BPB_SecPerClus
001345 e0a0      	LDI  R26,LOW(1024)
001346 e0b4      	LDI  R27,HIGH(1024)
001347 e0f0      	LDI  R31,0
001348 940e 1e54 	CALL __MULW12
00134a 91a0 0bb9 	LDS  R26,__FF_ROOT_ADDR
00134c 91b0 0bba 	LDS  R27,__FF_ROOT_ADDR+1
00134e 9180 0bbb 	LDS  R24,__FF_ROOT_ADDR+2
001350 9190 0bbc 	LDS  R25,__FF_ROOT_ADDR+3
001352 940e 1e27 	CALL __CWD1
001354 940e 1dd6 	CALL __ADDD12
001356 81a8
001357 81b9
001358 818a
001359 819b      	__GETD2S 0
00135a 940e 1f2b 	CALL __CPD21
00135c f4e8      	BRSH _0x1EF
                 ;    2885 	{
                 ;    2886 		if (_FF_write(c)==0)
00135d 81e8
00135e 81f9
00135f 816a
001360 817b      	__GETD1S 0
001361 940e 1ed7 	CALL __PUTPARD1
001363 940e 0c05 	CALL __FF_write
001365 30e0      	CPI  R30,0
001366 f431      	BRNE _0x1F0
                 ;    2887 		{
                 ;    2888 			_FF_error = WRITE_ERR;
001367 e0e3      	LDI  R30,LOW(3)
001368 93e0 0bd3 	STS  __FF_error,R30
                 ;    2889 			return (EOF);
00136a efef      	LDI  R30,LOW(65535)
00136b efff      	LDI  R31,HIGH(65535)
00136c c03f      	RJMP _0x41E
                 ;    2890 		}
                 ;    2891 		c += 0x200;
                 _0x1F0:
00136d 81e8
00136e 81f9
00136f 816a
001370 817b      	__GETD1S 0
001371 50e0
001372 4ffe
001373 4f6f
001374 4f7f      	__ADDD1N 512
001375 83e8
001376 83f9
001377 836a
001378 837b      	__PUTD1S 0
                 ;    2892 	}	
001379 cfc9      	RJMP _0x1ED
                 _0x1EF:
                 ;    2893 	_FF_buff[0] = 0xF8;
00137a efe8      	LDI  R30,LOW(248)
00137b 93e0 0990 	STS  __FF_buff,R30
                 ;    2894 	_FF_buff[1] = 0xFF;
00137d efef      	LDI  R30,LOW(255)
00137e 93e0 0991 	__PUTB1MN __FF_buff,1
                 ;    2895 	_FF_buff[2] = 0xFF;
001380 93e0 0992 	__PUTB1MN __FF_buff,2
                 ;    2896 	if (BPB_FATType == 0x36)
001382 91a0 0ba0 	LDS  R26,_BPB_FATType
001384 33a6      	CPI  R26,LOW(0x36)
001385 f411      	BRNE _0x1F1
                 ;    2897 		_FF_buff[3] = 0xFF;
001386 93e0 0993 	__PUTB1MN __FF_buff,3
                 ;    2898 	if ((_FF_write(_FF_FAT1_ADDR)==0) || (_FF_write(_FF_FAT2_ADDR)==0))
                 _0x1F1:
001388 91e0 0bc1 	LDS  R30,__FF_FAT1_ADDR
00138a 91f0 0bc2 	LDS  R31,__FF_FAT1_ADDR+1
00138c 9160 0bc3 	LDS  R22,__FF_FAT1_ADDR+2
00138e 9170 0bc4 	LDS  R23,__FF_FAT1_ADDR+3
001390 940e 1ed7 	CALL __PUTPARD1
001392 940e 0c05 	CALL __FF_write
001394 30e0      	CPI  R30,0
001395 f071      	BREQ _0x1F3
001396 91e0 0bc5 	LDS  R30,__FF_FAT2_ADDR
001398 91f0 0bc6 	LDS  R31,__FF_FAT2_ADDR+1
00139a 9160 0bc7 	LDS  R22,__FF_FAT2_ADDR+2
00139c 9170 0bc8 	LDS  R23,__FF_FAT2_ADDR+3
00139e 940e 1ed7 	CALL __PUTPARD1
0013a0 940e 0c05 	CALL __FF_write
0013a2 30e0      	CPI  R30,0
0013a3 f431      	BRNE _0x1F2
                 _0x1F3:
                 ;    2899 	{
                 ;    2900 		_FF_error = WRITE_ERR;
0013a4 e0e3      	LDI  R30,LOW(3)
0013a5 93e0 0bd3 	STS  __FF_error,R30
                 ;    2901 		return (EOF);
0013a7 efef      	LDI  R30,LOW(65535)
0013a8 efff      	LDI  R31,HIGH(65535)
0013a9 c002      	RJMP _0x41E
                 ;    2902 	}
                 ;    2903 	return (0);
                 _0x1F2:
0013aa e0e0      	LDI  R30,LOW(0)
0013ab e0f0      	LDI  R31,HIGH(0)
                 _0x41E:
0013ac 9624      	ADIW R28,4
0013ad 9508      	RET
                 ;    2904 }
                 ;    2905 #endif
                 ;    2906 
                 ;    2907 // function that checks for directory changes then gets into a working form
                 ;    2908 int _FF_checkdir(char *F_PATH, unsigned long *SAVE_ADDR, char *path_temp)
                 ;    2909 {
                 __FF_checkdir:
                 ;    2910 	unsigned char *sp, *qp;
                 ;    2911     
                 ;    2912     *SAVE_ADDR = _FF_DIR_ADDR;	// save local dir addr
0013ae 940e 1f32 	CALL __SAVELOCR4
                 ;	*F_PATH -> Y+8
                 ;	*SAVE_ADDR -> Y+6
                 ;	*path_temp -> Y+4
                 ;	*sp -> R16,R17
                 ;	*qp -> R18,R19
0013b0 91e0 0bbd 	LDS  R30,__FF_DIR_ADDR
0013b2 91f0 0bbe 	LDS  R31,__FF_DIR_ADDR+1
0013b4 9160 0bbf 	LDS  R22,__FF_DIR_ADDR+2
0013b6 9170 0bc0 	LDS  R23,__FF_DIR_ADDR+3
0013b8 81ae      	LDD  R26,Y+6
0013b9 81bf      	LDD  R27,Y+6+1
0013ba 940e 1ece 	CALL __PUTDP1
                 ;    2913     
                 ;    2914     qp = F_PATH;
0013bc 8528
0013bd 8539      	__GETWRS 18,19,8
                 ;    2915     if (*qp=='\\')
0013be 01d9      	MOVW R26,R18
0013bf 91ac      	LD   R26,X
0013c0 35ac      	CPI  R26,LOW(0x5C)
0013c1 f491      	BRNE _0x1F5
                 ;    2916     {
                 ;    2917     	_FF_DIR_ADDR = _FF_ROOT_ADDR;
0013c2 91e0 0bb9 	LDS  R30,__FF_ROOT_ADDR
0013c4 91f0 0bba 	LDS  R31,__FF_ROOT_ADDR+1
0013c6 9160 0bbb 	LDS  R22,__FF_ROOT_ADDR+2
0013c8 9170 0bbc 	LDS  R23,__FF_ROOT_ADDR+3
0013ca 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0013cc 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0013ce 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0013d0 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    2918 		qp++;
0013d2 5f2f
0013d3 4f3f      	__ADDWRN 18,19,1
                 ;    2919 	}
                 ;    2920 
                 ;    2921 	sp = path_temp;
                 _0x1F5:
0013d4 810c
0013d5 811d      	__GETWRS 16,17,4
                 ;    2922 	while(*qp)
                 _0x1F6:
0013d6 01d9      	MOVW R26,R18
0013d7 91ec      	LD   R30,X
0013d8 30e0      	CPI  R30,0
0013d9 f191      	BREQ _0x1F8
                 ;    2923 	{
                 ;    2924 		if ((valid_file_char(*qp)==0) || (*qp=='.'))
0013da 93ea      	ST   -Y,R30
0013db 940e 0c94 	CALL _valid_file_char
0013dd 9730      	SBIW R30,0
0013de f021      	BREQ _0x1FA
0013df 01d9      	MOVW R26,R18
0013e0 91ac      	LD   R26,X
0013e1 32ae      	CPI  R26,LOW(0x2E)
0013e2 f479      	BRNE _0x1F9
                 _0x1FA:
                 ;    2925 			*sp++ = toupper(*qp++);
0013e3 931f      	PUSH R17
0013e4 930f      	PUSH R16
0013e5 5f0f
0013e6 4f1f      	__ADDWRN 16,17,1
0013e7 01d9      	MOVW R26,R18
0013e8 5f2f
0013e9 4f3f      	__ADDWRN 18,19,1
0013ea 91ec      	LD   R30,X
0013eb 93ea      	ST   -Y,R30
0013ec 940e 1dc3 	CALL _toupper
0013ee 91af      	POP  R26
0013ef 91bf      	POP  R27
0013f0 93ec      	ST   X,R30
                 ;    2926 		else if (*qp=='\\')
0013f1 c019      	RJMP _0x1FC
                 _0x1F9:
0013f2 01d9      	MOVW R26,R18
0013f3 91ac      	LD   R26,X
0013f4 35ac      	CPI  R26,LOW(0x5C)
0013f5 f491      	BRNE _0x1FD
                 ;    2927 		{
                 ;    2928 			*sp = 0;	// terminate string
0013f6 01d8      	MOVW R26,R16
0013f7 e0e0      	LDI  R30,LOW(0)
0013f8 93ec      	ST   X,R30
                 ;    2929 			if (_FF_chdir(path_temp))
0013f9 81ec      	LDD  R30,Y+4
0013fa 81fd      	LDD  R31,Y+4+1
0013fb 93fa      	ST   -Y,R31
0013fc 93ea      	ST   -Y,R30
0013fd d017      	RCALL __FF_chdir
0013fe 9730      	SBIW R30,0
0013ff f019      	BREQ _0x1FE
                 ;    2930 			{
                 ;    2931 				return (EOF);
001400 efef      	LDI  R30,LOW(65535)
001401 efff      	LDI  R31,HIGH(65535)
001402 c00e      	RJMP _0x41D
                 ;    2932 			}
                 ;    2933 			sp = path_temp;
                 _0x1FE:
001403 810c
001404 811d      	__GETWRS 16,17,4
                 ;    2934 			qp++;
001405 5f2f
001406 4f3f      	__ADDWRN 18,19,1
                 ;    2935 		}
                 ;    2936 		else
001407 c003      	RJMP _0x1FF
                 _0x1FD:
                 ;    2937 			return (EOF);
001408 efef      	LDI  R30,LOW(65535)
001409 efff      	LDI  R31,HIGH(65535)
00140a c006      	RJMP _0x41D
                 ;    2938 	}
                 _0x1FF:
                 _0x1FC:
00140b cfca      	RJMP _0x1F6
                 _0x1F8:
                 ;    2939 	
                 ;    2940 	*sp = 0;		// terminate string
00140c 01d8      	MOVW R26,R16
00140d e0e0      	LDI  R30,LOW(0)
00140e 93ec      	ST   X,R30
                 ;    2941 	return (0);
00140f e0e0      	LDI  R30,LOW(0)
001410 e0f0      	LDI  R31,HIGH(0)
                 _0x41D:
001411 940e 1f39 	CALL __LOADLOCR4
001413 962a      	ADIW R28,10
001414 9508      	RET
                 ;    2942 }
                 ;    2943 
                 ;    2944 #ifndef _READ_ONLY_
                 ;    2945 int mkdir(char *F_PATH)
                 ;    2946 {
                 ;    2947 	unsigned char *sp, *qp;
                 ;    2948 	unsigned char fpath[14];
                 ;    2949 	unsigned int c, calc_temp, clus_temp, calc_time, calc_date;
                 ;    2950 	int s;
                 ;    2951 	unsigned long addr_temp, path_addr_temp;
                 ;    2952     
                 ;    2953     addr_temp = 0;	// save local dir addr
                 ;	*F_PATH -> Y+38
                 ;	*sp -> R16,R17
                 ;	*qp -> R18,R19
                 ;	fpath -> Y+24
                 ;	c -> R20,R21
                 ;	calc_temp -> Y+22
                 ;	clus_temp -> Y+20
                 ;	calc_time -> Y+18
                 ;	calc_date -> Y+16
                 ;	s -> Y+14
                 ;	addr_temp -> Y+10
                 ;	path_addr_temp -> Y+6
                 ;    2954     
                 ;    2955     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
                 ;    2956 	{
                 ;    2957 		_FF_DIR_ADDR = addr_temp;
                 ;    2958 		return (EOF);
                 ;    2959 	}
                 ;    2960     
                 ;    2961 	path_addr_temp = _FF_DIR_ADDR;
                 ;    2962 	s = scan_directory(&path_addr_temp, fpath);
                 ;    2963 	if ((s) || (path_addr_temp==0))
                 ;    2964 	{
                 ;    2965 		_FF_DIR_ADDR = addr_temp;
                 ;    2966 		return (EOF);
                 ;    2967 	}
                 ;    2968 	clus_temp = prev_cluster(0);				
                 ;    2969 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    2970 	path_addr_temp -= calc_temp;
                 ;    2971 	if (_FF_read(path_addr_temp)==0)	
                 ;    2972 	{
                 ;    2973 		_FF_DIR_ADDR = addr_temp;
                 ;    2974 		return (EOF);
                 ;    2975 	}
                 ;    2976 	
                 ;    2977 	sp = &_FF_buff[calc_temp];
                 ;    2978 	qp = fpath;
                 ;    2979 
                 ;    2980 	for (c=0; c<11; c++)	// Write Folder name
                 ;    2981 	{
                 ;    2982 	 	if (*qp)
                 ;    2983 		 	*sp++ = *qp++;
                 ;    2984 		else 
                 ;    2985 			*sp++ = 0x20;	// '0' pad
                 ;    2986 	}
                 ;    2987 	*sp++ = 0x10;				// Attribute bit auto set to "Directory"
                 ;    2988 	*sp++ = 0;					// Reserved for WinNT
                 ;    2989 	*sp++ = 0;					// Mili-second stamp for create
                 ;    2990 	for (c=0; c<4; c++)			// set create and modify time to '0'
                 ;    2991 		*sp++ = 0;
                 ;    2992 	*sp++ = 0;					// File access date (2 bytes)
                 ;    2993 	*sp++ = 0;
                 ;    2994 	*sp++ = 0;					// 0 for FAT12/16 (2 bytes)
                 ;    2995 	*sp++ = 0;
                 ;    2996 	#ifdef _RTC_ON_
                 ;    2997 		rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
                 ;    2998 		calc_time = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
                 ;    2999 		*sp++ = calc_time&0x00FF;	// File modify Time 
                 ;    3000 		*sp++ = (calc_time&0xFF00) >> 8;
                 ;    3001 		calc_date = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
                 ;    3002 		*sp++ = calc_date&0x00FF;	// File modify Date
                 ;    3003 		*sp++ = (calc_date&0xFF00) >> 8;
                 ;    3004 	#else
                 ;    3005 		for (c=0; c<4; c++)			// set file create and modify time to '0'
                 ;    3006 			*sp++ = 0;
                 ;    3007 	#endif
                 ;    3008 	
                 ;    3009 	*sp++ = clus_temp & 0xFF;				// Starting cluster (2 bytes)
                 ;    3010 	*sp++ = (clus_temp >> 8) & 0xFF;
                 ;    3011 	for (c=0; c<4; c++)
                 ;    3012 		*sp++ = 0;			// File length (0 for folder)
                 ;    3013 
                 ;    3014 	
                 ;    3015 	if (_FF_write(path_addr_temp)==0)	// write entry to card
                 ;    3016 	{
                 ;    3017 		_FF_DIR_ADDR = addr_temp;
                 ;    3018 		return (EOF);
                 ;    3019 	}
                 ;    3020 	if (write_clus_table(clus_temp, 0xFFFF, SINGLE)==0)
                 ;    3021 	{
                 ;    3022 		_FF_DIR_ADDR = addr_temp;
                 ;    3023 		return (EOF);
                 ;    3024 	}
                 ;    3025 	if (_FF_read(_FF_DIR_ADDR)==0)	
                 ;    3026 	{
                 ;    3027 		_FF_DIR_ADDR = addr_temp;
                 ;    3028 		return (EOF);
                 ;    3029 	}
                 ;    3030 	if (_FF_DIR_ADDR != _FF_ROOT_ADDR)
                 ;    3031 	{
                 ;    3032 		sp = &_FF_buff[0];
                 ;    3033 		qp = &_FF_buff[0x20];
                 ;    3034 		for (c=0; c<0x20; c++)
                 ;    3035 			*qp++ = *sp++;
                 ;    3036 		_FF_buff[1] = ' ';
                 ;    3037 		for (c=0x3C; c<0x40; c++)
                 ;    3038 			_FF_buff[c] = 0;
                 ;    3039 	}
                 ;    3040 	else
                 ;    3041 	{
                 ;    3042 		for (c=0x01; c<0x0B; c++)
                 ;    3043 			_FF_buff[c] = 0x20;
                 ;    3044 		for (c=0x0C; c<0x20; c++)
                 ;    3045 			_FF_buff[c] = 0;
                 ;    3046 		_FF_buff[0] = '.';
                 ;    3047 		_FF_buff[0x0B] = 0x10;
                 ;    3048 		#ifdef _RTC_ON_
                 ;    3049 			_FF_buff[0x0E] = calc_time&0x00FF;	// File modify Time 
                 ;    3050 			_FF_buff[0x0F] = (calc_time&0xFF00) >> 8;
                 ;    3051 			_FF_buff[0x10] = calc_date&0x00FF;	// File modify Date
                 ;    3052 			_FF_buff[0x11] = (calc_date&0xFF00) >> 8;
                 ;    3053 			_FF_buff[0x16] = calc_time&0x00FF;	// File modify Time 
                 ;    3054 			_FF_buff[0x17] = (calc_time&0xFF00) >> 8;
                 ;    3055 			_FF_buff[0x18] = calc_date&0x00FF;	// File modify Date
                 ;    3056 			_FF_buff[0x19] = (calc_date&0xFF00) >> 8;
                 ;    3057 		#endif
                 ;    3058 		for (c=0x3A; c<0x40; c++)
                 ;    3059 			_FF_buff[c] = 0;
                 ;    3060 	}
                 ;    3061 	for (c=0x22; c<0x2B; c++)
                 ;    3062 		_FF_buff[c] = 0x20;
                 ;    3063 	#ifdef _RTC_ON_
                 ;    3064 		_FF_buff[0x2E] = calc_time&0x00FF;	// File modify Time 
                 ;    3065 		_FF_buff[0x2F] = (calc_time&0xFF00) >> 8;
                 ;    3066 		_FF_buff[0x30] = calc_date&0x00FF;	// File modify Date
                 ;    3067 		_FF_buff[0x31] = (calc_date&0xFF00) >> 8;
                 ;    3068 		_FF_buff[0x36] = calc_time&0x00FF;	// File modify Time 
                 ;    3069 		_FF_buff[0x37] = (calc_time&0xFF00) >> 8;
                 ;    3070 		_FF_buff[0x38] = calc_date&0x00FF;	// File modify Date
                 ;    3071 		_FF_buff[0x39] = (calc_date&0xFF00) >> 8;
                 ;    3072 	#endif
                 ;    3073 	_FF_buff[0x20] = '.';
                 ;    3074 	_FF_buff[0x21] = '.';
                 ;    3075 	_FF_buff[0x2B] = 0x10;
                 ;    3076 
                 ;    3077 	_FF_buff[0x1A] = clus_temp & 0xFF;				// Starting cluster (2 bytes)
                 ;    3078 	_FF_buff[0x1B] = (clus_temp >> 8) & 0xFF;
                 ;    3079 	for (c=0x40; c<BPB_BytsPerSec; c++)
                 ;    3080 		_FF_buff[c] = 0;
                 ;    3081 	path_addr_temp = clust_to_addr(clus_temp);
                 ;    3082 
                 ;    3083 	_FF_DIR_ADDR = addr_temp;	// reset dir addr
                 ;    3084 	if (_FF_write(path_addr_temp)==0)	
                 ;    3085 		return (EOF);
                 ;    3086 	for (c=0; c<0x40; c++)
                 ;    3087 		_FF_buff[c] = 0;
                 ;    3088 	for (c=1; c<BPB_SecPerClus; c++)
                 ;    3089 	{
                 ;    3090 		if (_FF_write(path_addr_temp+((long)c*0x200))==0)	
                 ;    3091 			return (EOF);
                 ;    3092 	}
                 ;    3093 	return (0);		
                 ;    3094 }
                 ;    3095 
                 ;    3096 int rmdir(char *F_PATH)
                 ;    3097 {
                 ;    3098 	unsigned char *sp;
                 ;    3099 	unsigned char fpath[14];
                 ;    3100 	unsigned int c, n, calc_temp, clus_temp;
                 ;    3101 	int s;
                 ;    3102 	unsigned long addr_temp, path_addr_temp;
                 ;    3103 	
                 ;    3104 	addr_temp = 0;	// save local dir addr
                 ;	*F_PATH -> Y+34
                 ;	*sp -> R16,R17
                 ;	fpath -> Y+20
                 ;	c -> R18,R19
                 ;	n -> R20,R21
                 ;	calc_temp -> Y+18
                 ;	clus_temp -> Y+16
                 ;	s -> Y+14
                 ;	addr_temp -> Y+10
                 ;	path_addr_temp -> Y+6
                 ;    3105     
                 ;    3106     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
                 ;    3107 	{
                 ;    3108 		_FF_DIR_ADDR = addr_temp;
                 ;    3109 		return (EOF);
                 ;    3110 	}
                 ;    3111 	if (fpath[0]==0)
                 ;    3112 	{
                 ;    3113 		_FF_DIR_ADDR = addr_temp;
                 ;    3114 		return (EOF);
                 ;    3115 	}
                 ;    3116 
                 ;    3117     path_addr_temp = _FF_DIR_ADDR;	// save addr for later
                 ;    3118 	
                 ;    3119 	if (_FF_chdir(fpath))	// Change directory to dir to be deleted
                 ;    3120 	{	
                 ;    3121 		_FF_DIR_ADDR = addr_temp;
                 ;    3122 		return (EOF);
                 ;    3123 	}
                 ;    3124 	if ((_FF_DIR_ADDR==_FF_ROOT_ADDR)||(_FF_DIR_ADDR==addr_temp))
                 ;    3125 	{	// if trying to delete root, or current dir error
                 ;    3126 		_FF_DIR_ADDR = addr_temp;
                 ;    3127 		return (EOF);
                 ;    3128 	}
                 ;    3129 	
                 ;    3130 	for (c=0; c<BPB_SecPerClus; c++)
                 ;    3131 	{	// scan through dir to see if it is empty
                 ;    3132 		if (_FF_read(_FF_DIR_ADDR+((long)c*0x200))==0)
                 ;    3133 		{	// read sectors 	
                 ;    3134 			_FF_DIR_ADDR = addr_temp;
                 ;    3135 			return (EOF);
                 ;    3136 		}
                 ;    3137 		for (n=0; n<0x10; n++)
                 ;    3138 		{
                 ;    3139 			if ((c==0)&&(n==0))	// skip first 2 entries 
                 ;    3140 				n=2;
                 ;    3141 			sp = &_FF_buff[n*0x20];
                 ;    3142 			if (*sp==0)
                 ;    3143 			{	// 
                 ;    3144 				c = BPB_SecPerClus;
                 ;    3145 				break;
                 ;    3146 			}
                 ;    3147 			while (valid_file_char(*sp)==0)
                 ;    3148 			{
                 ;    3149 				sp++;
                 ;    3150 				if (sp == &_FF_buff[(n*0x20)+0x0A])
                 ;    3151 				{	// a valid file or folder found
                 ;    3152 					_FF_DIR_ADDR = addr_temp;
                 ;    3153 					return (EOF);
                 ;    3154 				}
                 ;    3155 			}
                 ;    3156 		}
                 ;    3157 	}
                 ;    3158 	// directory empty, delete dir
                 ;    3159 	_FF_DIR_ADDR = path_addr_temp;	// go back to previous directory 
                 ;    3160 
                 ;    3161 	s = scan_directory(&path_addr_temp, fpath);
                 ;    3162 
                 ;    3163 	_FF_DIR_ADDR = addr_temp;	// reset address
                 ;    3164 
                 ;    3165 	if (s == 0)
                 ;    3166 		return (EOF);
                 ;    3167 	
                 ;    3168 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    3169 	path_addr_temp -= calc_temp;
                 ;    3170 
                 ;    3171 	if (_FF_read(path_addr_temp)==0)	
                 ;    3172 		return (EOF);
                 ;    3173     
                 ;    3174 	clus_temp = ((int) _FF_buff[calc_temp+0x1B] << 8) | _FF_buff[calc_temp+0x1A];
                 ;    3175 	_FF_buff[calc_temp] = 0xE5;
                 ;    3176 	
                 ;    3177 	if (_FF_buff[calc_temp+0x0B]&0x02)
                 ;    3178 		return (EOF);
                 ;    3179 	if (_FF_write(path_addr_temp)==0) 
                 ;    3180 		return (EOF);
                 ;    3181 	if (erase_clus_chain(clus_temp)==0)
                 ;    3182 		return (EOF);
                 ;    3183 	
                 ;    3184     return (0);
                 ;    3185 }
                 ;    3186 #endif
                 ;    3187 
                 ;    3188 int chdirc(char flash *F_PATH)
                 ;    3189 {
                 ;    3190 	unsigned char fpath[_FF_PATH_LENGTH];
                 ;    3191 	int c;
                 ;    3192 	
                 ;    3193 	for (c=0; c<_FF_PATH_LENGTH; c++)
                 ;	*F_PATH -> Y+102
                 ;	fpath -> Y+2
                 ;	c -> R16,R17
                 ;    3194 	{
                 ;    3195 		fpath[c] = F_PATH[c];
                 ;    3196 		if (F_PATH[c]==0)
                 ;    3197 			break;
                 ;    3198 	}
                 ;    3199 	return (chdir(fpath));
                 ;    3200 }
                 ;    3201 
                 ;    3202 int chdir(char *F_PATH)
                 ;    3203 {
                 ;    3204 	unsigned char *qp, *sp, fpath[14], valid_flag;
                 ;    3205 	unsigned int m, n, c, d, calc;
                 ;    3206 	unsigned long addr_temp;
                 ;    3207 
                 ;    3208     
                 ;    3209     addr_temp = 0;	// save local dir addr
                 ;	*F_PATH -> Y+33
                 ;	*qp -> R16,R17
                 ;	*sp -> R18,R19
                 ;	fpath -> Y+19
                 ;	valid_flag -> R20
                 ;	m -> Y+17
                 ;	n -> Y+15
                 ;	c -> Y+13
                 ;	d -> Y+11
                 ;	calc -> Y+9
                 ;	addr_temp -> Y+5
                 ;    3210     
                 ;    3211 	if ((F_PATH[0]=='\\') && (F_PATH[1]==0))
                 ;    3212 	{
                 ;    3213 		_FF_DIR_ADDR = _FF_ROOT_ADDR;
                 ;    3214 		_FF_FULL_PATH[1] = 0;
                 ;    3215 		return (0);
                 ;    3216 	}
                 ;    3217 	
                 ;    3218     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
                 ;    3219 	{
                 ;    3220 		_FF_DIR_ADDR = addr_temp;
                 ;    3221 		return (EOF);
                 ;    3222 	}
                 ;    3223 	if (fpath[0]==0)
                 ;    3224 		return (EOF);
                 ;    3225 
                 ;    3226 	if ((fpath[0]=='.') && (fpath[1]=='.') && (fpath[2]==0))
                 ;    3227 	{	// trying to get back to prev dir
                 ;    3228 		if (_FF_DIR_ADDR == _FF_ROOT_ADDR)		// already as far back as can go
                 ;    3229 			return (EOF);
                 ;    3230 		if (_FF_read(_FF_DIR_ADDR)==0)
                 ;    3231 			return (EOF);
                 ;    3232 		m = ((unsigned int) _FF_buff[0x3B] << 8) | (unsigned int) _FF_buff[0x3A];
                 ;    3233 		if (m)
                 ;    3234 			_FF_DIR_ADDR = clust_to_addr(m);
                 ;    3235 		else
                 ;    3236 			_FF_DIR_ADDR = _FF_ROOT_ADDR;
                 ;    3237 		
                 ;    3238 					sp = F_PATH;
                 ;    3239 					qp = _FF_FULL_PATH + strlen(_FF_FULL_PATH);
                 ;    3240 					while (*sp)
                 ;    3241 					{
                 ;    3242 						if ((*sp=='.')&&(*(sp+1)=='.'))
                 ;    3243 						{
                 ;    3244 							#ifdef _ICCAVR_
                 ;    3245 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3246 								if (qp==0)
                 ;    3247 								   return (EOF);
                 ;    3248 								*qp = 0;
                 ;    3249 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3250 								if (qp==0)
                 ;    3251 								   return (EOF);
                 ;    3252 								qp++;
                 ;    3253 							#endif
                 ;    3254 							#ifdef _CVAVR_
                 ;    3255 								_FF_FULL_PATH[strrpos(_FF_FULL_PATH, '\\')] = 0;
                 ;    3256 							    c = strrpos(_FF_FULL_PATH, '\\');
                 ;    3257 								if (c==EOF)
                 ;    3258 									return (EOF);
                 ;    3259 								qp = _FF_FULL_PATH + c;
                 ;    3260 							#endif
                 ;    3261 							*qp = 0;
                 ;    3262 							sp += 2;
                 ;    3263 						}
                 ;    3264 						else 
                 ;    3265 							*qp++ = toupper(*sp++);
                 ;    3266 					}
                 ;    3267 					*qp++ = '\\';
                 ;    3268 					*qp = 0;
                 ;    3269 
                 ;    3270 		return (0);
                 ;    3271 	}
                 ;    3272 		
                 ;    3273 	qp = fpath;
                 ;    3274 	sp = fpath;
                 ;    3275 	while(sp < (fpath+11))
                 ;    3276 	{
                 ;    3277 		if (*qp)
                 ;    3278 			*sp++ = toupper(*qp++);
                 ;    3279 		else	// (*qp==0)
                 ;    3280 			*sp++ = 0x20;
                 ;    3281 	}     
                 ;    3282 	*sp = 0;
                 ;    3283 
                 ;    3284 	qp = fpath;
                 ;    3285 	m = 0;
                 ;    3286 	d = 0;
                 ;    3287 	valid_flag = 0;
                 ;    3288 	while (d<BPB_RootEntCnt)
                 ;    3289 	{
                 ;    3290     	_FF_read(_FF_DIR_ADDR+(m*0x200));
                 ;    3291 		for (n=0; n<16; n++)
                 ;    3292 		{
                 ;    3293 			if (_FF_buff[n*0x20] == 0)	// no more entries in dir
                 ;    3294 			{
                 ;    3295 				_FF_DIR_ADDR = addr_temp;
                 ;    3296 				return (EOF);
                 ;    3297 			}
                 ;    3298 			calc = (n*0x20);
                 ;    3299 			for (c=0; c<11; c++)
                 ;    3300 			{	// check for name match
                 ;    3301 				if (fpath[c] == _FF_buff[calc+c])
                 ;    3302 					valid_flag = 1;
                 ;    3303 				else if (fpath[c] == 0)
                 ;    3304 				{
                 ;    3305 					if (_FF_buff[calc+c]==0x20)
                 ;    3306 						break;
                 ;    3307 				}
                 ;    3308 				else
                 ;    3309 				{
                 ;    3310 					valid_flag = 0;	
                 ;    3311 					break;
                 ;    3312 				}
                 ;    3313 		    }   
                 ;    3314 		    if (valid_flag)
                 ;    3315 	  		{
                 ;    3316 	  			if (_FF_buff[calc+0xB] != 0x10)	// not a directory
                 ;    3317 	  				valid_flag = 0;
                 ;    3318 	  			else
                 ;    3319 	  			{
                 ;    3320 	  				c = ((int) _FF_buff[calc+0x1B] << 8) | ((int) _FF_buff[calc+0x1A]);
                 ;    3321 					_FF_DIR_ADDR = clust_to_addr(c);
                 ;    3322 					sp = F_PATH;
                 ;    3323 					if (*sp=='\\')
                 ;    3324 					{	// Restart String @root
                 ;    3325 						qp = _FF_FULL_PATH + 1;
                 ;    3326 						*qp = 0;
                 ;    3327 						sp++;
                 ;    3328 					}
                 ;    3329 					else
                 ;    3330 						qp = _FF_FULL_PATH + strlen(_FF_FULL_PATH);
                 ;    3331 					while (*sp)
                 ;    3332 					{
                 ;    3333 						if ((*sp=='.')&&(*(sp+1)=='.'))
                 ;    3334 						{
                 ;    3335 							#ifdef _ICCAVR_
                 ;    3336 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3337 								if (qp==0)
                 ;    3338 								   return (EOF);
                 ;    3339 								*qp = 0;
                 ;    3340 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3341 								if (qp==0)
                 ;    3342 								   return (EOF);
                 ;    3343 								qp++;
                 ;    3344 							#endif
                 ;    3345 							#ifdef _CVAVR_
                 ;    3346 								_FF_FULL_PATH[strrpos(_FF_FULL_PATH, '\\')] = 0;
                 ;    3347 								c = strrpos(_FF_FULL_PATH, '\\');
                 ;    3348 								if (c==EOF)
                 ;    3349 								   return (EOF);
                 ;    3350 								qp = _FF_FULL_PATH + c;
                 ;    3351 							#endif
                 ;    3352 							*qp = 0;
                 ;    3353 							sp += 2;
                 ;    3354 						}
                 ;    3355 						else 
                 ;    3356 							*qp++ = toupper(*sp++);
                 ;    3357 					}
                 ;    3358 					*qp++ = '\\';
                 ;    3359 					*qp = 0;
                 ;    3360 					return (0);
                 ;    3361 				}
                 ;    3362 			}
                 ;    3363 		  	d++;		  		
                 ;    3364 		}
                 ;    3365 		m++;
                 ;    3366 	}
                 ;    3367 	_FF_DIR_ADDR = addr_temp;
                 ;    3368 	return (EOF);
                 ;    3369 }
                 ;    3370 
                 ;    3371 // Function to change directories one at a time, not effecting the working dir string
                 ;    3372 int _FF_chdir(char *F_PATH)
                 ;    3373 {
                 __FF_chdir:
                 ;    3374 	unsigned char *qp, *sp, valid_flag, fpath[14];
                 ;    3375 	unsigned int m, n, c, d, calc;
                 ;    3376     
                 ;    3377 	if ((F_PATH[0]=='.') && (F_PATH[1]=='.') && (F_PATH[2]==0))
001415 9768      	SBIW R28,24
001416 940e 1f31 	CALL __SAVELOCR5
                 ;	*F_PATH -> Y+29
                 ;	*qp -> R16,R17
                 ;	*sp -> R18,R19
                 ;	valid_flag -> R20
                 ;	fpath -> Y+15
                 ;	m -> Y+13
                 ;	n -> Y+11
                 ;	c -> Y+9
                 ;	d -> Y+7
                 ;	calc -> Y+5
001418 8dad      	LDD  R26,Y+29
001419 8dbe      	LDD  R27,Y+29+1
00141a 91ac      	LD   R26,X
00141b 32ae      	CPI  R26,LOW(0x2E)
00141c f461      	BRNE _0x289
00141d 8dad      	LDD  R26,Y+29
00141e 8dbe      	LDD  R27,Y+29+1
00141f 9611      	ADIW R26,1
001420 91ac      	LD   R26,X
001421 32ae      	CPI  R26,LOW(0x2E)
001422 f431      	BRNE _0x289
001423 8dad      	LDD  R26,Y+29
001424 8dbe      	LDD  R27,Y+29+1
001425 9612      	ADIW R26,2
001426 91ac      	LD   R26,X
001427 30a0      	CPI  R26,LOW(0x0)
001428 f009      	BREQ _0x28A
                 _0x289:
001429 c04b      	RJMP _0x288
                 _0x28A:
                 ;    3378 	{	// trying to get back to prev dir
                 ;    3379 		if (_FF_DIR_ADDR == _FF_ROOT_ADDR)		// already as far back as can go
00142a 91e0 0bb9 	LDS  R30,__FF_ROOT_ADDR
00142c 91f0 0bba 	LDS  R31,__FF_ROOT_ADDR+1
00142e 9160 0bbb 	LDS  R22,__FF_ROOT_ADDR+2
001430 9170 0bbc 	LDS  R23,__FF_ROOT_ADDR+3
001432 91a0 0bbd 	LDS  R26,__FF_DIR_ADDR
001434 91b0 0bbe 	LDS  R27,__FF_DIR_ADDR+1
001436 9180 0bbf 	LDS  R24,__FF_DIR_ADDR+2
001438 9190 0bc0 	LDS  R25,__FF_DIR_ADDR+3
00143a 940e 1f26 	CALL __CPD12
00143c f419      	BRNE _0x28B
                 ;    3380 			return (EOF);
00143d efef      	LDI  R30,LOW(65535)
00143e efff      	LDI  R31,HIGH(65535)
00143f c109      	RJMP _0x41C
                 ;    3381 		if (_FF_read(_FF_DIR_ADDR)==0)
                 _0x28B:
001440 91e0 0bbd 	LDS  R30,__FF_DIR_ADDR
001442 91f0 0bbe 	LDS  R31,__FF_DIR_ADDR+1
001444 9160 0bbf 	LDS  R22,__FF_DIR_ADDR+2
001446 9170 0bc0 	LDS  R23,__FF_DIR_ADDR+3
001448 940e 1ed7 	CALL __PUTPARD1
00144a 940e 0b5e 	CALL __FF_read
00144c 30e0      	CPI  R30,0
00144d f419      	BRNE _0x28C
                 ;    3382 			return (EOF);
00144e efef      	LDI  R30,LOW(65535)
00144f efff      	LDI  R31,HIGH(65535)
001450 c0f8      	RJMP _0x41C
                 ;    3383 		m = ((unsigned int) _FF_buff[0x3B] << 8) | (unsigned int) _FF_buff[0x3A];
                 _0x28C:
001451 91b0 09cb 	__GETBRMN 27,__FF_buff,59
001453 e0a0      	LDI  R26,LOW(0)
001454 91e0 09ca 	__GETB1MN __FF_buff,58
001456 e0f0      	LDI  R31,0
001457 2bea      	OR   R30,R26
001458 2bfb      	OR   R31,R27
001459 87ed      	STD  Y+13,R30
00145a 87fe      	STD  Y+13+1,R31
                 ;    3384 		if (m)
00145b 9730      	SBIW R30,0
00145c f029      	BREQ _0x28D
                 ;    3385 			_FF_DIR_ADDR = clust_to_addr(m);
00145d 93fa      	ST   -Y,R31
00145e 93ea      	ST   -Y,R30
00145f 940e 0eeb 	CALL _clust_to_addr
001461 c008      	RJMP _0x438
                 ;    3386 		else
                 _0x28D:
                 ;    3387 			_FF_DIR_ADDR = _FF_ROOT_ADDR;
001462 91e0 0bb9 	LDS  R30,__FF_ROOT_ADDR
001464 91f0 0bba 	LDS  R31,__FF_ROOT_ADDR+1
001466 9160 0bbb 	LDS  R22,__FF_ROOT_ADDR+2
001468 9170 0bbc 	LDS  R23,__FF_ROOT_ADDR+3
                 _0x438:
00146a 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00146c 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00146e 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001470 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3388 		return (0);
001472 e0e0      	LDI  R30,LOW(0)
001473 e0f0      	LDI  R31,HIGH(0)
001474 c0d4      	RJMP _0x41C
                 ;    3389 	}
                 ;    3390 		
                 ;    3391 	qp = F_PATH;
                 _0x288:
001475 8d0d
001476 8d1e      	__GETWRS 16,17,29
                 ;    3392 	sp = fpath;
001477 01fe      	MOVW R30,R28
001478 963f      	ADIW R30,15
001479 019f      	MOVW R18,R30
                 ;    3393 	while(sp < (fpath+11))
                 _0x28F:
00147a 01fe      	MOVW R30,R28
00147b 967a      	ADIW R30,26
00147c 172e      	CP   R18,R30
00147d 073f      	CPC  R19,R31
00147e f520      	BRSH _0x291
                 ;    3394 	{
                 ;    3395 		if (valid_file_char(*qp)==0)
00147f 01d8      	MOVW R26,R16
001480 91ec      	LD   R30,X
001481 93ea      	ST   -Y,R30
001482 940e 0c94 	CALL _valid_file_char
001484 9730      	SBIW R30,0
001485 f479      	BRNE _0x292
                 ;    3396 			*sp++ = toupper(*qp++);
001486 933f      	PUSH R19
001487 932f      	PUSH R18
001488 5f2f
001489 4f3f      	__ADDWRN 18,19,1
00148a 01d8      	MOVW R26,R16
00148b 5f0f
00148c 4f1f      	__ADDWRN 16,17,1
00148d 91ec      	LD   R30,X
00148e 93ea      	ST   -Y,R30
00148f 940e 1dc3 	CALL _toupper
001491 91af      	POP  R26
001492 91bf      	POP  R27
001493 93ec      	ST   X,R30
                 ;    3397 		else if (*qp==0)
001494 c00d      	RJMP _0x293
                 _0x292:
001495 01d8      	MOVW R26,R16
001496 91ec      	LD   R30,X
001497 30e0      	CPI  R30,0
001498 f431      	BRNE _0x294
                 ;    3398 			*sp++ = 0x20;
001499 01d9      	MOVW R26,R18
00149a 5f2f
00149b 4f3f      	__ADDWRN 18,19,1
00149c e2e0      	LDI  R30,LOW(32)
00149d 93ec      	ST   X,R30
                 ;    3399 		else
00149e c003      	RJMP _0x295
                 _0x294:
                 ;    3400 			return (EOF);
00149f efef      	LDI  R30,LOW(65535)
0014a0 efff      	LDI  R31,HIGH(65535)
0014a1 c0a7      	RJMP _0x41C
                 ;    3401 	}     
                 _0x295:
                 _0x293:
0014a2 cfd7      	RJMP _0x28F
                 _0x291:
                 ;    3402 	*sp = 0;
0014a3 01d9      	MOVW R26,R18
0014a4 e0e0      	LDI  R30,LOW(0)
0014a5 93ec      	ST   X,R30
                 ;    3403 	m = 0;
0014a6 e0e0      	LDI  R30,0
0014a7 87ed      	STD  Y+13,R30
0014a8 87ee      	STD  Y+13+1,R30
                 ;    3404 	d = 0;
0014a9 e0e0      	LDI  R30,0
0014aa 83ef      	STD  Y+7,R30
0014ab 87e8      	STD  Y+7+1,R30
                 ;    3405 	valid_flag = 0;
0014ac e040      	LDI  R20,LOW(0)
                 ;    3406 	while (d<BPB_RootEntCnt)
                 _0x296:
0014ad 91e0 0b9c 	LDS  R30,_BPB_RootEntCnt
0014af 91f0 0b9d 	LDS  R31,_BPB_RootEntCnt+1
0014b1 81af      	LDD  R26,Y+7
0014b2 85b8      	LDD  R27,Y+7+1
0014b3 17ae      	CP   R26,R30
0014b4 07bf      	CPC  R27,R31
0014b5 f010      	BRLO PC+3
0014b6 940c 1547 	JMP _0x298
                 ;    3407 	{
                 ;    3408     	_FF_read(_FF_DIR_ADDR+(m*0x200));
0014b8 85ed      	LDD  R30,Y+13
0014b9 85fe      	LDD  R31,Y+13+1
0014ba 0fee      	LSL  R30
0014bb 1fff      	ROL  R31
0014bc 2ffe      	MOV  R31,R30
0014bd e0e0      	LDI  R30,0
0014be 91a0 0bbd 	LDS  R26,__FF_DIR_ADDR
0014c0 91b0 0bbe 	LDS  R27,__FF_DIR_ADDR+1
0014c2 9180 0bbf 	LDS  R24,__FF_DIR_ADDR+2
0014c4 9190 0bc0 	LDS  R25,__FF_DIR_ADDR+3
0014c6 2766      	CLR  R22
0014c7 2777      	CLR  R23
0014c8 940e 1dd6 	CALL __ADDD12
0014ca 940e 1ed7 	CALL __PUTPARD1
0014cc 940e 0b5e 	CALL __FF_read
                 ;    3409 		for (n=0; n<16; n++)
0014ce e0e0      	LDI  R30,0
0014cf 87eb      	STD  Y+11,R30
0014d0 87ec      	STD  Y+11+1,R30
                 _0x29A:
0014d1 85ab      	LDD  R26,Y+11
0014d2 85bc      	LDD  R27,Y+11+1
0014d3 9750      	SBIW R26,16
0014d4 f010      	BRLO PC+3
0014d5 940c 1541 	JMP _0x29B
                 ;    3410 		{
                 ;    3411 			calc = (n*0x20);
0014d7 85eb      	LDD  R30,Y+11
0014d8 85fc      	LDD  R31,Y+11+1
0014d9 0fee      	LSL  R30
0014da 1fff      	ROL  R31
0014db 940e 1e14 	CALL __LSLW4
0014dd 83ed      	STD  Y+5,R30
0014de 83fe      	STD  Y+5+1,R31
                 ;    3412 			if (_FF_buff[calc] == 0)	// no more entries in dir
0014df 57e0      	SUBI R30,LOW(-__FF_buff)
0014e0 4ff6      	SBCI R31,HIGH(-__FF_buff)
0014e1 81e0      	LD   R30,Z
0014e2 30e0      	CPI  R30,0
0014e3 f419      	BRNE _0x29C
                 ;    3413 				return (EOF);
0014e4 efef      	LDI  R30,LOW(65535)
0014e5 efff      	LDI  R31,HIGH(65535)
0014e6 c062      	RJMP _0x41C
                 ;    3414 			for (c=0; c<11; c++)
                 _0x29C:
0014e7 e0e0      	LDI  R30,0
0014e8 87e9      	STD  Y+9,R30
0014e9 87ea      	STD  Y+9+1,R30
                 _0x29E:
0014ea 85a9      	LDD  R26,Y+9
0014eb 85ba      	LDD  R27,Y+9+1
0014ec 971b      	SBIW R26,11
0014ed f4e8      	BRSH _0x29F
                 ;    3415 			{	// check for name match
                 ;    3416 				if (fpath[c] == _FF_buff[calc+c])
0014ee 85e9      	LDD  R30,Y+9
0014ef 85fa      	LDD  R31,Y+9+1
0014f0 01de      	MOVW R26,R28
0014f1 961f      	ADIW R26,15
0014f2 0fae      	ADD  R26,R30
0014f3 1fbf      	ADC  R27,R31
0014f4 900c      	LD   R0,X
0014f5 81ad      	LDD  R26,Y+5
0014f6 81be      	LDD  R27,Y+5+1
0014f7 0fea      	ADD  R30,R26
0014f8 1ffb      	ADC  R31,R27
0014f9 57e0      	SUBI R30,LOW(-__FF_buff)
0014fa 4ff6      	SBCI R31,HIGH(-__FF_buff)
0014fb 81e0      	LD   R30,Z
0014fc 15e0      	CP   R30,R0
0014fd f411      	BRNE _0x2A0
                 ;    3417 					valid_flag = 1;
0014fe e041      	LDI  R20,LOW(1)
                 ;    3418 				else
0014ff c005      	RJMP _0x2A1
                 _0x2A0:
                 ;    3419 				{
                 ;    3420 					valid_flag = 0;	
001500 e040      	LDI  R20,LOW(0)
                 ;    3421 					c = 11;
001501 e0eb      	LDI  R30,LOW(11)
001502 e0f0      	LDI  R31,HIGH(11)
001503 87e9      	STD  Y+9,R30
001504 87fa      	STD  Y+9+1,R31
                 ;    3422 				}
                 _0x2A1:
                 ;    3423 		    }   
001505 85e9      	LDD  R30,Y+9
001506 85fa      	LDD  R31,Y+9+1
001507 9631      	ADIW R30,1
001508 87e9      	STD  Y+9,R30
001509 87fa      	STD  Y+9+1,R31
00150a cfdf      	RJMP _0x29E
                 _0x29F:
                 ;    3424 		    if (valid_flag)
00150b 3040      	CPI  R20,0
00150c f149      	BREQ _0x2A2
                 ;    3425 	  		{
                 ;    3426 	  			if (_FF_buff[calc+0xB] != 0x10)	// not a directory
00150d 81ed      	LDD  R30,Y+5
00150e 81fe      	LDD  R31,Y+5+1
00150f 56e5
001510 4ff6      	__ADDW1MN __FF_buff,11
001511 81e0      	LD   R30,Z
001512 31e0      	CPI  R30,LOW(0x10)
001513 f011      	BREQ _0x2A3
                 ;    3427 	  				valid_flag = 0;
001514 e040      	LDI  R20,LOW(0)
                 ;    3428 	  			else
001515 c020      	RJMP _0x2A4
                 _0x2A3:
                 ;    3429 	  			{
                 ;    3430 	  				c = ((int) _FF_buff[calc+0x1B] << 8) | ((int) _FF_buff[calc+0x1A]);
001516 81ed      	LDD  R30,Y+5
001517 81fe      	LDD  R31,Y+5+1
001518 55e5
001519 4ff6      	__ADDW1MN __FF_buff,27
00151a 81f0      	LD   R31,Z
00151b e0e0      	LDI  R30,LOW(0)
00151c 01df      	MOVW R26,R30
00151d 81ed      	LDD  R30,Y+5
00151e 81fe      	LDD  R31,Y+5+1
00151f 55e6
001520 4ff6      	__ADDW1MN __FF_buff,26
001521 81e0      	LD   R30,Z
001522 e0f0      	LDI  R31,0
001523 2bea      	OR   R30,R26
001524 2bfb      	OR   R31,R27
001525 87e9      	STD  Y+9,R30
001526 87fa      	STD  Y+9+1,R31
                 ;    3431 					_FF_DIR_ADDR = clust_to_addr(c);
001527 93fa      	ST   -Y,R31
001528 93ea      	ST   -Y,R30
001529 940e 0eeb 	CALL _clust_to_addr
00152b 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00152d 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00152f 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001531 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3432 					return (0);
001533 e0e0      	LDI  R30,LOW(0)
001534 e0f0      	LDI  R31,HIGH(0)
001535 c013      	RJMP _0x41C
                 ;    3433 				}
                 _0x2A4:
                 ;    3434 			}
                 ;    3435 		  	d++;		  		
                 _0x2A2:
001536 81ef      	LDD  R30,Y+7
001537 85f8      	LDD  R31,Y+7+1
001538 9631      	ADIW R30,1
001539 83ef      	STD  Y+7,R30
00153a 87f8      	STD  Y+7+1,R31
                 ;    3436 		}
00153b 85eb      	LDD  R30,Y+11
00153c 85fc      	LDD  R31,Y+11+1
00153d 9631      	ADIW R30,1
00153e 87eb      	STD  Y+11,R30
00153f 87fc      	STD  Y+11+1,R31
001540 cf90      	RJMP _0x29A
                 _0x29B:
                 ;    3437 		m++;
001541 85ed      	LDD  R30,Y+13
001542 85fe      	LDD  R31,Y+13+1
001543 9631      	ADIW R30,1
001544 87ed      	STD  Y+13,R30
001545 87fe      	STD  Y+13+1,R31
                 ;    3438 	}
001546 cf66      	RJMP _0x296
                 _0x298:
                 ;    3439 	return (EOF);
001547 efef      	LDI  R30,LOW(65535)
001548 efff      	LDI  R31,HIGH(65535)
                 _0x41C:
001549 940e 1f38 	CALL __LOADLOCR5
00154b 966f      	ADIW R28,31
00154c 9508      	RET
                 ;    3440 }
                 ;    3441 
                 ;    3442 #ifndef _SECOND_FAT_ON_
                 ;    3443 // Function that clears the secondary FAT table
                 ;    3444 int clear_second_FAT(void)
                 ;    3445 {
                 ;    3446 	unsigned int c, d;
                 ;    3447 	unsigned long n;
                 ;    3448 	
                 ;    3449 	for (n=1; n<BPB_FATSz16; n++)
                 ;    3450 	{
                 ;    3451 		if (_FF_read(_FF_FAT2_ADDR+(n*0x200))==0)
                 ;    3452 			return (EOF);
                 ;    3453 		for (c=0; c<BPB_BytsPerSec; c++)
                 ;    3454 		{
                 ;    3455 			if (_FF_buff[c] != 0)
                 ;    3456 			{
                 ;    3457 				for (d=0; d<BPB_BytsPerSec; d++)
                 ;    3458 					_FF_buff[d] = 0;
                 ;    3459 				if (_FF_write(_FF_FAT2_ADDR+(n*0x200))==0)
                 ;    3460 					return (EOF);
                 ;    3461 				break;
                 ;    3462 			}
                 ;    3463 		}
                 ;    3464 	}
                 ;    3465 	for (d=2; d<BPB_BytsPerSec; d++)
                 ;    3466 		_FF_buff[d] = 0;
                 ;    3467 	_FF_buff[0] = 0xF8;
                 ;    3468 	_FF_buff[1] = 0xFF;
                 ;    3469 	_FF_buff[2] = 0xFF;
                 ;    3470 	if (BPB_FATType == 0x36)
                 ;    3471 		_FF_buff[3] = 0xFF;
                 ;    3472 	if (_FF_write(_FF_FAT2_ADDR)==0)
                 ;    3473 		return (EOF);
                 ;    3474 	
                 ;    3475 	return (1);
                 ;    3476 }
                 ;    3477 #endif
                 ;    3478  
                 ;    3479 // Open a file, name stored in string fileopen
                 ;    3480 FILE *fopenc(unsigned char flash *NAMEC, unsigned char MODEC)
                 ;    3481 {
                 ;    3482 	unsigned char c, temp_data[12];
                 ;    3483 	FILE *tp;
                 ;    3484 	
                 ;    3485 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+16
                 ;	MODEC -> Y+15
                 ;	c -> R16
                 ;	temp_data -> Y+3
                 ;	*tp -> R17,R18
                 ;    3486 		temp_data[c] = NAMEC[c];
                 ;    3487 	
                 ;    3488 	tp = fopen(temp_data, MODEC);
                 ;    3489 	return(tp);
                 ;    3490 }
                 ;    3491 
                 ;    3492 FILE *fopen(unsigned char *NAME, unsigned char MODE)
                 ;    3493 {
                 _fopen:
                 ;    3494 	unsigned char fpath[14];
                 ;    3495 	unsigned int c, s, calc_temp;
                 ;    3496 	unsigned char *sp, *qp;
                 ;    3497 	unsigned long addr_temp, path_addr_temp;
                 ;    3498 	FILE *rp;
                 ;    3499 	
                 ;    3500 	#ifdef _READ_ONLY_
                 ;    3501 		if (MODE!=READ)
                 ;    3502 			return (0);
                 ;    3503 	#endif
                 ;    3504 	
                 ;    3505     addr_temp = 0;	// save local dir addr
00154d 976c      	SBIW R28,28
00154e 940e 1f30 	CALL __SAVELOCR6
                 ;	*NAME -> Y+35
                 ;	MODE -> Y+34
                 ;	fpath -> Y+20
                 ;	c -> R16,R17
                 ;	s -> R18,R19
                 ;	calc_temp -> R20,R21
                 ;	*sp -> Y+18
                 ;	*qp -> Y+16
                 ;	addr_temp -> Y+12
                 ;	path_addr_temp -> Y+8
                 ;	*rp -> Y+6
001550 e0e0
001551 87ec
001552 87ed
001553 87ee
001554 87ef      	__CLRD1S 12
                 ;    3506     
                 ;    3507     if (_FF_checkdir(NAME, &addr_temp, fpath))
001555 a1eb      	LDD  R30,Y+35
001556 a1fc      	LDD  R31,Y+35+1
001557 93fa      	ST   -Y,R31
001558 93ea      	ST   -Y,R30
001559 01fe      	MOVW R30,R28
00155a 963e      	ADIW R30,14
00155b 93fa      	ST   -Y,R31
00155c 93ea      	ST   -Y,R30
00155d 01fe      	MOVW R30,R28
00155e 9678      	ADIW R30,24
00155f 93fa      	ST   -Y,R31
001560 93ea      	ST   -Y,R30
001561 940e 13ae 	CALL __FF_checkdir
001563 9730      	SBIW R30,0
001564 f079      	BREQ _0x2A8
                 ;    3508 	{
                 ;    3509 		_FF_DIR_ADDR = addr_temp;
001565 85ec
001566 85fd
001567 856e
001568 857f      	__GETD1S 12
001569 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00156b 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00156d 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
00156f 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3510 		return (0);
001571 e0e0      	LDI  R30,LOW(0)
001572 e0f0      	LDI  R31,HIGH(0)
001573 c4aa      	RJMP _0x41B
                 ;    3511 	}
                 ;    3512 	if (fpath[0]==0)
                 _0x2A8:
001574 89ec      	LDD  R30,Y+20
001575 30e0      	CPI  R30,0
001576 f479      	BRNE _0x2A9
                 ;    3513 	{
                 ;    3514 		_FF_DIR_ADDR = addr_temp;
001577 85ec
001578 85fd
001579 856e
00157a 857f      	__GETD1S 12
00157b 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00157d 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00157f 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001581 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3515 		return (0);
001583 e0e0      	LDI  R30,LOW(0)
001584 e0f0      	LDI  R31,HIGH(0)
001585 c498      	RJMP _0x41B
                 ;    3516 	}
                 ;    3517     
                 ;    3518 	path_addr_temp = _FF_DIR_ADDR;
                 _0x2A9:
001586 91e0 0bbd 	LDS  R30,__FF_DIR_ADDR
001588 91f0 0bbe 	LDS  R31,__FF_DIR_ADDR+1
00158a 9160 0bbf 	LDS  R22,__FF_DIR_ADDR+2
00158c 9170 0bc0 	LDS  R23,__FF_DIR_ADDR+3
00158e 87e8
00158f 87f9
001590 876a
001591 877b      	__PUTD1S 8
                 ;    3519 	s = scan_directory(&path_addr_temp, fpath);
001592 01fe      	MOVW R30,R28
001593 9638      	ADIW R30,8
001594 93fa      	ST   -Y,R31
001595 93ea      	ST   -Y,R30
001596 01fe      	MOVW R30,R28
001597 9676      	ADIW R30,22
001598 93fa      	ST   -Y,R31
001599 93ea      	ST   -Y,R30
00159a 940e 0cbc 	CALL _scan_directory
00159c 019f      	MOVW R18,R30
                 ;    3520 	if ((path_addr_temp==0) || (s==0))
00159d 85a8
00159e 85b9
00159f 858a
0015a0 859b      	__GETD2S 8
0015a1 940e 1f20 	CALL __CPD02
0015a3 f021      	BREQ _0x2AB
0015a4 2400      	CLR  R0
0015a5 1602      	CP   R0,R18
0015a6 0603      	CPC  R0,R19
0015a7 f479      	BRNE _0x2AA
                 _0x2AB:
                 ;    3521 	{
                 ;    3522 		_FF_DIR_ADDR = addr_temp;
0015a8 85ec
0015a9 85fd
0015aa 856e
0015ab 857f      	__GETD1S 12
0015ac 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0015ae 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0015b0 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0015b2 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3523 		return (0);
0015b4 e0e0      	LDI  R30,LOW(0)
0015b5 e0f0      	LDI  R31,HIGH(0)
0015b6 c467      	RJMP _0x41B
                 ;    3524 	}
                 ;    3525 
                 ;    3526 	rp = 0;
                 _0x2AA:
0015b7 e0e0      	LDI  R30,0
0015b8 83ee      	STD  Y+6,R30
0015b9 83ef      	STD  Y+6+1,R30
                 ;    3527 	rp = malloc(sizeof(FILE));
0015ba e2e9      	LDI  R30,LOW(553)
0015bb e0f2      	LDI  R31,HIGH(553)
0015bc 93fa      	ST   -Y,R31
0015bd 93ea      	ST   -Y,R30
0015be 940e 1d36 	CALL _malloc
0015c0 83ee      	STD  Y+6,R30
0015c1 83ff      	STD  Y+6+1,R31
                 ;    3528 	if (rp == 0)
0015c2 9730      	SBIW R30,0
0015c3 f491      	BRNE _0x2AD
                 ;    3529 	{	// Could not allocate requested memory
                 ;    3530 		_FF_error = ALLOC_ERR;
0015c4 e0e9      	LDI  R30,LOW(9)
0015c5 93e0 0bd3 	STS  __FF_error,R30
                 ;    3531 		_FF_DIR_ADDR = addr_temp;
0015c7 85ec
0015c8 85fd
0015c9 856e
0015ca 857f      	__GETD1S 12
0015cb 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0015cd 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0015cf 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0015d1 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3532 		return (0);
0015d3 e0e0      	LDI  R30,LOW(0)
0015d4 e0f0      	LDI  R31,HIGH(0)
0015d5 c448      	RJMP _0x41B
                 ;    3533 	}
                 ;    3534 	rp->length = 0x46344456;
                 _0x2AD:
0015d6 81ae      	LDD  R26,Y+6
0015d7 81bf      	LDD  R27,Y+6+1
0015d8 5ea4      	SUBI R26,LOW(-540)
0015d9 4fbd      	SBCI R27,HIGH(-540)
0015da e5e6
0015db e4f4
0015dc e364
0015dd e476      	__GETD1N 0x46344456
0015de 940e 1ece 	CALL __PUTDP1
                 ;    3535 	rp->clus_start = 0xe4;
0015e0 81ae      	LDD  R26,Y+6
0015e1 81bf      	LDD  R27,Y+6+1
0015e2 961c      	ADIW R26,12
0015e3 eee4      	LDI  R30,LOW(228)
0015e4 e0f0      	LDI  R31,HIGH(228)
0015e5 93ed      	ST   X+,R30
0015e6 93fc      	ST   X,R31
                 ;    3536 	rp->position = 0x45664446;
0015e7 81ae      	LDD  R26,Y+6
0015e8 81bf      	LDD  R27,Y+6+1
0015e9 5ea0      	SUBI R26,LOW(-544)
0015ea 4fbd      	SBCI R27,HIGH(-544)
0015eb e4e6
0015ec e4f4
0015ed e666
0015ee e475      	__GETD1N 0x45664446
0015ef 940e 1ece 	CALL __PUTDP1
                 ;    3537 
                 ;    3538 	calc_temp = path_addr_temp % BPB_BytsPerSec;
0015f1 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0015f3 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0015f5 85a8
0015f6 85b9
0015f7 858a
0015f8 859b      	__GETD2S 8
0015f9 2766      	CLR  R22
0015fa 2777      	CLR  R23
0015fb 940e 1e9f 	CALL __MODD21U
0015fd 01af      	MOVW R20,R30
                 ;    3539 	path_addr_temp -= calc_temp;
0015fe 01fa      	MOVW R30,R20
0015ff 85a8
001600 85b9
001601 858a
001602 859b      	__GETD2S 8
001603 2766      	CLR  R22
001604 2777      	CLR  R23
001605 940e 1de5 	CALL __SUBD21
001607 87a8
001608 87b9
001609 878a
00160a 879b      	__PUTD2S 8
                 ;    3540 	if (_FF_read(path_addr_temp)==0)	
00160b 85e8
00160c 85f9
00160d 856a
00160e 857b      	__GETD1S 8
00160f 940e 1ed7 	CALL __PUTPARD1
001611 940e 0b5e 	CALL __FF_read
001613 30e0      	CPI  R30,0
001614 f479      	BRNE _0x2AE
                 ;    3541 	{
                 ;    3542 		_FF_DIR_ADDR = addr_temp;
001615 85ec
001616 85fd
001617 856e
001618 857f      	__GETD1S 12
001619 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00161b 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00161d 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
00161f 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3543 		return (0);
001621 e0e0      	LDI  R30,LOW(0)
001622 e0f0      	LDI  R31,HIGH(0)
001623 c3fa      	RJMP _0x41B
                 ;    3544 	}
                 ;    3545 	
                 ;    3546 	// Get the filename into a form we can use to compare
                 ;    3547 	qp = file_name_conversion(fpath);
                 _0x2AE:
001624 01fe      	MOVW R30,R28
001625 9674      	ADIW R30,20
001626 93fa      	ST   -Y,R31
001627 93ea      	ST   -Y,R30
001628 940e 107c 	CALL _file_name_conversion
00162a 8be8      	STD  Y+16,R30
00162b 8bf9      	STD  Y+16+1,R31
                 ;    3548 	if (qp==0)
00162c 9730      	SBIW R30,0
00162d f4a9      	BRNE _0x2AF
                 ;    3549 	{	// If File name entered is NOT valid, return 0
                 ;    3550 		free(rp);
00162e 81ee      	LDD  R30,Y+6
00162f 81ff      	LDD  R31,Y+6+1
001630 93fa      	ST   -Y,R31
001631 93ea      	ST   -Y,R30
001632 940e 1d53 	CALL _free
                 ;    3551 		_FF_DIR_ADDR = addr_temp;
001634 85ec
001635 85fd
001636 856e
001637 857f      	__GETD1S 12
001638 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00163a 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00163c 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
00163e 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3552 		return (0);
001640 e0e0      	LDI  R30,LOW(0)
001641 e0f0      	LDI  R31,HIGH(0)
001642 c3db      	RJMP _0x41B
                 ;    3553 	}
                 ;    3554 	
                 ;    3555 	sp = &_FF_buff[calc_temp];
                 _0x2AF:
001643 01fa      	MOVW R30,R20
001644 57e0      	SUBI R30,LOW(-__FF_buff)
001645 4ff6      	SBCI R31,HIGH(-__FF_buff)
001646 8bea      	STD  Y+18,R30
001647 8bfb      	STD  Y+18+1,R31
                 ;    3556 
                 ;    3557 	if (s)
001648 2e02      	MOV  R0,R18
001649 2a03      	OR   R0,R19
00164a f411      	BRNE PC+3
00164b 940c 182d 	JMP _0x2B0
                 ;    3558 	{	// File exists, open 
                 ;    3559 		if (((MODE==WRITE) || (MODE==APPEND)) && (_FF_buff[calc_temp+0x0B]&0x01))
00164d a1aa      	LDD  R26,Y+34
00164e 30a2      	CPI  R26,LOW(0x2)
00164f f011      	BREQ _0x2B2
001650 30a3      	CPI  R26,LOW(0x3)
001651 f431      	BRNE _0x2B4
                 _0x2B2:
001652 01fa      	MOVW R30,R20
001653 56e5
001654 4ff6      	__ADDW1MN __FF_buff,11
001655 81e0      	LD   R30,Z
001656 70e1      	ANDI R30,LOW(0x1)
001657 f409      	BRNE _0x2B5
                 _0x2B4:
001658 c018      	RJMP _0x2B1
                 _0x2B5:
                 ;    3560 		{	// if writing to file verify it is not "READ ONLY"
                 ;    3561 			_FF_error = MODE_ERR;
001659 e0eb      	LDI  R30,LOW(11)
00165a 93e0 0bd3 	STS  __FF_error,R30
                 ;    3562 			free(rp);
00165c 81ee      	LDD  R30,Y+6
00165d 81ff      	LDD  R31,Y+6+1
00165e 93fa      	ST   -Y,R31
00165f 93ea      	ST   -Y,R30
001660 940e 1d53 	CALL _free
                 ;    3563 			_FF_DIR_ADDR = addr_temp;
001662 85ec
001663 85fd
001664 856e
001665 857f      	__GETD1S 12
001666 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001668 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00166a 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
00166c 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3564 			return (0);
00166e e0e0      	LDI  R30,LOW(0)
00166f e0f0      	LDI  R31,HIGH(0)
001670 c3ad      	RJMP _0x41B
                 ;    3565 		}
                 ;    3566 		for (c=0; c<12; c++)	// Save Filename to Buffer
                 _0x2B1:
001671 e000
001672 e010      	__GETWRN 16,17,0
                 _0x2B7:
001673 300c
001674 e0e0
001675 071e      	__CPWRN 16,17,12
001676 f480      	BRSH _0x2B8
                 ;    3567 			rp->name[c] = FILENAME[c];
001677 01f8      	MOVW R30,R16
001678 81ae      	LDD  R26,Y+6
001679 81bf      	LDD  R27,Y+6+1
00167a 0fea      	ADD  R30,R26
00167b 1ffb      	ADC  R31,R27
00167c 010f      	MOVW R0,R30
00167d e5a1      	LDI  R26,LOW(_FILENAME)
00167e e0bc      	LDI  R27,HIGH(_FILENAME)
00167f 0fa0      	ADD  R26,R16
001680 1fb1      	ADC  R27,R17
001681 91ec      	LD   R30,X
001682 01d0      	MOVW R26,R0
001683 93ec      	ST   X,R30
                 ;    3568 		// Save Starting Cluster
                 ;    3569 		rp->clus_start = ((int) _FF_buff[calc_temp+0x1B] << 8) | (int) _FF_buff[calc_temp+0x1A];
001684 5f0f
001685 4f1f      	__ADDWRN 16,17,1
001686 cfec      	RJMP _0x2B7
                 _0x2B8:
001687 01fa      	MOVW R30,R20
001688 55e5
001689 4ff6      	__ADDW1MN __FF_buff,27
00168a 81f0      	LD   R31,Z
00168b e0e0      	LDI  R30,LOW(0)
00168c 01df      	MOVW R26,R30
00168d 01fa      	MOVW R30,R20
00168e 55e6
00168f 4ff6      	__ADDW1MN __FF_buff,26
001690 81e0      	LD   R30,Z
001691 e0f0      	LDI  R31,0
001692 2bea      	OR   R30,R26
001693 2bfb      	OR   R31,R27
001694 81ae
001695 81bf
001696 961c
001697 93ed
001698 93fc      	__PUTW1SNS 6,12
                 ;    3570 		// Set Current Cluster
                 ;    3571 		rp->clus_current = rp->clus_start;
001699 81ae      	LDD  R26,Y+6
00169a 81bf      	LDD  R27,Y+6+1
00169b 961c      	ADIW R26,12
00169c 940e 1ec4 	CALL __GETW1P
00169e 81ae
00169f 81bf
0016a0 961e
0016a1 93ed
0016a2 93fc      	__PUTW1SNS 6,14
                 ;    3572 		// Set Previous Cluster to 0 (indicating @start)
                 ;    3573 		rp->clus_prev = 0;
0016a3 81ae      	LDD  R26,Y+6
0016a4 81bf      	LDD  R27,Y+6+1
0016a5 9652      	ADIW R26,18
0016a6 e0e0      	LDI  R30,LOW(0)
0016a7 e0f0      	LDI  R31,HIGH(0)
0016a8 93ed      	ST   X+,R30
0016a9 93fc      	ST   X,R31
                 ;    3574 		// Save file length
                 ;    3575 		rp->length = 0;
0016aa 81ae      	LDD  R26,Y+6
0016ab 81bf      	LDD  R27,Y+6+1
0016ac 5ea4      	SUBI R26,LOW(-540)
0016ad 4fbd      	SBCI R27,HIGH(-540)
0016ae e0e0
0016af e0f0
0016b0 e060
0016b1 e070      	__GETD1N 0x0
0016b2 940e 1ece 	CALL __PUTDP1
                 ;    3576 		sp = _FF_buff + calc_temp + 0x1F;
0016b4 01fa      	MOVW R30,R20
0016b5 57e0      	SUBI R30,LOW(-__FF_buff)
0016b6 4ff6      	SBCI R31,HIGH(-__FF_buff)
0016b7 967f      	ADIW R30,31
0016b8 8bea      	STD  Y+18,R30
0016b9 8bfb      	STD  Y+18+1,R31
                 ;    3577 		for (c=0; c<4; c++)
0016ba e000
0016bb e010      	__GETWRN 16,17,0
                 _0x2BA:
0016bc 3004
0016bd e0e0
0016be 071e      	__CPWRN 16,17,4
0016bf f5a0      	BRSH _0x2BB
                 ;    3578 		{
                 ;    3579 			rp->length <<= 8;
0016c0 81ee      	LDD  R30,Y+6
0016c1 81ff      	LDD  R31,Y+6+1
0016c2 5ee4      	SUBI R30,LOW(-540)
0016c3 4ffd      	SBCI R31,HIGH(-540)
0016c4 93ff      	PUSH R31
0016c5 93ef      	PUSH R30
0016c6 01df      	MOVW R26,R30
0016c7 940e 1ec8 	CALL __GETD1P
0016c9 01df      	MOVW R26,R30
0016ca 01cb      	MOVW R24,R22
0016cb e0e8      	LDI  R30,LOW(8)
0016cc 940e 1dfc 	CALL __LSLD12
0016ce 91af      	POP  R26
0016cf 91bf      	POP  R27
0016d0 940e 1ece 	CALL __PUTDP1
                 ;    3580 			rp->length |= *sp--;
0016d2 81ee      	LDD  R30,Y+6
0016d3 81ff      	LDD  R31,Y+6+1
0016d4 5ee4      	SUBI R30,LOW(-540)
0016d5 4ffd      	SBCI R31,HIGH(-540)
0016d6 010f      	MOVW R0,R30
0016d7 01df      	MOVW R26,R30
0016d8 940e 1ec8 	CALL __GETD1P
0016da 937f      	PUSH R23
0016db 936f      	PUSH R22
0016dc 93ff      	PUSH R31
0016dd 93ef      	PUSH R30
0016de 89aa      	LDD  R26,Y+18
0016df 89bb      	LDD  R27,Y+18+1
0016e0 9711      	SBIW R26,1
0016e1 8baa      	STD  Y+18,R26
0016e2 8bbb      	STD  Y+18+1,R27
0016e3 9611      	ADIW R26,1
0016e4 91ec      	LD   R30,X
0016e5 91af      	POP  R26
0016e6 91bf      	POP  R27
0016e7 918f      	POP  R24
0016e8 919f      	POP  R25
0016e9 27ff      	CLR  R31
0016ea 2766      	CLR  R22
0016eb 2777      	CLR  R23
0016ec 940e 1dea 	CALL __ORD12
0016ee 01d0      	MOVW R26,R0
0016ef 940e 1ece 	CALL __PUTDP1
                 ;    3581 		}
0016f1 5f0f
0016f2 4f1f      	__ADDWRN 16,17,1
0016f3 cfc8      	RJMP _0x2BA
                 _0x2BB:
                 ;    3582 		// Set Current Position to 0
                 ;    3583 		rp->position = 0;
0016f4 81ae      	LDD  R26,Y+6
0016f5 81bf      	LDD  R27,Y+6+1
0016f6 5ea0      	SUBI R26,LOW(-544)
0016f7 4fbd      	SBCI R27,HIGH(-544)
0016f8 e0e0
0016f9 e0f0
0016fa e060
0016fb e070      	__GETD1N 0x0
0016fc 940e 1ece 	CALL __PUTDP1
                 ;    3584 		#ifndef _READ_ONLY_
                 ;    3585 			if (MODE==WRITE)
0016fe a1aa      	LDD  R26,Y+34
0016ff 30a2      	CPI  R26,LOW(0x2)
001700 f011      	BREQ PC+3
001701 940c 176a 	JMP _0x2BC
                 ;    3586 			{	// Change file to blank
                 ;    3587 				sp = _FF_buff + calc_temp + 0x1F;
001703 01fa      	MOVW R30,R20
001704 57e0      	SUBI R30,LOW(-__FF_buff)
001705 4ff6      	SBCI R31,HIGH(-__FF_buff)
001706 967f      	ADIW R30,31
001707 8bea      	STD  Y+18,R30
001708 8bfb      	STD  Y+18+1,R31
                 ;    3588 				for (c=0; c<6; c++)
001709 e000
00170a e010      	__GETWRN 16,17,0
                 _0x2BE:
00170b 3006
00170c e0e0
00170d 071e      	__CPWRN 16,17,6
00170e f458      	BRSH _0x2BF
                 ;    3589 					*sp-- = 0;
00170f 89aa      	LDD  R26,Y+18
001710 89bb      	LDD  R27,Y+18+1
001711 9711      	SBIW R26,1
001712 8baa      	STD  Y+18,R26
001713 8bbb      	STD  Y+18+1,R27
001714 9611      	ADIW R26,1
001715 e0e0      	LDI  R30,LOW(0)
001716 93ec      	ST   X,R30
                 ;    3590 				if (rp->length)
001717 5f0f
001718 4f1f      	__ADDWRN 16,17,1
001719 cff1      	RJMP _0x2BE
                 _0x2BF:
00171a 81ae      	LDD  R26,Y+6
00171b 81bf      	LDD  R27,Y+6+1
00171c 5ea4      	SUBI R26,LOW(-540)
00171d 4fbd      	SBCI R27,HIGH(-540)
00171e 940e 1ec8 	CALL __GETD1P
001720 940e 1f18 	CALL __CPD10
001722 f411      	BRNE PC+3
001723 940c 176a 	JMP _0x2C0
                 ;    3591 				{
                 ;    3592 					if (_FF_write(_FF_DIR_ADDR + (0x200 * s))==0)
001725 01f9      	MOVW R30,R18
001726 0fee      	LSL  R30
001727 1fff      	ROL  R31
001728 2ffe      	MOV  R31,R30
001729 e0e0      	LDI  R30,0
00172a 91a0 0bbd 	LDS  R26,__FF_DIR_ADDR
00172c 91b0 0bbe 	LDS  R27,__FF_DIR_ADDR+1
00172e 9180 0bbf 	LDS  R24,__FF_DIR_ADDR+2
001730 9190 0bc0 	LDS  R25,__FF_DIR_ADDR+3
001732 2766      	CLR  R22
001733 2777      	CLR  R23
001734 940e 1dd6 	CALL __ADDD12
001736 940e 1ed7 	CALL __PUTPARD1
001738 940e 0c05 	CALL __FF_write
00173a 30e0      	CPI  R30,0
00173b f4a9      	BRNE _0x2C1
                 ;    3593 					{
                 ;    3594 						free(rp);
00173c 81ee      	LDD  R30,Y+6
00173d 81ff      	LDD  R31,Y+6+1
00173e 93fa      	ST   -Y,R31
00173f 93ea      	ST   -Y,R30
001740 940e 1d53 	CALL _free
                 ;    3595 						_FF_DIR_ADDR = addr_temp;
001742 85ec
001743 85fd
001744 856e
001745 857f      	__GETD1S 12
001746 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001748 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00174a 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
00174c 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3596 						return (0);
00174e e0e0      	LDI  R30,LOW(0)
00174f e0f0      	LDI  R31,HIGH(0)
001750 c2cd      	RJMP _0x41B
                 ;    3597 					}
                 ;    3598 					rp->length = 0;
                 _0x2C1:
001751 81ae      	LDD  R26,Y+6
001752 81bf      	LDD  R27,Y+6+1
001753 5ea4      	SUBI R26,LOW(-540)
001754 4fbd      	SBCI R27,HIGH(-540)
001755 e0e0
001756 e0f0
001757 e060
001758 e070      	__GETD1N 0x0
001759 940e 1ece 	CALL __PUTDP1
                 ;    3599 					erase_clus_chain(rp->clus_start);
00175b 81ee      	LDD  R30,Y+6
00175c 81ff      	LDD  R31,Y+6+1
00175d 85a4      	LDD  R26,Z+12
00175e 85b5      	LDD  R27,Z+13
00175f 93ba      	ST   -Y,R27
001760 93aa      	ST   -Y,R26
001761 940e 12b2 	CALL _erase_clus_chain
                 ;    3600 					rp->clus_start = 0;
001763 81ae      	LDD  R26,Y+6
001764 81bf      	LDD  R27,Y+6+1
001765 961c      	ADIW R26,12
001766 e0e0      	LDI  R30,LOW(0)
001767 e0f0      	LDI  R31,HIGH(0)
001768 93ed      	ST   X+,R30
001769 93fc      	ST   X,R31
                 ;    3601 				}
                 ;    3602 			}
                 _0x2C0:
                 ;    3603 		#endif
                 ;    3604 		// Set and save next cluster #
                 ;    3605 		rp->clus_next = next_cluster(rp->clus_current, SINGLE);
                 _0x2BC:
00176a 81ee      	LDD  R30,Y+6
00176b 81ff      	LDD  R31,Y+6+1
00176c 85a6      	LDD  R26,Z+14
00176d 85b7      	LDD  R27,Z+15
00176e 93ba      	ST   -Y,R27
00176f 93aa      	ST   -Y,R26
001770 e0e1      	LDI  R30,LOW(1)
001771 93ea      	ST   -Y,R30
001772 940e 0fa7 	CALL _next_cluster
001774 81ae
001775 81bf
001776 9650
001777 93ed
001778 93fc      	__PUTW1SNS 6,16
                 ;    3606 		if ((rp->length==0) && (rp->clus_start==0))
001779 81ae      	LDD  R26,Y+6
00177a 81bf      	LDD  R27,Y+6+1
00177b 5ea4      	SUBI R26,LOW(-540)
00177c 4fbd      	SBCI R27,HIGH(-540)
00177d 940e 1ec8 	CALL __GETD1P
00177f 940e 1f18 	CALL __CPD10
001781 f439      	BRNE _0x2C3
001782 81ae      	LDD  R26,Y+6
001783 81bf      	LDD  R27,Y+6+1
001784 961c      	ADIW R26,12
001785 940e 1ec4 	CALL __GETW1P
001787 9730      	SBIW R30,0
001788 f009      	BREQ _0x2C4
                 _0x2C3:
001789 c01d      	RJMP _0x2C2
                 _0x2C4:
                 ;    3607 		{	// Check for Blank File 
                 ;    3608 			if (MODE==READ)
00178a a1aa      	LDD  R26,Y+34
00178b 30a1      	CPI  R26,LOW(0x1)
00178c f4c1      	BRNE _0x2C5
                 ;    3609 			{	// IF trying to open a blank file to read, ERROR
                 ;    3610 				_FF_error = MODE_ERR;
00178d e0eb      	LDI  R30,LOW(11)
00178e 93e0 0bd3 	STS  __FF_error,R30
                 ;    3611 				free(rp);
001790 81ee      	LDD  R30,Y+6
001791 81ff      	LDD  R31,Y+6+1
001792 93fa      	ST   -Y,R31
001793 93ea      	ST   -Y,R30
001794 940e 1d53 	CALL _free
                 ;    3612 				_FF_DIR_ADDR = addr_temp;
001796 85ec
001797 85fd
001798 856e
001799 857f      	__GETD1S 12
00179a 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00179c 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00179e 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0017a0 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3613 				return (0);
0017a2 e0e0      	LDI  R30,LOW(0)
0017a3 e0f0      	LDI  R31,HIGH(0)
0017a4 c279      	RJMP _0x41B
                 ;    3614 			}
                 ;    3615 			//Setup blank FILE characteristics
                 ;    3616 			#ifndef _READ_ONLY_
                 ;    3617 				MODE = WRITE; 
                 _0x2C5:
0017a5 e0e2      	LDI  R30,LOW(2)
0017a6 a3ea      	STD  Y+34,R30
                 ;    3618 			#endif
                 ;    3619 		}
                 ;    3620 		// Save the file offset to read entry
                 ;    3621 		rp->entry_sec_addr = path_addr_temp;
                 _0x2C2:
0017a7 85e8
0017a8 85f9
0017a9 856a
0017aa 857b      	__GETD1S 8
0017ab 81ae
0017ac 81bf
0017ad 9656
0017ae 940e 1ece 	__PUTD1SNS 6,22
                 ;    3622 		rp->entry_offset =  calc_temp;
0017b0 01fa      	MOVW R30,R20
0017b1 81ae
0017b2 81bf
0017b3 965a
0017b4 93ed
0017b5 93fc      	__PUTW1SNS 6,26
                 ;    3623 		// Set sector offset to 1
                 ;    3624 		rp->sec_offset = 1;
0017b6 81ae      	LDD  R26,Y+6
0017b7 81bf      	LDD  R27,Y+6+1
0017b8 9654      	ADIW R26,20
0017b9 e0e1      	LDI  R30,LOW(1)
0017ba e0f0      	LDI  R31,HIGH(1)
0017bb 93ed      	ST   X+,R30
0017bc 93fc      	ST   X,R31
                 ;    3625 		if (MODE==APPEND)
0017bd a1aa      	LDD  R26,Y+34
0017be 30a3      	CPI  R26,LOW(0x3)
0017bf f539      	BRNE _0x2C6
                 ;    3626 		{
                 ;    3627 			if (fseek(rp, 0,SEEK_END)==EOF)
0017c0 81ee      	LDD  R30,Y+6
0017c1 81ff      	LDD  R31,Y+6+1
0017c2 93fa      	ST   -Y,R31
0017c3 93ea      	ST   -Y,R30
0017c4 e0e0
0017c5 e0f0
0017c6 e060
0017c7 e070      	__GETD1N 0x0
0017c8 940e 1ed7 	CALL __PUTPARD1
0017ca e0e1      	LDI  R30,LOW(1)
0017cb 93ea      	ST   -Y,R30
0017cc d2ed      	RCALL _fseek
0017cd 3fef      	CPI  R30,LOW(0xFFFF)
0017ce efaf      	LDI  R26,HIGH(0xFFFF)
0017cf 07fa      	CPC  R31,R26
0017d0 f4a9      	BRNE _0x2C7
                 ;    3628 			{
                 ;    3629 				free(rp);
0017d1 81ee      	LDD  R30,Y+6
0017d2 81ff      	LDD  R31,Y+6+1
0017d3 93fa      	ST   -Y,R31
0017d4 93ea      	ST   -Y,R30
0017d5 940e 1d53 	CALL _free
                 ;    3630 				_FF_DIR_ADDR = addr_temp;
0017d7 85ec
0017d8 85fd
0017d9 856e
0017da 857f      	__GETD1S 12
0017db 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0017dd 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0017df 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0017e1 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3631 				return (0);
0017e3 e0e0      	LDI  R30,LOW(0)
0017e4 e0f0      	LDI  R31,HIGH(0)
0017e5 c238      	RJMP _0x41B
                 ;    3632 			}
                 ;    3633 		}
                 _0x2C7:
                 ;    3634 		else
0017e6 c02e      	RJMP _0x2C8
                 _0x2C6:
                 ;    3635 		{	// Set pointer to the begining of the file
                 ;    3636 			_FF_read(clust_to_addr(rp->clus_current));
0017e7 81ee      	LDD  R30,Y+6
0017e8 81ff      	LDD  R31,Y+6+1
0017e9 85a6      	LDD  R26,Z+14
0017ea 85b7      	LDD  R27,Z+15
0017eb 93ba      	ST   -Y,R27
0017ec 93aa      	ST   -Y,R26
0017ed 940e 0eeb 	CALL _clust_to_addr
0017ef 940e 1ed7 	CALL __PUTPARD1
0017f1 940e 0b5e 	CALL __FF_read
                 ;    3637 			for (c=0; c<BPB_BytsPerSec; c++)
0017f3 e000
0017f4 e010      	__GETWRN 16,17,0
                 _0x2CA:
0017f5 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0017f7 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0017f9 170e      	CP   R16,R30
0017fa 071f      	CPC  R17,R31
0017fb f480      	BRSH _0x2CB
                 ;    3638 				rp->buff[c] = _FF_buff[c];
0017fc 81ee      	LDD  R30,Y+6
0017fd 81ff      	LDD  R31,Y+6+1
0017fe 967c      	ADIW R30,28
0017ff 0fe0      	ADD  R30,R16
001800 1ff1      	ADC  R31,R17
001801 010f      	MOVW R0,R30
001802 e9a0      	LDI  R26,LOW(__FF_buff)
001803 e0b9      	LDI  R27,HIGH(__FF_buff)
001804 0fa0      	ADD  R26,R16
001805 1fb1      	ADC  R27,R17
001806 91ec      	LD   R30,X
001807 01d0      	MOVW R26,R0
001808 93ec      	ST   X,R30
                 ;    3639 			rp->pntr = &rp->buff[0];
001809 5f0f
00180a 4f1f      	__ADDWRN 16,17,1
00180b cfe9      	RJMP _0x2CA
                 _0x2CB:
00180c 81ee      	LDD  R30,Y+6
00180d 81ff      	LDD  R31,Y+6+1
00180e 967c      	ADIW R30,28
00180f 81ae
001810 81bf
001811 5da9
001812 4fbd
001813 93ed
001814 93fc      	__PUTW1SN 6,551
                 ;    3640 		}
                 _0x2C8:
                 ;    3641 		#ifndef _READ_ONLY_
                 ;    3642 			#ifndef _SECOND_FAT_ON_
                 ;    3643 				if ((MODE==WRITE) || (MODE==APPEND))
                 ;    3644 					clear_second_FAT();
                 ;    3645 			#endif
                 ;    3646     	#endif
                 ;    3647 		rp->mode = MODE;
001815 a1ea      	LDD  R30,Y+34
001816 81ae
001817 81bf
001818 5dac
001819 4fbd
00181a 93ec      	__PUTB1SN 6,548
                 ;    3648 		_FF_error = NO_ERR;
00181b e0e0      	LDI  R30,LOW(0)
00181c 93e0 0bd3 	STS  __FF_error,R30
                 ;    3649 		_FF_DIR_ADDR = addr_temp;
00181e 85ec
00181f 85fd
001820 856e
001821 857f      	__GETD1S 12
001822 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001824 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001826 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001828 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3650 		return(rp);
00182a 81ee      	LDD  R30,Y+6
00182b 81ff      	LDD  R31,Y+6+1
00182c c1f1      	RJMP _0x41B
                 ;    3651 	}
                 ;    3652 	else
                 _0x2B0:
                 ;    3653 	{                          		
                 ;    3654 		_FF_error = FILE_ERR;
00182d e0e2      	LDI  R30,LOW(2)
00182e 93e0 0bd3 	STS  __FF_error,R30
                 ;    3655 		free(rp);
001830 81ee      	LDD  R30,Y+6
001831 81ff      	LDD  R31,Y+6+1
001832 93fa      	ST   -Y,R31
001833 93ea      	ST   -Y,R30
001834 940e 1d53 	CALL _free
                 ;    3656 		_FF_DIR_ADDR = addr_temp;
001836 85ec
001837 85fd
001838 856e
001839 857f      	__GETD1S 12
00183a 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00183c 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00183e 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001840 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3657 		return(0);
001842 e0e0      	LDI  R30,LOW(0)
001843 e0f0      	LDI  R31,HIGH(0)
001844 c1d9      	RJMP _0x41B
                 ;    3658 	}
                 ;    3659 }
                 ;    3660 
                 ;    3661 #ifndef _READ_ONLY_
                 ;    3662 // Create a file
                 ;    3663 FILE *fcreatec(unsigned char flash *NAMEC, unsigned char MODE)
                 ;    3664 {
                 ;    3665 	unsigned char sd_temp[12];
                 ;    3666 	int c;
                 ;    3667 
                 ;    3668 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+15
                 ;	MODE -> Y+14
                 ;	sd_temp -> Y+2
                 ;	c -> R16,R17
                 ;    3669 		sd_temp[c] = NAMEC[c];
                 ;    3670 	
                 ;    3671 	return (fcreate(sd_temp, MODE));
                 ;    3672 }
                 ;    3673 
                 ;    3674 FILE *fcreate(unsigned char *NAME, unsigned char MODE)
                 ;    3675 {
                 _fcreate:
                 ;    3676 	unsigned char fpath[14];
                 ;    3677 	unsigned int c, s, calc_temp;
                 ;    3678 	unsigned char *sp, *qp;
                 ;    3679 	unsigned long addr_temp, path_addr_temp;
                 ;    3680 	FILE *temp_file_pntr;
                 ;    3681 
                 ;    3682     addr_temp = 0;	// save local dir addr
001845 976c      	SBIW R28,28
001846 940e 1f30 	CALL __SAVELOCR6
                 ;	*NAME -> Y+35
                 ;	MODE -> Y+34
                 ;	fpath -> Y+20
                 ;	c -> R16,R17
                 ;	s -> R18,R19
                 ;	calc_temp -> R20,R21
                 ;	*sp -> Y+18
                 ;	*qp -> Y+16
                 ;	addr_temp -> Y+12
                 ;	path_addr_temp -> Y+8
                 ;	*temp_file_pntr -> Y+6
001848 e0e0
001849 87ec
00184a 87ed
00184b 87ee
00184c 87ef      	__CLRD1S 12
                 ;    3683     
                 ;    3684     if (_FF_checkdir(NAME, &addr_temp, fpath))
00184d a1eb      	LDD  R30,Y+35
00184e a1fc      	LDD  R31,Y+35+1
00184f 93fa      	ST   -Y,R31
001850 93ea      	ST   -Y,R30
001851 01fe      	MOVW R30,R28
001852 963e      	ADIW R30,14
001853 93fa      	ST   -Y,R31
001854 93ea      	ST   -Y,R30
001855 01fe      	MOVW R30,R28
001856 9678      	ADIW R30,24
001857 93fa      	ST   -Y,R31
001858 93ea      	ST   -Y,R30
001859 940e 13ae 	CALL __FF_checkdir
00185b 9730      	SBIW R30,0
00185c f091      	BREQ _0x2D0
                 ;    3685 	{
                 ;    3686 		_FF_error = PATH_ERR;
00185d e0ee      	LDI  R30,LOW(14)
00185e 93e0 0bd3 	STS  __FF_error,R30
                 ;    3687 		_FF_DIR_ADDR = addr_temp;
001860 85ec
001861 85fd
001862 856e
001863 857f      	__GETD1S 12
001864 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001866 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001868 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
00186a 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3688 		return (0);
00186c e0e0      	LDI  R30,LOW(0)
00186d e0f0      	LDI  R31,HIGH(0)
00186e c1af      	RJMP _0x41B
                 ;    3689 	}
                 ;    3690 	if (fpath[0]==0)
                 _0x2D0:
00186f 89ec      	LDD  R30,Y+20
001870 30e0      	CPI  R30,0
001871 f491      	BRNE _0x2D1
                 ;    3691 	{
                 ;    3692 		_FF_error = NAME_ERR; 
001872 e0e5      	LDI  R30,LOW(5)
001873 93e0 0bd3 	STS  __FF_error,R30
                 ;    3693 		_FF_DIR_ADDR = addr_temp;
001875 85ec
001876 85fd
001877 856e
001878 857f      	__GETD1S 12
001879 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00187b 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00187d 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
00187f 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3694 		return (0);
001881 e0e0      	LDI  R30,LOW(0)
001882 e0f0      	LDI  R31,HIGH(0)
001883 c19a      	RJMP _0x41B
                 ;    3695 	}
                 ;    3696     
                 ;    3697 	path_addr_temp = _FF_DIR_ADDR;
                 _0x2D1:
001884 91e0 0bbd 	LDS  R30,__FF_DIR_ADDR
001886 91f0 0bbe 	LDS  R31,__FF_DIR_ADDR+1
001888 9160 0bbf 	LDS  R22,__FF_DIR_ADDR+2
00188a 9170 0bc0 	LDS  R23,__FF_DIR_ADDR+3
00188c 87e8
00188d 87f9
00188e 876a
00188f 877b      	__PUTD1S 8
                 ;    3698 	s = scan_directory(&path_addr_temp, fpath);
001890 01fe      	MOVW R30,R28
001891 9638      	ADIW R30,8
001892 93fa      	ST   -Y,R31
001893 93ea      	ST   -Y,R30
001894 01fe      	MOVW R30,R28
001895 9676      	ADIW R30,22
001896 93fa      	ST   -Y,R31
001897 93ea      	ST   -Y,R30
001898 940e 0cbc 	CALL _scan_directory
00189a 019f      	MOVW R18,R30
                 ;    3699 	if (path_addr_temp==0)
00189b 85e8
00189c 85f9
00189d 856a
00189e 857b      	__GETD1S 8
00189f 940e 1f18 	CALL __CPD10
0018a1 f491      	BRNE _0x2D2
                 ;    3700 	{
                 ;    3701 		_FF_error = NO_ENTRY_AVAL;
0018a2 e0ef      	LDI  R30,LOW(15)
0018a3 93e0 0bd3 	STS  __FF_error,R30
                 ;    3702 		_FF_DIR_ADDR = addr_temp;
0018a5 85ec
0018a6 85fd
0018a7 856e
0018a8 857f      	__GETD1S 12
0018a9 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0018ab 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0018ad 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0018af 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3703 		return (0);
0018b1 e0e0      	LDI  R30,LOW(0)
0018b2 e0f0      	LDI  R31,HIGH(0)
0018b3 c16a      	RJMP _0x41B
                 ;    3704 	}
                 ;    3705 
                 ;    3706 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 _0x2D2:
0018b4 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0018b6 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0018b8 85a8
0018b9 85b9
0018ba 858a
0018bb 859b      	__GETD2S 8
0018bc 2766      	CLR  R22
0018bd 2777      	CLR  R23
0018be 940e 1e9f 	CALL __MODD21U
0018c0 01af      	MOVW R20,R30
                 ;    3707 	path_addr_temp -= calc_temp;
0018c1 01fa      	MOVW R30,R20
0018c2 85a8
0018c3 85b9
0018c4 858a
0018c5 859b      	__GETD2S 8
0018c6 2766      	CLR  R22
0018c7 2777      	CLR  R23
0018c8 940e 1de5 	CALL __SUBD21
0018ca 87a8
0018cb 87b9
0018cc 878a
0018cd 879b      	__PUTD2S 8
                 ;    3708 	if (_FF_read(path_addr_temp)==0)	
0018ce 85e8
0018cf 85f9
0018d0 856a
0018d1 857b      	__GETD1S 8
0018d2 940e 1ed7 	CALL __PUTPARD1
0018d4 940e 0b5e 	CALL __FF_read
0018d6 30e0      	CPI  R30,0
0018d7 f491      	BRNE _0x2D3
                 ;    3709 	{
                 ;    3710 		_FF_error = READ_ERR;
0018d8 e0e4      	LDI  R30,LOW(4)
0018d9 93e0 0bd3 	STS  __FF_error,R30
                 ;    3711 		_FF_DIR_ADDR = addr_temp;
0018db 85ec
0018dc 85fd
0018dd 856e
0018de 857f      	__GETD1S 12
0018df 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0018e1 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0018e3 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0018e5 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3712 		return (0);
0018e7 e0e0      	LDI  R30,LOW(0)
0018e8 e0f0      	LDI  R31,HIGH(0)
0018e9 c134      	RJMP _0x41B
                 ;    3713 	}
                 ;    3714 
                 ;    3715 	// Get the filename into a form we can use to compare
                 ;    3716 	qp = file_name_conversion(fpath);
                 _0x2D3:
0018ea 01fe      	MOVW R30,R28
0018eb 9674      	ADIW R30,20
0018ec 93fa      	ST   -Y,R31
0018ed 93ea      	ST   -Y,R30
0018ee 940e 107c 	CALL _file_name_conversion
0018f0 8be8      	STD  Y+16,R30
0018f1 8bf9      	STD  Y+16+1,R31
                 ;    3717 	if (qp==0)
0018f2 9730      	SBIW R30,0
0018f3 f491      	BRNE _0x2D4
                 ;    3718 	{
                 ;    3719 		_FF_error = NAME_ERR; 
0018f4 e0e5      	LDI  R30,LOW(5)
0018f5 93e0 0bd3 	STS  __FF_error,R30
                 ;    3720 		_FF_DIR_ADDR = addr_temp;
0018f7 85ec
0018f8 85fd
0018f9 856e
0018fa 857f      	__GETD1S 12
0018fb 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0018fd 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0018ff 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001901 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3721 		return (0);
001903 e0e0      	LDI  R30,LOW(0)
001904 e0f0      	LDI  R31,HIGH(0)
001905 c118      	RJMP _0x41B
                 ;    3722 	}
                 ;    3723 	sp = &_FF_buff[calc_temp];
                 _0x2D4:
001906 01fa      	MOVW R30,R20
001907 57e0      	SUBI R30,LOW(-__FF_buff)
001908 4ff6      	SBCI R31,HIGH(-__FF_buff)
001909 8bea      	STD  Y+18,R30
00190a 8bfb      	STD  Y+18+1,R31
                 ;    3724 	
                 ;    3725 	if (s)
00190b 2e02      	MOV  R0,R18
00190c 2a03      	OR   R0,R19
00190d f0d1      	BREQ _0x2D5
                 ;    3726 	{
                 ;    3727 		if ((_FF_buff[calc_temp+0x0B]&0x1)==1)	// is file read only
00190e 01fa      	MOVW R30,R20
00190f 56e5
001910 4ff6      	__ADDW1MN __FF_buff,11
001911 81e0      	LD   R30,Z
001912 70e1      	ANDI R30,LOW(0x1)
001913 30e1      	CPI  R30,LOW(0x1)
001914 f491      	BRNE _0x2D6
                 ;    3728 		{
                 ;    3729 			_FF_error = READONLY_ERR;
001915 e0e6      	LDI  R30,LOW(6)
001916 93e0 0bd3 	STS  __FF_error,R30
                 ;    3730 			_FF_DIR_ADDR = addr_temp;
001918 85ec
001919 85fd
00191a 856e
00191b 857f      	__GETD1S 12
00191c 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00191e 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001920 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001922 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3731 			return (0);
001924 e0e0      	LDI  R30,LOW(0)
001925 e0f0      	LDI  R31,HIGH(0)
001926 c0f7      	RJMP _0x41B
                 ;    3732 		}
                 ;    3733 	}
                 _0x2D6:
                 ;    3734 	else
001927 c0aa      	RJMP _0x2D7
                 _0x2D5:
                 ;    3735 	{
                 ;    3736 		for (c=0; c<11; c++)	// Write Filename
001928 e000
001929 e010      	__GETWRN 16,17,0
                 _0x2D9:
00192a 300b
00192b e0e0
00192c 071e      	__CPWRN 16,17,11
00192d f488      	BRSH _0x2DA
                 ;    3737 			*sp++ = *qp++;
00192e 89ea      	LDD  R30,Y+18
00192f 89fb      	LDD  R31,Y+18+1
001930 9631      	ADIW R30,1
001931 8bea      	STD  Y+18,R30
001932 8bfb      	STD  Y+18+1,R31
001933 9731      	SBIW R30,1
001934 010f      	MOVW R0,R30
001935 89a8      	LDD  R26,Y+16
001936 89b9      	LDD  R27,Y+16+1
001937 91ed      	LD   R30,X+
001938 8ba8      	STD  Y+16,R26
001939 8bb9      	STD  Y+16+1,R27
00193a 01d0      	MOVW R26,R0
00193b 93ec      	ST   X,R30
                 ;    3738 		*sp = 0x20;				// Attribute bit auto set to "ARCHIVE"
00193c 5f0f
00193d 4f1f      	__ADDWRN 16,17,1
00193e cfeb      	RJMP _0x2D9
                 _0x2DA:
00193f 89aa      	LDD  R26,Y+18
001940 89bb      	LDD  R27,Y+18+1
001941 e2e0      	LDI  R30,LOW(32)
001942 93ec      	ST   X,R30
                 ;    3739 		sp++;		
001943 89ea      	LDD  R30,Y+18
001944 89fb      	LDD  R31,Y+18+1
001945 9631      	ADIW R30,1
001946 8bea      	STD  Y+18,R30
001947 8bfb      	STD  Y+18+1,R31
                 ;    3740 		*sp++ = 0;				// Reserved for WinNT
001948 89aa      	LDD  R26,Y+18
001949 89bb      	LDD  R27,Y+18+1
00194a 9611      	ADIW R26,1
00194b 8baa      	STD  Y+18,R26
00194c 8bbb      	STD  Y+18+1,R27
00194d 9711      	SBIW R26,1
00194e e0e0      	LDI  R30,LOW(0)
00194f 93ec      	ST   X,R30
                 ;    3741 		*sp++ = 0;				// Mili-second stamp for create
001950 89aa      	LDD  R26,Y+18
001951 89bb      	LDD  R27,Y+18+1
001952 9611      	ADIW R26,1
001953 8baa      	STD  Y+18,R26
001954 8bbb      	STD  Y+18+1,R27
001955 9711      	SBIW R26,1
001956 93ec      	ST   X,R30
                 ;    3742 	
                 ;    3743 		#ifdef _RTC_ON_
                 ;    3744 			rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
                 ;    3745     	    calc_temp = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
                 ;    3746 			*sp++ = calc_temp&0x00FF;	// File create Time 
                 ;    3747 			*sp++ = (calc_temp&0xFF00) >> 8;
                 ;    3748 			calc_temp = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
                 ;    3749 			*sp++ = calc_temp&0x00FF;	// File create Date
                 ;    3750 			*sp++ = (calc_temp&0xFF00) >> 8;
                 ;    3751 		#else
                 ;    3752 			for (c=0; c<4; c++)
001957 e000
001958 e010      	__GETWRN 16,17,0
                 _0x2DC:
001959 3004
00195a e0e0
00195b 071e      	__CPWRN 16,17,4
00195c f458      	BRSH _0x2DD
                 ;    3753 				*sp++ = 0;
00195d 89aa      	LDD  R26,Y+18
00195e 89bb      	LDD  R27,Y+18+1
00195f 9611      	ADIW R26,1
001960 8baa      	STD  Y+18,R26
001961 8bbb      	STD  Y+18+1,R27
001962 9711      	SBIW R26,1
001963 e0e0      	LDI  R30,LOW(0)
001964 93ec      	ST   X,R30
                 ;    3754 		#endif
                 ;    3755 
                 ;    3756 		*sp++ = 0;				// File access date (2 bytes)
001965 5f0f
001966 4f1f      	__ADDWRN 16,17,1
001967 cff1      	RJMP _0x2DC
                 _0x2DD:
001968 89aa      	LDD  R26,Y+18
001969 89bb      	LDD  R27,Y+18+1
00196a 9611      	ADIW R26,1
00196b 8baa      	STD  Y+18,R26
00196c 8bbb      	STD  Y+18+1,R27
00196d 9711      	SBIW R26,1
00196e e0e0      	LDI  R30,LOW(0)
00196f 93ec      	ST   X,R30
                 ;    3757 		*sp++ = 0;
001970 89aa      	LDD  R26,Y+18
001971 89bb      	LDD  R27,Y+18+1
001972 9611      	ADIW R26,1
001973 8baa      	STD  Y+18,R26
001974 8bbb      	STD  Y+18+1,R27
001975 9711      	SBIW R26,1
001976 93ec      	ST   X,R30
                 ;    3758 		*sp++ = 0;				// 0 for FAT12/16 (2 bytes)
001977 89aa      	LDD  R26,Y+18
001978 89bb      	LDD  R27,Y+18+1
001979 9611      	ADIW R26,1
00197a 8baa      	STD  Y+18,R26
00197b 8bbb      	STD  Y+18+1,R27
00197c 9711      	SBIW R26,1
00197d 93ec      	ST   X,R30
                 ;    3759 		*sp++ = 0;
00197e 89aa      	LDD  R26,Y+18
00197f 89bb      	LDD  R27,Y+18+1
001980 9611      	ADIW R26,1
001981 8baa      	STD  Y+18,R26
001982 8bbb      	STD  Y+18+1,R27
001983 9711      	SBIW R26,1
001984 93ec      	ST   X,R30
                 ;    3760 		for (c=0; c<4; c++)		// Modify time/date
001985 e000
001986 e010      	__GETWRN 16,17,0
                 _0x2DF:
001987 3004
001988 e0e0
001989 071e      	__CPWRN 16,17,4
00198a f458      	BRSH _0x2E0
                 ;    3761 			*sp++ = 0;
00198b 89aa      	LDD  R26,Y+18
00198c 89bb      	LDD  R27,Y+18+1
00198d 9611      	ADIW R26,1
00198e 8baa      	STD  Y+18,R26
00198f 8bbb      	STD  Y+18+1,R27
001990 9711      	SBIW R26,1
001991 e0e0      	LDI  R30,LOW(0)
001992 93ec      	ST   X,R30
                 ;    3762 		*sp++ = 0;				// Starting cluster (2 bytes)
001993 5f0f
001994 4f1f      	__ADDWRN 16,17,1
001995 cff1      	RJMP _0x2DF
                 _0x2E0:
001996 89aa      	LDD  R26,Y+18
001997 89bb      	LDD  R27,Y+18+1
001998 9611      	ADIW R26,1
001999 8baa      	STD  Y+18,R26
00199a 8bbb      	STD  Y+18+1,R27
00199b 9711      	SBIW R26,1
00199c e0e0      	LDI  R30,LOW(0)
00199d 93ec      	ST   X,R30
                 ;    3763 		*sp++ = 0;
00199e 89aa      	LDD  R26,Y+18
00199f 89bb      	LDD  R27,Y+18+1
0019a0 9611      	ADIW R26,1
0019a1 8baa      	STD  Y+18,R26
0019a2 8bbb      	STD  Y+18+1,R27
0019a3 9711      	SBIW R26,1
0019a4 93ec      	ST   X,R30
                 ;    3764 		for (c=0; c<4; c++)
0019a5 e000
0019a6 e010      	__GETWRN 16,17,0
                 _0x2E2:
0019a7 3004
0019a8 e0e0
0019a9 071e      	__CPWRN 16,17,4
0019aa f458      	BRSH _0x2E3
                 ;    3765 			*sp++ = 0;			// File length (0 for new)
0019ab 89aa      	LDD  R26,Y+18
0019ac 89bb      	LDD  R27,Y+18+1
0019ad 9611      	ADIW R26,1
0019ae 8baa      	STD  Y+18,R26
0019af 8bbb      	STD  Y+18+1,R27
0019b0 9711      	SBIW R26,1
0019b1 e0e0      	LDI  R30,LOW(0)
0019b2 93ec      	ST   X,R30
                 ;    3766 	
                 ;    3767 		if (_FF_write(path_addr_temp)==0)
0019b3 5f0f
0019b4 4f1f      	__ADDWRN 16,17,1
0019b5 cff1      	RJMP _0x2E2
                 _0x2E3:
0019b6 85e8
0019b7 85f9
0019b8 856a
0019b9 857b      	__GETD1S 8
0019ba 940e 1ed7 	CALL __PUTPARD1
0019bc 940e 0c05 	CALL __FF_write
0019be 30e0      	CPI  R30,0
0019bf f491      	BRNE _0x2E4
                 ;    3768 		{
                 ;    3769 			_FF_error = WRITE_ERR;
0019c0 e0e3      	LDI  R30,LOW(3)
0019c1 93e0 0bd3 	STS  __FF_error,R30
                 ;    3770 			_FF_DIR_ADDR = addr_temp;
0019c3 85ec
0019c4 85fd
0019c5 856e
0019c6 857f      	__GETD1S 12
0019c7 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0019c9 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0019cb 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0019cd 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3771 			return (0);				
0019cf e0e0      	LDI  R30,LOW(0)
0019d0 e0f0      	LDI  R31,HIGH(0)
0019d1 c04c      	RJMP _0x41B
                 ;    3772 		}
                 ;    3773 	}
                 _0x2E4:
                 _0x2D7:
                 ;    3774 	_FF_DIR_ADDR = addr_temp;
0019d2 85ec
0019d3 85fd
0019d4 856e
0019d5 857f      	__GETD1S 12
0019d6 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0019d8 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0019da 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0019dc 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3775 	temp_file_pntr = fopen(NAME, WRITE);
0019de a1eb      	LDD  R30,Y+35
0019df a1fc      	LDD  R31,Y+35+1
0019e0 93fa      	ST   -Y,R31
0019e1 93ea      	ST   -Y,R30
0019e2 e0e2      	LDI  R30,LOW(2)
0019e3 93ea      	ST   -Y,R30
0019e4 940e 154d 	CALL _fopen
0019e6 83ee      	STD  Y+6,R30
0019e7 83ff      	STD  Y+6+1,R31
                 ;    3776 	if (temp_file_pntr == 0)	// Will file open
0019e8 9730      	SBIW R30,0
0019e9 f419      	BRNE _0x2E5
                 ;    3777 		return (0);				
0019ea e0e0      	LDI  R30,LOW(0)
0019eb e0f0      	LDI  R31,HIGH(0)
0019ec c031      	RJMP _0x41B
                 ;    3778 	if (MODE)
                 _0x2E5:
0019ed a1ea      	LDD  R30,Y+34
0019ee 30e0      	CPI  R30,0
0019ef f149      	BREQ _0x2E6
                 ;    3779 	{
                 ;    3780 		if (_FF_read(addr_temp)==0)
0019f0 85ec
0019f1 85fd
0019f2 856e
0019f3 857f      	__GETD1S 12
0019f4 940e 1ed7 	CALL __PUTPARD1
0019f6 940e 0b5e 	CALL __FF_read
0019f8 30e0      	CPI  R30,0
0019f9 f431      	BRNE _0x2E7
                 ;    3781 		{
                 ;    3782 			_FF_error = READ_ERR;
0019fa e0e4      	LDI  R30,LOW(4)
0019fb 93e0 0bd3 	STS  __FF_error,R30
                 ;    3783 			return (0);
0019fd e0e0      	LDI  R30,LOW(0)
0019fe e0f0      	LDI  R31,HIGH(0)
0019ff c01e      	RJMP _0x41B
                 ;    3784 		}
                 ;    3785 		_FF_buff[calc_temp+12] |= MODE;		
                 _0x2E7:
001a00 01fa      	MOVW R30,R20
001a01 56e4
001a02 4ff6      	__ADDW1MN __FF_buff,12
001a03 010f      	MOVW R0,R30
001a04 81e0      	LD   R30,Z
001a05 a1aa      	LDD  R26,Y+34
001a06 2bea      	OR   R30,R26
001a07 01d0      	MOVW R26,R0
001a08 93ec      	ST   X,R30
                 ;    3786 		if (_FF_write(addr_temp)==0)
001a09 85ec
001a0a 85fd
001a0b 856e
001a0c 857f      	__GETD1S 12
001a0d 940e 1ed7 	CALL __PUTPARD1
001a0f 940e 0c05 	CALL __FF_write
001a11 30e0      	CPI  R30,0
001a12 f431      	BRNE _0x2E8
                 ;    3787 		{
                 ;    3788 			_FF_error = WRITE_ERR;
001a13 e0e3      	LDI  R30,LOW(3)
001a14 93e0 0bd3 	STS  __FF_error,R30
                 ;    3789 			return (0);
001a16 e0e0      	LDI  R30,LOW(0)
001a17 e0f0      	LDI  R31,HIGH(0)
001a18 c005      	RJMP _0x41B
                 ;    3790 		}
                 ;    3791 	}
                 _0x2E8:
                 ;    3792 	_FF_error = NO_ERR;
                 _0x2E6:
001a19 e0e0      	LDI  R30,LOW(0)
001a1a 93e0 0bd3 	STS  __FF_error,R30
                 ;    3793 	return (temp_file_pntr);
001a1c 81ee      	LDD  R30,Y+6
001a1d 81ff      	LDD  R31,Y+6+1
                 _0x41B:
001a1e 940e 1f37 	CALL __LOADLOCR6
001a20 96a5      	ADIW R28,37
001a21 9508      	RET
                 ;    3794 }
                 ;    3795 #endif
                 ;    3796 
                 ;    3797 #ifndef _READ_ONLY_
                 ;    3798 // Open a file, name stored in string fileopen
                 ;    3799 int removec(unsigned char flash *NAMEC)
                 ;    3800 {
                 ;    3801 	int c;
                 ;    3802 	unsigned char sd_temp[12];
                 ;    3803 	
                 ;    3804 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+14
                 ;	c -> R16,R17
                 ;	sd_temp -> Y+2
                 ;    3805 		sd_temp[c] = NAMEC[c];
                 ;    3806 	
                 ;    3807 	c = remove(sd_temp);
                 ;    3808 	return (c);
                 ;    3809 }
                 ;    3810 
                 ;    3811 // Remove a file from the root directory
                 ;    3812 int remove(unsigned char *NAME)
                 ;    3813 {
                 ;    3814 	unsigned char fpath[14];
                 ;    3815 	unsigned int s, calc_temp;
                 ;    3816 	unsigned long addr_temp, path_addr_temp;
                 ;    3817 	
                 ;    3818 	#ifndef _SECOND_FAT_ON_
                 ;    3819 		clear_second_FAT();
                 ;    3820     #endif
                 ;    3821     
                 ;    3822     addr_temp = 0;	// save local dir addr
                 ;	*NAME -> Y+26
                 ;	fpath -> Y+12
                 ;	s -> R16,R17
                 ;	calc_temp -> R18,R19
                 ;	addr_temp -> Y+8
                 ;	path_addr_temp -> Y+4
                 ;    3823     
                 ;    3824     if (_FF_checkdir(NAME, &addr_temp, fpath))
                 ;    3825 	{
                 ;    3826 		_FF_error = PATH_ERR;
                 ;    3827 		_FF_DIR_ADDR = addr_temp;
                 ;    3828 		return (EOF);
                 ;    3829 	}
                 ;    3830 	if (fpath[0]==0)
                 ;    3831 	{
                 ;    3832 		_FF_error = NAME_ERR; 
                 ;    3833 		_FF_DIR_ADDR = addr_temp;
                 ;    3834 		return (EOF);
                 ;    3835 	}
                 ;    3836     
                 ;    3837 	path_addr_temp = _FF_DIR_ADDR;
                 ;    3838 	s = scan_directory(&path_addr_temp, fpath);
                 ;    3839 	if ((path_addr_temp==0) || (s==0))
                 ;    3840 	{
                 ;    3841 		_FF_error = NO_ENTRY_AVAL;
                 ;    3842 		_FF_DIR_ADDR = addr_temp;
                 ;    3843 		return (EOF);
                 ;    3844 	}
                 ;    3845 	_FF_DIR_ADDR = addr_temp;		// Reset current dir
                 ;    3846 
                 ;    3847 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    3848 	path_addr_temp -= calc_temp;
                 ;    3849 	if (_FF_read(path_addr_temp)==0)	
                 ;    3850 	{
                 ;    3851 		_FF_error = READ_ERR;
                 ;    3852 		return (EOF);
                 ;    3853 	}
                 ;    3854 	
                 ;    3855 	// Erase entry (put 0xE5 into start of the filename
                 ;    3856 	_FF_buff[calc_temp] = 0xE5;
                 ;    3857 	if (_FF_write(path_addr_temp)==0)
                 ;    3858 	{
                 ;    3859 		_FF_error = WRITE_ERR;
                 ;    3860 		return (EOF);
                 ;    3861 	}
                 ;    3862 	// Save Starting Cluster
                 ;    3863 	calc_temp = ((int) _FF_buff[calc_temp+0x1B] << 8) | (int) _FF_buff[calc_temp+0x1A];
                 ;    3864 	// Destroy cluster chain
                 ;    3865 	if (calc_temp)
                 ;    3866 		if (erase_clus_chain(calc_temp) == 0)
                 ;    3867 			return (EOF);
                 ;    3868 			
                 ;    3869 	return (1);
                 ;    3870 }
                 ;    3871 #endif
                 ;    3872 
                 ;    3873 #ifndef _READ_ONLY_
                 ;    3874 // Rename a file in the Root Directory
                 ;    3875 int rename(unsigned char *NAME_OLD, unsigned char *NAME_NEW)
                 ;    3876 {
                 ;    3877 	unsigned char c;
                 ;    3878 	unsigned int calc_temp;
                 ;    3879 	unsigned long addr_temp, path_addr_temp;
                 ;    3880 	unsigned char *sp, *qp;
                 ;    3881 	unsigned char fpath[14];
                 ;    3882 
                 ;    3883 	// Get the filename into a form we can use to compare
                 ;    3884 	qp = file_name_conversion(NAME_NEW);
                 ;	*NAME_OLD -> Y+31
                 ;	*NAME_NEW -> Y+29
                 ;	c -> R16
                 ;	calc_temp -> R17,R18
                 ;	addr_temp -> Y+25
                 ;	path_addr_temp -> Y+21
                 ;	*sp -> R19,R20
                 ;	*qp -> Y+19
                 ;	fpath -> Y+5
                 ;    3885 	if (qp==0)
                 ;    3886 	{
                 ;    3887 		_FF_error = NAME_ERR;
                 ;    3888 		return (EOF);
                 ;    3889 	}
                 ;    3890 	
                 ;    3891     addr_temp = 0;	// save local dir addr
                 ;    3892     
                 ;    3893     if (_FF_checkdir(NAME_OLD, &addr_temp, fpath))
                 ;    3894 	{
                 ;    3895 		_FF_error = PATH_ERR;
                 ;    3896 		_FF_DIR_ADDR = addr_temp;
                 ;    3897 		return (EOF);
                 ;    3898 	}
                 ;    3899 	if (fpath[0]==0)
                 ;    3900 	{
                 ;    3901 		_FF_error = NAME_ERR; 
                 ;    3902 		_FF_DIR_ADDR = addr_temp;
                 ;    3903 		return (EOF);
                 ;    3904 	}
                 ;    3905 
                 ;    3906 	path_addr_temp = _FF_DIR_ADDR;
                 ;    3907 	calc_temp = scan_directory(&path_addr_temp, NAME_NEW);
                 ;    3908 	if (calc_temp)
                 ;    3909 	{	// does new name alread exist?
                 ;    3910 		_FF_DIR_ADDR = addr_temp;
                 ;    3911 		_FF_error = EXIST_ERR;
                 ;    3912 		return (EOF);
                 ;    3913 	}
                 ;    3914 
                 ;    3915 	path_addr_temp = _FF_DIR_ADDR;
                 ;    3916 	calc_temp = scan_directory(&path_addr_temp, fpath);
                 ;    3917 	if ((path_addr_temp==0) || (calc_temp==0))
                 ;    3918 	{
                 ;    3919 		_FF_DIR_ADDR = addr_temp;
                 ;    3920 		_FF_error = EXIST_ERR;
                 ;    3921 		return (EOF);
                 ;    3922 	}
                 ;    3923 
                 ;    3924 
                 ;    3925 	_FF_DIR_ADDR = addr_temp;		// Reset current dir
                 ;    3926 
                 ;    3927 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    3928 	path_addr_temp -= calc_temp;
                 ;    3929 	if (_FF_read(path_addr_temp)==0)	
                 ;    3930 	{
                 ;    3931 		_FF_error = READ_ERR;
                 ;    3932 		return (EOF);
                 ;    3933 	}
                 ;    3934 	
                 ;    3935 	// Rename entry
                 ;    3936 	sp = &_FF_buff[calc_temp];
                 ;    3937 	for (c=0; c<11; c++)
                 ;    3938 		*sp++ = *qp++;
                 ;    3939 	if (_FF_write(path_addr_temp)==0)
                 ;    3940 		return (EOF);
                 ;    3941 
                 ;    3942 	return(0);
                 ;    3943 }
                 ;    3944 #endif
                 ;    3945 
                 ;    3946 #ifndef _READ_ONLY_
                 ;    3947 // Save Contents of file, w/o closing
                 ;    3948 int fflush(FILE *rp)	
                 ;    3949 {
                 _fflush:
                 ;    3950 	unsigned int  n;
                 ;    3951 	unsigned long addr_temp;
                 ;    3952 	
                 ;    3953 	if ((rp==NULL) || (rp->mode==READ))
001a22 9724      	SBIW R28,4
001a23 931a      	ST   -Y,R17
001a24 930a      	ST   -Y,R16
                 ;	*rp -> Y+6
                 ;	n -> R16,R17
                 ;	addr_temp -> Y+2
001a25 81ae      	LDD  R26,Y+6
001a26 81bf      	LDD  R27,Y+6+1
001a27 940e 1f1c 	CALL __CPW02
001a29 f029      	BREQ _0x302
001a2a 5dac      	SUBI R26,LOW(-548)
001a2b 4fbd      	SBCI R27,HIGH(-548)
001a2c 91ac      	LD   R26,X
001a2d 30a1      	CPI  R26,LOW(0x1)
001a2e f419      	BRNE _0x301
                 _0x302:
                 ;    3954 		return (EOF);
001a2f efef      	LDI  R30,LOW(65535)
001a30 efff      	LDI  R31,HIGH(65535)
001a31 c063      	RJMP _0x41A
                 ;    3955 	
                 ;    3956 	if ((rp->mode==WRITE) || (rp->mode==APPEND))
                 _0x301:
001a32 81ae      	LDD  R26,Y+6
001a33 81bf      	LDD  R27,Y+6+1
001a34 5dac      	SUBI R26,LOW(-548)
001a35 4fbd      	SBCI R27,HIGH(-548)
001a36 91ac      	LD   R26,X
001a37 30a2      	CPI  R26,LOW(0x2)
001a38 f041      	BREQ _0x305
001a39 81ae      	LDD  R26,Y+6
001a3a 81bf      	LDD  R27,Y+6+1
001a3b 5dac      	SUBI R26,LOW(-548)
001a3c 4fbd      	SBCI R27,HIGH(-548)
001a3d 91ac      	LD   R26,X
001a3e 30a3      	CPI  R26,LOW(0x3)
001a3f f009      	BREQ _0x305
001a40 c052      	RJMP _0x304
                 _0x305:
                 ;    3957 	{
                 ;    3958 		addr_temp = (clust_to_addr(rp->clus_current) + ((rp->sec_offset-1)*BPB_BytsPerSec));
001a41 81ee      	LDD  R30,Y+6
001a42 81ff      	LDD  R31,Y+6+1
001a43 85a6      	LDD  R26,Z+14
001a44 85b7      	LDD  R27,Z+15
001a45 93ba      	ST   -Y,R27
001a46 93aa      	ST   -Y,R26
001a47 940e 0eeb 	CALL _clust_to_addr
001a49 937f      	PUSH R23
001a4a 936f      	PUSH R22
001a4b 93ff      	PUSH R31
001a4c 93ef      	PUSH R30
001a4d 81ae      	LDD  R26,Y+6
001a4e 81bf      	LDD  R27,Y+6+1
001a4f 9654      	ADIW R26,20
001a50 940e 1ec4 	CALL __GETW1P
001a52 9731      	SBIW R30,1
001a53 91a0 0b96 	LDS  R26,_BPB_BytsPerSec
001a55 91b0 0b97 	LDS  R27,_BPB_BytsPerSec+1
001a57 940e 1e2c 	CALL __MULW12U
001a59 91af      	POP  R26
001a5a 91bf      	POP  R27
001a5b 918f      	POP  R24
001a5c 919f      	POP  R25
001a5d 2766      	CLR  R22
001a5e 2777      	CLR  R23
001a5f 940e 1dd6 	CALL __ADDD12
001a61 83ea
001a62 83fb
001a63 836c
001a64 837d      	__PUTD1S 2
                 ;    3959 		for (n=0; n<BPB_BytsPerSec; n++)	// Save file buffer to SD buffer
001a65 e000
001a66 e010      	__GETWRN 16,17,0
                 _0x308:
001a67 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001a69 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001a6b 170e      	CP   R16,R30
001a6c 071f      	CPC  R17,R31
001a6d f468      	BRSH _0x309
                 ;    3960 			_FF_buff[n] = rp->buff[n];
001a6e 01d8      	MOVW R26,R16
001a6f 57a0      	SUBI R26,LOW(-__FF_buff)
001a70 4fb6      	SBCI R27,HIGH(-__FF_buff)
001a71 81ee      	LDD  R30,Y+6
001a72 81ff      	LDD  R31,Y+6+1
001a73 967c      	ADIW R30,28
001a74 0fe0      	ADD  R30,R16
001a75 1ff1      	ADC  R31,R17
001a76 81e0      	LD   R30,Z
001a77 93ec      	ST   X,R30
                 ;    3961 		if (_FF_write(addr_temp)==0)	// Write SD buffer to disk
001a78 5f0f
001a79 4f1f      	__ADDWRN 16,17,1
001a7a cfec      	RJMP _0x308
                 _0x309:
001a7b 81ea
001a7c 81fb
001a7d 816c
001a7e 817d      	__GETD1S 2
001a7f 940e 1ed7 	CALL __PUTPARD1
001a81 940e 0c05 	CALL __FF_write
001a83 30e0      	CPI  R30,0
001a84 f419      	BRNE _0x30A
                 ;    3962 			return (EOF);
001a85 efef      	LDI  R30,LOW(65535)
001a86 efff      	LDI  R31,HIGH(65535)
001a87 c00d      	RJMP _0x41A
                 ;    3963 		if (append_toc(rp)==0)	// Update Entry or Error
                 _0x30A:
001a88 81ee      	LDD  R30,Y+6
001a89 81ff      	LDD  R31,Y+6+1
001a8a 93fa      	ST   -Y,R31
001a8b 93ea      	ST   -Y,R30
001a8c 940e 11e4 	CALL _append_toc
001a8e 30e0      	CPI  R30,0
001a8f f419      	BRNE _0x30B
                 ;    3964 			return (EOF);
001a90 efef      	LDI  R30,LOW(65535)
001a91 efff      	LDI  R31,HIGH(65535)
001a92 c002      	RJMP _0x41A
                 ;    3965 	}
                 _0x30B:
                 ;    3966 	
                 ;    3967 	return (0);
                 _0x304:
001a93 e0e0      	LDI  R30,LOW(0)
001a94 e0f0      	LDI  R31,HIGH(0)
                 _0x41A:
001a95 8119      	LDD  R17,Y+1
001a96 8108      	LDD  R16,Y+0
001a97 9628      	ADIW R28,8
001a98 9508      	RET
                 ;    3968 }
                 ;    3969 #endif		
                 ;    3970 
                 ;    3971 
                 ;    3972 // Close an open file
                 ;    3973 int fclose(FILE *rp)	
                 ;    3974 {
                 _fclose:
                 ;    3975 	#ifndef _READ_ONLY_
                 ;    3976 	if (rp->mode!=READ)
001a99 81a8      	LD   R26,Y
001a9a 81b9      	LDD  R27,Y+1
001a9b 5dac      	SUBI R26,LOW(-548)
001a9c 4fbd      	SBCI R27,HIGH(-548)
001a9d 91ac      	LD   R26,X
001a9e 30a1      	CPI  R26,LOW(0x1)
001a9f f069      	BREQ _0x30C
                 ;    3977 		if (fflush(rp)==EOF)
001aa0 81e8      	LD   R30,Y
001aa1 81f9      	LDD  R31,Y+1
001aa2 93fa      	ST   -Y,R31
001aa3 93ea      	ST   -Y,R30
001aa4 940e 1a22 	CALL _fflush
001aa6 3fef      	CPI  R30,LOW(0xFFFF)
001aa7 efaf      	LDI  R26,HIGH(0xFFFF)
001aa8 07fa      	CPC  R31,R26
001aa9 f419      	BRNE _0x30D
                 ;    3978 			return (EOF);
001aaa efef      	LDI  R30,LOW(65535)
001aab efff      	LDI  R31,HIGH(65535)
001aac c00b      	RJMP _0x419
                 ;    3979 	#endif	
                 ;    3980 	// Clear File Structure
                 ;    3981 	free(rp);
                 _0x30D:
                 _0x30C:
001aad 81e8      	LD   R30,Y
001aae 81f9      	LDD  R31,Y+1
001aaf 93fa      	ST   -Y,R31
001ab0 93ea      	ST   -Y,R30
001ab1 940e 1d53 	CALL _free
                 ;    3982 	rp = 0;
001ab3 e0e0      	LDI  R30,0
001ab4 83e8      	STD  Y+0,R30
001ab5 83e9      	STD  Y+0+1,R30
                 ;    3983 	return(0);
001ab6 e0e0      	LDI  R30,LOW(0)
001ab7 e0f0      	LDI  R31,HIGH(0)
                 _0x419:
001ab8 9622      	ADIW R28,2
001ab9 9508      	RET
                 ;    3984 }
                 ;    3985 
                 ;    3986 int ffreemem(FILE *rp)	
                 ;    3987 {
                 ;    3988 	// Clear File Structure
                 ;    3989 	if (rp==0)
                 ;    3990 		return (EOF);
                 ;    3991 	free(rp);
                 ;    3992 	return(0);
                 ;    3993 }
                 ;    3994 
                 ;    3995 int fget_file_infoc(unsigned char flash *NAMEC, unsigned long *F_SIZE, unsigned char *F_CREATE,
                 ;    3996 				unsigned char *F_MODIFY, unsigned char *F_ATTRIBUTE, unsigned int *F_CLUS_START)
                 ;    3997 {
                 ;    3998 	int c;
                 ;    3999 	unsigned char sd_temp[12];
                 ;    4000 	
                 ;    4001 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+24
                 ;	*F_SIZE -> Y+22
                 ;	*F_CREATE -> Y+20
                 ;	*F_MODIFY -> Y+18
                 ;	*F_ATTRIBUTE -> Y+16
                 ;	*F_CLUS_START -> Y+14
                 ;	c -> R16,R17
                 ;	sd_temp -> Y+2
                 ;    4002 		sd_temp[c] = NAMEC[c];
                 ;    4003 	
                 ;    4004 	c = fget_file_info(sd_temp, F_SIZE, F_CREATE, F_MODIFY, F_ATTRIBUTE, F_CLUS_START);
                 ;    4005 	return (c);
                 ;    4006 }
                 ;    4007 
                 ;    4008 int fget_file_info(unsigned char *NAME, unsigned long *F_SIZE, unsigned char *F_CREATE,
                 ;    4009 				unsigned char *F_MODIFY, unsigned char *F_ATTRIBUTE, unsigned int *F_CLUS_START)
                 ;    4010 {
                 ;    4011 	unsigned char n;
                 ;    4012 	unsigned int s, calc_temp;
                 ;    4013 	unsigned long addr_temp, file_calc_temp;
                 ;    4014 	unsigned char *sp, *qp;
                 ;    4015 	
                 ;    4016 	// Get the filename into a form we can use to compare
                 ;    4017 	qp = file_name_conversion(NAME);
                 ;	*NAME -> Y+27
                 ;	*F_SIZE -> Y+25
                 ;	*F_CREATE -> Y+23
                 ;	*F_MODIFY -> Y+21
                 ;	*F_ATTRIBUTE -> Y+19
                 ;	*F_CLUS_START -> Y+17
                 ;	n -> R16
                 ;	s -> R17,R18
                 ;	calc_temp -> R19,R20
                 ;	addr_temp -> Y+13
                 ;	file_calc_temp -> Y+9
                 ;	*sp -> Y+7
                 ;	*qp -> Y+5
                 ;    4018 	if (qp==0)
                 ;    4019 	{
                 ;    4020 		_FF_error = NAME_ERR;
                 ;    4021 		return (EOF);
                 ;    4022 	}
                 ;    4023 	
                 ;    4024 	for (s=0; s<BPB_BytsPerSec; s++)
                 ;    4025 	{	// Scan through directory entries to find file
                 ;    4026 		addr_temp = _FF_DIR_ADDR + (0x200 * s);
                 ;    4027 		if (_FF_read(addr_temp)==0)
                 ;    4028 			return (EOF);
                 ;    4029 		for (n=0; n<16; n++)
                 ;    4030 		{
                 ;    4031 			calc_temp = (int) n * 0x20;
                 ;    4032 			qp = &FILENAME[0];
                 ;    4033 			sp = &_FF_buff[calc_temp];
                 ;    4034 			if (*sp == 0)
                 ;    4035 				return (EOF);
                 ;    4036 			if (strncmp(qp, sp, 11)==0)		// Does this entry == Filename
                 ;    4037 			{
                 ;    4038 				*F_ATTRIBUTE = _FF_buff[calc_temp+11];	// Save ATTRIBUTE Byte to location
                 ;    4039 				*F_SIZE = ((long) _FF_buff[calc_temp+31] << 24) | ((long) _FF_buff[calc_temp+30] << 16)
                 ;    4040 							| ((long) _FF_buff[calc_temp+29] << 8) | ((long) _FF_buff[calc_temp+28]);
                 ;    4041 							// Save SIZE of file to location
                 ;    4042                 *F_CLUS_START = ((unsigned int) _FF_buff[calc_temp+27] << 8) | ((unsigned int) _FF_buff[calc_temp+26]);
                 ;    4043 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+17] << 8) | ((unsigned int) _FF_buff[calc_temp+16]);
                 ;    4044 				qp = F_CREATE;
                 ;    4045 				*qp++ = (((file_calc_temp >> 5) & 0x0F) / 10) + '0';
                 ;    4046 				*qp++ = (((file_calc_temp >> 5) & 0x0F) % 10) + '0';
                 ;    4047 				*qp++ = '/';
                 ;    4048 				*qp++ = ((file_calc_temp & 0x1F) / 10) + '0';
                 ;    4049 				*qp++ = ((file_calc_temp & 0x1F) % 10) + '0';
                 ;    4050 				*qp++ = '/';
                 ;    4051 				file_calc_temp = ((file_calc_temp >> 9) & 0x7F) + 1980;
                 ;    4052 				*qp++ = (file_calc_temp / 1000) + '0';
                 ;    4053 				file_calc_temp %= 1000;
                 ;    4054 				*qp++ = (file_calc_temp / 100) + '0';
                 ;    4055 				file_calc_temp %= 100;
                 ;    4056 				*qp++ = (file_calc_temp / 10) + '0';
                 ;    4057 				*qp++ = (file_calc_temp % 10) + '0';
                 ;    4058 				*qp++ = ' ';
                 ;    4059 				*qp++ = ' ';
                 ;    4060 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+15] << 8) | ((unsigned int) _FF_buff[calc_temp+14]);
                 ;    4061 				*qp++ = (((file_calc_temp >> 11) & 0x1F) / 10) + '0';
                 ;    4062 				*qp++ = (((file_calc_temp >> 11) & 0x1F) % 10) + '0';
                 ;    4063 				*qp++ = ':';
                 ;    4064 				*qp++ = (((file_calc_temp >> 5) & 0x3F) / 10) + '0';
                 ;    4065 				*qp++ = (((file_calc_temp >> 5) & 0x3F) % 10) + '0';
                 ;    4066 				*qp++ = ':';
                 ;    4067 				*qp++ = (((file_calc_temp & 0x1F) * 2) / 10) + '0';
                 ;    4068 				*qp++ = (((file_calc_temp & 0x1F) * 2) % 10) + '0';
                 ;    4069 				*qp = 0;
                 ;    4070 				
                 ;    4071 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+25] << 8) | ((unsigned int) _FF_buff[calc_temp+24]);
                 ;    4072 				qp = F_MODIFY;
                 ;    4073 				*qp++ = (((file_calc_temp >> 5) & 0x0F) / 10) + '0';
                 ;    4074 				*qp++ = (((file_calc_temp >> 5) & 0x0F) % 10) + '0';
                 ;    4075 				*qp++ = '/';
                 ;    4076 				*qp++ = ((file_calc_temp & 0x1F) / 10) + '0';
                 ;    4077 				*qp++ = ((file_calc_temp & 0x1F) % 10) + '0';
                 ;    4078 				*qp++ = '/';
                 ;    4079 				file_calc_temp = ((file_calc_temp >> 9) & 0x7F) + 1980;
                 ;    4080 				*qp++ = (file_calc_temp / 1000) + '0';
                 ;    4081 				file_calc_temp %= 1000;
                 ;    4082 				*qp++ = (file_calc_temp / 100) + '0';
                 ;    4083 				file_calc_temp %= 100;
                 ;    4084 				*qp++ = (file_calc_temp / 10) + '0';
                 ;    4085 				*qp++ = (file_calc_temp % 10) + '0';
                 ;    4086 				*qp++ = ' ';
                 ;    4087 				*qp++ = ' ';
                 ;    4088 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+23] << 8) | ((unsigned int) _FF_buff[calc_temp+22]);
                 ;    4089 				*qp++ = (((file_calc_temp >> 11) & 0x1F) / 10) + '0';
                 ;    4090 				*qp++ = (((file_calc_temp >> 11) & 0x1F) % 10) + '0';
                 ;    4091 				*qp++ = ':';
                 ;    4092 				*qp++ = (((file_calc_temp >> 5) & 0x3F) / 10) + '0';
                 ;    4093 				*qp++ = (((file_calc_temp >> 5) & 0x3F) % 10) + '0';
                 ;    4094 				*qp++ = ':';
                 ;    4095 				*qp++ = (((file_calc_temp & 0x1F) * 2) / 10) + '0';
                 ;    4096 				*qp++ = (((file_calc_temp & 0x1F) * 2) % 10) + '0';
                 ;    4097 				*qp = 0;
                 ;    4098 				
                 ;    4099 				return (0);
                 ;    4100 			}
                 ;    4101 		}                          		
                 ;    4102 	}
                 ;    4103 	_FF_error = FILE_ERR;
                 ;    4104 	return(EOF);
                 ;    4105 }
                 ;    4106 
                 ;    4107 // Get File data and increment file pointer
                 ;    4108 int fgetc(FILE *rp)
                 ;    4109 {
                 ;    4110 	unsigned char get_data;
                 ;    4111 	unsigned int n;
                 ;    4112 	unsigned long addr_temp;
                 ;    4113 	
                 ;    4114 	if (rp==NULL)
                 ;	*rp -> Y+7
                 ;	get_data -> R16
                 ;	n -> R17,R18
                 ;	addr_temp -> Y+3
                 ;    4115 		return (EOF);
                 ;    4116 
                 ;    4117 	if (rp->position == rp->length)
                 ;    4118 	{
                 ;    4119 		rp->error = POS_ERR;
                 ;    4120 		return (EOF);
                 ;    4121 	}
                 ;    4122 	
                 ;    4123 	get_data = *rp->pntr;
                 ;    4124 	
                 ;    4125 	if ((rp->pntr)==(&rp->buff[BPB_BytsPerSec-1]))
                 ;    4126 	{	// Check to see if pointer is at the end of a sector
                 ;    4127 		#ifndef _READ_ONLY_
                 ;    4128 		if ((rp->mode==WRITE) || (rp->mode==APPEND))
                 ;    4129 		{	// if in write or append mode, update the current sector before loading next
                 ;    4130 			for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4131 				_FF_buff[n] = rp->buff[n];
                 ;    4132 			addr_temp = clust_to_addr(rp->clus_current) + (((rp->sec_offset)-1)*BPB_BytsPerSec);
                 ;    4133 			if (_FF_write(addr_temp)==0)
                 ;    4134 				return (EOF);
                 ;    4135 		}
                 ;    4136 		#endif
                 ;    4137 		if (rp->sec_offset < BPB_SecPerClus)
                 ;    4138 		{	// Goto next sector if not at the end of a cluster
                 ;    4139 			addr_temp = clust_to_addr(rp->clus_current) + (rp->sec_offset*BPB_BytsPerSec);
                 ;    4140 			rp->sec_offset++;
                 ;    4141 		}
                 ;    4142 		else
                 ;    4143 		{	// End of Cluster, find next
                 ;    4144 			if (rp->clus_next>=0xFFF8)	// No next cluster, EOF marker
                 ;    4145 			{
                 ;    4146 				rp->EOF_flag = 1;	// Set flag so Putchar knows to get new cluster
                 ;    4147 				rp->position++;		// Only time doing this, position + 1 should equal length
                 ;    4148 				return(get_data);
                 ;    4149 			}
                 ;    4150 			addr_temp = clust_to_addr(rp->clus_next);
                 ;    4151 			rp->sec_offset = 1;
                 ;    4152 			rp->clus_prev = rp->clus_current;
                 ;    4153 			rp->clus_current = rp->clus_next;
                 ;    4154 			rp->clus_next = next_cluster(rp->clus_current, SINGLE);
                 ;    4155 		}
                 ;    4156 		if (_FF_read(addr_temp)==0)
                 ;    4157 			return (EOF);
                 ;    4158 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4159 			rp->buff[n] = _FF_buff[n];
                 ;    4160 		rp->pntr = &rp->buff[0];
                 ;    4161 	}
                 ;    4162 	else
                 ;    4163 		rp->pntr++;
                 ;    4164 	
                 ;    4165 	rp->position++;	
                 ;    4166 	return(get_data);		
                 ;    4167 }
                 ;    4168 
                 ;    4169 char *fgets(char *buffer, int n, FILE *rp)
                 ;    4170 {
                 ;    4171 	int c, temp_data;
                 ;    4172 	
                 ;    4173 	for (c=0; c<n; c++)
                 ;	*buffer -> Y+8
                 ;	n -> Y+6
                 ;	*rp -> Y+4
                 ;	c -> R16,R17
                 ;	temp_data -> R18,R19
                 ;    4174 	{
                 ;    4175 		temp_data = fgetc(rp);
                 ;    4176 		*buffer = temp_data & 0xFF;
                 ;    4177 		if (temp_data == '\n')
                 ;    4178 			break;
                 ;    4179 		else if (temp_data == EOF)
                 ;    4180 			break;
                 ;    4181 		buffer++;
                 ;    4182 	}
                 ;    4183 	if (c==n)
                 ;    4184 		buffer++;
                 ;    4185 	*buffer-- = '\0';
                 ;    4186 	if (temp_data == EOF)
                 ;    4187 		return (NULL);
                 ;    4188 	return (buffer);
                 ;    4189 }
                 ;    4190 
                 ;    4191 #ifndef _READ_ONLY_
                 ;    4192 // Decrement file pointer, then get file data
                 ;    4193 int ungetc(unsigned char file_data, FILE *rp)
                 ;    4194 {
                 ;    4195 	unsigned int n;
                 ;    4196 	unsigned long addr_temp;
                 ;    4197 	
                 ;    4198 	if ((rp==NULL) || (rp->position==0))
                 ;	file_data -> Y+8
                 ;	*rp -> Y+6
                 ;	n -> R16,R17
                 ;	addr_temp -> Y+2
                 ;    4199 		return (EOF);
                 ;    4200 	if ((rp->mode!=APPEND) && (rp->mode!=WRITE))
                 ;    4201 		return (EOF);	// needs to be in WRITE or APPEND mode
                 ;    4202 
                 ;    4203 	if (((rp->position) == rp->length) && (rp->EOF_flag))
                 ;    4204 	{	// if the file posisition is equal to the length, return data, turn flag off
                 ;    4205 		rp->EOF_flag = 0;
                 ;    4206 		*rp->pntr = file_data;
                 ;    4207 		return (*rp->pntr);
                 ;    4208 	}
                 ;    4209 	if ((rp->pntr)==(&rp->buff[0]))
                 ;    4210 	{	// Check to see if pointer is at the beginning of a Sector
                 ;    4211 		// Update the current sector before loading next
                 ;    4212 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4213 			_FF_buff[n] = rp->buff[n];
                 ;    4214 		addr_temp = clust_to_addr(rp->clus_current) + (((rp->sec_offset)-1)*BPB_BytsPerSec);
                 ;    4215 		if (_FF_write(addr_temp)==0)
                 ;    4216 			return (EOF);
                 ;    4217 			
                 ;    4218 		if (rp->sec_offset > 1)
                 ;    4219 		{	// Goto previous sector if not at the beginning of a cluster
                 ;    4220 			addr_temp = clust_to_addr(rp->clus_current) + ((rp->sec_offset-2)*BPB_BytsPerSec);
                 ;    4221 			rp->sec_offset--;
                 ;    4222 		}
                 ;    4223 		else
                 ;    4224 		{	// Beginning of Cluster, find previous
                 ;    4225 			if (rp->clus_start==rp->clus_current)
                 ;    4226 			{	// Positioned @ Beginning of File
                 ;    4227 				_FF_error = SOF_ERR;
                 ;    4228 				return(EOF);
                 ;    4229 			}
                 ;    4230 			rp->sec_offset = BPB_SecPerClus;	// Set sector offset to last sector
                 ;    4231 			rp->clus_next = rp->clus_current;
                 ;    4232 			rp->clus_current = rp->clus_prev;
                 ;    4233 			if (rp->clus_current != rp->clus_start)
                 ;    4234 				rp->clus_prev = prev_cluster(rp->clus_current);
                 ;    4235 			else
                 ;    4236 				rp->clus_prev = 0;
                 ;    4237 			addr_temp = clust_to_addr(rp->clus_current) + (((long) BPB_SecPerClus-1) * (long) BPB_BytsPerSec);
                 ;    4238 		}
                 ;    4239 		_FF_read(addr_temp);
                 ;    4240 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4241 			rp->buff[n] = _FF_buff[n];
                 ;    4242 		rp->pntr = &rp->buff[511];
                 ;    4243 	}
                 ;    4244 	else
                 ;    4245 		rp->pntr--;
                 ;    4246 	
                 ;    4247 	rp->position--;
                 ;    4248 	*rp->pntr = file_data;	
                 ;    4249 	return(*rp->pntr);	// Get data	
                 ;    4250 }
                 ;    4251 #endif
                 ;    4252 
                 ;    4253 #ifndef _READ_ONLY_
                 ;    4254 int fputc(unsigned char file_data, FILE *rp)	
                 ;    4255 {
                 ;    4256 	unsigned int n;
                 ;    4257 	unsigned long addr_temp;
                 ;    4258 	
                 ;    4259 	if (rp==NULL)
                 ;	file_data -> Y+8
                 ;	*rp -> Y+6
                 ;	n -> R16,R17
                 ;	addr_temp -> Y+2
                 ;    4260 		return (EOF);
                 ;    4261 
                 ;    4262 	if (rp->mode == READ)
                 ;    4263 	{
                 ;    4264 		_FF_error = READONLY_ERR;
                 ;    4265 		return(EOF);
                 ;    4266 	}
                 ;    4267 	if (rp->length == 0)
                 ;    4268 	{	// Blank file start writing cluster table
                 ;    4269 		rp->clus_start = prev_cluster(0);
                 ;    4270 		rp->clus_next = 0xFFFF;
                 ;    4271 		rp->clus_current = rp->clus_start;
                 ;    4272 		if (write_clus_table(rp->clus_start, rp->clus_next, SINGLE)==0)
                 ;    4273 		{
                 ;    4274 			return (EOF);
                 ;    4275 		}
                 ;    4276 	}
                 ;    4277 	
                 ;    4278 	if ((rp->position==rp->length) && (rp->EOF_flag))
                 ;    4279 	{	// At end of file, and end of cluster, flagged
                 ;    4280 		rp->clus_prev = rp->clus_current;
                 ;    4281 		rp->clus_current = prev_cluster(0);	// Find first cluster pointing to '0'
                 ;    4282 		rp->clus_next = 0xFFFF;
                 ;    4283 		rp->sec_offset = 1;
                 ;    4284 		if (write_clus_table(rp->clus_prev, rp->clus_current, CHAIN)==0)
                 ;    4285 		{
                 ;    4286 			return (EOF);
                 ;    4287 		}
                 ;    4288 		if (write_clus_table(rp->clus_current, rp->clus_next, END_CHAIN)==0)
                 ;    4289 		{
                 ;    4290 			return (EOF);
                 ;    4291 		}
                 ;    4292 		if (append_toc(rp)==0)
                 ;    4293 		{
                 ;    4294 			return (EOF);
                 ;    4295 		}
                 ;    4296 		rp->EOF_flag = 0;
                 ;    4297 		rp->pntr = &rp->buff[0];		
                 ;    4298 	}
                 ;    4299 	
                 ;    4300 	*rp->pntr = file_data;
                 ;    4301 	
                 ;    4302 	if (rp->pntr == &rp->buff[BPB_BytsPerSec-1])
                 ;    4303 	{	// This is on the Sector Limit
                 ;    4304 		if (rp->position > rp->length)
                 ;    4305 		{	// ERROR, position should never be greater than length
                 ;    4306 			_FF_error = 0x10;		// file position ERROR
                 ;    4307 			return (EOF); 
                 ;    4308 		}
                 ;    4309 		// Position is at end of a sector?
                 ;    4310 		
                 ;    4311 		addr_temp = (clust_to_addr(rp->clus_current) + ((rp->sec_offset-1)*BPB_BytsPerSec));
                 ;    4312 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4313 			_FF_buff[n] = rp->buff[n];
                 ;    4314 		_FF_write(addr_temp);
                 ;    4315 			// Save MMC buffer to card, set pointer to begining of new buffer
                 ;    4316 		if (rp->sec_offset < BPB_SecPerClus)
                 ;    4317 		{	// Are there more sectors in this cluster?
                 ;    4318 			addr_temp = clust_to_addr(rp->clus_current) + (rp->sec_offset * BPB_BytsPerSec);
                 ;    4319 			rp->sec_offset++;
                 ;    4320 		}
                 ;    4321 		else
                 ;    4322 		{	// Find next cluster, load first sector into file.buff
                 ;    4323 			if (((rp->clus_next>=0xFFF8)&&(BPB_FATType==0x36)) ||
                 ;    4324 				((rp->clus_next>=0xFF8)&&(BPB_FATType==0x32)))
                 ;    4325 			{	// EOF, need to find new empty cluster
                 ;    4326 				if (rp->position != rp->length)
                 ;    4327 				{	// if not equal there's an error
                 ;    4328 					_FF_error = 0x20;		// EOF position error
                 ;    4329 					return (EOF);
                 ;    4330 				}
                 ;    4331 				rp->EOF_flag = 1;
                 ;    4332 			}
                 ;    4333 			else
                 ;    4334 			{	// Not EOF, find next cluster
                 ;    4335 				rp->clus_prev = rp->clus_current;
                 ;    4336 				rp->clus_current = rp->clus_next;
                 ;    4337 				rp->clus_next = next_cluster(rp->clus_current, SINGLE);
                 ;    4338 			}
                 ;    4339 			rp->sec_offset = 1;
                 ;    4340 			addr_temp = clust_to_addr(rp->clus_current);
                 ;    4341 		}
                 ;    4342 		
                 ;    4343 		if (rp->EOF_flag == 0)
                 ;    4344 		{
                 ;    4345 			if (_FF_read(addr_temp)==0)
                 ;    4346 				return(EOF);
                 ;    4347 			for (n=0; n<512; n++)
                 ;    4348 				rp->buff[n] = _FF_buff[n];
                 ;    4349 			rp->pntr = &rp->buff[0];	// Set pointer to next location				
                 ;    4350 		}
                 ;    4351 		if (rp->length==rp->position)
                 ;    4352 			rp->length++;
                 ;    4353 		if (append_toc(rp)==0)
                 ;    4354 			return(EOF);
                 ;    4355 	}
                 ;    4356 	else
                 ;    4357 	{
                 ;    4358 		rp->pntr++;
                 ;    4359 		if (rp->length==rp->position)
                 ;    4360 			rp->length++;
                 ;    4361 	}
                 ;    4362 	rp->position++;
                 ;    4363 	return(file_data);
                 ;    4364 }
                 ;    4365 
                 ;    4366 int fputs(unsigned char *file_data, FILE *rp)
                 ;    4367 {
                 ;    4368 	while(*file_data)
                 ;    4369 		if (fputc(*file_data++,rp) == EOF)
                 ;    4370 			return (EOF);
                 ;    4371 	if (fputc('\r',rp) == EOF)
                 ;    4372 		return (EOF);
                 ;    4373 	if (fputc('\n',rp) == EOF)
                 ;    4374 		return (EOF);
                 ;    4375 	return (0);
                 ;    4376 }
                 ;    4377 
                 ;    4378 int fputsc(flash unsigned char *file_data, FILE *rp)
                 ;    4379 {
                 ;    4380 	while(*file_data)
                 ;    4381 		if (fputc(*file_data++,rp) == EOF)
                 ;    4382 			return (EOF);
                 ;    4383 	if (fputc('\r',rp) == EOF)
                 ;    4384 		return (EOF);
                 ;    4385 	if (fputc('\n',rp) == EOF)
                 ;    4386 		return (EOF);
                 ;    4387 	return (0);
                 ;    4388 }
                 ;    4389 #endif
                 ;    4390 
                 ;    4391 //#ifndef _READ_ONLY_
                 ;    4392 #ifdef _CVAVR_
                 ;    4393 void fprintf(FILE *rp, unsigned char flash *pstr, ...)
                 ;    4394 {
                 ;    4395 	va_list arglist;
                 ;    4396 	unsigned char temp_buff[_FF_MAX_FPRINT], *fp;
                 ;    4397 	
                 ;    4398 	va_start(arglist, pstr);
                 ;	*rp -> Y+106
                 ;	*pstr -> Y+104
                 ;	*arglist -> R16,R17
                 ;	temp_buff -> Y+4
                 ;	*fp -> R18,R19
                 ;    4399 	vsprintf(temp_buff, pstr, arglist);
                 ;    4400 	va_end(arglist);
                 ;    4401 	
                 ;    4402 	fp = temp_buff;
                 ;    4403 	while (*fp)
                 ;    4404 		fputc(*fp++, rp);	
                 ;    4405 }
                 ;    4406 #endif
                 ;    4407 #ifdef _ICCAVR_
                 ;    4408 void fprintf(FILE *rp, unsigned char flash *pstr, long var)
                 ;    4409 {
                 ;    4410 	unsigned char temp_buff[_FF_MAX_FPRINT], *fp;
                 ;    4411 	
                 ;    4412 	csprintf(temp_buff, pstr, var);
                 ;    4413 	
                 ;    4414 	fp = temp_buff;
                 ;    4415 	while (*fp)
                 ;    4416 		fputc(*fp++, rp);	
                 ;    4417 }
                 ;    4418 #endif
                 ;    4419 //#endif
                 ;    4420 
                 ;    4421 // Set file pointer to the end of the file
                 ;    4422 int fend(FILE *rp)
                 ;    4423 {
                 ;    4424 	return (fseek(rp, 0, SEEK_END));	
                 ;    4425 }
                 ;    4426 
                 ;    4427 // Goto position "off_set" of a file
                 ;    4428 int fseek(FILE *rp, unsigned long off_set, unsigned char mode)
                 ;    4429 {
                 _fseek:
                 ;    4430 	unsigned int n, clus_temp;
                 ;    4431 	unsigned long length_check, addr_calc;
                 ;    4432 	
                 ;    4433 	if (rp==NULL)
001aba 9728      	SBIW R28,8
001abb 940e 1f32 	CALL __SAVELOCR4
                 ;	*rp -> Y+17
                 ;	off_set -> Y+13
                 ;	mode -> Y+12
                 ;	n -> R16,R17
                 ;	clus_temp -> R18,R19
                 ;	length_check -> Y+8
                 ;	addr_calc -> Y+4
001abd 89e9      	LDD  R30,Y+17
001abe 89fa      	LDD  R31,Y+17+1
001abf 9730      	SBIW R30,0
001ac0 f431      	BRNE _0x37F
                 ;    4434 	{	// ERROR if FILE pointer is NULL
                 ;    4435 		_FF_error = FILE_ERR;
001ac1 e0e2      	LDI  R30,LOW(2)
001ac2 93e0 0bd3 	STS  __FF_error,R30
                 ;    4436 		return (EOF);
001ac4 efef      	LDI  R30,LOW(65535)
001ac5 efff      	LDI  R31,HIGH(65535)
001ac6 c1b1      	RJMP _0x418
                 ;    4437 	}
                 ;    4438 	if (mode==SEEK_CUR)
                 _0x37F:
001ac7 85ec      	LDD  R30,Y+12
001ac8 30e0      	CPI  R30,0
001ac9 f481      	BRNE _0x380
                 ;    4439 	{	// Trying to position pointer to offset from current position
                 ;    4440 		off_set += rp->position;
001aca 89a9      	LDD  R26,Y+17
001acb 89ba      	LDD  R27,Y+17+1
001acc 5ea0      	SUBI R26,LOW(-544)
001acd 4fbd      	SBCI R27,HIGH(-544)
001ace 940e 1ec8 	CALL __GETD1P
001ad0 85ad
001ad1 85be
001ad2 858f
001ad3 8998      	__GETD2S 13
001ad4 940e 1dd6 	CALL __ADDD12
001ad6 87ed
001ad7 87fe
001ad8 876f
001ad9 8b78      	__PUTD1S 13
                 ;    4441 	}
                 ;    4442 	if (off_set > rp->length)
                 _0x380:
001ada 89a9      	LDD  R26,Y+17
001adb 89ba      	LDD  R27,Y+17+1
001adc 5ea4      	SUBI R26,LOW(-540)
001add 4fbd      	SBCI R27,HIGH(-540)
001ade 940e 1ec8 	CALL __GETD1P
001ae0 85ad
001ae1 85be
001ae2 858f
001ae3 8998      	__GETD2S 13
001ae4 940e 1f26 	CALL __CPD12
001ae6 f458      	BRSH _0x381
                 ;    4443 	{	// trying to position beyond or before file
                 ;    4444 		rp->error = POS_ERR;
001ae7 89a9      	LDD  R26,Y+17
001ae8 89ba      	LDD  R27,Y+17+1
001ae9 5dab      	SUBI R26,LOW(-549)
001aea 4fbd      	SBCI R27,HIGH(-549)
001aeb e0ea      	LDI  R30,LOW(10)
001aec 93ec      	ST   X,R30
                 ;    4445 		_FF_error = POS_ERR;
001aed 93e0 0bd3 	STS  __FF_error,R30
                 ;    4446 		return (EOF);
001aef efef      	LDI  R30,LOW(65535)
001af0 efff      	LDI  R31,HIGH(65535)
001af1 c186      	RJMP _0x418
                 ;    4447 	}
                 ;    4448 	if (mode==SEEK_END)
                 _0x381:
001af2 85ac      	LDD  R26,Y+12
001af3 30a1      	CPI  R26,LOW(0x1)
001af4 f481      	BRNE _0x382
                 ;    4449 	{	// Trying to position pointer to offset from EOF
                 ;    4450 		off_set = rp->length - off_set;
001af5 89a9      	LDD  R26,Y+17
001af6 89ba      	LDD  R27,Y+17+1
001af7 5ea4      	SUBI R26,LOW(-540)
001af8 4fbd      	SBCI R27,HIGH(-540)
001af9 940e 1ec8 	CALL __GETD1P
001afb 85ad
001afc 85be
001afd 858f
001afe 8998      	__GETD2S 13
001aff 940e 1de0 	CALL __SUBD12
001b01 87ed
001b02 87fe
001b03 876f
001b04 8b78      	__PUTD1S 13
                 ;    4451 	}
                 ;    4452 	#ifndef _READ_ONLY_
                 ;    4453 	if (rp->mode != READ)
                 _0x382:
001b05 89a9      	LDD  R26,Y+17
001b06 89ba      	LDD  R27,Y+17+1
001b07 5dac      	SUBI R26,LOW(-548)
001b08 4fbd      	SBCI R27,HIGH(-548)
001b09 91ac      	LD   R26,X
001b0a 30a1      	CPI  R26,LOW(0x1)
001b0b f059      	BREQ _0x383
                 ;    4454 		if (fflush(rp))
001b0c 89e9      	LDD  R30,Y+17
001b0d 89fa      	LDD  R31,Y+17+1
001b0e 93fa      	ST   -Y,R31
001b0f 93ea      	ST   -Y,R30
001b10 940e 1a22 	CALL _fflush
001b12 9730      	SBIW R30,0
001b13 f019      	BREQ _0x384
                 ;    4455 			return (EOF);
001b14 efef      	LDI  R30,LOW(65535)
001b15 efff      	LDI  R31,HIGH(65535)
001b16 c161      	RJMP _0x418
                 ;    4456 	#endif
                 ;    4457 	clus_temp = rp->clus_start;
                 _0x384:
                 _0x383:
001b17 89a9      	LDD  R26,Y+17
001b18 89ba      	LDD  R27,Y+17+1
001b19 961c      	ADIW R26,12
001b1a 912d      	LD   R18,X+
001b1b 913c      	LD   R19,X
                 ;    4458 	rp->clus_current = clus_temp;
001b1c 01f9      	MOVW R30,R18
001b1d 89a9
001b1e 89ba
001b1f 961e
001b20 93ed
001b21 93fc      	__PUTW1SNS 17,14
                 ;    4459 	rp->clus_next = next_cluster(clus_temp, SINGLE);
001b22 933a      	ST   -Y,R19
001b23 932a      	ST   -Y,R18
001b24 e0e1      	LDI  R30,LOW(1)
001b25 93ea      	ST   -Y,R30
001b26 940e 0fa7 	CALL _next_cluster
001b28 89a9
001b29 89ba
001b2a 9650
001b2b 93ed
001b2c 93fc      	__PUTW1SNS 17,16
                 ;    4460 	rp->clus_prev = 0;
001b2d 89a9      	LDD  R26,Y+17
001b2e 89ba      	LDD  R27,Y+17+1
001b2f 9652      	ADIW R26,18
001b30 e0e0      	LDI  R30,LOW(0)
001b31 e0f0      	LDI  R31,HIGH(0)
001b32 93ed      	ST   X+,R30
001b33 93fc      	ST   X,R31
                 ;    4461 	
                 ;    4462 	addr_calc = off_set / ((long) BPB_BytsPerSec * (long) BPB_SecPerClus);
001b34 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001b36 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001b38 2766      	CLR  R22
001b39 2777      	CLR  R23
001b3a 01df      	MOVW R26,R30
001b3b 01cb      	MOVW R24,R22
001b3c 91e0 0b98 	LDS  R30,_BPB_SecPerClus
001b3e 27ff      	CLR  R31
001b3f 2766      	CLR  R22
001b40 2777      	CLR  R23
001b41 940e 1e59 	CALL __MULD12
001b43 85ad
001b44 85be
001b45 858f
001b46 8998      	__GETD2S 13
001b47 940e 1e71 	CALL __DIVD21U
001b49 83ec
001b4a 83fd
001b4b 836e
001b4c 837f      	__PUTD1S 4
                 ;    4463 	length_check = off_set % ((long) BPB_BytsPerSec * (long) BPB_SecPerClus);
001b4d 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001b4f 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001b51 2766      	CLR  R22
001b52 2777      	CLR  R23
001b53 01df      	MOVW R26,R30
001b54 01cb      	MOVW R24,R22
001b55 91e0 0b98 	LDS  R30,_BPB_SecPerClus
001b57 27ff      	CLR  R31
001b58 2766      	CLR  R22
001b59 2777      	CLR  R23
001b5a 940e 1e59 	CALL __MULD12
001b5c 85ad
001b5d 85be
001b5e 858f
001b5f 8998      	__GETD2S 13
001b60 940e 1e9f 	CALL __MODD21U
001b62 87e8
001b63 87f9
001b64 876a
001b65 877b      	__PUTD1S 8
                 ;    4464 	rp->EOF_flag = 0;
001b66 89a9      	LDD  R26,Y+17
001b67 89ba      	LDD  R27,Y+17+1
001b68 5daa      	SUBI R26,LOW(-550)
001b69 4fbd      	SBCI R27,HIGH(-550)
001b6a e0e0      	LDI  R30,LOW(0)
001b6b 93ec      	ST   X,R30
                 ;    4465 
                 ;    4466 	while (addr_calc)
                 _0x385:
001b6c 81ec
001b6d 81fd
001b6e 816e
001b6f 817f      	__GETD1S 4
001b70 940e 1f18 	CALL __CPD10
001b72 f411      	BRNE PC+3
001b73 940c 1bcf 	JMP _0x387
                 ;    4467 	{
                 ;    4468 		if (rp->clus_next >= 0xFFF8)
001b75 89e9      	LDD  R30,Y+17
001b76 89fa      	LDD  R31,Y+17+1
001b77 89a0      	LDD  R26,Z+16
001b78 89b1      	LDD  R27,Z+17
001b79 3fa8      	CPI  R26,LOW(0xFFF8)
001b7a efef      	LDI  R30,HIGH(0xFFF8)
001b7b 07be      	CPC  R27,R30
001b7c f130      	BRLO _0x388
                 ;    4469 		{	// trying to position beyond or before file
                 ;    4470 			if ((addr_calc==1) && (length_check==0))
001b7d 81ac
001b7e 81bd
001b7f 818e
001b80 819f      	__GETD2S 4
001b81 30a1
001b82 e0e0
001b83 07be
001b84 e0e0
001b85 078e
001b86 e0e0
001b87 079e      	__CPD2N 0x1
001b88 f439      	BRNE _0x38A
001b89 85a8
001b8a 85b9
001b8b 858a
001b8c 859b      	__GETD2S 8
001b8d 940e 1f20 	CALL __CPD02
001b8f f009      	BREQ _0x38B
                 _0x38A:
001b90 c007      	RJMP _0x389
                 _0x38B:
                 ;    4471 			{
                 ;    4472 				rp->EOF_flag = 1;
001b91 89a9      	LDD  R26,Y+17
001b92 89ba      	LDD  R27,Y+17+1
001b93 5daa      	SUBI R26,LOW(-550)
001b94 4fbd      	SBCI R27,HIGH(-550)
001b95 e0e1      	LDI  R30,LOW(1)
001b96 93ec      	ST   X,R30
                 ;    4473 				break;
001b97 c037      	RJMP _0x387
                 ;    4474 			}				
                 ;    4475 			rp->error = POS_ERR;
                 _0x389:
001b98 89a9      	LDD  R26,Y+17
001b99 89ba      	LDD  R27,Y+17+1
001b9a 5dab      	SUBI R26,LOW(-549)
001b9b 4fbd      	SBCI R27,HIGH(-549)
001b9c e0ea      	LDI  R30,LOW(10)
001b9d 93ec      	ST   X,R30
                 ;    4476 			_FF_error = POS_ERR;
001b9e 93e0 0bd3 	STS  __FF_error,R30
                 ;    4477 			return (EOF);
001ba0 efef      	LDI  R30,LOW(65535)
001ba1 efff      	LDI  R31,HIGH(65535)
001ba2 c0d5      	RJMP _0x418
                 ;    4478 		}
                 ;    4479 		clus_temp = rp->clus_next;
                 _0x388:
001ba3 89a9      	LDD  R26,Y+17
001ba4 89ba      	LDD  R27,Y+17+1
001ba5 9650      	ADIW R26,16
001ba6 912d      	LD   R18,X+
001ba7 913c      	LD   R19,X
                 ;    4480 		rp->clus_prev = rp->clus_current;
001ba8 89a9      	LDD  R26,Y+17
001ba9 89ba      	LDD  R27,Y+17+1
001baa 961e      	ADIW R26,14
001bab 940e 1ec4 	CALL __GETW1P
001bad 89a9
001bae 89ba
001baf 9652
001bb0 93ed
001bb1 93fc      	__PUTW1SNS 17,18
                 ;    4481 		rp->clus_current = clus_temp;
001bb2 01f9      	MOVW R30,R18
001bb3 89a9
001bb4 89ba
001bb5 961e
001bb6 93ed
001bb7 93fc      	__PUTW1SNS 17,14
                 ;    4482 		rp->clus_next = next_cluster(clus_temp, CHAIN);
001bb8 933a      	ST   -Y,R19
001bb9 932a      	ST   -Y,R18
001bba e0e0      	LDI  R30,LOW(0)
001bbb 93ea      	ST   -Y,R30
001bbc 940e 0fa7 	CALL _next_cluster
001bbe 89a9
001bbf 89ba
001bc0 9650
001bc1 93ed
001bc2 93fc      	__PUTW1SNS 17,16
                 ;    4483 		addr_calc--;
001bc3 81ec
001bc4 81fd
001bc5 816e
001bc6 817f      	__GETD1S 4
001bc7 9731      	SBIW R30,1
001bc8 4060      	SBCI R22,0
001bc9 4070      	SBCI R23,0
001bca 83ec
001bcb 83fd
001bcc 836e
001bcd 837f      	__PUTD1S 4
                 ;    4484 	}
001bce cf9d      	RJMP _0x385
                 _0x387:
                 ;    4485 	
                 ;    4486 	addr_calc = clust_to_addr(rp->clus_current);
001bcf 89e9      	LDD  R30,Y+17
001bd0 89fa      	LDD  R31,Y+17+1
001bd1 85a6      	LDD  R26,Z+14
001bd2 85b7      	LDD  R27,Z+15
001bd3 93ba      	ST   -Y,R27
001bd4 93aa      	ST   -Y,R26
001bd5 940e 0eeb 	CALL _clust_to_addr
001bd7 83ec
001bd8 83fd
001bd9 836e
001bda 837f      	__PUTD1S 4
                 ;    4487 	rp->sec_offset = 1;			// Reset Reading Sector
001bdb 89a9      	LDD  R26,Y+17
001bdc 89ba      	LDD  R27,Y+17+1
001bdd 9654      	ADIW R26,20
001bde e0e1      	LDI  R30,LOW(1)
001bdf e0f0      	LDI  R31,HIGH(1)
001be0 93ed      	ST   X+,R30
001be1 93fc      	ST   X,R31
                 ;    4488 	while (length_check >= BPB_BytsPerSec)
                 _0x38C:
001be2 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001be4 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001be6 85a8
001be7 85b9
001be8 858a
001be9 859b      	__GETD2S 8
001bea 2766      	CLR  R22
001beb 2777      	CLR  R23
001bec 940e 1f2b 	CALL __CPD21
001bee f148      	BRLO _0x38E
                 ;    4489 	{
                 ;    4490 		addr_calc += BPB_BytsPerSec;
001bef 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001bf1 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001bf3 81ac
001bf4 81bd
001bf5 818e
001bf6 819f      	__GETD2S 4
001bf7 2766      	CLR  R22
001bf8 2777      	CLR  R23
001bf9 940e 1dd6 	CALL __ADDD12
001bfb 83ec
001bfc 83fd
001bfd 836e
001bfe 837f      	__PUTD1S 4
                 ;    4491 		length_check -= BPB_BytsPerSec;
001bff 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001c01 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001c03 85a8
001c04 85b9
001c05 858a
001c06 859b      	__GETD2S 8
001c07 2766      	CLR  R22
001c08 2777      	CLR  R23
001c09 940e 1de5 	CALL __SUBD21
001c0b 87a8
001c0c 87b9
001c0d 878a
001c0e 879b      	__PUTD2S 8
                 ;    4492 		rp->sec_offset++;
001c0f 89a9      	LDD  R26,Y+17
001c10 89ba      	LDD  R27,Y+17+1
001c11 9654      	ADIW R26,20
001c12 940e 1ec4 	CALL __GETW1P
001c14 9631      	ADIW R30,1
001c15 93ed      	ST   X+,R30
001c16 93fc      	ST   X,R31
                 ;    4493 	}
001c17 cfca      	RJMP _0x38C
                 _0x38E:
                 ;    4494 	
                 ;    4495 	if (_FF_read(addr_calc)==0)		// Read Current Data Sector
001c18 81ec
001c19 81fd
001c1a 816e
001c1b 817f      	__GETD1S 4
001c1c 940e 1ed7 	CALL __PUTPARD1
001c1e 940e 0b5e 	CALL __FF_read
001c20 30e0      	CPI  R30,0
001c21 f419      	BRNE _0x38F
                 ;    4496 		return(EOF);		// Read Error  
001c22 efef      	LDI  R30,LOW(65535)
001c23 efff      	LDI  R31,HIGH(65535)
001c24 c053      	RJMP _0x418
                 ;    4497 		
                 ;    4498 	for (n=0; n<BPB_BytsPerSec; n++)
                 _0x38F:
001c25 e000
001c26 e010      	__GETWRN 16,17,0
                 _0x391:
001c27 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001c29 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001c2b 170e      	CP   R16,R30
001c2c 071f      	CPC  R17,R31
001c2d f480      	BRSH _0x392
                 ;    4499 		rp->buff[n] = _FF_buff[n];
001c2e 89e9      	LDD  R30,Y+17
001c2f 89fa      	LDD  R31,Y+17+1
001c30 967c      	ADIW R30,28
001c31 0fe0      	ADD  R30,R16
001c32 1ff1      	ADC  R31,R17
001c33 010f      	MOVW R0,R30
001c34 e9a0      	LDI  R26,LOW(__FF_buff)
001c35 e0b9      	LDI  R27,HIGH(__FF_buff)
001c36 0fa0      	ADD  R26,R16
001c37 1fb1      	ADC  R27,R17
001c38 91ec      	LD   R30,X
001c39 01d0      	MOVW R26,R0
001c3a 93ec      	ST   X,R30
                 ;    4500     
                 ;    4501     if ((rp->EOF_flag == 1) && (length_check == 0))
001c3b 5f0f
001c3c 4f1f      	__ADDWRN 16,17,1
001c3d cfe9      	RJMP _0x391
                 _0x392:
001c3e 89a9      	LDD  R26,Y+17
001c3f 89ba      	LDD  R27,Y+17+1
001c40 5daa      	SUBI R26,LOW(-550)
001c41 4fbd      	SBCI R27,HIGH(-550)
001c42 91ac      	LD   R26,X
001c43 30a1      	CPI  R26,LOW(0x1)
001c44 f439      	BRNE _0x394
001c45 85a8
001c46 85b9
001c47 858a
001c48 859b      	__GETD2S 8
001c49 940e 1f20 	CALL __CPD02
001c4b f009      	BREQ _0x395
                 _0x394:
001c4c c010      	RJMP _0x393
                 _0x395:
                 ;    4502     	rp->pntr = &rp->buff[BPB_BytsPerSec-1];
001c4d 89a9      	LDD  R26,Y+17
001c4e 89ba      	LDD  R27,Y+17+1
001c4f 965c      	ADIW R26,28
001c50 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001c52 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001c54 9731      	SBIW R30,1
001c55 0fea      	ADD  R30,R26
001c56 1ffb      	ADC  R31,R27
001c57 89a9
001c58 89ba
001c59 5da9
001c5a 4fbd
001c5b 93ed
001c5c 93fc      	__PUTW1SN 17,551
                 ;    4503 	rp->pntr = &rp->buff[length_check];
                 _0x393:
001c5d 89a9      	LDD  R26,Y+17
001c5e 89ba      	LDD  R27,Y+17+1
001c5f 965c      	ADIW R26,28
001c60 85e8
001c61 85f9
001c62 856a
001c63 857b      	__GETD1S 8
001c64 0fea      	ADD  R30,R26
001c65 1ffb      	ADC  R31,R27
001c66 89a9
001c67 89ba
001c68 5da9
001c69 4fbd
001c6a 93ed
001c6b 93fc      	__PUTW1SN 17,551
                 ;    4504 	rp->position = off_set;
001c6c 85ed
001c6d 85fe
001c6e 856f
001c6f 8978      	__GETD1S 13
001c70 89a9
001c71 89ba
001c72 5ea0
001c73 4fbd
001c74 940e 1ece 	__PUTD1SN 17,544
                 ;    4505 		
                 ;    4506 	return (0);	
001c76 e0e0      	LDI  R30,LOW(0)
001c77 e0f0      	LDI  R31,HIGH(0)
                 _0x418:
001c78 940e 1f39 	CALL __LOADLOCR4
001c7a 9663      	ADIW R28,19
001c7b 9508      	RET
                 ;    4507 }
                 ;    4508 
                 ;    4509 // Return the current position of the file rp with respect to the begining of the file
                 ;    4510 long ftell(FILE *rp)
                 ;    4511 {
                 ;    4512 	if (rp==NULL)
                 ;    4513 		return (EOF);
                 ;    4514 	else
                 ;    4515 		return (rp->position);
                 ;    4516 }
                 ;    4517 
                 ;    4518 // Funtion that returns a '1' for @EOF, '0' otherwise
                 ;    4519 int feof(FILE *rp)
                 ;    4520 {
                 ;    4521 	if (rp==NULL)
                 ;    4522 		return (EOF);
                 ;    4523 	
                 ;    4524 	if (rp->length==rp->position)
                 ;    4525 		return (1);
                 ;    4526 	else
                 ;    4527 		return (0);
                 ;    4528 }
                 ;    4529 		
                 ;    4530 void dump_file_data_hex(FILE *rp)
                 ;    4531 {
                 ;    4532 	unsigned int n, c;
                 ;    4533 	
                 ;    4534 	if (rp==NULL)
                 ;	*rp -> Y+4
                 ;	n -> R16,R17
                 ;	c -> R18,R19
                 ;    4535 		return;
                 ;    4536 
                 ;    4537 	for (n=0; n<0x20; n++)
                 ;    4538 	{   
                 ;    4539 		printf("\n\r");
                 ;    4540 		for (c=0; c<0x10; c++)
                 ;    4541 			printf("%02X ", rp->buff[(n*0x20)+c]);
                 ;    4542 	}
                 ;    4543 }
                 ;    4544 
                 ;    4545 void dump_file_data_view(FILE *rp)
                 ;    4546 {
                 ;    4547 	unsigned int n;
                 ;    4548 	
                 ;    4549 	if (rp==NULL)
                 ;	*rp -> Y+2
                 ;	n -> R16,R17
                 ;    4550 		return;
                 ;    4551 
                 ;    4552 	printf("\n\r");
                 ;    4553 	for (n=0; n<512; n++)
                 ;    4554 		putchar(rp->buff[n]);
                 ;    4555 }
                 ;    4556 
                 
                 _getchar:
001c7c 9b5f           sbis usr,rxc
001c7d cffe           rjmp _getchar
001c7e b1ec           in   r30,udr
001c7f 9508      	RET
                 _putchar:
001c80 9b5d           sbis usr,udre
001c81 cffe           rjmp _putchar
001c82 81e8           ld   r30,y
001c83 b9ec           out  udr,r30
001c84 9621      	ADIW R28,1
001c85 9508      	RET
                 _allocate_block_G9:
001c86 9722      	SBIW R28,2
001c87 940e 1f30 	CALL __SAVELOCR6
001c89 ea08
001c8a e01c      	__GETWRN 16,17,3240
001c8b 01d8      	MOVW R26,R16
001c8c e0e0      	LDI  R30,LOW(0)
001c8d e0f0      	LDI  R31,HIGH(0)
001c8e 93ed      	ST   X+,R30
001c8f 93fc      	ST   X,R31
                 _0x404:
001c90 2e00      	MOV  R0,R16
001c91 2a01      	OR   R0,R17
001c92 f1a9      	BREQ _0x406
001c93 01d8      	MOVW R26,R16
001c94 940e 1ec4 	CALL __GETW1P
001c96 0fe0      	ADD  R30,R16
001c97 1ff1      	ADC  R31,R17
001c98 9634      	ADIW R30,4
001c99 01af      	MOVW R20,R30
001c9a 9612      	ADIW R26,2
001c9b 940e 1ec4 	CALL __GETW1P
001c9d 019f      	MOVW R18,R30
001c9e 9730      	SBIW R30,0
001c9f f019      	BREQ _0x407
001ca0 832e
001ca1 833f      	__PUTWSR 18,19,6
001ca2 c004      	RJMP _0x408
                 _0x407:
001ca3 e0e0      	LDI  R30,LOW(4352)
001ca4 e1f1      	LDI  R31,HIGH(4352)
001ca5 83ee      	STD  Y+6,R30
001ca6 83ff      	STD  Y+6+1,R31
                 _0x408:
001ca7 81ee      	LDD  R30,Y+6
001ca8 81ff      	LDD  R31,Y+6+1
001ca9 1be4      	SUB  R30,R20
001caa 0bf5      	SBC  R31,R21
001cab 01df      	MOVW R26,R30
001cac 85e8      	LDD  R30,Y+8
001cad 85f9      	LDD  R31,Y+8+1
001cae 9634      	ADIW R30,4
001caf 17ae      	CP   R26,R30
001cb0 07bf      	CPC  R27,R31
001cb1 f098      	BRLO _0x409
001cb2 01fa      	MOVW R30,R20
001cb3 01d8
001cb4 9612
001cb5 93ed
001cb6 93fc      	__PUTW1RNS 16,2
001cb7 01f9      	MOVW R30,R18
001cb8 01da
001cb9 9612
001cba 93ed
001cbb 93fc      	__PUTW1RNS 20,2
001cbc 85e8      	LDD  R30,Y+8
001cbd 85f9      	LDD  R31,Y+8+1
001cbe 01da      	MOVW R26,R20
001cbf 93ed      	ST   X+,R30
001cc0 93fc      	ST   X,R31
001cc1 5f4c
001cc2 4f5f      	__ADDWRN 20,21,4
001cc3 01fa      	MOVW R30,R20
001cc4 c005      	RJMP _0x417
                 _0x409:
001cc5 2f02
001cc6 2f13      	__MOVEWRR 16,17,18,19
001cc7 cfc8      	RJMP _0x404
                 _0x406:
001cc8 e0e0      	LDI  R30,LOW(0)
001cc9 e0f0      	LDI  R31,HIGH(0)
                 _0x417:
001cca 940e 1f37 	CALL __LOADLOCR6
001ccc 962a      	ADIW R28,10
001ccd 9508      	RET
                 _find_prev_block_G9:
001cce 940e 1f32 	CALL __SAVELOCR4
001cd0 ea08
001cd1 e01c      	__GETWRN 16,17,3240
                 _0x40A:
001cd2 2e00      	MOV  R0,R16
001cd3 2a01      	OR   R0,R17
001cd4 f081      	BREQ _0x40C
001cd5 01d8      	MOVW R26,R16
001cd6 9612      	ADIW R26,2
001cd7 940e 1ec4 	CALL __GETW1P
001cd9 019f      	MOVW R18,R30
001cda 01df      	MOVW R26,R30
001cdb 81ec      	LDD  R30,Y+4
001cdc 81fd      	LDD  R31,Y+4+1
001cdd 17ea      	CP   R30,R26
001cde 07fb      	CPC  R31,R27
001cdf f411      	BRNE _0x40D
001ce0 01f8      	MOVW R30,R16
001ce1 c005      	RJMP _0x416
                 _0x40D:
001ce2 2f02
001ce3 2f13      	__MOVEWRR 16,17,18,19
001ce4 cfed      	RJMP _0x40A
                 _0x40C:
001ce5 e0e0      	LDI  R30,LOW(0)
001ce6 e0f0      	LDI  R31,HIGH(0)
                 _0x416:
001ce7 940e 1f39 	CALL __LOADLOCR4
001ce9 9626      	ADIW R28,6
001cea 9508      	RET
                 _realloc:
001ceb 9722      	SBIW R28,2
001cec 940e 1f30 	CALL __SAVELOCR6
001cee 85ea      	LDD  R30,Y+10
001cef 85fb      	LDD  R31,Y+10+1
001cf0 9730      	SBIW R30,0
001cf1 f411      	BRNE PC+3
001cf2 940c 1d30 	JMP _0x40E
001cf4 9734      	SBIW R30,4
001cf5 018f      	MOVW R16,R30
001cf6 931a      	ST   -Y,R17
001cf7 930a      	ST   -Y,R16
001cf8 dfd5      	RCALL _find_prev_block_G9
001cf9 019f      	MOVW R18,R30
001cfa 9730      	SBIW R30,0
001cfb f1a1      	BREQ _0x40F
001cfc 01d8      	MOVW R26,R16
001cfd 9612      	ADIW R26,2
001cfe 940e 1ec4 	CALL __GETW1P
001d00 01d9
001d01 9612
001d02 93ed
001d03 93fc      	__PUTW1RNS 18,2
001d04 85e8      	LDD  R30,Y+8
001d05 85f9      	LDD  R31,Y+8+1
001d06 9730      	SBIW R30,0
001d07 f141      	BREQ _0x410
001d08 93fa      	ST   -Y,R31
001d09 93ea      	ST   -Y,R30
001d0a df7b      	RCALL _allocate_block_G9
001d0b 01af      	MOVW R20,R30
001d0c 9730      	SBIW R30,0
001d0d f0e9      	BREQ _0x411
001d0e 01d8      	MOVW R26,R16
001d0f 940e 1ec4 	CALL __GETW1P
001d11 83ee      	STD  Y+6,R30
001d12 83ff      	STD  Y+6+1,R31
001d13 01df      	MOVW R26,R30
001d14 85e8      	LDD  R30,Y+8
001d15 85f9      	LDD  R31,Y+8+1
001d16 17ae      	CP   R26,R30
001d17 07bf      	CPC  R27,R31
001d18 f420      	BRSH _0x412
001d19 81ee      	LDD  R30,Y+6
001d1a 81ff      	LDD  R31,Y+6+1
001d1b 87e8      	STD  Y+8,R30
001d1c 87f9      	STD  Y+8+1,R31
                 _0x412:
001d1d 935a      	ST   -Y,R21
001d1e 934a      	ST   -Y,R20
001d1f 85ec      	LDD  R30,Y+12
001d20 85fd      	LDD  R31,Y+12+1
001d21 93fa      	ST   -Y,R31
001d22 93ea      	ST   -Y,R30
001d23 85ec      	LDD  R30,Y+12
001d24 85fd      	LDD  R31,Y+12+1
001d25 93fa      	ST   -Y,R31
001d26 93ea      	ST   -Y,R30
001d27 940e 1d5e 	CALL _memmove
001d29 01fa      	MOVW R30,R20
001d2a c007      	RJMP _0x415
                 _0x411:
001d2b 01f8      	MOVW R30,R16
001d2c 01d9
001d2d 9612
001d2e 93ed
001d2f 93fc      	__PUTW1RNS 18,2
                 _0x410:
                 _0x40F:
                 _0x40E:
001d30 e0e0      	LDI  R30,LOW(0)
001d31 e0f0      	LDI  R31,HIGH(0)
                 _0x415:
001d32 940e 1f37 	CALL __LOADLOCR6
001d34 962c      	ADIW R28,12
001d35 9508      	RET
                 _malloc:
001d36 931a      	ST   -Y,R17
001d37 930a      	ST   -Y,R16
001d38 e000
001d39 e010      	__GETWRN 16,17,0
001d3a 81ea      	LDD  R30,Y+2
001d3b 81fb      	LDD  R31,Y+2+1
001d3c 9730      	SBIW R30,0
001d3d f081      	BREQ _0x413
001d3e 93fa      	ST   -Y,R31
001d3f 93ea      	ST   -Y,R30
001d40 df45      	RCALL _allocate_block_G9
001d41 018f      	MOVW R16,R30
001d42 9730      	SBIW R30,0
001d43 f051      	BREQ _0x414
001d44 931a      	ST   -Y,R17
001d45 930a      	ST   -Y,R16
001d46 e0e0      	LDI  R30,LOW(0)
001d47 93ea      	ST   -Y,R30
001d48 81ed      	LDD  R30,Y+5
001d49 81fe      	LDD  R31,Y+5+1
001d4a 93fa      	ST   -Y,R31
001d4b 93ea      	ST   -Y,R30
001d4c 940e 1d7b 	CALL _memset
                 _0x414:
                 _0x413:
001d4e 01f8      	MOVW R30,R16
001d4f 8119      	LDD  R17,Y+1
001d50 8108      	LDD  R16,Y+0
001d51 9624      	ADIW R28,4
001d52 9508      	RET
                 _free:
001d53 81e8      	LD   R30,Y
001d54 81f9      	LDD  R31,Y+1
001d55 93fa      	ST   -Y,R31
001d56 93ea      	ST   -Y,R30
001d57 e0e0      	LDI  R30,LOW(0)
001d58 e0f0      	LDI  R31,HIGH(0)
001d59 93fa      	ST   -Y,R31
001d5a 93ea      	ST   -Y,R30
001d5b df8f      	RCALL _realloc
001d5c 9622      	ADIW R28,2
001d5d 9508      	RET
                 
                 _memmove:
001d5e 8199      	ldd  r25,y+1
001d5f 8188      	ld   r24,y
001d60 9600      	adiw r24,0
001d61 f0a9      	breq __memmove3
001d62 81bd      	ldd  r27,y+5
001d63 81ac      	ldd  r26,y+4
001d64 81fb      	ldd  r31,y+3
001d65 81ea      	ldd  r30,y+2
001d66 17ea      	cp   r30,r26
001d67 07fb      	cpc  r31,r27
001d68 f071      	breq __memmove3
001d69 f02c      	brlt __memmove1
                 __memmove0:
001d6a 9161      	ld   r22,z+
001d6b 936d      	st   x+,r22
001d6c 9701      	sbiw r24,1
001d6d f7e1      	brne __memmove0
001d6e c008      	rjmp __memmove3
                 __memmove1:
001d6f 0fa8      	add  r26,r24
001d70 1fb9      	adc  r27,r25
001d71 0fe8      	add  r30,r24
001d72 1ff9      	adc  r31,r25
                 __memmove2:
001d73 9162      	ld   r22,-z
001d74 936e      	st   -x,r22
001d75 9701      	sbiw r24,1
001d76 f7e1      	brne __memmove2
                 __memmove3:
001d77 81fd      	ldd  r31,y+5
001d78 81ec      	ldd  r30,y+4
001d79 9626      	adiw r28,6
001d7a 9508      	ret
                 
                 _memset:
001d7b 81b9      	ldd  r27,y+1
001d7c 81a8      	ld   r26,y
001d7d 9610      	adiw r26,0
001d7e f031      	breq __memset1
001d7f 81fc      	ldd  r31,y+4
001d80 81eb      	ldd  r30,y+3
001d81 816a      	ldd  r22,y+2
                 __memset0:
001d82 9361      	st   z+,r22
001d83 9711      	sbiw r26,1
001d84 f7e9      	brne __memset0
                 __memset1:
001d85 81eb      	ldd  r30,y+3
001d86 81fc      	ldd  r31,y+4
001d87 9625      	adiw r28,5
001d88 9508      	ret
                 
                 _strlen:
001d89 91a9      	ld   r26,y+
001d8a 91b9      	ld   r27,y+
001d8b 27ee      	clr  r30
001d8c 27ff      	clr  r31
                 __strlen0:
001d8d 916d      	ld   r22,x+
001d8e 2366      	tst  r22
001d8f f011      	breq __strlen1
001d90 9631      	adiw r30,1
001d91 cffb      	rjmp __strlen0
                 __strlen1:
001d92 9508      	ret
                 
                 _strlenf:
001d93 27aa      	clr  r26
001d94 27bb      	clr  r27
001d95 91e9      	ld   r30,y+
001d96 91f9      	ld   r31,y+
                 __strlenf0:
001d97 9005      	lpm  r0,z+
001d98 2000      	tst  r0
001d99 f011      	breq __strlenf1
001d9a 9611      	adiw r26,1
001d9b cffb      	rjmp __strlenf0
                 __strlenf1:
001d9c 01fd      	movw r30,r26
001d9d 9508      	ret
                 
                 _strncmp:
001d9e 2766      	clr  r22
001d9f 2777      	clr  r23
001da0 9189      	ld   r24,y+
001da1 91e9      	ld   r30,y+
001da2 91f9      	ld   r31,y+
001da3 91a9      	ld   r26,y+
001da4 91b9      	ld   r27,y+
                 __strncmp0:
001da5 2388      	tst  r24
001da6 f049      	breq __strncmp1
001da7 958a      	dec  r24
001da8 916d      	ld   r22,x+
001da9 9171      	ld   r23,z+
001daa 1767      	cp   r22,r23
001dab f421      	brne __strncmp1
001dac 2366      	tst  r22
001dad f7b9      	brne __strncmp0
                 __strncmp3:
001dae 27ee      	clr  r30
001daf 9508      	ret
                 __strncmp1:
001db0 1b67      	sub  r22,r23
001db1 f3e1      	breq __strncmp3
001db2 e0e1      	ldi  r30,1
001db3 f408      	brcc __strncmp2
001db4 50e2      	subi r30,2
                 __strncmp2:
001db5 9508      	ret
                 
                 _strrpos:
001db6 9169      	ld   r22,y+
001db7 91a9      	ld   r26,y+
001db8 91b9      	ld   r27,y+
001db9 efef      	ldi  r30,-1
001dba 27ff      	clr  r31
                 __strrpos0:
001dbb 917d      	ld   r23,x+
001dbc 1767      	cp   r22,r23
001dbd f409      	brne __strrpos1
001dbe 2fef      	mov  r30,r31
                 __strrpos1:
001dbf 95f3      	inc  r31
001dc0 2377      	tst  r23
001dc1 f7c9      	brne __strrpos0
001dc2 9508      	ret
                 
                 _toupper:
001dc3 91e9      	ld   r30,y+
001dc4 36e1      	cpi  r30,'a'
001dc5 f018      	brlo __toupper0
001dc6 37eb      	cpi  r30,'z'+1
001dc7 f408      	brcc __toupper0
001dc8 52e0      	subi r30,32
                 __toupper0:
001dc9 9508      	ret
                 
                 _delay_ms:
001dca 91e9      	ld   r30,y+
001dcb 91f9      	ld   r31,y+
001dcc 9630      	adiw r30,0
001dcd f039      	breq __delay_ms1
                 __delay_ms0:
001dce ed80
001dcf e097
001dd0 9701
001dd1 f7f1      	__DELAY_USW 0x7D0
001dd2 95a8      	wdr
001dd3 9731      	sbiw r30,1
001dd4 f7c9      	brne __delay_ms0
                 __delay_ms1:
001dd5 9508      	ret
                 
                 __ADDD12:
001dd6 0fea      	ADD  R30,R26
001dd7 1ffb      	ADC  R31,R27
001dd8 1f68      	ADC  R22,R24
001dd9 1f79      	ADC  R23,R25
001dda 9508      	RET
                 
                 __ADDD21:
001ddb 0fae      	ADD  R26,R30
001ddc 1fbf      	ADC  R27,R31
001ddd 1f86      	ADC  R24,R22
001dde 1f97      	ADC  R25,R23
001ddf 9508      	RET
                 
                 __SUBD12:
001de0 1bea      	SUB  R30,R26
001de1 0bfb      	SBC  R31,R27
001de2 0b68      	SBC  R22,R24
001de3 0b79      	SBC  R23,R25
001de4 9508      	RET
                 
                 __SUBD21:
001de5 1bae      	SUB  R26,R30
001de6 0bbf      	SBC  R27,R31
001de7 0b86      	SBC  R24,R22
001de8 0b97      	SBC  R25,R23
001de9 9508      	RET
                 
                 __ORD12:
001dea 2bea      	OR   R30,R26
001deb 2bfb      	OR   R31,R27
001dec 2b68      	OR   R22,R24
001ded 2b79      	OR   R23,R25
001dee 9508      	RET
                 
                 __ANEGW1:
001def 95e0      	COM  R30
001df0 95f0      	COM  R31
001df1 9631      	ADIW R30,1
001df2 9508      	RET
                 
                 __ANEGD1:
001df3 95e0      	COM  R30
001df4 95f0      	COM  R31
001df5 9560      	COM  R22
001df6 9570      	COM  R23
001df7 5fef      	SUBI R30,-1
001df8 4fff      	SBCI R31,-1
001df9 4f6f      	SBCI R22,-1
001dfa 4f7f      	SBCI R23,-1
001dfb 9508      	RET
                 
                 __LSLD12:
001dfc 23ee      	TST  R30
001dfd 2e0e      	MOV  R0,R30
001dfe 01fd      	MOVW R30,R26
001dff 01bc      	MOVW R22,R24
001e00 f031      	BREQ __LSLD12R
                 __LSLD12L:
001e01 0fee      	LSL  R30
001e02 1fff      	ROL  R31
001e03 1f66      	ROL  R22
001e04 1f77      	ROL  R23
001e05 940a      	DEC  R0
001e06 f7d1      	BRNE __LSLD12L
                 __LSLD12R:
001e07 9508      	RET
                 
                 __LSRD12:
001e08 23ee      	TST  R30
001e09 2e0e      	MOV  R0,R30
001e0a 01fd      	MOVW R30,R26
001e0b 01bc      	MOVW R22,R24
001e0c f031      	BREQ __LSRD12R
                 __LSRD12L:
001e0d 9576      	LSR  R23
001e0e 9567      	ROR  R22
001e0f 95f7      	ROR  R31
001e10 95e7      	ROR  R30
001e11 940a      	DEC  R0
001e12 f7d1      	BRNE __LSRD12L
                 __LSRD12R:
001e13 9508      	RET
                 
                 __LSLW4:
001e14 0fee      	LSL  R30
001e15 1fff      	ROL  R31
                 __LSLW3:
001e16 0fee      	LSL  R30
001e17 1fff      	ROL  R31
                 __LSLW2:
001e18 0fee      	LSL  R30
001e19 1fff      	ROL  R31
001e1a 0fee      	LSL  R30
001e1b 1fff      	ROL  R31
001e1c 9508      	RET
                 
                 __LSRD16:
001e1d 2fe6      	MOV  R30,R22
001e1e 2ff7      	MOV  R31,R23
001e1f e060      	LDI  R22,0
001e20 e070      	LDI  R23,0
001e21 9508      	RET
                 
                 __LSLD16:
001e22 2f6e      	MOV  R22,R30
001e23 2f7f      	MOV  R23,R31
001e24 e0e0      	LDI  R30,0
001e25 e0f0      	LDI  R31,0
001e26 9508      	RET
                 
                 __CWD1:
001e27 2f6f      	MOV  R22,R31
001e28 0f66      	ADD  R22,R22
001e29 0b66      	SBC  R22,R22
001e2a 2f76      	MOV  R23,R22
001e2b 9508      	RET
                 
                 __MULW12U:
001e2c 9ffa      	MUL  R31,R26
001e2d 2df0      	MOV  R31,R0
001e2e 9feb      	MUL  R30,R27
001e2f 0df0      	ADD  R31,R0
001e30 9fea      	MUL  R30,R26
001e31 2de0      	MOV  R30,R0
001e32 0df1      	ADD  R31,R1
001e33 9508      	RET
                 
                 __MULD12U:
001e34 9f7a      	MUL  R23,R26
001e35 2d70      	MOV  R23,R0
001e36 9f6b      	MUL  R22,R27
001e37 0d70      	ADD  R23,R0
001e38 9ff8      	MUL  R31,R24
001e39 0d70      	ADD  R23,R0
001e3a 9fe9      	MUL  R30,R25
001e3b 0d70      	ADD  R23,R0
001e3c 9f6a      	MUL  R22,R26
001e3d 2d60      	MOV  R22,R0
001e3e 0d71      	ADD  R23,R1
001e3f 9ffb      	MUL  R31,R27
001e40 0d60      	ADD  R22,R0
001e41 1d71      	ADC  R23,R1
001e42 9fe8      	MUL  R30,R24
001e43 0d60      	ADD  R22,R0
001e44 1d71      	ADC  R23,R1
001e45 2788      	CLR  R24
001e46 9ffa      	MUL  R31,R26
001e47 2df0      	MOV  R31,R0
001e48 0d61      	ADD  R22,R1
001e49 1f78      	ADC  R23,R24
001e4a 9feb      	MUL  R30,R27
001e4b 0df0      	ADD  R31,R0
001e4c 1d61      	ADC  R22,R1
001e4d 1f78      	ADC  R23,R24
001e4e 9fea      	MUL  R30,R26
001e4f 2de0      	MOV  R30,R0
001e50 0df1      	ADD  R31,R1
001e51 1f68      	ADC  R22,R24
001e52 1f78      	ADC  R23,R24
001e53 9508      	RET
                 
                 __MULW12:
001e54 d04e      	RCALL __CHKSIGNW
001e55 dfd6      	RCALL __MULW12U
001e56 f40e      	BRTC __MULW121
001e57 df97      	RCALL __ANEGW1
                 __MULW121:
001e58 9508      	RET
                 
                 __MULD12:
001e59 d057      	RCALL __CHKSIGND
001e5a dfd9      	RCALL __MULD12U
001e5b f40e      	BRTC __MULD121
001e5c df96      	RCALL __ANEGD1
                 __MULD121:
001e5d 9508      	RET
                 
                 __DIVW21U:
001e5e 2400      	CLR  R0
001e5f 2411      	CLR  R1
001e60 e190      	LDI  R25,16
                 __DIVW21U1:
001e61 0faa      	LSL  R26
001e62 1fbb      	ROL  R27
001e63 1c00      	ROL  R0
001e64 1c11      	ROL  R1
001e65 1a0e      	SUB  R0,R30
001e66 0a1f      	SBC  R1,R31
001e67 f418      	BRCC __DIVW21U2
001e68 0e0e      	ADD  R0,R30
001e69 1e1f      	ADC  R1,R31
001e6a c001      	RJMP __DIVW21U3
                 __DIVW21U2:
001e6b 60a1      	SBR  R26,1
                 __DIVW21U3:
001e6c 959a      	DEC  R25
001e6d f799      	BRNE __DIVW21U1
001e6e 01fd      	MOVW R30,R26
001e6f 01d0      	MOVW R26,R0
001e70 9508      	RET
                 
                 __DIVD21U:
001e71 933f      	PUSH R19
001e72 934f      	PUSH R20
001e73 935f      	PUSH R21
001e74 2400      	CLR  R0
001e75 2411      	CLR  R1
001e76 2733      	CLR  R19
001e77 2744      	CLR  R20
001e78 e250      	LDI  R21,32
                 __DIVD21U1:
001e79 0faa      	LSL  R26
001e7a 1fbb      	ROL  R27
001e7b 1f88      	ROL  R24
001e7c 1f99      	ROL  R25
001e7d 1c00      	ROL  R0
001e7e 1c11      	ROL  R1
001e7f 1f33      	ROL  R19
001e80 1f44      	ROL  R20
001e81 1a0e      	SUB  R0,R30
001e82 0a1f      	SBC  R1,R31
001e83 0b36      	SBC  R19,R22
001e84 0b47      	SBC  R20,R23
001e85 f428      	BRCC __DIVD21U2
001e86 0e0e      	ADD  R0,R30
001e87 1e1f      	ADC  R1,R31
001e88 1f36      	ADC  R19,R22
001e89 1f47      	ADC  R20,R23
001e8a c001      	RJMP __DIVD21U3
                 __DIVD21U2:
001e8b 60a1      	SBR  R26,1
                 __DIVD21U3:
001e8c 955a      	DEC  R21
001e8d f759      	BRNE __DIVD21U1
001e8e 01fd      	MOVW R30,R26
001e8f 01bc      	MOVW R22,R24
001e90 01d0      	MOVW R26,R0
001e91 2f83      	MOV  R24,R19
001e92 2f94      	MOV  R25,R20
001e93 915f      	POP  R21
001e94 914f      	POP  R20
001e95 913f      	POP  R19
001e96 9508      	RET
                 
                 __DIVD21:
001e97 d019      	RCALL __CHKSIGND
001e98 dfd8      	RCALL __DIVD21U
001e99 f40e      	BRTC __DIVD211
001e9a df58      	RCALL __ANEGD1
                 __DIVD211:
001e9b 9508      	RET
                 
                 __MODW21U:
001e9c dfc1      	RCALL __DIVW21U
001e9d 01fd      	MOVW R30,R26
001e9e 9508      	RET
                 
                 __MODD21U:
001e9f dfd1      	RCALL __DIVD21U
001ea0 01fd      	MOVW R30,R26
001ea1 01bc      	MOVW R22,R24
001ea2 9508      	RET
                 
                 __CHKSIGNW:
001ea3 94e8      	CLT
001ea4 fff7      	SBRS R31,7
001ea5 c002      	RJMP __CHKSW1
001ea6 df48      	RCALL __ANEGW1
001ea7 9468      	SET
                 __CHKSW1:
001ea8 ffb7      	SBRS R27,7
001ea9 c006      	RJMP __CHKSW2
001eaa 95a0      	COM  R26
001eab 95b0      	COM  R27
001eac 9611      	ADIW R26,1
001ead f800      	BLD  R0,0
001eae 9403      	INC  R0
001eaf fa00      	BST  R0,0
                 __CHKSW2:
001eb0 9508      	RET
                 
                 __CHKSIGND:
001eb1 94e8      	CLT
001eb2 ff77      	SBRS R23,7
001eb3 c002      	RJMP __CHKSD1
001eb4 df3e      	RCALL __ANEGD1
001eb5 9468      	SET
                 __CHKSD1:
001eb6 ff97      	SBRS R25,7
001eb7 c00b      	RJMP __CHKSD2
001eb8 2400      	CLR  R0
001eb9 95a0      	COM  R26
001eba 95b0      	COM  R27
001ebb 9580      	COM  R24
001ebc 9590      	COM  R25
001ebd 9611      	ADIW R26,1
001ebe 1d80      	ADC  R24,R0
001ebf 1d90      	ADC  R25,R0
001ec0 f800      	BLD  R0,0
001ec1 9403      	INC  R0
001ec2 fa00      	BST  R0,0
                 __CHKSD2:
001ec3 9508      	RET
                 
                 __GETW1P:
001ec4 91ed      	LD   R30,X+
001ec5 91fc      	LD   R31,X
001ec6 9711      	SBIW R26,1
001ec7 9508      	RET
                 
                 __GETD1P:
001ec8 91ed      	LD   R30,X+
001ec9 91fd      	LD   R31,X+
001eca 916d      	LD   R22,X+
001ecb 917c      	LD   R23,X
001ecc 9713      	SBIW R26,3
001ecd 9508      	RET
                 
                 __PUTDP1:
001ece 93ed      	ST   X+,R30
001ecf 93fd      	ST   X+,R31
001ed0 936d      	ST   X+,R22
001ed1 937c      	ST   X,R23
001ed2 9508      	RET
                 
                 __GETW1PF:
001ed3 9005      	LPM  R0,Z+
001ed4 91f4      	LPM  R31,Z
001ed5 2de0      	MOV  R30,R0
001ed6 9508      	RET
                 
                 __PUTPARD1:
001ed7 937a      	ST   -Y,R23
001ed8 936a      	ST   -Y,R22
001ed9 93fa      	ST   -Y,R31
001eda 93ea      	ST   -Y,R30
001edb 9508      	RET
                 
                 __PUTPARD2:
001edc 939a      	ST   -Y,R25
001edd 938a      	ST   -Y,R24
001ede 93ba      	ST   -Y,R27
001edf 93aa      	ST   -Y,R26
001ee0 9508      	RET
                 
                 __EEPROMRDD:
001ee1 9612      	ADIW R26,2
001ee2 d003      	RCALL __EEPROMRDW
001ee3 2f7f      	MOV  R23,R31
001ee4 2f6e      	MOV  R22,R30
001ee5 9712      	SBIW R26,2
                 
                 __EEPROMRDW:
001ee6 9611      	ADIW R26,1
001ee7 d002      	RCALL __EEPROMRDB
001ee8 2ffe      	MOV  R31,R30
001ee9 9711      	SBIW R26,1
                 
                 __EEPROMRDB:
001eea 99e1      	SBIC EECR,EEWE
001eeb cffe      	RJMP __EEPROMRDB
001eec 93ff      	PUSH R31
001eed b7ff      	IN   R31,SREG
001eee 94f8      	CLI
001eef bbae      	OUT  EEARL,R26
001ef0 bbbf      	OUT  EEARH,R27
001ef1 9ae0      	SBI  EECR,EERE
001ef2 b3ed      	IN   R30,EEDR
001ef3 bfff      	OUT  SREG,R31
001ef4 91ff      	POP  R31
001ef5 9508      	RET
                 
                 __EEPROMWRD:
001ef6 d00a      	RCALL __EEPROMWRW
001ef7 9612      	ADIW R26,2
001ef8 2e0e      	MOV  R0,R30
001ef9 2e1f      	MOV  R1,R31
001efa 2fe6      	MOV  R30,R22
001efb 2ff7      	MOV  R31,R23
001efc d004      	RCALL __EEPROMWRW
001efd 2de0      	MOV  R30,R0
001efe 2df1      	MOV  R31,R1
001eff 9712      	SBIW R26,2
001f00 9508      	RET
                 
                 __EEPROMWRW:
001f01 d007      	RCALL __EEPROMWRB
001f02 9611      	ADIW R26,1
001f03 93ef      	PUSH R30
001f04 2fef      	MOV  R30,R31
001f05 d003      	RCALL __EEPROMWRB
001f06 91ef      	POP  R30
001f07 9711      	SBIW R26,1
001f08 9508      	RET
                 
                 __EEPROMWRB:
001f09 99e1      	SBIC EECR,EEWE
001f0a cffe      	RJMP __EEPROMWRB
001f0b b79f      	IN   R25,SREG
001f0c 94f8      	CLI
001f0d bbae      	OUT  EEARL,R26
001f0e bbbf      	OUT  EEARH,R27
001f0f 9ae0      	SBI  EECR,EERE
001f10 b38d      	IN   R24,EEDR
001f11 17e8      	CP   R30,R24
001f12 f019      	BREQ __EEPROMWRB0
001f13 bbed      	OUT  EEDR,R30
001f14 9ae2      	SBI  EECR,EEMWE
001f15 9ae1      	SBI  EECR,EEWE
                 __EEPROMWRB0:
001f16 bf9f      	OUT  SREG,R25
001f17 9508      	RET
                 
                 __CPD10:
001f18 9730      	SBIW R30,0
001f19 4060      	SBCI R22,0
001f1a 4070      	SBCI R23,0
001f1b 9508      	RET
                 
                 __CPW02:
001f1c 2400      	CLR  R0
001f1d 160a      	CP   R0,R26
001f1e 060b      	CPC  R0,R27
001f1f 9508      	RET
                 
                 __CPD02:
001f20 2400      	CLR  R0
001f21 160a      	CP   R0,R26
001f22 060b      	CPC  R0,R27
001f23 0608      	CPC  R0,R24
001f24 0609      	CPC  R0,R25
001f25 9508      	RET
                 
                 __CPD12:
001f26 17ea      	CP   R30,R26
001f27 07fb      	CPC  R31,R27
001f28 0768      	CPC  R22,R24
001f29 0779      	CPC  R23,R25
001f2a 9508      	RET
                 
                 __CPD21:
001f2b 17ae      	CP   R26,R30
001f2c 07bf      	CPC  R27,R31
001f2d 0786      	CPC  R24,R22
001f2e 0797      	CPC  R25,R23
001f2f 9508      	RET
                 
                 __SAVELOCR6:
001f30 935a      	ST   -Y,R21
                 __SAVELOCR5:
001f31 934a      	ST   -Y,R20
                 __SAVELOCR4:
001f32 933a      	ST   -Y,R19
                 __SAVELOCR3:
001f33 932a      	ST   -Y,R18
                 __SAVELOCR2:
001f34 931a      	ST   -Y,R17
001f35 930a      	ST   -Y,R16
001f36 9508      	RET
                 
                 __LOADLOCR6:
001f37 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
001f38 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
001f39 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
001f3a 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
001f3b 8119      	LDD  R17,Y+1
001f3c 8108      	LD   R16,Y
001f3d 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega128 register use summary:
r0 :  92 r1 :  18 r2 :   0 r3 :   0 r4 :   1 r5 :   0 r6 :   0 r7 :   0 
r8 :   6 r9 :   5 r10:   3 r11:  11 r12:   3 r13:   7 r14:   3 r15:   0 
r16: 224 r17: 131 r18:  83 r19:  45 r20:  56 r21:  15 r22: 375 r23: 332 
r24: 172 r25: 125 r26: 700 r27: 395 r28:  66 r29:   1 r30:2079 r31: 823 
x  : 164 y  :1581 z  :  60 
Registers used: 29 out of 35 (82.9%)

ATmega128 instruction use summary:
adc   :  53 add   :  55 adiw  : 134 and   :   0 andi  :  42 asr   :   0 
bclr  :   0 bld   :   2 brbc  :   0 brbs  :   0 brcc  :   4 brcs  :   0 
break :   0 breq  :  93 brge  :   1 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :  26 brlt  :   1 brmi  :   0 brne  : 174 brpl  :   0 
brsh  :  52 brtc  :   3 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   2 call  : 460 cbi   :  11 cbr   :   0 clc   :   0 clh   :   0 
cli   :   3 cln   :   0 clr   : 209 cls   :   0 clt   :   2 clv   :   0 
clz   :   0 com   :  12 cp    :  36 cpc   :  71 cpi   : 209 cpse  :   0 
dec   :   6 elpm  :   0 eor   :   3 fmul  :   0 fmuls :   0 fmulsu:   0 
icall :   0 ijmp  :   0 in    :  21 inc   :   3 jmp   :  59 ld    : 132 
ldd   : 898 ldi   : 787 lds   : 391 lpm   :  12 lsl   :  22 lsr   :   5 
mov   : 120 movw  : 195 mul   :  13 muls  :   0 mulsu :   0 neg   :   0 
nop   :   0 or    :  33 ori   :   7 out   :  53 pop   :  65 push  :  65 
rcall :  91 ret   : 110 reti  :   4 rjmp  : 270 rol   :  29 ror   :   7 
sbc   :  12 sbci  : 144 sbi   :  41 sbic  :   2 sbis  :   4 sbiw  :  88 
sbr   :   2 sbrc  :   0 sbrs  :   4 sec   :   0 seh   :   0 sei   :   1 
sen   :   0 ser   :   0 ses   :   0 set   :   2 sev   :   0 sez   :   0 
sleep :   0 spm   :   0 st    : 415 std   : 348 sts   : 298 sub   :   6 
subi  : 157 swap  :   0 tst   :   8 wdr   :   1 
Instructions used: 66 out of 112 (58.9%)

ATmega128 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003e7c  15594    402  15996  131072  12.2%
[.dseg] 0x000100 0x000c5d      0   1885   1885    4096  46.0%
[.eseg] 0x000000 0x000005      0      5      5    4096   0.1%

Assembly complete, 0 errors, 16 warnings
