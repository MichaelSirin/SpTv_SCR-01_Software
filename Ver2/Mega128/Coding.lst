
AVRASM ver. 2.1.2  Coding.asm Mon Jul 03 14:21:50 2006

Coding.asm(939): Including file 'Coding.vec'
Coding.asm(940): Including file 'Coding.inc'
Coding.inc(15): warning: Register r4 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(18): warning: Register r6 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(21): warning: Register r8 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(30): warning: Register r10 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(31): warning: Register r11 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(34): warning: Register r12 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(35): warning: Register r13 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(36): warning: Register r14 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
                 
                 
                 ;(C) Copyright 1998-2005 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Chip type              : ATmega128
                 ;Program type           : Application
                 ;Clock frequency        : 8,000000 MHz
                 ;Memory model           : Small
                 ;Optimize for           : Speed
                 ;(s)printf features     : int, width
                 ;(s)scanf features      : int, width
                 ;External SRAM size     : 0
                 ;Data Stack size        : 1024 byte(s)
                 ;Heap size              : 1112 byte(s)
                 ;Promote char to int    : No
                 ;char is unsigned       : Yes
                 ;8 bit enums            : No
                 ;Word align FLASH struct: No
                 ;Enhanced core instructions    : On
                 ;Automatic register allocation : On
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega128
                 	#pragma AVRPART MEMORY PROG_FLASH 131072
                 	#pragma AVRPART MEMORY EEPROM 4096
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU USR=0xB
                 	.EQU UDR=0xC
                 	.EQU SPSR=0xE
                 	.EQU SPDR=0xF
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU EECR=0x1C
                 	.EQU EEDR=0x1D
                 	.EQU EEARL=0x1E
                 	.EQU EEARH=0x1F
                 	.EQU WDTCR=0x21
                 	.EQU MCUCR=0x35
                 	.EQU RAMPZ=0x3B
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU XMCRA=0x6D
                 	.EQU XMCRB=0x6C
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __se_bit=0x20
                 	.EQU __sm_mask=0x1C
                 	.EQU __sm_adc_noise_red=0x08
                 	.EQU __sm_powerdown=0x10
                 	.EQU __sm_powersave=0x18
                 	.EQU __sm_standby=0x14
                 	.EQU __sm_ext_standby=0x1C
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	LDI  R30,0
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+@1)
                 	LDI  R31,HIGH(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+@1)
                 	LDI  R31,HIGH(2*@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+@1)
                 	LDI  R31,HIGH(2*@0+@1)
                 	LDI  R22,BYTE3(2*@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+@1)
                 	LDI  R27,HIGH(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+@2)
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+@3)
                 	LDI  R@1,HIGH(@2+@3)
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+@3)
                 	LDI  R@1,HIGH(@2*2+@3)
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+@1
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+@1
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+@1
                 	LDS  R31,@0+@1+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+@1
                 	LDS  R31,@0+@1+1
                 	LDS  R22,@0+@1+2
                 	LDS  R23,@0+@1+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+@2
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+@3
                 	LDS  R@1,@2+@3+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+@1
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+@1
                 	LDS  R27,@0+@1+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+@1
                 	LDS  R27,@0+@1+1
                 	LDS  R24,@0+@1+2
                 	LDS  R25,@0+@1+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+@1,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+@1,R30
                 	STS  @0+@1+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+@1,R30
                 	STS  @0+@1+1,R31
                 	STS  @0+@1+2,R22
                 	STS  @0+@1+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+@1,R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+@1,R@2
                 	STS  @0+@1+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+@1
                 	LDS  R31,@0+@1+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+@1)
                 	LDI  R31,HIGH(2*@0+@1)
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	LDI  R26,LOW(@0+@1)
                 	LDI  R27,HIGH(@0+@1)
                 	CALL __EEPROMRDW
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R26,SPL
                 	IN   R27,SPH
                 	ADIW R26,@0+1
                 	LD   R30,X+
                 	LD   R31,X
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	CLR  R0
                 	ST   Z+,R0
                 	ST   Z,R0
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	CLR  R0
                 	ST   Z+,R0
                 	ST   Z+,R0
                 	ST   Z+,R0
                 	ST   Z,R0
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.CSEG
                 	.ORG 0
                 
                 	.INCLUDE "Coding.vec"
                 
                 ;INTERRUPT VECTORS
000000 940c 010f 	JMP  __RESET
000002 940c 0000 	JMP  0x00
000004 940c 0000 	JMP  0x00
000006 940c 0000 	JMP  0x00
000008 940c 0000 	JMP  0x00
00000a 940c 0000 	JMP  0x00
00000c 940c 0000 	JMP  0x00
00000e 940c 0000 	JMP  0x00
000010 940c 0000 	JMP  0x00
000012 940c 0000 	JMP  0x00
000014 940c 0000 	JMP  0x00
000016 940c 0000 	JMP  0x00
000018 940c 0335 	JMP  _timer1_comp_a_isr
00001a 940c 0428 	JMP  _timer1_comp_b_isr
00001c 940c 0000 	JMP  0x00
00001e 940c 0000 	JMP  0x00
000020 940c 04f3 	JMP  _timer0_ovf_isr
000022 940c 0000 	JMP  0x00
000024 940c 02c8 	JMP  _uart_rx_isr
000026 940c 0000 	JMP  0x00
000028 940c 0000 	JMP  0x00
00002a 940c 0000 	JMP  0x00
00002c 940c 0000 	JMP  0x00
00002e 940c 0000 	JMP  0x00
000030 940c 0000 	JMP  0x00
000032 940c 0000 	JMP  0x00
000034 940c 0000 	JMP  0x00
000036 940c 0000 	JMP  0x00
000038 940c 0000 	JMP  0x00
00003a 940c 0000 	JMP  0x00
00003c 940c 0000 	JMP  0x00
00003e 940c 0000 	JMP  0x00
000040 940c 0000 	JMP  0x00
000042 940c 0000 	JMP  0x00
000044 940c 0000 	JMP  0x00
                 
                 	.INCLUDE "Coding.inc"
                 
                 _device_name:
000046 6f50
000047 7472
000048 4420
000049 7665      	.DB  0x50,0x6F,0x72,0x74,0x20,0x44,0x65,0x76
00004a 6369
00004b 2065
00004c 3176
00004d 302e      	.DB  0x69,0x63,0x65,0x20,0x76,0x31,0x2E,0x30
Coding.inc(5): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00004e 0000      	.DB  0x0
00004f 0000      	.DW  0x0
000050 0000      	.DW  0x0
000051 0000      	.DW  0x0
000052 0000      	.DW  0x0
000053 0000      	.DW  0x0
000054 0000      	.DW  0x0
000055 0000      	.DW  0x0
                 _my_version:
000056 0100      	.DB  0x0,0x1
                 	.DEF _str=R4
                 _3:
000057 0785      	.DW  _rx0buf
                 	.DEF _str1=R6
                 _4:
000058 0785      	.DW  _rx0buf
                 	.DEF _pntr1=R8
                 _5:
Coding.inc(23): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
000059 0001      	.DB  0x1
                 _6:
Coding.inc(25): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005a 0002      	.DB  0x2
                 _7:
Coding.inc(27): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005b 0003      	.DB  0x3
                 _8:
Coding.inc(29): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005c 0004      	.DB  0x4
                 	.DEF _tx0crc=R10
                 	.DEF _rx0state=R11
                 _61:
Coding.inc(33): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005d 0001      	.DB  0x1
                 	.DEF _rx0crc=R12
                 	.DEF _rx0len=R13
                 	.DEF _rx0type=R14
                 _135:
Coding.inc(38): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005e 000a      	.DB  0xA
                 _sd_cmd:
00005f 0000      	.DB  0x0,0x0
000060 0040      	.DB  0x40,0x0
000061 0000      	.DB  0x0,0x0
000062 0000      	.DB  0x0,0x0
000063 0001      	.DB  0x1,0x0
000064 0041      	.DB  0x41,0x0
000065 0000      	.DB  0x0,0x0
000066 0000      	.DB  0x0,0x0
000067 0002      	.DB  0x2,0x0
000068 0049      	.DB  0x49,0x0
000069 0000      	.DB  0x0,0x0
00006a 0000      	.DB  0x0,0x0
00006b 0003      	.DB  0x3,0x0
00006c 004a      	.DB  0x4A,0x0
00006d 0000      	.DB  0x0,0x0
00006e 0000      	.DB  0x0,0x0
00006f 0004      	.DB  0x4,0x0
000070 004c      	.DB  0x4C,0x0
000071 0000      	.DB  0x0,0x0
000072 0000      	.DB  0x0,0x0
000073 0005      	.DB  0x5,0x0
000074 004d      	.DB  0x4D,0x0
000075 0000      	.DB  0x0,0x0
000076 0002      	.DB  0x2,0x0
000077 0006      	.DB  0x6,0x0
000078 0050      	.DB  0x50,0x0
000079 0001      	.DB  0x1,0x0
00007a 0000      	.DB  0x0,0x0
00007b 0007      	.DB  0x7,0x0
00007c 0051      	.DB  0x51,0x0
00007d 0002      	.DB  0x2,0x0
00007e 0000      	.DB  0x0,0x0
00007f 0008      	.DB  0x8,0x0
000080 0052      	.DB  0x52,0x0
000081 0002      	.DB  0x2,0x0
000082 0000      	.DB  0x0,0x0
000083 0009      	.DB  0x9,0x0
000084 0058      	.DB  0x58,0x0
000085 0002      	.DB  0x2,0x0
000086 0000      	.DB  0x0,0x0
000087 000a      	.DB  0xA,0x0
000088 0059      	.DB  0x59,0x0
000089 0002      	.DB  0x2,0x0
00008a 0000      	.DB  0x0,0x0
00008b 000b      	.DB  0xB,0x0
00008c 005b      	.DB  0x5B,0x0
00008d 0000      	.DB  0x0,0x0
00008e 0000      	.DB  0x0,0x0
00008f 000c      	.DB  0xC,0x0
000090 005c      	.DB  0x5C,0x0
000091 0002      	.DB  0x2,0x0
000092 0001      	.DB  0x1,0x0
000093 000d      	.DB  0xD,0x0
000094 005d      	.DB  0x5D,0x0
000095 0002      	.DB  0x2,0x0
000096 0001      	.DB  0x1,0x0
000097 000e      	.DB  0xE,0x0
000098 005e      	.DB  0x5E,0x0
000099 0002      	.DB  0x2,0x0
00009a 0000      	.DB  0x0,0x0
00009b 000f      	.DB  0xF,0x0
00009c 0060      	.DB  0x60,0x0
00009d 0002      	.DB  0x2,0x0
00009e 0000      	.DB  0x0,0x0
00009f 0010      	.DB  0x10,0x0
0000a0 0061      	.DB  0x61,0x0
0000a1 0002      	.DB  0x2,0x0
0000a2 0000      	.DB  0x0,0x0
0000a3 0011      	.DB  0x11,0x0
0000a4 0062      	.DB  0x62,0x0
0000a5 0002      	.DB  0x2,0x0
0000a6 0000      	.DB  0x0,0x0
0000a7 0012      	.DB  0x12,0x0
0000a8 0063      	.DB  0x63,0x0
0000a9 0002      	.DB  0x2,0x0
0000aa 0000      	.DB  0x0,0x0
0000ab 0013      	.DB  0x13,0x0
0000ac 0064      	.DB  0x64,0x0
0000ad 0002      	.DB  0x2,0x0
0000ae 0000      	.DB  0x0,0x0
0000af 0014      	.DB  0x14,0x0
0000b0 0065      	.DB  0x65,0x0
0000b1 0002      	.DB  0x2,0x0
0000b2 0000      	.DB  0x0,0x0
0000b3 0015      	.DB  0x15,0x0
0000b4 0066      	.DB  0x66,0x0
0000b5 0003      	.DB  0x3,0x0
0000b6 0001      	.DB  0x1,0x0
0000b7 0016      	.DB  0x16,0x0
0000b8 006a      	.DB  0x6A,0x0
0000b9 0003      	.DB  0x3,0x0
0000ba 0001      	.DB  0x1,0x0
0000bb 0017      	.DB  0x17,0x0
0000bc 007a      	.DB  0x7A,0x0
0000bd 0000      	.DB  0x0,0x0
0000be 0003      	.DB  0x3,0x0
0000bf 0018      	.DB  0x18,0x0
0000c0 007b      	.DB  0x7B,0x0
0000c1 0003      	.DB  0x3,0x0
0000c2 0000      	.DB  0x0,0x0
0000c3 0019      	.DB  0x19,0x0
0000c4 0069      	.DB  0x69,0x0
0000c5 0000      	.DB  0x0,0x0
0000c6 0000      	.DB  0x0,0x0
                 _tbl10_G8:
0000c7 2710
0000c8 03e8
0000c9 0064
0000ca 000a      	.DB  0x10,0x27,0xE8,0x3,0x64,0x0,0xA,0x0
0000cb 0001      	.DB  0x1,0x0
                 _tbl16_G8:
0000cc 1000
0000cd 0100
0000ce 0010
0000cf 0001      	.DB  0x0,0x10,0x0,0x1,0x10,0x0,0x1,0x0
                 _0:
0000d0 eecf
0000d1 f2f0
0000d2 3120
0000d3 cf00      	.DB  0xCF,0xEE,0xF0,0xF2,0x20,0x31,0x0,0xCF
0000d4 f0ee
0000d5 20f2
0000d6 0032
0000d7 eecf      	.DB  0xEE,0xF0,0xF2,0x20,0x32,0x0,0xCF,0xEE
0000d8 f2f0
0000d9 3320
0000da cf00
0000db f0ee      	.DB  0xF0,0xF2,0x20,0x33,0x0,0xCF,0xEE,0xF0
0000dc 20f2
0000dd 0034
0000de 0d0a
0000df 2500      	.DB  0xF2,0x20,0x34,0x0,0xA,0xD,0x0,0x25
0000e0 2058
0000e1 2500
0000e2 3230
0000e3 2058      	.DB  0x58,0x20,0x0,0x25,0x30,0x32,0x58,0x20
Coding.inc(155): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
0000e4 0000      	.DB  0x0
                 
                 ;HEAP START MARKER INITIALIZATION
                 __HEAP_START_MARKER:
0000e5 0000
0000e6 0000      	.DW  0,0
                 
                 __GLOBAL_INI_TBL:
0000e7 0004      	.DW  0x04
0000e8 0ca8      	.DW  0xCA8
0000e9 01ca      	.DW  __HEAP_START_MARKER*2
                 
0000ea 0002      	.DW  0x02
0000eb 0004      	.DW  0x04
0000ec 00ae      	.DW  _3*2
                 
0000ed 0002      	.DW  0x02
0000ee 0006      	.DW  0x06
0000ef 00b0      	.DW  _4*2
                 
0000f0 0007      	.DW  0x07
0000f1 0740      	.DW  _0cp
0000f2 01a0      	.DW  _0*2
                 
0000f3 0001      	.DW  0x01
0000f4 0750      	.DW  _1cp
0000f5 00b2      	.DW  _5*2
                 
0000f6 0007      	.DW  0x07
0000f7 0751      	.DW  _2cp
0000f8 01a7      	.DW  _0*2+0x07
                 
0000f9 0001      	.DW  0x01
0000fa 0761      	.DW  _3cp
0000fb 00b4      	.DW  _6*2
                 
0000fc 0007      	.DW  0x07
0000fd 0762      	.DW  _4cp
0000fe 01ae      	.DW  _0*2+0x0E
                 
0000ff 0001      	.DW  0x01
000100 0772      	.DW  _5cp
000101 00b6      	.DW  _7*2
                 
000102 0007      	.DW  0x07
000103 0773      	.DW  _6cp
000104 01b5      	.DW  _0*2+0x15
                 
000105 0001      	.DW  0x01
000106 0783      	.DW  _7cp
000107 00b8      	.DW  _8*2
                 
000108 0001      	.DW  0x01
000109 000b      	.DW  0x0B
00010a 00ba      	.DW  _61*2
                 
00010b 0001      	.DW  0x01
00010c 0886      	.DW  _rx1state
00010d 00bc      	.DW  _135*2
                 
00010e 0000      	.DW  0
                 _0x43C:
                 
                 __RESET:
00010f 94f8      	CLI
000110 27ee      	CLR  R30
000111 bbec      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF FLASH
000112 e0f1      	LDI  R31,1
000113 bff5      	OUT  MCUCR,R31
000114 bfe5      	OUT  MCUCR,R30
000115 93e0 006c 	STS  XMCRB,R30
000117 bfeb      	OUT  RAMPZ,R30
                 
                 ;DISABLE WATCHDOG
000118 e1f8      	LDI  R31,0x18
000119 bdf1      	OUT  WDTCR,R31
00011a bde1      	OUT  WDTCR,R30
                 
                 ;CLEAR R2-R14
00011b e08d      	LDI  R24,13
00011c e0a2      	LDI  R26,2
00011d 27bb      	CLR  R27
                 __CLEAR_REG:
00011e 93ed      	ST   X+,R30
00011f 958a      	DEC  R24
000120 f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
000121 ea88      	LDI  R24,LOW(0xBA8)
000122 e09b      	LDI  R25,HIGH(0xBA8)
000123 e0a0      	LDI  R26,LOW(0x100)
000124 e0b1      	LDI  R27,HIGH(0x100)
                 __CLEAR_SRAM:
000125 93ed      	ST   X+,R30
000126 9701      	SBIW R24,1
000127 f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GLOBAL VARIABLES INITIALIZATION
000128 ecee      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
000129 e0f1      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
                 __GLOBAL_INI_NEXT:
00012a 9185      	LPM  R24,Z+
00012b 9195      	LPM  R25,Z+
00012c 9700      	SBIW R24,0
00012d f061      	BREQ __GLOBAL_INI_END
00012e 91a5      	LPM  R26,Z+
00012f 91b5      	LPM  R27,Z+
000130 9005      	LPM  R0,Z+
000131 9015      	LPM  R1,Z+
000132 01bf      	MOVW R22,R30
000133 01f0      	MOVW R30,R0
                 __GLOBAL_INI_LOOP:
000134 9005      	LPM  R0,Z+
000135 920d      	ST   X+,R0
000136 9701      	SBIW R24,1
000137 f7e1      	BRNE __GLOBAL_INI_LOOP
000138 01fb      	MOVW R30,R22
000139 cff0      	RJMP __GLOBAL_INI_NEXT
                 __GLOBAL_INI_END:
                 
                 ;STACK POINTER INITIALIZATION
00013a eae7      	LDI  R30,LOW(0xCA7)
00013b bfed      	OUT  SPL,R30
00013c e0ec      	LDI  R30,HIGH(0xCA7)
00013d bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
00013e e0c0      	LDI  R28,LOW(0x500)
00013f e0d5      	LDI  R29,HIGH(0x500)
                 
000140 940c 023d 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x500
                 ;       1 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                 ;       2 // Управляющая программа КОДЕРА
                 ;       3 
                 ;       4 #include "Coding.h"
                 ;       5 
                 ;       6 flash unsigned char device_name[32] =					// Имя устройства
                 
                 	.CSEG
                 ;       7 		"Port Device v1.0";
                 ;       8 eeprom unsigned long my_ser_num = 0;					// Серийный номер устройства
                 
                 	.ESEG
                 _my_ser_num:
000000 00 00     	.DW  0x0
000002 00 00     	.DW  0x0
                 ;       9 const flash unsigned short my_version = 0x0100;			// Версия софта 
                 
                 	.CSEG
                 ;      10 eeprom unsigned char my_addr = TO_MON;					// Мой адрес - изначально TO_MON
                 
                 	.ESEG
                 _my_addr:
000004 fe        	.DB  0xFE
                 ;      11 
                 ;      12 unsigned char txBuffer [256];		//буффер передатчика
                 
                 	.DSEG
                 _txBuffer:
000500           	.BYTE 0x100
                 ;      13 unsigned char rxBuffer [256];		//буер приемника
                 _rxBuffer:
000600           	.BYTE 0x100
                 ;      14 unsigned char lAddrDevice	[64];	// храним лог. адреса подключенных устройств
                 _lAddrDevice:
000700           	.BYTE 0x40
                 ;      15 															// 0 ячейка - кол-во портов 232 .1 ячейка содержит лог. адрес порта 1, 2-лог.
                 ;      16 															// адрес порта 2 и т. д.
                 ;      17 // Переменные для работы с CF Card
                 ;      18 /*
                 ;      19 typedef struct 				// структура приемного пакета при передаче имени файла
                 ;      20 {
                 ;      21 	char Ptype;               // тип принятого пакета
                 ;      22 	char fname[13];        // имя файла
                 ;      23 } strInPack; */
                 ;      24 
                 ;      25 strInPack * str = (strInPack *)(rx0buf);
                 ;      26 strDataPack * str1 = (strDataPack *)(rx0buf);
                 ;      27 
                 ;      28 FILE *pntr1; 
                 ;      29 
                 ;      30 
                 ;      31 typedef struct _chip_port
                 ;      32 {
                 ;      33 	flash char name[16];
                 ;      34 	flash unsigned char addr;
                 ;      35 } CHIPPORT;
                 ;      36 
                 ;      37 CHIPPORT cp[] = {
                 _cp:
                 ;      38 	{"Порт 1", 1},
                 _0cp:
000740           	.BYTE 0x10
                 _1cp:
000750           	.BYTE 0x1
                 ;      39 	{"Порт 2", 2},
                 _2cp:
000751           	.BYTE 0x10
                 _3cp:
000761           	.BYTE 0x1
                 ;      40 	{"Порт 3", 3},
                 _4cp:
000762           	.BYTE 0x10
                 _5cp:
000772           	.BYTE 0x1
                 ;      41 	{"Порт 4", 4}
                 _6cp:
000773           	.BYTE 0x10
                 _7cp:
000783           	.BYTE 0x1
                 ;      42 };
                 ;      43 
                 ;      44 //-----------------------------------------------------------------------------------------------------------------
                 ;      45 // Возвращаю состояние устройства
                 ;      46 static void GetState(void)
                 ;      47 {
                 
                 	.CSEG
                 _GetState_G1:
                 ;      48 	register unsigned char i, n, b;
                 ;      49 	
                 ;      50 	#define strq  ((RQ_GETSTATE *)rx0buf)
                 ;      51 
                 ;      52 	switch(strq->page)
000142 940e 1f27 	CALL __SAVELOCR3
                 ;	i -> R16
                 ;	n -> R17
                 ;	b -> R18
000144 91e0 0785 	LDS  R30,_rx0buf
                 ;      53 	{
                 ;      54 	case 0:
000146 30e0      	CPI  R30,0
000147 f011      	BREQ PC+3
000148 940c 0188 	JMP _0xC
                 ;      55 		StartReply(2 + 16*(sizeof(cp) / sizeof(CHIPPORT)) + 1);
00014a e4e3      	LDI  R30,LOW(67)
00014b 93ea      	ST   -Y,R30
00014c d16d      	RCALL _StartReply
                 ;      56 
                 ;      57 		putchar0(2);               						 // число доступных страниц, включая эту
00014d e0e2      	LDI  R30,LOW(2)
00014e 93ea      	ST   -Y,R30
00014f d164      	RCALL _putchar0
                 ;      58 		putchar0(0);										// зарезервирован
000150 e0e0      	LDI  R30,LOW(0)
000151 93ea      	ST   -Y,R30
000152 d161      	RCALL _putchar0
                 ;      59 		
                 ;      60 		for (n = 0; n < (sizeof(cp) / sizeof(CHIPPORT)); n ++)
000153 e010      	LDI  R17,LOW(0)
                 _0xE:
000154 3014      	CPI  R17,4
000155 f568      	BRSH _0xF
                 ;      61 		{
                 ;      62 			for (i = 0; i < 15; i ++)
000156 e000      	LDI  R16,LOW(0)
                 _0x11:
000157 300f      	CPI  R16,15
000158 f4a0      	BRSH _0x12
                 ;      63 			{
                 ;      64 				b = cp[n].name[i];
000159 2fe1      	MOV  R30,R17
00015a e0f0      	LDI  R31,0
00015b e1a1      	LDI  R26,LOW(17)
00015c e0b0      	LDI  R27,HIGH(17)
00015d 940e 1e20 	CALL __MULW12U
00015f 5ce0      	SUBI R30,LOW(-_cp)
000160 4ff8      	SBCI R31,HIGH(-_cp)
000161 01df      	MOVW R26,R30
000162 2fe0      	MOV  R30,R16
000163 e0f0      	LDI  R31,0
000164 0fae      	ADD  R26,R30
000165 1fbf      	ADC  R27,R31
000166 912c      	LD   R18,X
                 ;      65 				if (!b)
000167 3020      	CPI  R18,0
000168 f021      	BREQ _0x12
                 ;      66 				{
                 ;      67 					break;
                 ;      68 				}
                 ;      69 				putchar0(b);
000169 932a      	ST   -Y,R18
00016a d149      	RCALL _putchar0
                 ;      70 			}
00016b 5f0f      	SUBI R16,-1
00016c cfea      	RJMP _0x11
                 _0x12:
                 ;      71 			while(i < 15)
                 _0x14:
00016d 300f      	CPI  R16,15
00016e f428      	BRSH _0x16
                 ;      72 			{
                 ;      73 				putchar0(' ');
00016f e2e0      	LDI  R30,LOW(32)
000170 93ea      	ST   -Y,R30
000171 d142      	RCALL _putchar0
                 ;      74 				i++;
000172 5f0f      	SUBI R16,-1
                 ;      75 			}
000173 cff9      	RJMP _0x14
                 _0x16:
                 ;      76 			
                 ;      77 			putchar0(cp[n].addr);
000174 2fa1      	MOV  R26,R17
000175 27bb      	CLR  R27
000176 e1e1      	LDI  R30,LOW(17)
000177 e0f0      	LDI  R31,HIGH(17)
000178 940e 1e20 	CALL __MULW12U
00017a e5a0
00017b e0b7      	__POINTW2MN _cp,16
00017c 0fae      	ADD  R26,R30
00017d 1fbf      	ADC  R27,R31
00017e 91ec      	LD   R30,X
00017f 93ea      	ST   -Y,R30
000180 d133      	RCALL _putchar0
                 ;      78 		}
000181 5f1f      	SUBI R17,-1
000182 cfd1      	RJMP _0xE
                 _0xF:
                 ;      79 		
                 ;      80 		putchar0(255);
000183 efef      	LDI  R30,LOW(255)
000184 93ea      	ST   -Y,R30
000185 d12e      	RCALL _putchar0
                 ;      81 
                 ;      82 		EndReply();
000186 d13b      	RCALL _EndReply
                 ;      83 		return;
000187 c02e      	RJMP _0x432
                 ;      84 
                 ;      85 	case 1:
                 _0xC:
000188 30e1      	CPI  R30,LOW(0x1)
000189 f561      	BRNE _0xB
                 ;      86 	
                 ;      87 		StartReply(3 * (sizeof(cp) / sizeof(CHIPPORT)) + 1);
00018a e0ed      	LDI  R30,LOW(13)
00018b 93ea      	ST   -Y,R30
00018c d12d      	RCALL _StartReply
                 ;      88 		
                 ;      89 		for (n = 0; n < (sizeof(cp) / sizeof(CHIPPORT)); n++)
00018d e010      	LDI  R17,LOW(0)
                 _0x19:
00018e 3014      	CPI  R17,4
00018f f510      	BRSH _0x1A
                 ;      90 		{
                 ;      91 			putchar0(n);
000190 931a      	ST   -Y,R17
000191 d122      	RCALL _putchar0
                 ;      92 			putchar0(cp[n].addr);
000192 2fa1      	MOV  R26,R17
000193 27bb      	CLR  R27
000194 e1e1      	LDI  R30,LOW(17)
000195 e0f0      	LDI  R31,HIGH(17)
000196 940e 1e20 	CALL __MULW12U
000198 e5a0
000199 e0b7      	__POINTW2MN _cp,16
00019a 0fae      	ADD  R26,R30
00019b 1fbf      	ADC  R27,R31
00019c 91ec      	LD   R30,X
00019d 93ea      	ST   -Y,R30
00019e d115      	RCALL _putchar0
                 ;      93 			putchar0(lAddrDevice [cp[n].addr]);
00019f 2fa1      	MOV  R26,R17
0001a0 27bb      	CLR  R27
0001a1 e1e1      	LDI  R30,LOW(17)
0001a2 e0f0      	LDI  R31,HIGH(17)
0001a3 940e 1e20 	CALL __MULW12U
0001a5 e5a0
0001a6 e0b7      	__POINTW2MN _cp,16
0001a7 0fae      	ADD  R26,R30
0001a8 1fbf      	ADC  R27,R31
0001a9 91ec      	LD   R30,X
0001aa e0f0      	LDI  R31,0
0001ab 50e0      	SUBI R30,LOW(-_lAddrDevice)
0001ac 4ff9      	SBCI R31,HIGH(-_lAddrDevice)
0001ad 81e0      	LD   R30,Z
0001ae 93ea      	ST   -Y,R30
0001af d104      	RCALL _putchar0
                 ;      94 		}
0001b0 5f1f      	SUBI R17,-1
0001b1 cfdc      	RJMP _0x19
                 _0x1A:
                 ;      95 
                 ;      96 		putchar0(255);
0001b2 efef      	LDI  R30,LOW(255)
0001b3 93ea      	ST   -Y,R30
0001b4 d0ff      	RCALL _putchar0
                 ;      97 
                 ;      98 		EndReply();
0001b5 d10c      	RCALL _EndReply
                 ;      99 		return;
                 ;     100 	}
                 _0xB:
                 ;     101 }
                 _0x432:
0001b6 940e 1f2e 	CALL __LOADLOCR3
0001b8 9623      	ADIW R28,3
0001b9 9508      	RET
                 ;     102 
                 ;     103 //-----------------------------------------------------------------------------------------------------------------
                 ;     104 // Информация об устройстве
                 ;     105 static void GetInfo(void)
                 ;     106 {
                 _GetInfo_G1:
                 ;     107 	register unsigned char i;
                 ;     108 	
                 ;     109 	// 	Начинаю передачу ответа
                 ;     110 	StartReply(40);
0001ba 930a      	ST   -Y,R16
                 ;	i -> R16
0001bb e2e8      	LDI  R30,LOW(40)
0001bc 93ea      	ST   -Y,R30
0001bd d0fc      	RCALL _StartReply
                 ;     111 	
                 ;     112 	for (i = 0; i < 32; i ++)	// Имя устройства
0001be e000      	LDI  R16,LOW(0)
                 _0x1C:
0001bf 3200      	CPI  R16,32
0001c0 f448      	BRSH _0x1D
                 ;     113 	{
                 ;     114 		putchar0(device_name[i]);
0001c1 2fe0      	MOV  R30,R16
0001c2 e0f0      	LDI  R31,0
0001c3 57e4      	SUBI R30,LOW(-_device_name*2)
0001c4 4fff      	SBCI R31,HIGH(-_device_name*2)
0001c5 91e4      	LPM  R30,Z
0001c6 93ea      	ST   -Y,R30
0001c7 d0ec      	RCALL _putchar0
                 ;     115 	}
0001c8 5f0f      	SUBI R16,-1
0001c9 cff5      	RJMP _0x1C
                 _0x1D:
                 ;     116 
                 ;     117 	putword0(my_ser_num);		// Серийный номер
0001ca e0a0      	LDI  R26,LOW(_my_ser_num)
0001cb e0b0      	LDI  R27,HIGH(_my_ser_num)
0001cc 940e 1ed5 	CALL __EEPROMRDD
0001ce 93fa      	ST   -Y,R31
0001cf 93ea      	ST   -Y,R30
0001d0 d18c      	RCALL _putword0
                 ;     118 	putword0(my_ser_num >> 16);	
0001d1 e0a0      	LDI  R26,LOW(_my_ser_num)
0001d2 e0b0      	LDI  R27,HIGH(_my_ser_num)
0001d3 940e 1ed5 	CALL __EEPROMRDD
0001d5 940e 1e11 	CALL __LSRD16
0001d7 93fa      	ST   -Y,R31
0001d8 93ea      	ST   -Y,R30
0001d9 d183      	RCALL _putword0
                 ;     119 	
                 ;     120 	putchar0(my_addr);			// Адрес устройстав
0001da e0a4      	LDI  R26,LOW(_my_addr)
0001db e0b0      	LDI  R27,HIGH(_my_addr)
0001dc 940e 1ede 	CALL __EEPROMRDB
0001de 93ea      	ST   -Y,R30
0001df d0d4      	RCALL _putchar0
                 ;     121 
                 ;     122 	putchar0(0);				// Зарезервированный байт
0001e0 e0e0      	LDI  R30,LOW(0)
0001e1 93ea      	ST   -Y,R30
0001e2 d0d1      	RCALL _putchar0
                 ;     123 	
                 ;     124 	putword0(my_version);		// Версия
0001e3 eaec      	LDI  R30,LOW(_my_version*2)
0001e4 e0f0      	LDI  R31,HIGH(_my_version*2)
0001e5 940e 1ec7 	CALL __GETW1PF
0001e7 93fa      	ST   -Y,R31
0001e8 93ea      	ST   -Y,R30
0001e9 d173      	RCALL _putword0
                 ;     125 	
                 ;     126 	EndReply();					// Завершаю ответ
0001ea d0d7      	RCALL _EndReply
                 ;     127 }
0001eb 9109      	LD   R16,Y+
0001ec 9508      	RET
                 ;     128 
                 ;     129 //-----------------------------------------------------------------------------------------------------------------
                 ;     130 // Смена адреса устройства
                 ;     131 static void SetAddr(void)
                 ;     132 {
                 _SetAddr_G1:
                 ;     133 	#define sap ((RQ_SETADDR *)rx0buf)
                 ;     134 	
                 ;     135 	my_addr = sap->addr;
0001ed 91e0 0785 	LDS  R30,_rx0buf
0001ef e0a4      	LDI  R26,LOW(_my_addr)
0001f0 e0b0      	LDI  R27,HIGH(_my_addr)
0001f1 940e 1efd 	CALL __EEPROMWRB
                 ;     136 	
                 ;     137 	StartReply(1);
0001f3 e0e1      	LDI  R30,LOW(1)
0001f4 93ea      	ST   -Y,R30
0001f5 d0c4      	RCALL _StartReply
                 ;     138 	putchar0(RES_OK);
0001f6 e0e1      	LDI  R30,LOW(1)
0001f7 93ea      	ST   -Y,R30
0001f8 d0bb      	RCALL _putchar0
                 ;     139 	EndReply();
0001f9 d0c8      	RCALL _EndReply
                 ;     140 }
0001fa 9508      	RET
                 ;     141 
                 ;     142 //-----------------------------------------------------------------------------------------------------------------
                 ;     143 // Назначение серийного номера устройства
                 ;     144 static void SetSerial(void)
                 ;     145 {
                 _SetSerial_G1:
                 ;     146 	#define ssp ((RQ_SETSERIAL *)rx0buf)
                 ;     147 	
                 ;     148 	if (my_ser_num)
0001fb e0a0      	LDI  R26,LOW(_my_ser_num)
0001fc e0b0      	LDI  R27,HIGH(_my_ser_num)
0001fd 940e 1ed5 	CALL __EEPROMRDD
0001ff 940e 1f0c 	CALL __CPD10
000201 f041      	BREQ _0x1E
                 ;     149 	{
                 ;     150 		StartReply(1);
000202 e0e1      	LDI  R30,LOW(1)
000203 93ea      	ST   -Y,R30
000204 d0b5      	RCALL _StartReply
                 ;     151 		putchar0(RES_ERR);
000205 e0e0      	LDI  R30,LOW(0)
000206 93ea      	ST   -Y,R30
000207 d0ac      	RCALL _putchar0
                 ;     152 		EndReply();
000208 d0b9      	RCALL _EndReply
                 ;     153 		return;
000209 9508      	RET
                 ;     154 	}
                 ;     155 	
                 ;     156 	my_ser_num = ssp->num;
                 _0x1E:
00020a 91e0 0785 	LDS  R30,_rx0buf
00020c 91f0 0786 	LDS  R31,_rx0buf+1
00020e 9160 0787 	LDS  R22,_rx0buf+2
000210 9170 0788 	LDS  R23,_rx0buf+3
000212 e0a0      	LDI  R26,LOW(_my_ser_num)
000213 e0b0      	LDI  R27,HIGH(_my_ser_num)
000214 940e 1eea 	CALL __EEPROMWRD
                 ;     157 	
                 ;     158 	StartReply(1);
000216 e0e1      	LDI  R30,LOW(1)
000217 93ea      	ST   -Y,R30
000218 d0a1      	RCALL _StartReply
                 ;     159 	putchar0(RES_OK);
000219 e0e1      	LDI  R30,LOW(1)
00021a 93ea      	ST   -Y,R30
00021b d098      	RCALL _putchar0
                 ;     160 	EndReply();
00021c d0a5      	RCALL _EndReply
                 ;     161 }
00021d 9508      	RET
                 ;     162 
                 ;     163 //-----------------------------------------------------------------------------------------------------------------
                 ;     164 // Перезагрузка в режим программирования
                 ;     165 static void ToProg(void)
                 ;     166 {
                 _ToProg_G1:
                 ;     167 	// Отправляю ответ
                 ;     168 	StartReply(0);
00021e e0e0      	LDI  R30,LOW(0)
00021f 93ea      	ST   -Y,R30
000220 d099      	RCALL _StartReply
                 ;     169 	EndReply();
000221 d0a0      	RCALL _EndReply
                 ;     170 
                 ;     171 	// На перезагрузку в монитор
                 ;     172 	MCUCR = 1 << IVCE;
000222 e0e1      	LDI  R30,LOW(1)
000223 bfe5      	OUT  0x35,R30
                 ;     173 	MCUCR = 1 << IVSEL;
000224 e0e2      	LDI  R30,LOW(2)
000225 bfe5      	OUT  0x35,R30
                 ;     174 
                 ;     175 	#asm("jmp 0xFC00");
000226 940c fc00 	jmp 0xFC00
                 ;     176 }
000228 9508      	RET
                 ;     177 
                 ;     178 //-----------------------------------------------------------------------------------------------------------------
                 ;     179 // Железо процессора в исходное состояние
                 ;     180 static void HardwareInit(void)
                 ;     181 {         
                 _HardwareInit_G1:
                 ;     182         twi_init ();      
000229 d165      	RCALL _twi_init
                 ;     183 		CommInit();				// Инициализация  COM-порта
00022a d123      	RCALL _CommInit
                 ;     184 		timer_0_Init ();			// Инициализируем таймер 0 (таймаут)
00022b d2b2      	RCALL _timer_0_Init
                 ;     185 		portInit();					// Выводы - в исходное состояние
00022c d2ae      	RCALL _portInit
                 ;     186         
                 ;     187 }
00022d 9508      	RET
                 ;     188 
                 ;     189 //-----------------------------------------------------------------------------------------------------------------
                 ;     190 // Сброс периферии
                 ;     191 void ResetPeripherial(void)
                 ;     192 {
                 _ResetPeripherial:
                 ;     193         CRST = 0;
00022e 98da      	CBI  0x1B,2
                 ;     194         delay_ms(10);
00022f e0ea      	LDI  R30,LOW(10)
000230 e0f0      	LDI  R31,HIGH(10)
000231 93fa      	ST   -Y,R31
000232 93ea      	ST   -Y,R30
000233 940e 1dbe 	CALL _delay_ms
                 ;     195         CRST = 1;
000235 9ada      	SBI  0x1B,2
                 ;     196         delay_ms(500);     //Ждем пока отработают сброс
000236 efe4      	LDI  R30,LOW(500)
000237 e0f1      	LDI  R31,HIGH(500)
000238 93fa      	ST   -Y,R31
000239 93ea      	ST   -Y,R30
00023a 940e 1dbe 	CALL _delay_ms
                 ;     197 }
00023c 9508      	RET
                 ;     198 
                 ;     199 //-----------------------------------------------------------------------------------------------------------------
                 ;     200 // Точка входа в программу
                 ;     201 void main(void)
                 ;     202 {
                 _main:
                 ;     203 unsigned char a;   
                 ;     204 
                 ;     205 //	Пока происходят внутренние работы светодиод - красный. По окончании - зеленый.
                 ;     206 
                 ;     207     LedRed();               
                 ;	a -> R16
00023d 9ad0      	SBI  0x1A,0
00023e 9ad1      	SBI  0x1A,1
00023f 98d8      	CBI  0x1B,0
000240 9ad9      	SBI  0x1B,1
                 ;     208 	HardwareInit();				// Железо процессора
000241 940e 0229 	CALL _HardwareInit_G1
                 ;     209 	ResetPeripherial();		// Сбрасываю периферию 
000243 940e 022e 	CALL _ResetPeripherial
                 ;     210 
                 ;     211 	#asm("sei")
000245 9478      	sei
                 ;     212 
                 ;     213 	UCSR0B.3 = 1;		 				// Разрешаю передатчик UART
000246 9a53      	SBI  0xA,3
                 ;     214 	delay_ms (3000);					// даем время отработать сброс
000247 ebe8      	LDI  R30,LOW(3000)
000248 e0fb      	LDI  R31,HIGH(3000)
000249 93fa      	ST   -Y,R31
00024a 93ea      	ST   -Y,R30
00024b 940e 1dbe 	CALL _delay_ms
                 ;     215 	verIntDev();							// Считаем	 количество подчиненных устройств 
00024d d2b3      	RCALL _verIntDev
                 ;     216 
                 ;     217 // работаем с карточкой...
                 ;     218 	while (!(initialize_media()));		// инициализация CF Card   
                 _0x1F:
00024e d53a      	RCALL _initialize_media
00024f 30e0      	CPI  R30,0
000250 f3e9      	BREQ _0x1F
                 ;     219 
                 ;     220 	while (1)
                 _0x22:
                 ;     221 	{
                 ;     222 		LedGreen();
000251 9ad0      	SBI  0x1A,0
000252 9ad1      	SBI  0x1A,1
000253 9ad8      	SBI  0x1B,0
000254 98d9      	CBI  0x1B,1
                 ;     223 
                 ;     224 		for (a=1; a<= int_Devices; a++) pingPack (a);	   			// вычитываем у кого что есть
000255 e001      	LDI  R16,LOW(1)
                 _0x26:
000256 91e0 098b 	LDS  R30,_int_Devices
000258 17e0      	CP   R30,R16
000259 f020      	BRLO _0x27
00025a 930a      	ST   -Y,R16
00025b d335      	RCALL _pingPack
                 ;     225 
                 ;     226 		ReadLogAddr ();				// Вычитываем лог. адреса
00025c 5f0f      	SUBI R16,-1
00025d cff8      	RJMP _0x26
                 _0x27:
00025e d2d5      	RCALL _ReadLogAddr
                 ;     227 	
                 ;     228 
                 ;     229 		// Проверяю, нет ли пакета и принимаю меры, если есть
                 ;     230 		if (HaveIncomingPack())
00025f d0e1      	RCALL _HaveIncomingPack
000260 30e0      	CPI  R30,0
000261 f411      	BRNE PC+3
000262 940c 02b2 	JMP _0x28
                 ;     231 		{
                 ;     232 		if ((rx0addr == my_addr) || (rx0addr == TO_ALL))				// адрес мой 
000264 e0a4      	LDI  R26,LOW(_my_addr)
000265 e0b0      	LDI  R27,HIGH(_my_addr)
000266 940e 1ede 	CALL __EEPROMRDB
000268 91a0 0784 	LDS  R26,_rx0addr
00026a 17ea      	CP   R30,R26
00026b f011      	BREQ _0x2A
00026c 3faf      	CPI  R26,LOW(0xFF)
00026d f521      	BRNE _0x29
                 _0x2A:
                 ;     233 			{
                 ;     234 				switch(IncomingPackType())
00026e d0da      	RCALL _IncomingPackType
                 ;     235 					{
                 ;     236 						case PT_GETSTATE:
00026f 30e1      	CPI  R30,LOW(0x1)
000270 f419      	BRNE _0x2F
                 ;     237 								GetState();
000271 940e 0142 	CALL _GetState_G1
                 ;     238 								break;
000273 c01d      	RJMP _0x2E
                 ;     239 				
                 ;     240 						case PT_GETINFO:
                 _0x2F:
000274 30e3      	CPI  R30,LOW(0x3)
000275 f419      	BRNE _0x30
                 ;     241 								GetInfo();
000276 940e 01ba 	CALL _GetInfo_G1
                 ;     242 								break;
000278 c018      	RJMP _0x2E
                 ;     243 				
                 ;     244 						case PT_SETADDR:
                 _0x30:
000279 30e4      	CPI  R30,LOW(0x4)
00027a f419      	BRNE _0x31
                 ;     245 								SetAddr();
00027b 940e 01ed 	CALL _SetAddr_G1
                 ;     246 								break;
00027d c013      	RJMP _0x2E
                 ;     247 				
                 ;     248 						case PT_SETSERIAL:
                 _0x31:
00027e 30e5      	CPI  R30,LOW(0x5)
00027f f419      	BRNE _0x32
                 ;     249 								SetSerial();
000280 940e 01fb 	CALL _SetSerial_G1
                 ;     250 								break;
000282 c00e      	RJMP _0x2E
                 ;     251 				
                 ;     252 						case PT_TOPROG:
                 _0x32:
000283 30e7      	CPI  R30,LOW(0x7)
000284 f419      	BRNE _0x33
                 ;     253 								ToProg();
000285 940e 021e 	CALL _ToProg_G1
                 ;     254 								break;      
000287 c009      	RJMP _0x2E
                 ;     255 
                 ;     256 						case PT_RELAY:           			// ретрансляция пакета при программировании
                 _0x33:
000288 30e6      	CPI  R30,LOW(0x6)
000289 f411      	BRNE _0x34
                 ;     257 							    RelayPack();	
00028a d0dc      	RCALL _RelayPack
                 ;     258                 				break;
00028b c005      	RJMP _0x2E
                 ;     259 
                 ;     260 						case PT_FLASH:								// пакеты для работы с CF Flash
                 _0x34:
00028c 3be4      	CPI  R30,LOW(0xB4)
00028d f411      	BRNE _0x36
                 ;     261 							    flash_Work();	
00028e d320      	RCALL _flash_Work
                 ;     262                 				break;
00028f c001      	RJMP _0x2E
                 ;     263                 			
                 ;     264 						default:
                 _0x36:
                 ;     265 								DiscardIncomingPack();
000290 d0ba      	RCALL _DiscardIncomingPack
                 ;     266 								break;
                 ;     267 					}
                 _0x2E:
                 ;     268 		   }
                 ;     269 		else																	// ретранслируем
000291 c020      	RJMP _0x37
                 _0x29:
                 ;     270 				{                                                                      
                 ;     271 					for (a=1; a<= int_Devices; a++)				// ищем порт по адресу
000292 e001      	LDI  R16,LOW(1)
                 _0x39:
000293 91e0 098b 	LDS  R30,_int_Devices
000295 17e0      	CP   R30,R16
000296 f0d8      	BRLO _0x3A
                 ;     272 						{
                 ;     273 						 	if (lAddrDevice [a]	== rx0addr)
000297 2fe0      	MOV  R30,R16
000298 e0f0      	LDI  R31,0
000299 50e0      	SUBI R30,LOW(-_lAddrDevice)
00029a 4ff9      	SBCI R31,HIGH(-_lAddrDevice)
00029b 81e0      	LD   R30,Z
00029c 91a0 0784 	LDS  R26,_rx0addr
00029e 17ea      	CP   R30,R26
00029f f481      	BRNE _0x3B
                 ;     274 						 		{
                 ;     275 									LedRed();
0002a0 9ad0      	SBI  0x1A,0
0002a1 9ad1      	SBI  0x1A,1
0002a2 98d8      	CBI  0x1B,0
0002a3 9ad9      	SBI  0x1B,1
                 ;     276 									recompPack (a);		
0002a4 930a      	ST   -Y,R16
0002a5 d2ba      	RCALL _recompPack
                 ;     277 									DiscardIncomingPack();        // разрешаем принимать след. пакет
0002a6 d0a4      	RCALL _DiscardIncomingPack
                 ;     278 									delay_ms (50);
0002a7 e3e2      	LDI  R30,LOW(50)
0002a8 e0f0      	LDI  R31,HIGH(50)
0002a9 93fa      	ST   -Y,R31
0002aa 93ea      	ST   -Y,R30
0002ab 940e 1dbe 	CALL _delay_ms
                 ;     279 									pingPack (a);	
0002ad 930a      	ST   -Y,R16
0002ae d2e2      	RCALL _pingPack
                 ;     280 									break;
0002af c002      	RJMP _0x3A
                 ;     281 						 		}
                 ;     282 						}
                 _0x3B:
0002b0 5f0f      	SUBI R16,-1
0002b1 cfe1      	RJMP _0x39
                 _0x3A:
                 ;     283 				}
                 _0x37:
                 ;     284 		}
                 ;     285 	}
                 _0x28:
0002b2 cf9e      	RJMP _0x22
                 ;     286 }    	
                 _0x3C:
0002b3 cfff      	RJMP _0x3C
                 ;     287 
                 ;     288 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                 ;     289 // Управляющая программа КОДЕРА
                 ;     290 // Связь с внешним миром
                 ;     291 
                 ;     292 #include "Coding.h"
                 ;     293 
                 ;     294 #define BAUD 38400
                 ;     295 
                 ;     296 /*
                 ;     297 ////////////////////////////////////////////////////////////////////////////////
                 ;     298 // Фазы работы приемопередатчиков
                 ;     299 #define RX_HDR	 1		// Принятый байт - заголовок
                 ;     300 #define RX_LEN   2		// Принятый байт - длина
                 ;     301 #define RX_ADDR  3		// Принятый байт - адрес
                 ;     302 #define RX_TYPE  4		// Принятый байт - тип пакета
                 ;     303 #define RX_DATA  5		// Принятый байт - байт данных
                 ;     304 #define RX_CRC   6		// Принятый байт - CRC
                 ;     305 #define RX_OK    7		// Пакет успешно принят и адресован мне
                 ;     306 #define RX_TIME  8		// Во время приема произошел тайм-аут
                 ;     307 #define RX_ERR   9		// Ошибка CRC приема
                 ;     308 #define RX_BUSY 10		// Запрос прочитан, а ответ еще не сформирован
                 ;     309 */
                 ;     310 #define UDRE 5
                 ;     311 #define DATA_REGISTER_EMPTY (1<<UDRE)
                 ;     312 
                 ;     313 #define RXTIMEOUT 4000	// Тайм-аут приема наружного канала
                 ;     314 
                 ;     315 ////////////////////////////////////////////////////////////////////////////////
                 ;     316 // Работа с наружным каналом
                 ;     317 
                 ;     318 unsigned char tx0crc;
                 ;     319 unsigned char rx0state = RX_HDR;
                 
                 	.DSEG
                 ;     320 unsigned char rx0crc;
                 ;     321 unsigned char rx0len;
                 ;     322 unsigned char rx0addr;
                 _rx0addr:
000784           	.BYTE 0x1
                 ;     323 unsigned char rx0type;
                 ;     324 
                 ;     325 #define COMBUFSIZ 255
                 ;     326 
                 ;     327 unsigned char rx0buf[COMBUFSIZ];
                 _rx0buf:
000785           	.BYTE 0xFF
                 ;     328 unsigned char rx0ptr;
                 _rx0ptr:
000884           	.BYTE 0x1
                 ;     329 
                 ;     330 // Передача байта во "внешний" канал
                 ;     331 void putchar0(char byt)
                 ;     332 {
                 
                 	.CSEG
                 _putchar0:
                 ;     333 	while ((UCSR0A & DATA_REGISTER_EMPTY)==0);
                 _0x3E:
0002b4 9b5d      	SBIS 0xB,5
0002b5 cffe      	RJMP _0x3E
                 ;     334 	UDR0 = byt;
0002b6 81e8      	LD   R30,Y
0002b7 b9ec      	OUT  0xC,R30
                 ;     335 	tx0crc += byt;
0002b8 0eae      	ADD  R10,R30
                 ;     336 }
0002b9 c164      	RJMP _0x431
                 ;     337 
                 ;     338 // Начало ответа на запрос по внешнему каналу
                 ;     339 void StartReply(unsigned char dlen) 
                 ;     340 {
                 _StartReply:
                 ;     341 //	rx0state = RX_BUSY;					// Запрос обработан
                 ;     342 	tx0crc = 0;										// Готовлю CRC
0002ba 24aa      	CLR  R10
                 ;     343 	
                 ;     344 	UCSR0B.3 = 1;								// Разрешаю передатчик
0002bb 9a53      	SBI  0xA,3
                 ;     345 	
                 ;     346 	putchar0(dlen+1);							// Передаю длину
0002bc 81e8      	LD   R30,Y
0002bd 5fef      	SUBI R30,-LOW(1)
0002be 93ea      	ST   -Y,R30
0002bf 940e 02b4 	CALL _putchar0
                 ;     347 }
0002c1 c15c      	RJMP _0x431
                 ;     348 
                 ;     349 void EndReply(void)
                 ;     350 {
                 _EndReply:
                 ;     351 	putchar0(tx0crc);							// Контрольная сумма
0002c2 92aa      	ST   -Y,R10
0002c3 940e 02b4 	CALL _putchar0
                 ;     352 //	UCSR0B.3 = 0;								// Запрещаю передатчик
                 ;     353 	rx0state = RX_HDR;						// Разрешаю прием след. запроса
0002c5 e0e1      	LDI  R30,LOW(1)
0002c6 2ebe      	MOV  R11,R30
                 ;     354 }
0002c7 9508      	RET
                 ;     355 
                 ;     356 // Прерывание по приему байта из "наружного" канала
                 ;     357 interrupt [USART0_RXC] void uart_rx_isr(void)
                 ;     358 {
                 _uart_rx_isr:
0002c8 93aa      	ST   -Y,R26
0002c9 93ea      	ST   -Y,R30
0002ca 93fa      	ST   -Y,R31
0002cb b7ef      	IN   R30,SREG
0002cc 93ea      	ST   -Y,R30
                 ;     359 	register unsigned char byt;
                 ;     360 
                 ;     361 	byt = UDR0;									// Принятый байт
0002cd 930a      	ST   -Y,R16
                 ;	byt -> R16
0002ce b10c      	IN   R16,12
                 ;     362 
                 ;     363 	
                 ;     364 	switch (rx0state)
0002cf 2deb      	MOV  R30,R11
                 ;     365 	{
                 ;     366 	case RX_HDR:								// Должен быть заголовок
0002d0 30e1      	CPI  R30,LOW(0x1)
0002d1 f491      	BRNE _0x44
                 ;     367 		if (byt != PACKHDR)					// Отбрасываю не заголовок
0002d2 3701      	CPI  R16,113
0002d3 f009      	BREQ _0x45
                 ;     368 		{
                 ;     369 			break;
0002d4 c058      	RJMP _0x43
                 ;     370 		}
                 ;     371 
                 ;     372 
                 ;     373 		rx0state = RX_LEN;					// Перехожу к ожиданию длины
                 _0x45:
0002d5 e0e2      	LDI  R30,LOW(2)
0002d6 2ebe      	MOV  R11,R30
                 ;     374 		rx0crc = 0;								// Готовлю подсчет CRC
0002d7 24cc      	CLR  R12
                 ;     375 		
                 ;     376 		OCR1A = TCNT1+RXTIMEOUT;	// Взвожу тайм-аут
0002d8 b5ec      	IN   R30,0x2C
0002d9 b5fd      	IN   R31,0x2C+1
0002da 56e0      	SUBI R30,LOW(-4000)
0002db 4ff0      	SBCI R31,HIGH(-4000)
0002dc bdfb      	OUT  0x2A+1,R31
0002dd bdea      	OUT  0x2A,R30
                 ;     377 		TIFR = 0x10;								// Предотвращаю ложное срабатывание
0002de e1e0      	LDI  R30,LOW(16)
0002df bfe6      	OUT  0x36,R30
                 ;     378 		TIMSK |= 0x10;							// Разрешение прерывания по тайм-ауту
0002e0 b7e7      	IN   R30,0x37
0002e1 61e0      	ORI  R30,0x10
0002e2 bfe7      	OUT  0x37,R30
                 ;     379 		break;
0002e3 c049      	RJMP _0x43
                 ;     380 		
                 ;     381 	case RX_LEN:
                 _0x44:
0002e4 30e2      	CPI  R30,LOW(0x2)
0002e5 f429      	BRNE _0x46
                 ;     382 		rx0len = byt - 3;							// Длина содержимого
0002e6 2fe0      	MOV  R30,R16
0002e7 50e3      	SUBI R30,LOW(3)
0002e8 2ede      	MOV  R13,R30
                 ;     383 		rx0state = RX_ADDR;					// К приему адреса
0002e9 e0e3      	LDI  R30,LOW(3)
0002ea c041      	RJMP _0x433
                 ;     384 		break;
                 ;     385 
                 ;     386 	case RX_ADDR:
                 _0x46:
0002eb 30e3      	CPI  R30,LOW(0x3)
0002ec f421      	BRNE _0x47
                 ;     387 		rx0addr = byt;							// Адрес
0002ed 9300 0784 	STS  _rx0addr,R16
                 ;     388 		rx0state = RX_TYPE;					// К приему типа
0002ef e0e4      	LDI  R30,LOW(4)
0002f0 c03b      	RJMP _0x433
                 ;     389 		break;
                 ;     390 
                 ;     391 	case RX_TYPE:
                 _0x47:
0002f1 30e4      	CPI  R30,LOW(0x4)
0002f2 f459      	BRNE _0x48
                 ;     392 		rx0type = byt;							// Тип
0002f3 2ee0      	MOV  R14,R16
                 ;     393 		rx0ptr = 0;									// Указатель на начало данных
0002f4 e0e0      	LDI  R30,LOW(0)
0002f5 93e0 0884 	STS  _rx0ptr,R30
                 ;     394 		if (rx0len)
0002f7 20dd      	TST  R13
0002f8 f011      	BREQ _0x49
                 ;     395 		{
                 ;     396 			rx0state = RX_DATA;				// К приему данных
0002f9 e0e5      	LDI  R30,LOW(5)
0002fa c001      	RJMP _0x434
                 ;     397 		}
                 ;     398 		else
                 _0x49:
                 ;     399 		{
                 ;     400 			rx0state = RX_CRC; 				// К приему контрольной суммы
0002fb e0e6      	LDI  R30,LOW(6)
                 _0x434:
0002fc 2ebe      	MOV  R11,R30
                 ;     401 		}
                 ;     402 		break;
0002fd c02f      	RJMP _0x43
                 ;     403 
                 ;     404 	case RX_DATA:
                 _0x48:
0002fe 30e5      	CPI  R30,LOW(0x5)
0002ff f4a9      	BRNE _0x4B
                 ;     405 		if (rx0ptr > (COMBUFSIZ-1))
000300 91a0 0884 	LDS  R26,_rx0ptr
000302 3faf      	CPI  R26,LOW(0xFF)
000303 f008      	BRLO _0x4C
                 ;     406 		{
                 ;     407 			rx0state = RX_HDR;				// Если пакет слишком длинный - отвергаю и иду в начало
000304 c026      	RJMP _0x435
                 ;     408 			break;
                 ;     409 		}
                 ;     410 		rx0buf[rx0ptr++] = byt;				// Данные
                 _0x4C:
000305 91e0 0884 	LDS  R30,_rx0ptr
000307 5fef      	SUBI R30,-LOW(1)
000308 93e0 0884 	STS  _rx0ptr,R30
00030a 50e1      	SUBI R30,LOW(1)
00030b e0f0      	LDI  R31,0
00030c 57eb      	SUBI R30,LOW(-_rx0buf)
00030d 4ff8      	SBCI R31,HIGH(-_rx0buf)
00030e 8300      	ST   Z,R16
                 ;     411 		if (rx0ptr < rx0len)						// Еще не все ?
00030f 91a0 0884 	LDS  R26,_rx0ptr
000311 15ad      	CP   R26,R13
000312 f0d0      	BRLO _0x43
                 ;     412 		{
                 ;     413 			break;
                 ;     414 		}
                 ;     415 		rx0state = RX_CRC;					// К приему контрольной суммы
000313 e0e6      	LDI  R30,LOW(6)
000314 c017      	RJMP _0x433
                 ;     416 		break;
                 ;     417 
                 ;     418 	case RX_CRC:
                 _0x4B:
000315 30e6      	CPI  R30,LOW(0x6)
000316 f4a1      	BRNE _0x51
                 ;     419 		if (byt != rx0crc)
000317 16c0      	CP   R12,R16
000318 f011      	BREQ _0x4F
                 ;     420 		{
                 ;     421 			rx0state = RX_HDR;				// Не сошлась CRC - игнорирую пакет и жду следующий
000319 e0e1      	LDI  R30,LOW(1)
00031a c00b      	RJMP _0x436
                 ;     422 		}
                 ;     423 // убрал фильтр адреса
                 ;     424 else
                 _0x4F:
                 ;     425 {
                 ;     426 rx0buf[rx0ptr++] = byt;						// Данные
00031b 91e0 0884 	LDS  R30,_rx0ptr
00031d 5fef      	SUBI R30,-LOW(1)
00031e 93e0 0884 	STS  _rx0ptr,R30
000320 50e1      	SUBI R30,LOW(1)
000321 e0f0      	LDI  R31,0
000322 57eb      	SUBI R30,LOW(-_rx0buf)
000323 4ff8      	SBCI R31,HIGH(-_rx0buf)
000324 8300      	ST   Z,R16
                 ;     427 rx0state = RX_OK;								// Принят пакет, на который нужно ответить
000325 e0e7      	LDI  R30,LOW(7)
                 _0x436:
000326 2ebe      	MOV  R11,R30
                 ;     428 }
                 ;     429 /*		else if ((rx0addr == my_addr) || (rx0addr == TO_ALL))
                 ;     430 		{
                 ;     431  			rx0buf[rx0ptr++] = byt;			// Данные
                 ;     432     		rx0state = RX_OK;				// Принят пакет, на который нужно ответить
                 ;     433 		}
                 ;     434 		else
                 ;     435 		{
                 ;     436 			rx0state = RX_HDR;				// Принят пакет, адресованный не мне - жду следующего
                 ;     437 		}*/
                 ;     438 		TIMSK &= 0x10 ^ 0xFF;				// Запретить прерывание по тайм-ауту
000327 b7e7      	IN   R30,0x37
000328 7eef      	ANDI R30,0xEF
000329 bfe7      	OUT  0x37,R30
                 ;     439 		break;
00032a c002      	RJMP _0x43
                 ;     440 		
                 ;     441 //	case RX_BUSY:							// Запрос принят, но ответ еще не готов
                 ;     442 		break;
                 ;     443 		
                 ;     444 	default:											// Ошибочное состояние
                 _0x51:
                 ;     445 		rx0state = RX_HDR;					// Перехожу на начало
                 _0x435:
00032b e0e1      	LDI  R30,LOW(1)
                 _0x433:
00032c 2ebe      	MOV  R11,R30
                 ;     446 		break;
                 ;     447 	}
                 _0x43:
                 ;     448 
                 ;     449 	rx0crc += byt;								// Подсчитываю контрольную сумму
00032d 0ec0      	ADD  R12,R16
                 ;     450 }
00032e 9109      	LD   R16,Y+
00032f 91e9      	LD   R30,Y+
000330 bfef      	OUT  SREG,R30
000331 91f9      	LD   R31,Y+
000332 91e9      	LD   R30,Y+
000333 91a9      	LD   R26,Y+
000334 9518      	RETI
                 ;     451 
                 ;     452 // Прерывание по сравнению A таймера 1 для подсчета тайм-аута приема "внешнего" канала
                 ;     453 interrupt [TIM1_COMPA] void timer1_comp_a_isr(void)
                 ;     454 {
                 _timer1_comp_a_isr:
000335 93ea      	ST   -Y,R30
000336 b7ef      	IN   R30,SREG
000337 93ea      	ST   -Y,R30
                 ;     455 	rx0state = RX_HDR;						// По тайм-ауту перехожу к началу приема нового пакета
000338 e0e1      	LDI  R30,LOW(1)
000339 2ebe      	MOV  R11,R30
                 ;     456 	TIMSK &= 0x10 ^ 0xFF;					// Больше не генерировать прерываний
00033a b7e7      	IN   R30,0x37
00033b 7eef      	ANDI R30,0xEF
00033c bfe7      	OUT  0x37,R30
                 ;     457 }
00033d 91e9      	LD   R30,Y+
00033e bfef      	OUT  SREG,R30
00033f 91e9      	LD   R30,Y+
000340 9518      	RETI
                 ;     458 
                 ;     459 unsigned char HaveIncomingPack(void)
                 ;     460 {
                 _HaveIncomingPack:
                 ;     461 	if (rx0state == RX_OK)	return 255;
000341 e0e7      	LDI  R30,LOW(7)
000342 15eb      	CP   R30,R11
000343 f411      	BRNE _0x52
000344 efef      	LDI  R30,LOW(255)
000345 9508      	RET
                 ;     462 	else					return 0;
                 _0x52:
000346 e0e0      	LDI  R30,LOW(0)
000347 9508      	RET
                 ;     463 }
000348 9508      	RET
                 ;     464 
                 ;     465 unsigned char IncomingPackType(void)
                 ;     466 {
                 _IncomingPackType:
                 ;     467 	return rx0type;
000349 2dee      	MOV  R30,R14
00034a 9508      	RET
                 ;     468 }
                 ;     469 
                 ;     470 void DiscardIncomingPack(void)
                 ;     471 {
                 _DiscardIncomingPack:
                 ;     472 	rx0state = RX_HDR;						// Разрешаю прием следующего пакета
00034b e0e1      	LDI  R30,LOW(1)
00034c 2ebe      	MOV  R11,R30
                 ;     473 }
00034d 9508      	RET
                 ;     474 
                 ;     475 // Настройка приемопередатчика
                 ;     476 void CommInit(void)
                 ;     477 {
                 _CommInit:
                 ;     478 	// Подтяжка на TXD
                 ;     479 //	DDRD.1 = 0;
                 ;     480 //	PORTD.1 = 1;
                 ;     481 /*	
                 ;     482 // USART0 initialization
                 ;     483 // Communication Parameters: 8 Data, 1 Stop, No Parity
                 ;     484 // USART0 Receiver: On
                 ;     485 // USART0 Transmitter: On
                 ;     486 // USART0 Mode: Asynchronous
                 ;     487 // USART0 Baud rate: 38400
                 ;     488 UCSR0A=0x00;
                 ;     489 UCSR0B=0x18;
                 ;     490 UCSR0C=0x06;
                 ;     491 UBRR0H=0x00;
                 ;     492 UBRR0L=0x0C;
                 ;     493 */
                 ;     494 
                 ;     495 
                 ;     496 	// Настраиваю UART
                 ;     497 	UCSR0A = 0b00000000;
00034e e0e0      	LDI  R30,LOW(0)
00034f b9eb      	OUT  0xB,R30
                 ;     498 	UCSR0B = 0b10010000;	//0b10011000;
000350 e9e0      	LDI  R30,LOW(144)
000351 b9ea      	OUT  0xA,R30
                 ;     499 	UCSR0C = 0x86;
000352 e8e6      	LDI  R30,LOW(134)
000353 93e0 0095 	STS  149,R30
                 ;     500 	UBRR0L = ((_MCU_CLOCK_FREQUENCY_ / (16 * BAUD)) - 1) & 0xFF;
000355 e0ec      	LDI  R30,LOW(12)
000356 b9e9      	OUT  0x9,R30
                 ;     501 	UBRR0H = (((_MCU_CLOCK_FREQUENCY_ / (16 * BAUD)) - 1) >> 8) & 0xFF;
000357 e0e0      	LDI  R30,LOW(0)
000358 93e0 0090 	STS  144,R30
                 ;     502 	
                 ;     503 	// Таймер 1 для подсчета тайм-аутов приема
                 ;     504 	TCCR1B  = 0b00000101;
00035a e0e5      	LDI  R30,LOW(5)
00035b bdee      	OUT  0x2E,R30
                 ;     505 }
00035c 9508      	RET
                 ;     506 
                 ;     507 void putword0(unsigned short wd)
                 ;     508 {
                 _putword0:
                 ;     509 	putchar0(wd);
00035d 81e8      	LD   R30,Y
00035e 93ea      	ST   -Y,R30
00035f 940e 02b4 	CALL _putchar0
                 ;     510 	putchar0(wd >> 8);
000361 81e9      	LDD  R30,Y+1
000362 70f0      	ANDI R31,HIGH(0x0)
000363 93ea      	ST   -Y,R30
000364 940e 02b4 	CALL _putchar0
                 ;     511 }                                  
000366 c0f2      	RJMP _0x430
                 ;     512 
                 ;     513 
                 ;     514 // Ретрансляция цикла обмена из внешнего во внутр. канал и обратно
                 ;     515 // "Внутренний" канал должен быть свободен
                 ;     516 
                 ;     517 void RelayPack(void)
                 ;     518 {
                 _RelayPack:
                 ;     519 	register unsigned char i,a;
                 ;     520  LedRed();	
000367 931a      	ST   -Y,R17
000368 930a      	ST   -Y,R16
                 ;	i -> R16
                 ;	a -> R17
000369 9ad0      	SBI  0x1A,0
00036a 9ad1      	SBI  0x1A,1
00036b 98d8      	CBI  0x1B,0
00036c 9ad9      	SBI  0x1B,1
                 ;     521 	// Передаю запрос
                 ;     522 	StartIntReq(rx0len);
00036d 92da      	ST   -Y,R13
00036e d087      	RCALL _StartIntReq
                 ;     523 	
                 ;     524 	// Тело пакета
                 ;     525 	for (i = 0; i < rx0len; i ++)
00036f e000      	LDI  R16,LOW(0)
                 _0x55:
000370 150d      	CP   R16,R13
000371 f498      	BRSH _0x56
                 ;     526 	{
                 ;     527 		twi_byte(rx0buf[i]);   
000372 2fe0      	MOV  R30,R16
000373 e0f0      	LDI  R31,0
000374 57eb      	SUBI R30,LOW(-_rx0buf)
000375 4ff8      	SBCI R31,HIGH(-_rx0buf)
000376 81e0      	LD   R30,Z
000377 93ea      	ST   -Y,R30
000378 d05a      	RCALL _twi_byte
                 ;     528 		tx1crc +=(rx0buf[i]);
000379 2fe0      	MOV  R30,R16
00037a e0f0      	LDI  R31,0
00037b 57eb      	SUBI R30,LOW(-_rx0buf)
00037c 4ff8      	SBCI R31,HIGH(-_rx0buf)
00037d 81e0      	LD   R30,Z
00037e 91a0 0885 	LDS  R26,_tx1crc
000380 0fea      	ADD  R30,R26
000381 93e0 0885 	STS  _tx1crc,R30
                 ;     529 	}
000383 5f0f      	SUBI R16,-1
000384 cfeb      	RJMP _0x55
                 _0x56:
                 ;     530 	
                 ;     531 	// Окончание запроса
                 ;     532 	EndIntReq();
000385 d09a      	RCALL _EndIntReq
                 ;     533 	DiscardIncomingPack();        // разрешаем принимать след. пакет
000386 940e 034b 	CALL _DiscardIncomingPack
                 ;     534 
                 ;     535 	delay_ms (10);						// принимаем ответ
000388 e0ea      	LDI  R30,LOW(10)
000389 e0f0      	LDI  R31,HIGH(10)
00038a 93fa      	ST   -Y,R31
00038b 93ea      	ST   -Y,R30
00038c 940e 1dbe 	CALL _delay_ms
                 ;     536 
                 ;     537 /*	if ((rx0buf[0] == TO_MON) || (rx0buf[0] == TO_MON))       // если пакет послан всем - принимаем ответ по очереди
                 ;     538 		{
                 ;     539 			for (a=1; a<= int_Devices; a++) pingPack (a);	
                 ;     540 		}
                 ;     541 	else	pingPack (rx0buf[0]);*/
                 ;     542 
                 ;     543 //	pingPack (4);	
                 ;     544 
                 ;     545 } 
00038e c1a2      	RJMP _0x42F
                 ;     546   
                 ;     547 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                 ;     548 // 
                 ;     549 // Связь с внешним миром
                 ;     550 
                 ;     551 #include <Coding.h>
                 ;     552 
                 ;     553 // Биты TWCR
                 ;     554 #define TWINT 7
                 ;     555 #define TWEA  6
                 ;     556 #define TWSTA 5
                 ;     557 #define TWSTO 4
                 ;     558 #define TWWC  3
                 ;     559 #define TWEN  2
                 ;     560 #define TWIE  0
                 ;     561 
                 ;     562 // Состояния
                 ;     563 #define START		0x08
                 ;     564 #define	REP_START	0x10
                 ;     565 
                 ;     566 // Коды статуса
                 ;     567 #define	MTX_ADR_ACK		0x18
                 ;     568 #define	MRX_ADR_ACK		0x40
                 ;     569 #define	MTX_DATA_ACK	0x28
                 ;     570 #define	MRX_DATA_NACK	0x58
                 ;     571 #define	MRX_DATA_ACK	0x50
                 ;     572 
                 ;     573 // Подготовка аппаратного мастера I2C
                 ;     574 void twi_init (void)
                 ;     575 {
                 _twi_init:
                 ;     576 	TWSR=0x00;
00038f e0e0      	LDI  R30,LOW(0)
000390 93e0 0071 	STS  113,R30
                 ;     577 	TWBR=0x20;
000392 e2e0      	LDI  R30,LOW(32)
000393 93e0 0070 	STS  112,R30
                 ;     578 	TWAR=0x00;
000395 e0e0      	LDI  R30,LOW(0)
000396 93e0 0072 	STS  114,R30
                 ;     579 	TWCR=0x04;
000398 e0e4      	LDI  R30,LOW(4)
000399 93e0 0074 	STS  116,R30
                 ;     580 }
00039b 9508      	RET
                 ;     581 
                 ;     582 // Жду флажка окончания текущей операции
                 ;     583 static void twi_wait_int (void)
                 ;     584 {
                 _twi_wait_int_G3:
                 ;     585 
                 ;     586 	while (!(TWCR & (1<<TWINT)))
                 _0x57:
00039c 91e0 0074 	LDS  R30,116
00039e 78e0      	ANDI R30,LOW(0x80)
00039f f429      	BRNE _0x59
                 ;     587 		{
                 ;     588 			   if ( flagTWI & ( 1<< time_is_Out))  break;  // выходим по тайм - ауту
0003a0 91e0 098a 	LDS  R30,_flagTWI
0003a2 70e1      	ANDI R30,LOW(0x1)
0003a3 f409      	BRNE _0x59
                 ;     589 		}; 
0003a4 cff7      	RJMP _0x57
                 _0x59:
                 ;     590 }
0003a5 9508      	RET
                 ;     591 
                 ;     592 // Стартовое условие
                 ;     593 // Возвращает не 0, если все в порядке
                 ;     594 unsigned char twi_start (void)
                 ;     595 {
                 _twi_start:
                 ;     596 	TWCR = ((1<<TWINT)+(1<<TWSTA)+(1<<TWEN));
0003a6 eae4      	LDI  R30,LOW(164)
0003a7 93e0 0074 	STS  116,R30
                 ;     597 	
                 ;     598 	twi_wait_int();
0003a9 940e 039c 	CALL _twi_wait_int_G3
                 ;     599 
                 ;     600     if((TWSR != START)&&(TWSR != REP_START))
0003ab 91a0 0071 	LDS  R26,113
0003ad 30a8      	CPI  R26,LOW(0x8)
0003ae f021      	BREQ _0x5C
0003af 91a0 0071 	LDS  R26,113
0003b1 31a0      	CPI  R26,LOW(0x10)
0003b2 f409      	BRNE _0x5D
                 _0x5C:
0003b3 c002      	RJMP _0x5B
                 _0x5D:
                 ;     601     {
                 ;     602 		return 0;
0003b4 e0e0      	LDI  R30,LOW(0)
0003b5 9508      	RET
                 ;     603 	}
                 ;     604 	
                 ;     605 	return 255;
                 _0x5B:
0003b6 efef      	LDI  R30,LOW(255)
0003b7 9508      	RET
                 ;     606 }
                 ;     607 
                 ;     608 // Стоповое условие
                 ;     609 void twi_stop (void)
                 ;     610 {
                 _twi_stop:
                 ;     611 	TWCR = ((1<<TWEN)+(1<<TWINT)+(1<<TWSTO));
0003b8 e9e4      	LDI  R30,LOW(148)
0003b9 93e0 0074 	STS  116,R30
                 ;     612 }
0003bb 9508      	RET
                 ;     613 
                 ;     614 // Передача адреса
                 ;     615 // Возвращает не 0, если все в порядке
                 ;     616 unsigned char twi_addr (unsigned char addr)
                 ;     617 {
                 _twi_addr:
                 ;     618 	twi_wait_int();
0003bc 940e 039c 	CALL _twi_wait_int_G3
                 ;     619 
                 ;     620 	TWDR = addr;
0003be 81e8      	LD   R30,Y
0003bf 93e0 0073 	STS  115,R30
                 ;     621 	TWCR = ((1<<TWINT)+(1<<TWEN));
0003c1 e8e4      	LDI  R30,LOW(132)
0003c2 93e0 0074 	STS  116,R30
                 ;     622 
                 ;     623 	twi_wait_int();                 		// Ждем отклик 
0003c4 940e 039c 	CALL _twi_wait_int_G3
                 ;     624 
                 ;     625 	if((TWSR != MTX_ADR_ACK)&&(TWSR != MRX_ADR_ACK))
0003c6 91a0 0071 	LDS  R26,113
0003c8 31a8      	CPI  R26,LOW(0x18)
0003c9 f021      	BREQ _0x5F
0003ca 91a0 0071 	LDS  R26,113
0003cc 34a0      	CPI  R26,LOW(0x40)
0003cd f409      	BRNE _0x60
                 _0x5F:
0003ce c002      	RJMP _0x5E
                 _0x60:
                 ;     626 	{
                 ;     627 		return 0;
0003cf e0e0      	LDI  R30,LOW(0)
0003d0 c04d      	RJMP _0x431
                 ;     628 	}
                 ;     629 	return 255;
                 _0x5E:
0003d1 efef      	LDI  R30,LOW(255)
0003d2 c04b      	RJMP _0x431
                 ;     630 }
                 ;     631 
                 ;     632 // Передача байта данных
                 ;     633 // Возвращает не 0, если все в порядке
                 ;     634 unsigned char twi_byte (unsigned char data)
                 ;     635 {
                 _twi_byte:
                 ;     636 	twi_wait_int();
0003d3 940e 039c 	CALL _twi_wait_int_G3
                 ;     637 
                 ;     638 	TWDR = data;
0003d5 81e8      	LD   R30,Y
0003d6 93e0 0073 	STS  115,R30
                 ;     639  	TWCR = ((1<<TWINT)+(1<<TWEN));
0003d8 e8e4      	LDI  R30,LOW(132)
0003d9 93e0 0074 	STS  116,R30
                 ;     640 
                 ;     641 	twi_wait_int();
0003db 940e 039c 	CALL _twi_wait_int_G3
                 ;     642 
                 ;     643 	if(TWSR != MTX_DATA_ACK)
0003dd 91a0 0071 	LDS  R26,113
0003df 32a8      	CPI  R26,LOW(0x28)
0003e0 f011      	BREQ _0x61
                 ;     644 	{
                 ;     645 		return 0;
0003e1 e0e0      	LDI  R30,LOW(0)
0003e2 c03b      	RJMP _0x431
                 ;     646 	}
                 ;     647 		
                 ;     648 	return 255;
                 _0x61:
0003e3 efef      	LDI  R30,LOW(255)
0003e4 c039      	RJMP _0x431
                 ;     649 }
                 ;     650 
                 ;     651 // Чтение байта 
                 ;     652 // Возвращает не 0, если все в порядке
                 ;     653 unsigned char  twi_read (unsigned char notlast)
                 ;     654 {
                 _twi_read:
                 ;     655 	timeOut ();									// запускаем тайм аут
0003e5 d105      	RCALL _timeOut
                 ;     656 
                 ;     657 	twi_wait_int();   
0003e6 940e 039c 	CALL _twi_wait_int_G3
                 ;     658 
                 ;     659 	if(notlast)     // формируем подтверждение приема
0003e8 81e8      	LD   R30,Y
0003e9 30e0      	CPI  R30,0
0003ea f011      	BREQ _0x62
                 ;     660 		{
                 ;     661 			TWCR = ((1<<TWINT)+(1<<TWEA)+(1<<TWEN));
0003eb ece4      	LDI  R30,LOW(196)
0003ec c001      	RJMP _0x437
                 ;     662 		}
                 ;     663 		else            // НЕ формируем подтверждение приема
                 _0x62:
                 ;     664 		{
                 ;     665 			TWCR = ((1<<TWINT)+(1<<TWEN));
0003ed e8e4      	LDI  R30,LOW(132)
                 _0x437:
0003ee 93e0 0074 	STS  116,R30
                 ;     666 		}
                 ;     667  	twi_wait_int();    
0003f0 940e 039c 	CALL _twi_wait_int_G3
                 ;     668 
                 ;     669  	timeOutStop ();							// останов таймера таймаута   
0003f2 d0fd      	RCALL _timeOutStop
                 ;     670 
                 ;     671 		return TWDR;
0003f3 91e0 0073 	LDS  R30,115
0003f5 c028      	RJMP _0x431
                 ;     672 }
                 ;     673 
                 ;     674 // Изменение значения бита порта
                 ;     675 static inline void PortBitChange(unsigned char port, unsigned char bnum, unsigned char set)
                 ;     676 {
                 ;     677 	register unsigned char mask;
                 ;     678 	#asm("cli");
                 ;	port -> Y+3
                 ;	bnum -> Y+2
                 ;	set -> Y+1
                 ;	mask -> R16
                 ;     679 
                 ;     680 	mask = 1 << bnum;		// Маска
                 ;     681 	if (!set)
                 ;     682 	{
                 ;     683 		mask ^= 0xFF;
                 ;     684 	}
                 ;     685 		
                 ;     686 	switch(port)
                 ;     687 	{
                 ;     688 	case 'B':
                 ;     689 		if (set) PORTB |= mask; else PORTB &= mask;
                 ;     690 		break;
                 ;     691 	case 'C':
                 ;     692 		if (set) PORTC |= mask; else PORTC &= mask;
                 ;     693 		break;
                 ;     694 	case 'D':
                 ;     695 		if (set) PORTD |= mask; else PORTD &= mask;
                 ;     696 		break;
                 ;     697 	}
                 ;     698 	
                 ;     699 	#asm("sei");
                 ;     700 }
                 ;     701 
                 ;     702 // Передача таблицы из FLASH в I2C
                 ;     703 void i2c_tab (flash unsigned char * tbl, void (* rwfunc)(void))
                 ;     704 {
                 ;     705 	register unsigned char n, p;
                 ;     706 	register flash unsigned char * ptr;
                 ;     707 	
                 ;     708 	while(1)
                 ;	*tbl -> Y+6
                 ;	*rwfunc -> Y+4
                 ;	n -> R16
                 ;	p -> R17
                 ;	*ptr -> R18,R19
                 ;     709 	{
                 ;     710 		if (rwfunc)			// Если нужно, запускаю ожидание готовности
                 ;     711 		{
                 ;     712 			(*rwfunc)();
                 ;     713 		}
                 ;     714 		
                 ;     715 		n = *tbl++;
                 ;     716 		
                 ;     717 		if (!n)				// Если больше нечего передавать ...
                 ;     718 		{
                 ;     719 			return;
                 ;     720 		}
                 ;     721 
                 ;     722 		if (n == 255)		// Если признак бита порта процессора ...
                 ;     723 		{
                 ;     724 			p = *tbl++;						// Порт B, C или D
                 ;     725 			n = *tbl++;						// Номер бита
                 ;     726 			PortBitChange(p, n, *tbl++);	// Взвести или сбросить
                 ;     727 			continue;						// К следующей строке
                 ;     728 		}
                 ;     729 
                 ;     730 		n = n - 2;
                 ;     731 		
                 ;     732 		ptr = tbl;
                 ;     733 		while(1)
                 ;     734 		{
                 ;     735 			if (!twi_start())
                 ;     736 			{
                 ;     737 				twi_stop();
                 ;     738 				continue;
                 ;     739 			}
                 ;     740 	
                 ;     741 			if (!twi_addr(*tbl++))
                 ;     742 			{
                 ;     743 				twi_stop();
                 ;     744 				tbl = ptr;
                 ;     745 				continue;
                 ;     746 			}
                 ;     747 		
                 ;     748 			break;
                 ;     749 		}
                 ;     750 		
                 ;     751 		twi_byte(*tbl++);
                 ;     752 		
                 ;     753 		while(n--)
                 ;     754 		{
                 ;     755 			twi_byte(*tbl++);
                 ;     756 		}
                 ;     757 		
                 ;     758 		twi_stop();
                 ;     759 	}
                 ;     760 }
                 ;     761 
                 ;     762 /*
                 ;     763 // Передача в заданный адрес I2C nbytes байт
                 ;     764 void i2c_bytes (unsigned char addr, unsigned char sbaddr, unsigned char nbytes, ...)
                 ;     765 {
                 ;     766 	va_list argptr;
                 ;     767 	char byt;
                 ;     768 	
                 ;     769 	va_start(argptr, nbytes);
                 ;     770 	
                 ;     771 	while(1)
                 ;     772 	{
                 ;     773 		if (!twi_start())
                 ;     774 		{
                 ;     775 			twi_stop();
                 ;     776 			continue;
                 ;     777 		}
                 ;     778 	
                 ;     779 		if (!twi_addr(addr))
                 ;     780 		{
                 ;     781 			twi_stop();
                 ;     782 			continue;
                 ;     783 		}
                 ;     784 		
                 ;     785 		break;
                 ;     786 	}
                 ;     787 	
                 ;     788 	twi_byte(sbaddr);
                 ;     789 
                 ;     790 	while(nbytes--)
                 ;     791 	{
                 ;     792 		byt = va_arg(argptr, char);
                 ;     793 		twi_byte(byt);
                 ;     794 	}		
                 ;     795 	va_end(argptr);
                 ;     796 		
                 ;     797 	twi_stop();
                 ;     798 }
                 ;     799 */
                 ;     800 
                 ;     801 // Передача в заданный адрес I2C таблицы PSI
                 ;     802 void i2c_psi_table (
                 ;     803 		unsigned char addr,
                 ;     804 		unsigned char sbaddr,
                 ;     805 		unsigned char tblnum,
                 ;     806 		unsigned short pid,
                 ;     807 		unsigned char * buf)
                 ;     808 {
                 ;     809 	unsigned char n;
                 ;     810 	
                 ;     811 	pid &= 0x1FFF;
                 ;	addr -> Y+7
                 ;	sbaddr -> Y+6
                 ;	tblnum -> Y+5
                 ;	pid -> Y+3
                 ;	*buf -> Y+1
                 ;	n -> R16
                 ;     812 	pid |= 0x4000;
                 ;     813 
                 ;     814 	while(1)
                 ;     815 	{	
                 ;     816 		if (!twi_start())
                 ;     817 		{
                 ;     818 			twi_stop();
                 ;     819 			continue;
                 ;     820 		}
                 ;     821 		
                 ;     822 		if (!twi_addr(addr))
                 ;     823 		{
                 ;     824 			twi_stop();
                 ;     825 			continue;
                 ;     826 		}
                 ;     827 		
                 ;     828 		break;
                 ;     829 	}
                 ;     830 		
                 ;     831 	twi_byte(sbaddr);
                 ;     832 	
                 ;     833 	twi_byte(tblnum);
                 ;     834 
                 ;     835 	twi_byte(0x47);			// Заголовок пакета
                 ;     836 	twi_byte(pid >> 8);	
                 ;     837 	twi_byte(pid & 0xFF);	
                 ;     838 	twi_byte(0x10);	
                 ;     839 	twi_byte(0x00);	
                 ;     840 	
                 ;     841 	for (n = buf[2] + 3; n != 0; n --)
                 ;     842 	{
                 ;     843 		twi_byte(*buf++);
                 ;     844 	}
                 ;     845 	
                 ;     846 	twi_stop();
                 ;     847 }
                 ;     848      
                 ;     849 ////////////////////////////////////////////////////////////////////////////////
                 ;     850 // Работа с внутренним каналом
                 ;     851 
                 ;     852 unsigned char tx1crc;
                 
                 	.DSEG
                 _tx1crc:
000885           	.BYTE 0x1
                 ;     853 unsigned char rx1state = RX_IDLE;
                 _rx1state:
000886           	.BYTE 0x1
                 ;     854 unsigned char rx1crc;
                 _rx1crc:
000887           	.BYTE 0x1
                 ;     855 unsigned char rx1len;
                 _rx1len:
000888           	.BYTE 0x1
                 ;     856 unsigned char rx1buf[256];
                 _rx1buf:
000889           	.BYTE 0x100
                 ;     857 unsigned char rx1ptr;
                 _rx1ptr:
000989           	.BYTE 0x1
                 ;     858 
                 ;     859 /*// Передача байта во "внутренний" канал
                 ;     860 void putword1(unsigned int wd)
                 ;     861 {
                 ;     862 	putchar1(wd);
                 ;     863 	putchar1(wd >> 8);
                 ;     864 } */
                 ;     865 
                 ;     866 // Начало запроса во внутренний канал
                 ;     867 void StartIntReq(unsigned char dlen) 
                 ;     868 {
                 
                 	.CSEG
                 _StartIntReq:
                 ;     869 	while(1)
                 _0x88:
                 ;     870 	{	
                 ;     871 		if (!twi_start())       // Cтарт пакета
0003f6 940e 03a6 	CALL _twi_start
0003f8 30e0      	CPI  R30,0
0003f9 f419      	BRNE _0x8B
                 ;     872 		{
                 ;     873 			twi_stop();
0003fa 940e 03b8 	CALL _twi_stop
                 ;     874 			continue;
0003fc cff9      	RJMP _0x88
                 ;     875 		}
                 ;     876 
                 ;     877 		
                 ;     878 		if (!twi_addr(0))       // Передача всем подчиненным
                 _0x8B:
0003fd e0e0      	LDI  R30,LOW(0)
0003fe 93ea      	ST   -Y,R30
0003ff 940e 03bc 	CALL _twi_addr
000401 30e0      	CPI  R30,0
000402 f419      	BRNE _0x8C
                 ;     879 		{
                 ;     880 			twi_stop();
000403 940e 03b8 	CALL _twi_stop
                 ;     881 			continue;
000405 cff0      	RJMP _0x88
                 ;     882 		}
                 ;     883 		
                 ;     884 		break;
                 _0x8C:
                 ;     885 	}
                 ;     886 
                 ;     887 
                 ;     888 	tx1crc = 0;					// Готовлю CRC
000406 e0e0      	LDI  R30,LOW(0)
000407 93e0 0885 	STS  _tx1crc,R30
                 ;     889 
                 ;     890 	twi_byte(PACKHDR);		    // Передаю заголовок
000409 e7e1      	LDI  R30,LOW(113)
00040a 93ea      	ST   -Y,R30
00040b 940e 03d3 	CALL _twi_byte
                 ;     891 	tx1crc+=(PACKHDR);
00040d 91e0 0885 	LDS  R30,_tx1crc
00040f 58ef      	SUBI R30,-LOW(113)
000410 93e0 0885 	STS  _tx1crc,R30
                 ;     892 
                 ;     893 	twi_byte(dlen+1);			// Передаю длину
000412 81e8      	LD   R30,Y
000413 5fef      	SUBI R30,-LOW(1)
000414 93ea      	ST   -Y,R30
000415 940e 03d3 	CALL _twi_byte
                 ;     894 	tx1crc+=(dlen+1);
000417 81e8      	LD   R30,Y
000418 5fef      	SUBI R30,-LOW(1)
000419 91a0 0885 	LDS  R26,_tx1crc
00041b 0fea      	ADD  R30,R26
00041c 93e0 0885 	STS  _tx1crc,R30
                 ;     895 }
                 _0x431:
00041e 9621      	ADIW R28,1
00041f 9508      	RET
                 ;     896 
                 ;     897 // Завершение запроса во внутренний канал
                 ;     898 void EndIntReq(void)
                 ;     899 {
                 _EndIntReq:
                 ;     900 	twi_byte(tx1crc);			// Контрольная сумма
000420 91e0 0885 	LDS  R30,_tx1crc
000422 93ea      	ST   -Y,R30
000423 940e 03d3 	CALL _twi_byte
                 ;     901 	twi_stop();                 // Cтоп
000425 940e 03b8 	CALL _twi_stop
                 ;     902 
                 ;     903 	
                 ;     904 //	rx1state = RX_LEN;			// Приемнику начать прием пакета
                 ;     905 
                 ;     906 //	OCR1B = TCNT1+RX1TIMEOUT;	// Взвожу тайм-аут
                 ;     907 //	TIFR = 0x08;				// Предотвращаю ложное срабатывание
                 ;     908 //	TIMSK |= 0x08;				// Разрешение прерывания по тайм-ауту
                 ;     909 }
000427 9508      	RET
                 ;     910 
                 ;     911 // Прием байта из "внутреннего" канала TWI
                 ;     912 void TWI_rx_isr(void)
                 ;     913 {
                 ;     914 	register unsigned char byt;
                 ;     915 	twi_start();                //Запрашиваю байт ответа
                 ;	byt -> R16
                 ;     916     	
                 ;     917     
                 ;     918 	byt = UDR1;
                 ;     919 	
                 ;     920 	switch (rx1state)
                 ;     921 	{
                 ;     922 	case RX_LEN:				// Принята длина пакета
                 ;     923 		rx1crc = 0;
                 ;     924 		rx1ptr = 0;
                 ;     925 		rx1len = byt - 1;
                 ;     926 		if (rx1len)
                 ;     927 		{
                 ;     928 			rx1state = RX_DATA;
                 ;     929 		}
                 ;     930 		else
                 ;     931 		{
                 ;     932 			rx1state = RX_CRC;
                 ;     933 		}
                 ;     934 //printf("L%d", rx1len);
                 ;     935 		break;
                 ;     936 
                 ;     937 	case RX_DATA:				// Принят байт данных пакета
                 ;     938 //printf("D");
                 ;     939 		rx1buf[rx1ptr++] = byt;
                 ;     940 		if (rx1ptr < rx1len)	// Уже все ?
                 ;     941 		{
                 ;     942 			break;
                 ;     943 		}
                 ;     944 		rx1state = RX_CRC;
                 ;     945 		break;
                 ;     946 		
                 ;     947 	case RX_CRC:				// Принята контрольная сумма пакета
                 ;     948 		if (byt != rx1crc)
                 ;     949 		{
                 ;     950 			rx1state = RX_ERR;	// Не сошлась CRC
                 ;     951 //printf("C");
                 ;     952 		}
                 ;     953 		else
                 ;     954 		{
                 ;     955 			rx1state = RX_OK;	// Пакет успешно принят
                 ;     956 //printf("+");
                 ;     957 		}
                 ;     958 
                 ;     959 		TIMSK &= 0x08 ^ 0xFF;	// Запретить прерывание по тайм-ауту
                 ;     960 		break;
                 ;     961 
                 ;     962 	default:					// В остальных состояниях - ничего не делать
                 ;     963 		break;
                 ;     964 	}
                 ;     965 
                 ;     966 	rx1crc += byt;				// Подсчитываю контрольную сумму
                 ;     967 } 
                 ;     968 
                 ;     969 // Прерывание по сравнению B таймера 1 для подсчета тайм-аута приема "внутреннего" канала
                 ;     970 interrupt [TIM1_COMPB] void timer1_comp_b_isr(void)
                 ;     971 {
                 _timer1_comp_b_isr:
000428 93ea      	ST   -Y,R30
000429 b7ef      	IN   R30,SREG
00042a 93ea      	ST   -Y,R30
                 ;     972 	rx1state = RX_TIME;		// Был тайм-аут
00042b e0e8      	LDI  R30,LOW(8)
00042c 93e0 0886 	STS  _rx1state,R30
                 ;     973 	TIMSK &= 0x08 ^ 0xFF;	// Запретить прерывание по тайм-ауту
00042e b7e7      	IN   R30,0x37
00042f 7fe7      	ANDI R30,0XF7
000430 bfe7      	OUT  0x37,R30
                 ;     974 //printf("T");
                 ;     975 }
000431 91e9      	LD   R30,Y+
000432 bfef      	OUT  SREG,R30
000433 91e9      	LD   R30,Y+
000434 9518      	RETI
                 ;     976 
                 ;     977 // Проверка занятости "внутреннего" канала
                 ;     978 unsigned char InternalComBusy(void)
                 ;     979 {
                 ;     980 	if (rx1state != RX_IDLE)	return 1;
                 ;     981 	else						return 0;
                 ;     982 }
                 ;     983 
                 ;     984 // Признак завершения цикла обмена во внутрю канале
                 ;     985 unsigned char HaveInternalReply(void)
                 ;     986 {
                 ;     987 	switch(rx1state)
                 ;     988 	{
                 ;     989 	case RX_OK:
                 ;     990 	case RX_TIME:
                 ;     991 	case RX_ERR:
                 ;     992 		return rx1state;
                 ;     993 	default:
                 ;     994 		return 0;
                 ;     995 	}
                 ;     996 }
                 ;     997 
                 ;     998 // Необходимо вызвать после завершения обработки принятого по "внутреннему" каналу пакета
                 ;     999 void FreeInternalCom(void)
                 ;    1000 {
                 ;    1001 	rx1state = RX_IDLE;
                 ;    1002 }
                 ;    1003 
                 ;    1004 // Передача байта byte по pAddr
                 ;    1005 unsigned char txTWIbyte (unsigned char pAddr, unsigned char byte)
                 ;    1006 	{  
                 _txTWIbyte:
                 ;    1007 
                 ;    1008 		timeOut ();									// запускаем тайм аут
000435 d0b5      	RCALL _timeOut
                 ;    1009 
                 ;    1010 		if (!twi_start())     		  				// Cтарт пакета
000436 940e 03a6 	CALL _twi_start
000438 30e0      	CPI  R30,0
000439 f411      	BRNE _0xA4
                 ;    1011 			{
                 ;    1012 				twi_stop();
00043a 940e 03b8 	CALL _twi_stop
                 ;    1013 			}
                 ;    1014 		
                 ;    1015 		if (!twi_addr((pAddr<<1)+0))       // Передача  по адресу pAddr (мл 0 - запись)
                 _0xA4:
00043c 81e9      	LDD  R30,Y+1
00043d 0fee      	LSL  R30
00043e 93ea      	ST   -Y,R30
00043f 940e 03bc 	CALL _twi_addr
000441 30e0      	CPI  R30,0
000442 f411      	BRNE _0xA5
                 ;    1016 			{
                 ;    1017 				twi_stop();
000443 940e 03b8 	CALL _twi_stop
                 ;    1018 			}            
                 ;    1019 			
                 ;    1020 		twi_byte(byte);								// передаем байт
                 _0xA5:
000445 81e8      	LD   R30,Y
000446 93ea      	ST   -Y,R30
000447 940e 03d3 	CALL _twi_byte
                 ;    1021 		twi_stop();									// стоп пакета
000449 940e 03b8 	CALL _twi_stop
                 ;    1022 
                 ;    1023 		timeOutStop ();							// останов таймера таймаута   
00044b d0a4      	RCALL _timeOutStop
                 ;    1024 		
                 ;    1025 	    if ( ! ( flagTWI & ( 1 << time_is_Out))) return 255;
00044c 91e0 098a 	LDS  R30,_flagTWI
00044e 70e1      	ANDI R30,LOW(0x1)
00044f f411      	BRNE _0xA6
000450 efef      	LDI  R30,LOW(255)
000451 c007      	RJMP _0x430
                 ;    1026 	    	else 
                 _0xA6:
                 ;    1027 	    		{
                 ;    1028 					flagTWI  = flagTWI  ^ (1 << time_is_Out);	//сбрасываем  признак
000452 91a0 098a 	LDS  R26,_flagTWI
000454 e0e1      	LDI  R30,LOW(1)
000455 27ea      	EOR  R30,R26
000456 93e0 098a 	STS  _flagTWI,R30
                 ;    1029 					return 0;
000458 e0e0      	LDI  R30,LOW(0)
                 ;    1030 	    		}
                 ;    1031 	}
                 _0x430:
000459 9622      	ADIW R28,2
00045a 9508      	RET
                 ;    1032 
                 ;    1033 unsigned char txTWIbuff (unsigned char pAddr)
                 ;    1034 	{                                                                           
                 _txTWIbuff:
                 ;    1035 		unsigned char a ;
                 ;    1036 		
                 ;    1037 		timeOut ();									// запускаем тайм аут
00045b 930a      	ST   -Y,R16
                 ;	pAddr -> Y+1
                 ;	a -> R16
00045c d08e      	RCALL _timeOut
                 ;    1038 		if (!twi_start())     		  				// Cтарт пакета
00045d 940e 03a6 	CALL _twi_start
00045f 30e0      	CPI  R30,0
000460 f411      	BRNE _0xA8
                 ;    1039 			{
                 ;    1040 				twi_stop();
000461 940e 03b8 	CALL _twi_stop
                 ;    1041 			}
                 ;    1042 
                 ;    1043 		if (!twi_addr((pAddr<<1)+0))       // Передача  по адресу pAddr (мл 0 - запись)
                 _0xA8:
000463 81e9      	LDD  R30,Y+1
000464 0fee      	LSL  R30
000465 93ea      	ST   -Y,R30
000466 940e 03bc 	CALL _twi_addr
000468 30e0      	CPI  R30,0
000469 f411      	BRNE _0xA9
                 ;    1044 			{
                 ;    1045 				twi_stop();
00046a 940e 03b8 	CALL _twi_stop
                 ;    1046 			}            
                 ;    1047 
                 ;    1048 	twi_wait_int(); 					// ждем отклик на адрес
                 _0xA9:
00046c 940e 039c 	CALL _twi_wait_int_G3
                 ;    1049 
                 ;    1050 		for (a=0;a<=txBuffer[1]+1;a++)     //длина+заголовок
00046e e000      	LDI  R16,LOW(0)
                 _0xAB:
00046f 91e0 0501 	__GETB1MN _txBuffer,1
000471 5fef      	SUBI R30,-LOW(1)
000472 17e0      	CP   R30,R16
000473 f050      	BRLO _0xAC
                 ;    1051 			{		                         
                 ;    1052 				twi_byte(txBuffer[a]);				// передаем байт
000474 2fe0      	MOV  R30,R16
000475 e0f0      	LDI  R31,0
000476 50e0      	SUBI R30,LOW(-_txBuffer)
000477 4ffb      	SBCI R31,HIGH(-_txBuffer)
000478 81e0      	LD   R30,Z
000479 93ea      	ST   -Y,R30
00047a 940e 03d3 	CALL _twi_byte
                 ;    1053 			}		
00047c 5f0f      	SUBI R16,-1
00047d cff1      	RJMP _0xAB
                 _0xAC:
                 ;    1054 
                 ;    1055 			twi_stop();									// стоп пакета
00047e 940e 03b8 	CALL _twi_stop
                 ;    1056 			timeOutStop ();							// останов таймера таймаута   
000480 d06f      	RCALL _timeOutStop
                 ;    1057 		
                 ;    1058 	    	if ( ! ( flagTWI & ( 1 << time_is_Out))) return 255;
000481 91e0 098a 	LDS  R30,_flagTWI
000483 70e1      	ANDI R30,LOW(0x1)
000484 f411      	BRNE _0xAD
000485 efef      	LDI  R30,LOW(255)
000486 c125      	RJMP _0x42E
                 ;    1059 	    		else 
                 _0xAD:
                 ;    1060 	    			{
                 ;    1061 						flagTWI  = flagTWI  ^ (1 << time_is_Out);	//сбрасываем  признак
000487 91a0 098a 	LDS  R26,_flagTWI
000489 e0e1      	LDI  R30,LOW(1)
00048a 27ea      	EOR  R30,R26
00048b 93e0 098a 	STS  _flagTWI,R30
                 ;    1062 						return 0;
00048d e0e0      	LDI  R30,LOW(0)
00048e c11d      	RJMP _0x42E
                 ;    1063 		    		}
                 ;    1064 	}
                 ;    1065 	
                 ;    1066 
                 ;    1067 // Вычитываем в буффер
                 ;    1068 unsigned char rxTWIbuff (unsigned char pAddr)
                 ;    1069 		{                                                         
                 _rxTWIbuff:
                 ;    1070 		unsigned char a;
                 ;    1071 
                 ;    1072 		if (!twi_start())     		  				// Cтарт пакета
00048f 930a      	ST   -Y,R16
                 ;	pAddr -> Y+1
                 ;	a -> R16
000490 940e 03a6 	CALL _twi_start
000492 30e0      	CPI  R30,0
000493 f411      	BRNE _0xAF
                 ;    1073 			{
                 ;    1074 				twi_stop();
000494 940e 03b8 	CALL _twi_stop
                 ;    1075 			}
                 ;    1076 
                 ;    1077 		if (!twi_addr((pAddr<<1)+1))       // Передача  по адресу pAddr (мл 1 - чтение)
                 _0xAF:
000496 81e9      	LDD  R30,Y+1
000497 0fee      	LSL  R30
000498 5fef      	SUBI R30,-LOW(1)
000499 93ea      	ST   -Y,R30
00049a 940e 03bc 	CALL _twi_addr
00049c 30e0      	CPI  R30,0
00049d f411      	BRNE _0xB0
                 ;    1078 			{
                 ;    1079 				twi_stop();
00049e 940e 03b8 	CALL _twi_stop
                 ;    1080 			}            
                 ;    1081 
                 ;    1082 		rxBuffer[0] = twi_read(1);				// читаем  и запоминаем  длину принимаемого пакета
                 _0xB0:
0004a0 e0e1      	LDI  R30,LOW(1)
0004a1 93ea      	ST   -Y,R30
0004a2 940e 03e5 	CALL _twi_read
0004a4 93e0 0600 	STS  _rxBuffer,R30
                 ;    1083 
                 ;    1084 		for (a=1; a<rxBuffer[0];  a++)
0004a6 e001      	LDI  R16,LOW(1)
                 _0xB2:
0004a7 91e0 0600 	LDS  R30,_rxBuffer
0004a9 170e      	CP   R16,R30
0004aa f478      	BRSH _0xB3
                 ;    1085 			{
                 ;    1086 				rxBuffer[a] = twi_read(1);			// не посл. байт - формируем ACK
0004ab 2fe0      	MOV  R30,R16
0004ac e0f0      	LDI  R31,0
0004ad 50e0      	SUBI R30,LOW(-_rxBuffer)
0004ae 4ffa      	SBCI R31,HIGH(-_rxBuffer)
0004af 93ff      	PUSH R31
0004b0 93ef      	PUSH R30
0004b1 e0e1      	LDI  R30,LOW(1)
0004b2 93ea      	ST   -Y,R30
0004b3 940e 03e5 	CALL _twi_read
0004b5 91af      	POP  R26
0004b6 91bf      	POP  R27
0004b7 93ec      	ST   X,R30
                 ;    1087 			}              
0004b8 5f0f      	SUBI R16,-1
0004b9 cfed      	RJMP _0xB2
                 _0xB3:
                 ;    1088 
                 ;    1089 				rxBuffer[a] = twi_read(0);			// посл. байт -  не формируем ACK
0004ba 2fe0      	MOV  R30,R16
0004bb e0f0      	LDI  R31,0
0004bc 50e0      	SUBI R30,LOW(-_rxBuffer)
0004bd 4ffa      	SBCI R31,HIGH(-_rxBuffer)
0004be 93ff      	PUSH R31
0004bf 93ef      	PUSH R30
0004c0 e0e0      	LDI  R30,LOW(0)
0004c1 93ea      	ST   -Y,R30
0004c2 940e 03e5 	CALL _twi_read
0004c4 91af      	POP  R26
0004c5 91bf      	POP  R27
0004c6 93ec      	ST   X,R30
                 ;    1090 
                 ;    1091 			twi_stop();									// стоп пакета               
0004c7 940e 03b8 	CALL _twi_stop
                 ;    1092 			
                 ;    1093 						// Проверяем таймаут и CRC
                 ;    1094 	    	if ( (! ( flagTWI & ( 1 << time_is_Out))) && (rxCRC())) return 255;	//Ok
0004c9 91e0 098a 	LDS  R30,_flagTWI
0004cb 70e1      	ANDI R30,LOW(0x1)
0004cc f419      	BRNE _0xB5
0004cd d049      	RCALL _rxCRC
0004ce 30e0      	CPI  R30,0
0004cf f409      	BRNE _0xB6
                 _0xB5:
0004d0 c002      	RJMP _0xB4
                 _0xB6:
0004d1 efef      	LDI  R30,LOW(255)
0004d2 c0d9      	RJMP _0x42E
                 ;    1095     		else 
                 _0xB4:
                 ;    1096 	    			{
                 ;    1097 						flagTWI  = flagTWI  ^ (1 << time_is_Out);		//сбрасываем  признак
0004d3 91a0 098a 	LDS  R26,_flagTWI
0004d5 e0e1      	LDI  R30,LOW(1)
0004d6 27ea      	EOR  R30,R26
0004d7 93e0 098a 	STS  _flagTWI,R30
                 ;    1098 						return 0;                                                          // Time Out
0004d9 e0e0      	LDI  R30,LOW(0)
0004da c0d1      	RJMP _0x42E
                 ;    1099 		    		}
                 ;    1100 		}
                 ;    1101 #include "Coding.h"
                 ;    1102 
                 ;    1103 unsigned char flagTWI				=	0;
                 
                 	.DSEG
                 _flagTWI:
00098a           	.BYTE 0x1
                 ;    1104 unsigned char int_Devices		=	0;			// количество подчиненных устройств
                 _int_Devices:
00098b           	.BYTE 0x1
                 ;    1105 
                 ;    1106 
                 ;    1107 
                 ;    1108 // Инициализация выводов
                 ;    1109 void portInit (void)
                 ;    1110 		{
                 
                 	.CSEG
                 _portInit:
                 ;    1111 			DDRB.7 = 1;		// testpin
0004db 9abf      	SBI  0x17,7
                 ;    1112 			CS_DDR_SET();	// для CF Card
0004dc 9abc      	SBI  0x17,4
                 ;    1113 		}
0004dd 9508      	RET
                 ;    1114 
                 ;    1115 
                 ;    1116 
                 ;    1117 // -------------------- Функции работы с таймером 0 -------------------------------
                 ;    1118 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;    1119 // Timer/Counter 0 initialization ; Clock source: System Clock
                 ;    1120 // Clock value: 31,250 kHz ;  Mode: Normal top=FFh
                 ;    1121 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;    1122 void timer_0_Init  (void)
                 ;    1123 	{
                 _timer_0_Init:
                 ;    1124 		ASSR=0x00;
0004de e0e0      	LDI  R30,LOW(0)
0004df bfe0      	OUT  0x30,R30
                 ;    1125 		TCCR0=0x0;        //0x06 -start
0004e0 bfe3      	OUT  0x33,R30
                 ;    1126 		TCNT0=0x01;
0004e1 e0e1      	LDI  R30,LOW(1)
0004e2 bfe2      	OUT  0x32,R30
                 ;    1127 		OCR0=0x00;
0004e3 e0e0      	LDI  R30,LOW(0)
0004e4 bfe1      	OUT  0x31,R30
                 ;    1128 
                 ;    1129 		TIMSK=0x01;			// Timer(s)/Counter(s) Interrupt(s) initialization
0004e5 e0e1      	LDI  R30,LOW(1)
0004e6 bfe7      	OUT  0x37,R30
                 ;    1130 		ETIMSK=0x00;
0004e7 e0e0      	LDI  R30,LOW(0)
0004e8 93e0 007d 	STS  125,R30
                 ;    1131 
                 ;    1132 	}
0004ea 9508      	RET
                 ;    1133 
                 ;    1134 // запускаем таймер для таймаута
                 ;    1135 void timeOut (void)
                 ;    1136 	{
                 _timeOut:
                 ;    1137 //		flagTWI  = (flagTWI  ^ (1 << time_is_Out));		// сброс признака
                 ;    1138 		TCNT0=0x0	;														// обнуляем счетчик
0004eb e0e0      	LDI  R30,LOW(0)
0004ec bfe2      	OUT  0x32,R30
                 ;    1139 		TCCR0 = 0x06;													// пускаем таймер (около 10 мс)
0004ed e0e6      	LDI  R30,LOW(6)
0004ee bfe3      	OUT  0x33,R30
                 ;    1140 	}
0004ef 9508      	RET
                 ;    1141 
                 ;    1142 // остановка таймера для таймаута
                 ;    1143 void timeOutStop (void)
                 ;    1144 	{
                 _timeOutStop:
                 ;    1145 		TCCR0 = 0x0; 						// осттанов таймера (около 10 мс)
0004f0 e0e0      	LDI  R30,LOW(0)
0004f1 bfe3      	OUT  0x33,R30
                 ;    1146 	}
0004f2 9508      	RET
                 ;    1147 
                 ;    1148 
                 ;    1149 // Timer 0 overflow interrupt service routine
                 ;    1150 interrupt [TIM0_OVF] void timer0_ovf_isr(void)
                 ;    1151 {
                 _timer0_ovf_isr:
0004f3 93ea      	ST   -Y,R30
0004f4 b7ef      	IN   R30,SREG
0004f5 93ea      	ST   -Y,R30
                 ;    1152 		TCCR0 = 0x0;						//останавливаем таймер
0004f6 e0e0      	LDI  R30,LOW(0)
0004f7 bfe3      	OUT  0x33,R30
                 ;    1153 		flagTWI  = flagTWI  | (1 << time_is_Out);	 //взводим признак    
0004f8 91e0 098a 	LDS  R30,_flagTWI
0004fa 60e1      	ORI  R30,1
0004fb 93e0 098a 	STS  _flagTWI,R30
                 ;    1154 
                 ;    1155 }
0004fd 91e9      	LD   R30,Y+
0004fe bfef      	OUT  SREG,R30
0004ff 91e9      	LD   R30,Y+
000500 9518      	RETI
                 ;    1156                                                                                              
                 ;    1157 // Проверяем количество подчиненных устройств
                 ;    1158 void verIntDev (void)
                 ;    1159 	{
                 _verIntDev:
                 ;    1160 		unsigned char a;
                 ;    1161 		for (a=1; a<10;a++)				// сканируем количество подчиненных устройств 
000501 930a      	ST   -Y,R16
                 ;	a -> R16
000502 e001      	LDI  R16,LOW(1)
                 _0xB9:
000503 300a      	CPI  R16,10
000504 f448      	BRSH _0xBA
                 ;    1162 			{											//  адреса начинаются с 1
                 ;    1163 				if (!(txTWIbyte ( a, 0xaa))) break;   
000505 930a      	ST   -Y,R16
000506 eaea      	LDI  R30,LOW(170)
000507 93ea      	ST   -Y,R30
000508 940e 0435 	CALL _txTWIbyte
00050a 30e0      	CPI  R30,0
00050b f011      	BREQ _0xBA
                 ;    1164 			}
00050c 5f0f      	SUBI R16,-1
00050d cff5      	RJMP _0xB9
                 _0xBA:
                 ;    1165         int_Devices = a-1;
00050e 2fe0      	MOV  R30,R16
00050f 50e1      	SUBI R30,LOW(1)
000510 93e0 098b 	STS  _int_Devices,R30
                 ;    1166 		lAddrDevice[0] = lAddrDevice;	// запоминаем кол-во портов 232
000512 e0e0      	LDI  R30,LOW(_lAddrDevice)
000513 e0f7      	LDI  R31,HIGH(_lAddrDevice)
000514 93e0 0700 	STS  _lAddrDevice,R30
                 ;    1167 	}     
000516 c0ea      	RJMP _0x42D
                 ;    1168 	
                 ;    1169 // считаем КС принятого пакета
                 ;    1170 unsigned char rxCRC (void)
                 ;    1171 	{                    
                 _rxCRC:
                 ;    1172 		unsigned char KS = 0, a;		
                 ;    1173 			for (a=0; a< rxBuffer [0] ;a++)
000517 931a      	ST   -Y,R17
000518 930a      	ST   -Y,R16
                 ;	KS -> R16
                 ;	a -> R17
000519 e000      	LDI  R16,0
00051a e010      	LDI  R17,LOW(0)
                 _0xBD:
00051b 91e0 0600 	LDS  R30,_rxBuffer
00051d 171e      	CP   R17,R30
00051e f440      	BRSH _0xBE
                 ;    1174 				{
                 ;    1175 					KS =KS+rxBuffer [a];
00051f 2fe1      	MOV  R30,R17
000520 e0f0      	LDI  R31,0
000521 50e0      	SUBI R30,LOW(-_rxBuffer)
000522 4ffa      	SBCI R31,HIGH(-_rxBuffer)
000523 81e0      	LD   R30,Z
000524 0f0e      	ADD  R16,R30
                 ;    1176 				}                                     
000525 5f1f      	SUBI R17,-1
000526 cff4      	RJMP _0xBD
                 _0xBE:
                 ;    1177 			if (KS == rxBuffer [a]) return 255; 	//Ok
000527 2fe1      	MOV  R30,R17
000528 e0f0      	LDI  R31,0
000529 50e0      	SUBI R30,LOW(-_rxBuffer)
00052a 4ffa      	SBCI R31,HIGH(-_rxBuffer)
00052b 81e0      	LD   R30,Z
00052c 17e0      	CP   R30,R16
00052d f411      	BRNE _0xBF
00052e efef      	LDI  R30,LOW(255)
00052f c001      	RJMP _0x42F
                 ;    1178 			else return 0;                                         // Error
                 _0xBF:
000530 e0e0      	LDI  R30,LOW(0)
                 ;    1179 		
                 ;    1180 	}	        
                 _0x42F:
000531 9109      	LD   R16,Y+
000532 9119      	LD   R17,Y+
000533 9508      	RET
                 ;    1181 
                 ;    1182 // вычитываем логические адреса устройств
                 ;    1183 void ReadLogAddr (void)
                 ;    1184 		{          
                 _ReadLogAddr:
                 ;    1185 		unsigned char b;
                 ;    1186 		
                 ;    1187 					txBuffer[0] = 'q';								// заголовок
000534 930a      	ST   -Y,R16
                 ;	b -> R16
000535 e7e1      	LDI  R30,LOW(113)
000536 93e0 0500 	STS  _txBuffer,R30
                 ;    1188 					txBuffer[1] = 3;		                 		// длина
000538 e0e3      	LDI  R30,LOW(3)
000539 93e0 0501 	__PUTB1MN _txBuffer,1
                 ;    1189 					txBuffer[2] = 0;                   		// адрес
00053b e0e0      	LDI  R30,LOW(0)
00053c 93e0 0502 	__PUTB1MN _txBuffer,2
                 ;    1190 					txBuffer[3] = GetLogAddr;       		// тип
00053e e0e1      	LDI  R30,LOW(1)
00053f 93e0 0503 	__PUTB1MN _txBuffer,3
                 ;    1191 					txBuffer[4] = 'q'+3+0+GetLogAddr; 		//KC
000541 e7e5      	LDI  R30,LOW(117)
000542 93e0 0504 	__PUTB1MN _txBuffer,4
                 ;    1192 
                 ;    1193 					txTWIbuff (0);		//передаем всем
000544 e0e0      	LDI  R30,LOW(0)
000545 93ea      	ST   -Y,R30
000546 940e 045b 	CALL _txTWIbuff
                 ;    1194 //					delay_ms (20);          
                 ;    1195 					delay_ms (5);          
000548 e0e5      	LDI  R30,LOW(5)
000549 e0f0      	LDI  R31,HIGH(5)
00054a 93fa      	ST   -Y,R31
00054b 93ea      	ST   -Y,R30
00054c 940e 1dbe 	CALL _delay_ms
                 ;    1196 
                 ;    1197 for (b=1; b<= int_Devices; b++)
00054e e001      	LDI  R16,LOW(1)
                 _0xC2:
00054f 91e0 098b 	LDS  R30,_int_Devices
000551 17e0      	CP   R30,R16
000552 f060      	BRLO _0xC3
                 ;    1198 	{
                 ;    1199 //					txTWIbuff (b);		//передаем 
                 ;    1200 //					delay_ms (10);          
                 ;    1201 					rxTWIbuff (b);
000553 930a      	ST   -Y,R16
000554 940e 048f 	CALL _rxTWIbuff
                 ;    1202 					lAddrDevice [b] = rxBuffer[1];		// запоминаем лог. адреса портов       
000556 2fa0      	MOV  R26,R16
000557 e0b0      	LDI  R27,0
000558 50a0      	SUBI R26,LOW(-_lAddrDevice)
000559 4fb9      	SBCI R27,HIGH(-_lAddrDevice)
00055a 91e0 0601 	__GETB1MN _rxBuffer,1
00055c 93ec      	ST   X,R30
                 ;    1203      }
00055d 5f0f      	SUBI R16,-1
00055e cff0      	RJMP _0xC2
                 _0xC3:
                 ;    1204 				
                 ;    1205 }  
00055f c0a1      	RJMP _0x42D
                 ;    1206 
                 ;    1207 // ретранслируем пакет
                 ;    1208 void		recompPack (unsigned char device)
                 ;    1209 	{
                 _recompPack:
                 ;    1210 		unsigned char a, b=0;
                 ;    1211 					txBuffer[0] = PACKHDR;				// заголовок
000560 931a      	ST   -Y,R17
000561 930a      	ST   -Y,R16
                 ;	device -> Y+2
                 ;	a -> R16
                 ;	b -> R17
000562 e010      	LDI  R17,0
000563 e7e1      	LDI  R30,LOW(113)
000564 93e0 0500 	STS  _txBuffer,R30
                 ;    1212 					txBuffer[1] = rx0len+3;            		// длина (+3 - тк. вычлось при приеме)
000566 2ded      	MOV  R30,R13
000567 5fed      	SUBI R30,-LOW(3)
000568 93e0 0501 	__PUTB1MN _txBuffer,1
                 ;    1213 					txBuffer[2] = rx0addr;                 	// адрес
00056a e0a2
00056b e0b5      	__POINTW2MN _txBuffer,2
00056c 91e0 0784 	LDS  R30,_rx0addr
00056e 93ec      	ST   X,R30
                 ;    1214 					txBuffer[3] = rx0type;					// тип
00056f 92e0 0503 	__PUTBMRN _txBuffer,3,14
                 ;    1215 
                 ;    1216 					for (a=4; a<=(rx0len+4); a++)
000571 e004      	LDI  R16,LOW(4)
                 _0xC5:
000572 2ded      	MOV  R30,R13
000573 5fec      	SUBI R30,-LOW(4)
000574 17e0      	CP   R30,R16
000575 f068      	BRLO _0xC6
                 ;    1217 						{
                 ;    1218 							txBuffer[a] = rx0buf 	[b++];				
000576 2fa0      	MOV  R26,R16
000577 e0b0      	LDI  R27,0
000578 50a0      	SUBI R26,LOW(-_txBuffer)
000579 4fbb      	SBCI R27,HIGH(-_txBuffer)
00057a 2fe1      	MOV  R30,R17
00057b 5f1f      	SUBI R17,-1
00057c e0f0      	LDI  R31,0
00057d 57eb      	SUBI R30,LOW(-_rx0buf)
00057e 4ff8      	SBCI R31,HIGH(-_rx0buf)
00057f 81e0      	LD   R30,Z
000580 93ec      	ST   X,R30
                 ;    1219 						}                   
000581 5f0f      	SUBI R16,-1
000582 cfef      	RJMP _0xC5
                 _0xC6:
                 ;    1220 
                 ;    1221 					txTWIbuff (device);								//передаем 
000583 81ea      	LDD  R30,Y+2
000584 93ea      	ST   -Y,R30
000585 940e 045b 	CALL _txTWIbuff
                 ;    1222 					delay_ms (10);
000587 e0ea      	LDI  R30,LOW(10)
000588 e0f0      	LDI  R31,HIGH(10)
000589 93fa      	ST   -Y,R31
00058a 93ea      	ST   -Y,R30
00058b 940e 1dbe 	CALL _delay_ms
                 ;    1223 
                 ;    1224 
                 ;    1225 	}
00058d 8119      	LDD  R17,Y+1
00058e 8108      	LDD  R16,Y+0
00058f 9623      	ADIW R28,3
000590 9508      	RET
                 ;    1226 	
                 ;    1227 // пингуем подчиненное для проверки информации
                 ;    1228 void pingPack (unsigned char device)
                 ;    1229 	{
                 _pingPack:
                 ;    1230 	unsigned char a;
                 ;    1231 			
                 ;    1232 /*					txBuffer[0] = 'q';									// заголовок
                 ;    1233 					txBuffer[1] = 3;                 					// длина
                 ;    1234 					txBuffer[2] = 0;                   				// адрес
                 ;    1235 					txBuffer[3] = pingPacket;       				// тип
                 ;    1236 					txBuffer[4] = 'q'+3+0+pingPacket; 		// KC
                 ;    1237 
                 ;    1238 					txTWIbuff (device);								// передаем 
                 ;    1239 
                 ;    1240 //					delay_ms (20);          */
                 ;    1241 //					delay_ms (10);          
                 ;    1242 
                 ;    1243 					rxTWIbuff (device);                  			// принимаем
000591 930a      	ST   -Y,R16
                 ;	device -> Y+1
                 ;	a -> R16
000592 81e9      	LDD  R30,Y+1
000593 93ea      	ST   -Y,R30
000594 940e 048f 	CALL _rxTWIbuff
                 ;    1244 
                 ;    1245 					if (rxBuffer[0] )
000596 91e0 0600 	LDS  R30,_rxBuffer
000598 30e0      	CPI  R30,0
000599 f091      	BREQ _0xC7
                 ;    1246 						{
                 ;    1247 						UCSR0B.3 = 1;								// Разрешаю передатчик
00059a 9a53      	SBI  0xA,3
                 ;    1248                             	for (a=0;a<=rxBuffer[0];a++)
00059b e000      	LDI  R16,LOW(0)
                 _0xC9:
00059c 91e0 0600 	LDS  R30,_rxBuffer
00059e 17e0      	CP   R30,R16
00059f f050      	BRLO _0xCA
                 ;    1249 									{
                 ;    1250 										putchar0 (rxBuffer [a]);
0005a0 2fe0      	MOV  R30,R16
0005a1 e0f0      	LDI  R31,0
0005a2 50e0      	SUBI R30,LOW(-_rxBuffer)
0005a3 4ffa      	SBCI R31,HIGH(-_rxBuffer)
0005a4 81e0      	LD   R30,Z
0005a5 93ea      	ST   -Y,R30
0005a6 940e 02b4 	CALL _putchar0
                 ;    1251 									}     
0005a8 5f0f      	SUBI R16,-1
0005a9 cff2      	RJMP _0xC9
                 _0xCA:
                 ;    1252 						rx0state = RX_HDR;					// Разрешаю прием след. запроса
0005aa e0e1      	LDI  R30,LOW(1)
0005ab 2ebe      	MOV  R11,R30
                 ;    1253 						
                 ;    1254 						}          
                 ;    1255 	
                 ;    1256 	
                 ;    1257 	}
                 _0xC7:
                 _0x42E:
0005ac 8108      	LDD  R16,Y+0
0005ad 9622      	ADIW R28,2
0005ae 9508      	RET
                 ;    1258 	
                 ;    1259 
                 ;    1260 	
                 ;    1261 	
                 ;    1262 
                 ;    1263 
                 ;    1264 #include "Coding.h"
                 ;    1265 
                 ;    1266 void flash_Work (void)
                 ;    1267 	{  
                 _flash_Work:
                 ;    1268 		unsigned char a;
                 ;    1269 		switch(rx0buf[0])
0005af 930a      	ST   -Y,R16
                 ;	a -> R16
0005b0 91e0 0785 	LDS  R30,_rx0buf
                 ;    1270 			{
                 ;    1271 				case PT_Fcreate: 		// создать и открыть файл
0005b2 30e1      	CPI  R30,LOW(0x1)
0005b3 f4b9      	BRNE _0xCE
                 ;    1272 					{       
                 ;    1273 LedRed();
0005b4 9ad0      	SBI  0x1A,0
0005b5 9ad1      	SBI  0x1A,1
0005b6 98d8      	CBI  0x1B,0
0005b7 9ad9      	SBI  0x1B,1
                 ;    1274 
                 ;    1275 						pntr1 = fcreate(str->fname, 0); 
0005b8 01f2      	MOVW R30,R4
0005b9 9631      	ADIW R30,1
0005ba 93fa      	ST   -Y,R31
0005bb 93ea      	ST   -Y,R30
0005bc e0e0      	LDI  R30,LOW(0)
0005bd 93ea      	ST   -Y,R30
0005be 940e 1839 	CALL _fcreate
0005c0 014f      	MOVW R8,R30
                 ;    1276 
                 ;    1277 						if (!(pntr1)) putchar (0); 						// если не могу создать файл то возращаем 0
0005c1 2c08      	MOV  R0,R8
0005c2 2809      	OR   R0,R9
0005c3 f411      	BRNE _0xCF
0005c4 e0e0      	LDI  R30,LOW(0)
0005c5 c001      	RJMP _0x438
                 ;    1278 						else putchar (0x255);
                 _0xCF:
0005c6 e5e5      	LDI  R30,LOW(597)
                 _0x438:
0005c7 93ea      	ST   -Y,R30
0005c8 940e 1c74 	CALL _putchar
                 ;    1279 
                 ;    1280 //						fputc('S', pntr1);      // write an ‘S’ to the file, increment file pointer */ 
                 ;    1281 //						fputs(str->fname, pntr1);    // add “Hello World!\r\n” to the end of the file 
                 ;    1282  
                 ;    1283 						break;
0005ca c034      	RJMP _0xCD
                 ;    1284 					}
                 ;    1285 				case PT_Fopen: 		// открыть файл
                 _0xCE:
0005cb 30e2      	CPI  R30,LOW(0x2)
0005cc f191      	BREQ _0xCD
                 ;    1286 					{       
                 ;    1287 					
                 ;    1288 						break;
                 ;    1289 					}
                 ;    1290 
                 ;    1291 				case PT_Fclose:
0005cd 30e3      	CPI  R30,LOW(0x3)
0005ce f491      	BRNE _0xD2
                 ;    1292 					{
                 ;    1293 LedRed();
0005cf 9ad0      	SBI  0x1A,0
0005d0 9ad1      	SBI  0x1A,1
0005d1 98d8      	CBI  0x1B,0
0005d2 9ad9      	SBI  0x1B,1
                 ;    1294 					    fclose(pntr1);     							   	// Close          
0005d3 929a      	ST   -Y,R9
0005d4 928a      	ST   -Y,R8
0005d5 940e 1a8d 	CALL _fclose
                 ;    1295 
                 ;    1296 						if (!(pntr1)) putchar (0); 						// если не могу создать файл то возращаем 0
0005d7 2c08      	MOV  R0,R8
0005d8 2809      	OR   R0,R9
0005d9 f411      	BRNE _0xD3
0005da e0e0      	LDI  R30,LOW(0)
0005db c001      	RJMP _0x439
                 ;    1297 						else putchar (0x255);
                 _0xD3:
0005dc e5e5      	LDI  R30,LOW(597)
                 _0x439:
0005dd 93ea      	ST   -Y,R30
0005de 940e 1c74 	CALL _putchar
                 ;    1298 						break;
0005e0 c01e      	RJMP _0xCD
                 ;    1299 					}
                 ;    1300 
                 ;    1301 				case PT_Fremove:
                 _0xD2:
0005e1 30e4      	CPI  R30,LOW(0x4)
0005e2 f0e1      	BREQ _0xCD
                 ;    1302 					{
                 ;    1303 						break;
                 ;    1304 					}
                 ;    1305 
                 ;    1306 				case PT_Frename:
0005e3 30e5      	CPI  R30,LOW(0x5)
0005e4 f0d1      	BREQ _0xCD
                 ;    1307 					{
                 ;    1308 						break;
                 ;    1309 					}
                 ;    1310 
                 ;    1311 				case PT_Ffseek:
0005e5 30e6      	CPI  R30,LOW(0x6)
0005e6 f0c1      	BREQ _0xCD
                 ;    1312 					{
                 ;    1313 						break;
                 ;    1314 					}
                 ;    1315 
                 ;    1316 				case PT_Fformat:
0005e7 30e7      	CPI  R30,LOW(0x7)
0005e8 f419      	BRNE _0xD8
                 ;    1317 					{
                 ;    1318 						fquickformat();    			// Delete all information on the card 
0005e9 940e 12fe 	CALL _fquickformat
                 ;    1319 						break;
0005eb c013      	RJMP _0xCD
                 ;    1320 					}
                 ;    1321 
                 ;    1322 				case PT_Fadd:
                 _0xD8:
0005ec 30e8      	CPI  R30,LOW(0x8)
0005ed f489      	BRNE _0xCD
                 ;    1323 					{
                 ;    1324 LedRed();
0005ee 9ad0      	SBI  0x1A,0
0005ef 9ad1      	SBI  0x1A,1
0005f0 98d8      	CBI  0x1B,0
0005f1 9ad9      	SBI  0x1B,1
                 ;    1325 //						fputs(str1->dataFlash, pntr1);    // add “Hello World!\r\n” to the end of the file 
                 ;    1326 //						fprintf(pntr1, "%x",11);  			// output the string to the file
                 ;    1327 
                 ;    1328 //						strcpyf (a,0x31);
                 ;    1329 						fflush (pntr1);
0005f2 929a      	ST   -Y,R9
0005f3 928a      	ST   -Y,R8
0005f4 940e 1a16 	CALL _fflush
                 ;    1330 
                 ;    1331 						if (!(pntr1)) putchar (0); 						// если не могу создать файл то возращаем 0
0005f6 2c08      	MOV  R0,R8
0005f7 2809      	OR   R0,R9
0005f8 f411      	BRNE _0xDA
0005f9 e0e0      	LDI  R30,LOW(0)
0005fa c001      	RJMP _0x43A
                 ;    1332 						else putchar (0x255);
                 _0xDA:
0005fb e5e5      	LDI  R30,LOW(597)
                 _0x43A:
0005fc 93ea      	ST   -Y,R30
0005fd 940e 1c74 	CALL _putchar
                 ;    1333 						break;
                 ;    1334 					}
                 ;    1335 
                 ;    1336     		}
                 _0xCD:
                 ;    1337 	rx0state = RX_HDR;						// Разрешаю прием след. запроса
0005ff e0e1      	LDI  R30,LOW(1)
000600 2ebe      	MOV  R11,R30
                 ;    1338 	}
                 _0x42D:
000601 9109      	LD   R16,Y+
000602 9508      	RET
                 ;    1339 
                 ;    1340 
                 ;    1341 
                 ;    1342 	
                 ;    1343 /*
                 ;    1344 	Progressive Resources LLC
                 ;    1345                                     
                 ;    1346 			FlashFile
                 ;    1347 	
                 ;    1348 	Version : 	1.32
                 ;    1349 	Date: 		12/31/2003
                 ;    1350 	Author: 	Erick M. Higa
                 ;    1351                                            
                 ;    1352 	Software License
                 ;    1353 	The use of Progressive Resources LLC FlashFile Source Package indicates 
                 ;    1354 	your understanding and acceptance of the following terms and conditions. 
                 ;    1355 	This license shall supersede any verbal or prior verbal or written, statement 
                 ;    1356 	or agreement to the contrary. If you do not understand or accept these terms, 
                 ;    1357 	or your local regulations prohibit "after sale" license agreements or limited 
                 ;    1358 	disclaimers, you must cease and desist using this product immediately.
                 ;    1359 	This product is © Copyright 2003 by Progressive Resources LLC, all rights 
                 ;    1360 	reserved. International copyright laws, international treaties and all other 
                 ;    1361 	applicable national or international laws protect this product. This software 
                 ;    1362 	product and documentation may not, in whole or in part, be copied, photocopied, 
                 ;    1363 	translated, or reduced to any electronic medium or machine readable form, without 
                 ;    1364 	prior consent in writing, from Progressive Resources LLC and according to all 
                 ;    1365 	applicable laws. The sole owner of this product is Progressive Resources LLC.
                 ;    1366 
                 ;    1367 	Operating License
                 ;    1368 	You have the non-exclusive right to use any enclosed product but have no right 
                 ;    1369 	to distribute it as a source code product without the express written permission 
                 ;    1370 	of Progressive Resources LLC. Use over a "local area network" (within the same 
                 ;    1371 	locale) is permitted provided that only a single person, on a single computer 
                 ;    1372 	uses the product at a time. Use over a "wide area network" (outside the same 
                 ;    1373 	locale) is strictly prohibited under any and all circumstances.
                 ;    1374                                            
                 ;    1375 	Liability Disclaimer
                 ;    1376 	This product and/or license is provided as is, without any representation or 
                 ;    1377 	warranty of any kind, either express or implied, including without limitation 
                 ;    1378 	any representations or endorsements regarding the use of, the results of, or 
                 ;    1379 	performance of the product, Its appropriateness, accuracy, reliability, or 
                 ;    1380 	correctness. The user and/or licensee assume the entire risk as to the use of 
                 ;    1381 	this product. Progressive Resources LLC does not assume liability for the use 
                 ;    1382 	of this product beyond the original purchase price of the software. In no event 
                 ;    1383 	will Progressive Resources LLC be liable for additional direct or indirect 
                 ;    1384 	damages including any lost profits, lost savings, or other incidental or 
                 ;    1385 	consequential damages arising from any defects, or the use or inability to 
                 ;    1386 	use these products, even if Progressive Resources LLC have been advised of 
                 ;    1387 	the possibility of such damages.
                 ;    1388 */                                 
                 ;    1389 
                 ;    1390 /*
                 ;    1391 #include _AVR_LIB_
                 ;    1392 #include <stdio.h>
                 ;    1393 
                 ;    1394 #ifndef _file_sys_h_
                 ;    1395 	#include "..\flash\file_sys.h"
                 ;    1396 #endif
                 ;    1397 */
                 ;    1398 	#include <coding.h>
                 ;    1399 
                 ;    1400 unsigned long OCR_REG;
                 
                 	.DSEG
                 _OCR_REG:
00098c           	.BYTE 0x4
                 ;    1401 unsigned char _FF_buff[512];
                 __FF_buff:
000990           	.BYTE 0x200
                 ;    1402 unsigned int PT_SecStart;
                 _PT_SecStart:
000b90           	.BYTE 0x2
                 ;    1403 unsigned long BS_jmpBoot;
                 _BS_jmpBoot:
000b92           	.BYTE 0x4
                 ;    1404 unsigned int BPB_BytsPerSec;
                 _BPB_BytsPerSec:
000b96           	.BYTE 0x2
                 ;    1405 unsigned char BPB_SecPerClus;
                 _BPB_SecPerClus:
000b98           	.BYTE 0x1
                 ;    1406 unsigned int BPB_RsvdSecCnt;
                 _BPB_RsvdSecCnt:
000b99           	.BYTE 0x2
                 ;    1407 unsigned char BPB_NumFATs;
                 _BPB_NumFATs:
000b9b           	.BYTE 0x1
                 ;    1408 unsigned int BPB_RootEntCnt;
                 _BPB_RootEntCnt:
000b9c           	.BYTE 0x2
                 ;    1409 unsigned int BPB_FATSz16;
                 _BPB_FATSz16:
000b9e           	.BYTE 0x2
                 ;    1410 unsigned char BPB_FATType;
                 _BPB_FATType:
000ba0           	.BYTE 0x1
                 ;    1411 unsigned long BPB_TotSec;
                 _BPB_TotSec:
000ba1           	.BYTE 0x4
                 ;    1412 unsigned long BS_VolSerial;
                 _BS_VolSerial:
000ba5           	.BYTE 0x4
                 ;    1413 unsigned char BS_VolLab[12];
                 _BS_VolLab:
000ba9           	.BYTE 0xC
                 ;    1414 unsigned long _FF_PART_ADDR, _FF_ROOT_ADDR, _FF_DIR_ADDR;
                 __FF_PART_ADDR:
000bb5           	.BYTE 0x4
                 __FF_ROOT_ADDR:
000bb9           	.BYTE 0x4
                 __FF_DIR_ADDR:
000bbd           	.BYTE 0x4
                 ;    1415 unsigned long _FF_FAT1_ADDR, _FF_FAT2_ADDR;
                 __FF_FAT1_ADDR:
000bc1           	.BYTE 0x4
                 __FF_FAT2_ADDR:
000bc5           	.BYTE 0x4
                 ;    1416 unsigned long _FF_RootDirSectors;
                 __FF_RootDirSectors:
000bc9           	.BYTE 0x4
                 ;    1417 unsigned int FirstDataSector;
                 _FirstDataSector:
000bcd           	.BYTE 0x2
                 ;    1418 unsigned long FirstSectorofCluster;
                 _FirstSectorofCluster:
000bcf           	.BYTE 0x4
                 ;    1419 unsigned char _FF_error;
                 __FF_error:
000bd3           	.BYTE 0x1
                 ;    1420 unsigned long _FF_buff_addr;
                 __FF_buff_addr:
000bd4           	.BYTE 0x4
                 ;    1421 extern unsigned long clus_0_addr, _FF_n_temp;
                 ;    1422 extern unsigned int c_counter;
                 ;    1423 //extern unsigned char _FF_FULL_PATH[_FF_PATH_LENGTH];
                 ;    1424 
                 ;    1425 unsigned long DataClusTot;
                 _DataClusTot:
000bd8           	.BYTE 0x4
                 ;    1426 
                 ;    1427 flash struct CMD
                 ;    1428 {
                 ;    1429 	unsigned int index;
                 ;    1430 	unsigned int tx_data;
                 ;    1431 	unsigned int arg;
                 ;    1432 	unsigned int resp;
                 ;    1433 };
                 ;    1434 
                 ;    1435 flash struct CMD sd_cmd[CMD_TOT] =
                 
                 	.CSEG
                 ;    1436 {
                 ;    1437 	{CMD0,	0x40,	NO_ARG,		RESP_1},		// GO_IDLE_STATE
                 ;    1438 	{CMD1,	0x41,	NO_ARG,		RESP_1},		// SEND_OP_COND (ACMD41 = 0x69)
                 ;    1439 	{CMD9,	0x49,	NO_ARG,		RESP_1},		// SEND_CSD
                 ;    1440 	{CMD10,	0x4A,	NO_ARG,		RESP_1},		// SEND_CID
                 ;    1441 	{CMD12,	0x4C,	NO_ARG,		RESP_1},		// STOP_TRANSMISSION
                 ;    1442 	{CMD13,	0x4D,	NO_ARG,		RESP_2},		// SEND_STATUS
                 ;    1443 	{CMD16,	0x50,	BLOCK_LEN,	RESP_1},		// SET_BLOCKLEN
                 ;    1444 	{CMD17, 0x51,	DATA_ADDR,	RESP_1},		// READ_SINGLE_BLOCK
                 ;    1445 	{CMD18, 0x52,	DATA_ADDR,	RESP_1},		// READ_MULTIPLE_BLOCK
                 ;    1446 	{CMD24, 0x58,	DATA_ADDR,	RESP_1},		// WRITE_BLOCK
                 ;    1447 	{CMD25, 0x59,	DATA_ADDR,	RESP_1},		// WRITE_MULTIPLE_BLOCK
                 ;    1448 	{CMD27,	0x5B,	NO_ARG,		RESP_1},		// PROGRAM_CSD
                 ;    1449 	{CMD28, 0x5C,	DATA_ADDR,	RESP_1b},		// SET_WRITE_PROT
                 ;    1450 	{CMD29, 0x5D,	DATA_ADDR,	RESP_1b},		// CLR_WRITE_PROT
                 ;    1451 	{CMD30, 0x5E,	DATA_ADDR,	RESP_1},		// SEND_WRITE_PROT
                 ;    1452 	{CMD32,	0x60,	DATA_ADDR,	RESP_1},		// TAG_SECTOR_START
                 ;    1453 	{CMD33,	0x61,	DATA_ADDR,	RESP_1},		// TAG_SECTOR_END
                 ;    1454 	{CMD34,	0x62,	DATA_ADDR,	RESP_1},		// UNTAG_SECTOR
                 ;    1455 	{CMD35,	0x63,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP_START
                 ;    1456 	{CMD36,	0x64,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP_END
                 ;    1457 	{CMD37,	0x65,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP
                 ;    1458 	{CMD38,	0x66,	STUFF_BITS,	RESP_1b},		// ERASE
                 ;    1459 	{CMD42,	0x6A,	STUFF_BITS,	RESP_1b},		// LOCK_UNLOCK
                 ;    1460 	{CMD58,	0x7A,	NO_ARG,		RESP_3},		// READ_OCR
                 ;    1461 	{CMD59,	0x7B,	STUFF_BITS,	RESP_1},		// CRC_ON_OFF
                 ;    1462 	{ACMD41, 0x69,	NO_ARG,		RESP_1}
                 ;    1463 };
                 ;    1464 
                 ;    1465 unsigned char _FF_spi(unsigned char mydata)
                 ;    1466 {
                 __FF_spi:
                 ;    1467     SPDR = mydata;          //byte 1
000603 81e8      	LD   R30,Y
000604 b9ef      	OUT  0xF,R30
                 ;    1468     while ((SPSR&0x80) == 0); 
                 _0xDC:
000605 9b77      	SBIS 0xE,7
000606 cffe      	RJMP _0xDC
                 ;    1469     return SPDR;
000607 b1ef      	IN   R30,0xF
000608 c6a5      	RJMP _0x427
                 ;    1470 }
                 ;    1471 	
                 ;    1472 unsigned int send_cmd(unsigned char command, unsigned long argument)
                 ;    1473 {
                 _send_cmd:
                 ;    1474 	unsigned char spi_data_out;
                 ;    1475 	unsigned char response_1;
                 ;    1476 	unsigned long response_2;
                 ;    1477 	unsigned int c, i;
                 ;    1478 	
                 ;    1479 	SD_CS_ON();			// select chip
000609 9724      	SBIW R28,4
00060a 940e 1f24 	CALL __SAVELOCR6
                 ;	command -> Y+14
                 ;	argument -> Y+10
                 ;	spi_data_out -> R16
                 ;	response_1 -> R17
                 ;	response_2 -> Y+6
                 ;	c -> R18,R19
                 ;	i -> R20,R21
00060c 98c4      	CBI  0x18,4
                 ;    1480 	
                 ;    1481 	spi_data_out = sd_cmd[command].tx_data;
00060d 85ae      	LDD  R26,Y+14
00060e 27bb      	CLR  R27
00060f ec60
000610 e070      	__POINTWRFN 22,23,_sd_cmd,2
000611 e0e8      	LDI  R30,LOW(8)
000612 e0f0      	LDI  R31,HIGH(8)
000613 940e 1e20 	CALL __MULW12U
000615 0fe6      	ADD  R30,R22
000616 1ff7      	ADC  R31,R23
000617 9104      	LPM  R16,Z
                 ;    1482 	_FF_spi(spi_data_out);
000618 930a      	ST   -Y,R16
000619 940e 0603 	CALL __FF_spi
                 ;    1483 	
                 ;    1484 	c = sd_cmd[command].arg;
00061b 85ae      	LDD  R26,Y+14
00061c 27bb      	CLR  R27
00061d ec62
00061e e070      	__POINTWRFN 22,23,_sd_cmd,4
00061f e0e8      	LDI  R30,LOW(8)
000620 e0f0      	LDI  R31,HIGH(8)
000621 940e 1e20 	CALL __MULW12U
000623 0fe6      	ADD  R30,R22
000624 1ff7      	ADC  R31,R23
000625 940e 1ec7 	CALL __GETW1PF
000627 019f      	MOVW R18,R30
                 ;    1485 	if (c == NO_ARG)
000628 2e02      	MOV  R0,R18
000629 2a03      	OR   R0,R19
00062a f471      	BRNE _0xDF
                 ;    1486 		for (i=0; i<4; i++)
00062b e040
00062c e050      	__GETWRN 20,21,0
                 _0xE1:
00062d 3044
00062e e0e0
00062f 075e      	__CPWRN 20,21,4
000630 f438      	BRSH _0xE2
                 ;    1487 			_FF_spi(0);
000631 e0e0      	LDI  R30,LOW(0)
000632 93ea      	ST   -Y,R30
000633 940e 0603 	CALL __FF_spi
                 ;    1488 	else
000635 5f4f
000636 4f5f      	__ADDWRN 20,21,1
000637 cff5      	RJMP _0xE1
                 _0xE2:
000638 c03c      	RJMP _0xE3
                 _0xDF:
                 ;    1489 	{
                 ;    1490 		spi_data_out = (argument & 0xFF000000) >> 24;
000639 85ea
00063a 85fb
00063b 856c
00063c 857d      	__GETD1S 10
00063d 70e0
00063e 70f0
00063f 7060
000640 7f7f      	__ANDD1N 0xFF000000
000641 01df      	MOVW R26,R30
000642 01cb      	MOVW R24,R22
000643 e1e8      	LDI  R30,LOW(24)
000644 940e 1dfc 	CALL __LSRD12
000646 2f0e      	MOV  R16,R30
                 ;    1491 		_FF_spi(spi_data_out);
000647 930a      	ST   -Y,R16
000648 940e 0603 	CALL __FF_spi
                 ;    1492 		spi_data_out = (argument & 0x00FF0000) >> 16;
00064a 85ea
00064b 85fb
00064c 856c
00064d 857d      	__GETD1S 10
00064e 70e0
00064f 70f0
000650 7f6f
000651 7070      	__ANDD1N 0xFF0000
000652 940e 1e11 	CALL __LSRD16
000654 2f0e      	MOV  R16,R30
                 ;    1493 		_FF_spi(spi_data_out);
000655 930a      	ST   -Y,R16
000656 940e 0603 	CALL __FF_spi
                 ;    1494 		spi_data_out = (argument & 0x0000FF00) >> 8;
000658 85ea
000659 85fb
00065a 856c
00065b 857d      	__GETD1S 10
00065c 70e0
00065d 7fff
00065e 7060
00065f 7070      	__ANDD1N 0xFF00
000660 01df      	MOVW R26,R30
000661 01cb      	MOVW R24,R22
000662 e0e8      	LDI  R30,LOW(8)
000663 940e 1dfc 	CALL __LSRD12
000665 2f0e      	MOV  R16,R30
                 ;    1495 		_FF_spi(spi_data_out);
000666 930a      	ST   -Y,R16
000667 940e 0603 	CALL __FF_spi
                 ;    1496 		spi_data_out = (argument & 0x000000FF);
000669 85ea
00066a 85fb
00066b 856c
00066c 857d      	__GETD1S 10
00066d 7fef
00066e 70f0
00066f 7060
000670 7070      	__ANDD1N 0xFF
000671 2f0e      	MOV  R16,R30
                 ;    1497 		_FF_spi(spi_data_out);
000672 930a      	ST   -Y,R16
000673 940e 0603 	CALL __FF_spi
                 ;    1498 	}
                 _0xE3:
                 ;    1499 	if (command == CMD0)
000675 85ee      	LDD  R30,Y+14
000676 30e0      	CPI  R30,0
000677 f411      	BRNE _0xE4
                 ;    1500 		spi_data_out = 0x95;		// CRC byte, don't care except for first signal=0x95
000678 e905      	LDI  R16,LOW(149)
                 ;    1501 	else
000679 c001      	RJMP _0xE5
                 _0xE4:
                 ;    1502 		spi_data_out = 0xFF;
00067a ef0f      	LDI  R16,LOW(255)
                 ;    1503 	_FF_spi(spi_data_out);
                 _0xE5:
00067b 930a      	ST   -Y,R16
00067c 940e 0603 	CALL __FF_spi
                 ;    1504 	_FF_spi(0xff);	
00067e efef      	LDI  R30,LOW(255)
00067f 93ea      	ST   -Y,R30
000680 940e 0603 	CALL __FF_spi
                 ;    1505 	c = sd_cmd[command].resp;
000682 85ae      	LDD  R26,Y+14
000683 27bb      	CLR  R27
000684 ec64
000685 e070      	__POINTWRFN 22,23,_sd_cmd,6
000686 e0e8      	LDI  R30,LOW(8)
000687 e0f0      	LDI  R31,HIGH(8)
000688 940e 1e20 	CALL __MULW12U
00068a 0fe6      	ADD  R30,R22
00068b 1ff7      	ADC  R31,R23
00068c 940e 1ec7 	CALL __GETW1PF
00068e 019f      	MOVW R18,R30
                 ;    1506 	switch(c)
00068f 01f9      	MOVW R30,R18
                 ;    1507 	{
                 ;    1508 		case RESP_1:
000690 9730      	SBIW R30,0
000691 f431      	BRNE _0xE9
                 ;    1509 			return (_FF_spi(0xFF));
000692 efef      	LDI  R30,LOW(255)
000693 93ea      	ST   -Y,R30
000694 940e 0603 	CALL __FF_spi
000696 e0f0      	LDI  R31,0
000697 c0e3      	RJMP _0x42C
                 ;    1510 			break;
                 ;    1511 		case RESP_1b:
                 _0xE9:
000698 30e1      	CPI  R30,LOW(0x1)
000699 e0a0      	LDI  R26,HIGH(0x1)
00069a 07fa      	CPC  R31,R26
00069b f501      	BRNE _0xEA
                 ;    1512 			response_1 = _FF_spi(0xFF);
00069c efef      	LDI  R30,LOW(255)
00069d 93ea      	ST   -Y,R30
00069e 940e 0603 	CALL __FF_spi
0006a0 2f1e      	MOV  R17,R30
                 ;    1513 			response_2 = 0;
0006a1 e0e0
0006a2 83ee
0006a3 83ef
0006a4 87e8
0006a5 87e9      	__CLRD1S 6
                 ;    1514 			while (response_2 == 0)
                 _0xEB:
0006a6 81ee
0006a7 81ff
0006a8 8568
0006a9 8579      	__GETD1S 6
0006aa 940e 1f0c 	CALL __CPD10
0006ac f461      	BRNE _0xED
                 ;    1515 				response_2 = _FF_spi(0xFF);
0006ad efef      	LDI  R30,LOW(255)
0006ae 93ea      	ST   -Y,R30
0006af 940e 0603 	CALL __FF_spi
0006b1 27ff      	CLR  R31
0006b2 2766      	CLR  R22
0006b3 2777      	CLR  R23
0006b4 83ee
0006b5 83ff
0006b6 8768
0006b7 8779      	__PUTD1S 6
                 ;    1516 			return (response_1);
0006b8 cfed      	RJMP _0xEB
                 _0xED:
0006b9 2fe1      	MOV  R30,R17
0006ba e0f0      	LDI  R31,0
0006bb c0bf      	RJMP _0x42C
                 ;    1517 			break;
                 ;    1518 		case RESP_2:
                 _0xEA:
0006bc 30e2      	CPI  R30,LOW(0x2)
0006bd e0a0      	LDI  R26,HIGH(0x2)
0006be 07fa      	CPC  R31,R26
0006bf f541      	BRNE _0xEE
                 ;    1519 			response_2 = _FF_spi(0xFF);
0006c0 efef      	LDI  R30,LOW(255)
0006c1 93ea      	ST   -Y,R30
0006c2 940e 0603 	CALL __FF_spi
0006c4 27ff      	CLR  R31
0006c5 2766      	CLR  R22
0006c6 2777      	CLR  R23
0006c7 83ee
0006c8 83ff
0006c9 8768
0006ca 8779      	__PUTD1S 6
                 ;    1520 			response_2 = (response_2 << 8) | _FF_spi(0xFF);
0006cb 81ae
0006cc 81bf
0006cd 8588
0006ce 8599      	__GETD2S 6
0006cf e0e8      	LDI  R30,LOW(8)
0006d0 940e 1df0 	CALL __LSLD12
0006d2 937f      	PUSH R23
0006d3 936f      	PUSH R22
0006d4 93ff      	PUSH R31
0006d5 93ef      	PUSH R30
0006d6 efef      	LDI  R30,LOW(255)
0006d7 93ea      	ST   -Y,R30
0006d8 940e 0603 	CALL __FF_spi
0006da 91af      	POP  R26
0006db 91bf      	POP  R27
0006dc 918f      	POP  R24
0006dd 919f      	POP  R25
0006de 27ff      	CLR  R31
0006df 2766      	CLR  R22
0006e0 2777      	CLR  R23
0006e1 940e 1dde 	CALL __ORD12
0006e3 83ee
0006e4 83ff
0006e5 8768
0006e6 8779      	__PUTD1S 6
                 ;    1521 			return (response_2);
0006e7 c093      	RJMP _0x42C
                 ;    1522 			break;
                 ;    1523 		case RESP_3:
                 _0xEE:
0006e8 30e3      	CPI  R30,LOW(0x3)
0006e9 e0a0      	LDI  R26,HIGH(0x3)
0006ea 07fa      	CPC  R31,R26
0006eb f011      	BREQ PC+3
0006ec 940c 0779 	JMP _0xE8
                 ;    1524 			response_1 = _FF_spi(0xFF);
0006ee efef      	LDI  R30,LOW(255)
0006ef 93ea      	ST   -Y,R30
0006f0 940e 0603 	CALL __FF_spi
0006f2 2f1e      	MOV  R17,R30
                 ;    1525 			OCR_REG = 0;
0006f3 e0e0      	LDI  R30,0
0006f4 93e0 098c 	STS  _OCR_REG,R30
0006f6 93e0 098d 	STS  _OCR_REG+1,R30
0006f8 93e0 098e 	STS  _OCR_REG+2,R30
0006fa 93e0 098f 	STS  _OCR_REG+3,R30
                 ;    1526 			response_2 = _FF_spi(0xFF);
0006fc efef      	LDI  R30,LOW(255)
0006fd 93ea      	ST   -Y,R30
0006fe 940e 0603 	CALL __FF_spi
000700 27ff      	CLR  R31
000701 2766      	CLR  R22
000702 2777      	CLR  R23
000703 83ee
000704 83ff
000705 8768
000706 8779      	__PUTD1S 6
                 ;    1527 			OCR_REG = response_2 << 24;
000707 81ae
000708 81bf
000709 8588
00070a 8599      	__GETD2S 6
00070b e1e8      	LDI  R30,LOW(24)
00070c 940e 1df0 	CALL __LSLD12
00070e 93e0 098c 	STS  _OCR_REG,R30
000710 93f0 098d 	STS  _OCR_REG+1,R31
000712 9360 098e 	STS  _OCR_REG+2,R22
000714 9370 098f 	STS  _OCR_REG+3,R23
                 ;    1528 			response_2 = _FF_spi(0xFF);
000716 efef      	LDI  R30,LOW(255)
000717 93ea      	ST   -Y,R30
000718 940e 0603 	CALL __FF_spi
00071a 27ff      	CLR  R31
00071b 2766      	CLR  R22
00071c 2777      	CLR  R23
00071d 83ee
00071e 83ff
00071f 8768
000720 8779      	__PUTD1S 6
                 ;    1529 			OCR_REG |= (response_2 << 16);
000721 940e 1e16 	CALL __LSLD16
000723 91a0 098c 	LDS  R26,_OCR_REG
000725 91b0 098d 	LDS  R27,_OCR_REG+1
000727 9180 098e 	LDS  R24,_OCR_REG+2
000729 9190 098f 	LDS  R25,_OCR_REG+3
00072b 940e 1dde 	CALL __ORD12
00072d 93e0 098c 	STS  _OCR_REG,R30
00072f 93f0 098d 	STS  _OCR_REG+1,R31
000731 9360 098e 	STS  _OCR_REG+2,R22
000733 9370 098f 	STS  _OCR_REG+3,R23
                 ;    1530 			response_2 = _FF_spi(0xFF);
000735 efef      	LDI  R30,LOW(255)
000736 93ea      	ST   -Y,R30
000737 940e 0603 	CALL __FF_spi
000739 27ff      	CLR  R31
00073a 2766      	CLR  R22
00073b 2777      	CLR  R23
00073c 83ee
00073d 83ff
00073e 8768
00073f 8779      	__PUTD1S 6
                 ;    1531 			OCR_REG |= (response_2 << 8);
000740 81ae
000741 81bf
000742 8588
000743 8599      	__GETD2S 6
000744 e0e8      	LDI  R30,LOW(8)
000745 940e 1df0 	CALL __LSLD12
000747 91a0 098c 	LDS  R26,_OCR_REG
000749 91b0 098d 	LDS  R27,_OCR_REG+1
00074b 9180 098e 	LDS  R24,_OCR_REG+2
00074d 9190 098f 	LDS  R25,_OCR_REG+3
00074f 940e 1dde 	CALL __ORD12
000751 93e0 098c 	STS  _OCR_REG,R30
000753 93f0 098d 	STS  _OCR_REG+1,R31
000755 9360 098e 	STS  _OCR_REG+2,R22
000757 9370 098f 	STS  _OCR_REG+3,R23
                 ;    1532 			response_2 = _FF_spi(0xFF);
000759 efef      	LDI  R30,LOW(255)
00075a 93ea      	ST   -Y,R30
00075b 940e 0603 	CALL __FF_spi
00075d 27ff      	CLR  R31
00075e 2766      	CLR  R22
00075f 2777      	CLR  R23
000760 83ee
000761 83ff
000762 8768
000763 8779      	__PUTD1S 6
                 ;    1533 			OCR_REG |= (response_2);
000764 91a0 098c 	LDS  R26,_OCR_REG
000766 91b0 098d 	LDS  R27,_OCR_REG+1
000768 9180 098e 	LDS  R24,_OCR_REG+2
00076a 9190 098f 	LDS  R25,_OCR_REG+3
00076c 940e 1dde 	CALL __ORD12
00076e 93e0 098c 	STS  _OCR_REG,R30
000770 93f0 098d 	STS  _OCR_REG+1,R31
000772 9360 098e 	STS  _OCR_REG+2,R22
000774 9370 098f 	STS  _OCR_REG+3,R23
                 ;    1534 			return (response_1);
000776 2fe1      	MOV  R30,R17
000777 e0f0      	LDI  R31,0
000778 c002      	RJMP _0x42C
                 ;    1535 			break;
                 ;    1536 	}
                 _0xE8:
                 ;    1537 	return (0);
000779 e0e0      	LDI  R30,LOW(0)
00077a e0f0      	LDI  R31,HIGH(0)
                 _0x42C:
00077b 940e 1f2b 	CALL __LOADLOCR6
00077d 962f      	ADIW R28,15
00077e 9508      	RET
                 ;    1538 }
                 ;    1539 
                 ;    1540 void clear_sd_buff(void)
                 ;    1541 {
                 _clear_sd_buff:
                 ;    1542 	SD_CS_OFF();
00077f 9ac4      	SBI  0x18,4
                 ;    1543 	_FF_spi(0xFF);
000780 efef      	LDI  R30,LOW(255)
000781 93ea      	ST   -Y,R30
000782 940e 0603 	CALL __FF_spi
                 ;    1544 	_FF_spi(0xFF);
000784 efef      	LDI  R30,LOW(255)
000785 93ea      	ST   -Y,R30
000786 940e 0603 	CALL __FF_spi
                 ;    1545 }	
000788 9508      	RET
                 ;    1546 
                 ;    1547 unsigned char initialize_media(void)
                 ;    1548 {
                 _initialize_media:
                 ;    1549 	unsigned char data_temp;
                 ;    1550 	unsigned long n;
                 ;    1551 	
                 ;    1552 	// SPI BUS SETUP
                 ;    1553 	// SPI initialization
                 ;    1554 	// SPI Type: Master
                 ;    1555 	// SPI Clock Rate: 921.600 kHz
                 ;    1556 	// SPI Clock Phase: Cycle Half
                 ;    1557 	// SPI Clock Polarity: Low
                 ;    1558 	// SPI Data Order: MSB First
                 ;    1559 	DDRB |= 0x07;		// Set SS, SCK, and MOSI to Output (If not output, processor will be a slave)
000789 9724      	SBIW R28,4
00078a 930a      	ST   -Y,R16
                 ;	data_temp -> R16
                 ;	n -> Y+1
00078b b3e7      	IN   R30,0x17
00078c 60e7      	ORI  R30,LOW(0x7)
00078d bbe7      	OUT  0x17,R30
                 ;    1560 	DDRB &= 0xF7;		// Set MISO to Input
00078e 98bb      	CBI  0x17,3
                 ;    1561 	CS_DDR_SET();		// Set CS to Output
00078f 9abc      	SBI  0x17,4
                 ;    1562 	SPCR=0x50;
000790 e5e0      	LDI  R30,LOW(80)
000791 b9ed      	OUT  0xD,R30
                 ;    1563 	SPSR=0x00;
000792 e0e0      	LDI  R30,LOW(0)
000793 b9ee      	OUT  0xE,R30
                 ;    1564 		
                 ;    1565 	BPB_BytsPerSec = 512;	// Initialize sector size to 512 (all SD cards have a 512 sector size)
000794 e0e0      	LDI  R30,LOW(512)
000795 e0f2      	LDI  R31,HIGH(512)
000796 93e0 0b96 	STS  _BPB_BytsPerSec,R30
000798 93f0 0b97 	STS  _BPB_BytsPerSec+1,R31
                 ;    1566     _FF_n_temp = 0;
00079a e0e0      	LDI  R30,0
00079b 93e0 0be7 	STS  __FF_n_temp,R30
00079d 93e0 0be8 	STS  __FF_n_temp+1,R30
00079f 93e0 0be9 	STS  __FF_n_temp+2,R30
0007a1 93e0 0bea 	STS  __FF_n_temp+3,R30
                 ;    1567 	if (reset_sd()==0)
0007a3 d347      	RCALL _reset_sd
0007a4 30e0      	CPI  R30,0
0007a5 f411      	BRNE _0xF0
                 ;    1568 		return (0);
0007a6 e0e0      	LDI  R30,LOW(0)
0007a7 c328      	RJMP _0x42B
                 ;    1569 	// delay_ms(50);
                 ;    1570 	for (n=0; ((n<100)||(data_temp==0)) ; n++)
                 _0xF0:
0007a8 e0e0
0007a9 83e9
0007aa 83ea
0007ab 83eb
0007ac 83ec      	__CLRD1S 1
                 _0xF2:
0007ad 81a9
0007ae 81ba
0007af 818b
0007b0 819c      	__GETD2S 1
0007b1 36a4
0007b2 e0e0
0007b3 07be
0007b4 e0e0
0007b5 078e
0007b6 e0e0
0007b7 079e      	__CPD2N 0x64
0007b8 f010      	BRLO _0xF4
0007b9 3000      	CPI  R16,0
0007ba f4a1      	BRNE _0xF3
                 _0xF4:
                 ;    1571 	{
                 ;    1572 		SD_CS_ON();
0007bb 98c4      	CBI  0x18,4
                 ;    1573 		data_temp = _FF_spi(0xFF);
0007bc efef      	LDI  R30,LOW(255)
0007bd 93ea      	ST   -Y,R30
0007be 940e 0603 	CALL __FF_spi
0007c0 2f0e      	MOV  R16,R30
                 ;    1574 		SD_CS_OFF();
0007c1 9ac4      	SBI  0x18,4
                 ;    1575 	}
0007c2 81e9
0007c3 81fa
0007c4 816b
0007c5 817c      	__GETD1S 1
0007c6 5fef
0007c7 4fff
0007c8 4f6f
0007c9 4f7f      	__SUBD1N -1
0007ca 83e9
0007cb 83fa
0007cc 836b
0007cd 837c      	__PUTD1S 1
0007ce cfde      	RJMP _0xF2
                 _0xF3:
                 ;    1576 	// delay_ms(50);
                 ;    1577 	for (n=0; n<100; n++)
0007cf e0e0
0007d0 83e9
0007d1 83ea
0007d2 83eb
0007d3 83ec      	__CLRD1S 1
                 _0xF7:
0007d4 81a9
0007d5 81ba
0007d6 818b
0007d7 819c      	__GETD2S 1
0007d8 36a4
0007d9 e0e0
0007da 07be
0007db e0e0
0007dc 078e
0007dd e0e0
0007de 079e      	__CPD2N 0x64
0007df f4f0      	BRSH _0xF8
                 ;    1578 	{
                 ;    1579 		if (init_sd())		// Initialization Succeeded
0007e0 d340      	RCALL _init_sd
0007e1 30e0      	CPI  R30,0
0007e2 f4d9      	BRNE _0xF8
                 ;    1580 			break;
                 ;    1581 		if (n==99)
0007e3 81a9
0007e4 81ba
0007e5 818b
0007e6 819c      	__GETD2S 1
0007e7 36a3
0007e8 e0e0
0007e9 07be
0007ea e0e0
0007eb 078e
0007ec e0e0
0007ed 079e      	__CPD2N 0x63
0007ee f411      	BRNE _0xFA
                 ;    1582 			return (0);
0007ef e0e0      	LDI  R30,LOW(0)
0007f0 c2df      	RJMP _0x42B
                 ;    1583 	}
                 _0xFA:
0007f1 81e9
0007f2 81fa
0007f3 816b
0007f4 817c      	__GETD1S 1
0007f5 5fef
0007f6 4fff
0007f7 4f6f
0007f8 4f7f      	__SUBD1N -1
0007f9 83e9
0007fa 83fa
0007fb 836b
0007fc 837c      	__PUTD1S 1
0007fd cfd6      	RJMP _0xF7
                 _0xF8:
                 ;    1584 
                 ;    1585 	if (_FF_read(0x0)==0)
0007fe e0e0
0007ff e0f0
000800 e060
000801 e070      	__GETD1N 0x0
000802 940e 1ecb 	CALL __PUTPARD1
000804 d34d      	RCALL __FF_read
000805 30e0      	CPI  R30,0
000806 f429      	BRNE _0xFB
                 ;    1586 	{
                 ;    1587 		#ifdef _DEBUG_ON_
                 ;    1588 			printf("\n\rREAD_ERR"); 		
                 ;    1589 		#endif
                 ;    1590 		_FF_error = INIT_ERR;
000807 e0e1      	LDI  R30,LOW(1)
000808 93e0 0bd3 	STS  __FF_error,R30
                 ;    1591 		return (0);
00080a e0e0      	LDI  R30,LOW(0)
00080b c2c4      	RJMP _0x42B
                 ;    1592 	}
                 ;    1593 	PT_SecStart = ((int) _FF_buff[0x1c7] << 8) | (int) _FF_buff[0x1c6];
                 _0xFB:
00080c 91b0 0b57 	__GETBRMN 27,__FF_buff,455
00080e e0a0      	LDI  R26,LOW(0)
00080f 91e0 0b56 	__GETB1MN __FF_buff,454
000811 e0f0      	LDI  R31,0
000812 2bea      	OR   R30,R26
000813 2bfb      	OR   R31,R27
000814 93e0 0b90 	STS  _PT_SecStart,R30
000816 93f0 0b91 	STS  _PT_SecStart+1,R31
                 ;    1594 	
                 ;    1595 	if ((((_FF_buff[0]==0xEB)&&(_FF_buff[2]==0x90))||(_FF_buff[0]==0xE9)) && ((_FF_buff[510]==0x55)&&(_FF_buff[511]==0xAA)))
000818 91a0 0990 	LDS  R26,__FF_buff
00081a 3eab      	CPI  R26,LOW(0xEB)
00081b f421      	BRNE _0xFD
00081c 91e0 0992 	__GETB1MN __FF_buff,2
00081e 39e0      	CPI  R30,LOW(0x90)
00081f f021      	BREQ _0xFF
                 _0xFD:
000820 91a0 0990 	LDS  R26,__FF_buff
000822 3ea9      	CPI  R26,LOW(0xE9)
000823 f451      	BRNE _0x101
                 _0xFF:
000824 91e0 0b8e 	__GETB1MN __FF_buff,510
000826 35e5      	CPI  R30,LOW(0x55)
000827 f421      	BRNE _0x102
000828 91e0 0b8f 	__GETB1MN __FF_buff,511
00082a 3aea      	CPI  R30,LOW(0xAA)
00082b f009      	BREQ _0x103
                 _0x102:
00082c c001      	RJMP _0x101
                 _0x103:
00082d c001      	RJMP _0x104
                 _0x101:
00082e c005      	RJMP _0xFC
                 _0x104:
                 ;    1596     	PT_SecStart = 0;
00082f e0e0      	LDI  R30,0
000830 93e0 0b90 	STS  _PT_SecStart,R30
000832 93e0 0b91 	STS  _PT_SecStart+1,R30
                 ;    1597  
                 ;    1598 	_FF_PART_ADDR = (long) PT_SecStart * (long) BPB_BytsPerSec;
                 _0xFC:
000834 91e0 0b90 	LDS  R30,_PT_SecStart
000836 91f0 0b91 	LDS  R31,_PT_SecStart+1
000838 2766      	CLR  R22
000839 2777      	CLR  R23
00083a 01df      	MOVW R26,R30
00083b 01cb      	MOVW R24,R22
00083c 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
00083e 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000840 2766      	CLR  R22
000841 2777      	CLR  R23
000842 940e 1e4d 	CALL __MULD12
000844 93e0 0bb5 	STS  __FF_PART_ADDR,R30
000846 93f0 0bb6 	STS  __FF_PART_ADDR+1,R31
000848 9360 0bb7 	STS  __FF_PART_ADDR+2,R22
00084a 9370 0bb8 	STS  __FF_PART_ADDR+3,R23
                 ;    1599 
                 ;    1600 	if (PT_SecStart)
00084c 91e0 0b90 	LDS  R30,_PT_SecStart
00084e 91f0 0b91 	LDS  R31,_PT_SecStart+1
000850 9730      	SBIW R30,0
000851 f091      	BREQ _0x105
                 ;    1601 	{
                 ;    1602 		if (_FF_read(_FF_PART_ADDR)==0)
000852 91e0 0bb5 	LDS  R30,__FF_PART_ADDR
000854 91f0 0bb6 	LDS  R31,__FF_PART_ADDR+1
000856 9160 0bb7 	LDS  R22,__FF_PART_ADDR+2
000858 9170 0bb8 	LDS  R23,__FF_PART_ADDR+3
00085a 940e 1ecb 	CALL __PUTPARD1
00085c d2f5      	RCALL __FF_read
00085d 30e0      	CPI  R30,0
00085e f429      	BRNE _0x106
                 ;    1603 		{
                 ;    1604 		   	#ifdef _DEBUG_ON_
                 ;    1605 				printf("\n\rREAD_ERR");
                 ;    1606 			#endif
                 ;    1607 			_FF_error = INIT_ERR;
00085f e0e1      	LDI  R30,LOW(1)
000860 93e0 0bd3 	STS  __FF_error,R30
                 ;    1608 			return (0);
000862 e0e0      	LDI  R30,LOW(0)
000863 c26c      	RJMP _0x42B
                 ;    1609 		}
                 ;    1610 	}
                 _0x106:
                 ;    1611 
                 ;    1612  	#ifdef _DEBUG_ON_
                 ;    1613 		printf("\n\rBoot_Sec: [0x%X %X %X] [0x%X] [0x%X]", _FF_buff[0],_FF_buff[1],_FF_buff[2],_FF_buff[510],_FF_buff[511]); 		
                 ;    1614 	#endif
                 ;    1615    	
                 ;    1616     BS_jmpBoot = (((long) _FF_buff[0] << 16) | ((int) _FF_buff[1] << 8) | (int) _FF_buff[2]);    		
                 _0x105:
000864 91e0 0990 	LDS  R30,__FF_buff
000866 27ff      	CLR  R31
000867 2766      	CLR  R22
000868 2777      	CLR  R23
000869 940e 1e16 	CALL __LSLD16
00086b 01df      	MOVW R26,R30
00086c 01cb      	MOVW R24,R22
00086d 91f0 0991 	__GETBRMN 31,__FF_buff,1
00086f e0e0      	LDI  R30,LOW(0)
000870 940e 1e1b 	CALL __CWD1
000872 940e 1dde 	CALL __ORD12
000874 01df      	MOVW R26,R30
000875 01cb      	MOVW R24,R22
000876 91e0 0992 	__GETB1MN __FF_buff,2
000878 e0f0      	LDI  R31,0
000879 940e 1e1b 	CALL __CWD1
00087b 940e 1dde 	CALL __ORD12
00087d 93e0 0b92 	STS  _BS_jmpBoot,R30
00087f 93f0 0b93 	STS  _BS_jmpBoot+1,R31
000881 9360 0b94 	STS  _BS_jmpBoot+2,R22
000883 9370 0b95 	STS  _BS_jmpBoot+3,R23
                 ;    1617 	BPB_BytsPerSec = ((int) _FF_buff[0xC] << 8) | (int) _FF_buff[0xB];
000885 91b0 099c 	__GETBRMN 27,__FF_buff,12
000887 e0a0      	LDI  R26,LOW(0)
000888 91e0 099b 	__GETB1MN __FF_buff,11
00088a e0f0      	LDI  R31,0
00088b 2bea      	OR   R30,R26
00088c 2bfb      	OR   R31,R27
00088d 93e0 0b96 	STS  _BPB_BytsPerSec,R30
00088f 93f0 0b97 	STS  _BPB_BytsPerSec+1,R31
                 ;    1618     BPB_SecPerClus = _FF_buff[0xD];
000891 91e0 099d 	__GETB1MN __FF_buff,13
000893 93e0 0b98 	STS  _BPB_SecPerClus,R30
                 ;    1619 	BPB_RsvdSecCnt = ((int) _FF_buff[0xF] << 8) | (int) _FF_buff[0xE];	
000895 91b0 099f 	__GETBRMN 27,__FF_buff,15
000897 e0a0      	LDI  R26,LOW(0)
000898 91e0 099e 	__GETB1MN __FF_buff,14
00089a e0f0      	LDI  R31,0
00089b 2bea      	OR   R30,R26
00089c 2bfb      	OR   R31,R27
00089d 93e0 0b99 	STS  _BPB_RsvdSecCnt,R30
00089f 93f0 0b9a 	STS  _BPB_RsvdSecCnt+1,R31
                 ;    1620 	BPB_NumFATs = _FF_buff[0x10];
0008a1 91e0 09a0 	__GETB1MN __FF_buff,16
0008a3 93e0 0b9b 	STS  _BPB_NumFATs,R30
                 ;    1621 	BPB_RootEntCnt = ((int) _FF_buff[0x12] << 8) | (int) _FF_buff[0x11];	
0008a5 91b0 09a2 	__GETBRMN 27,__FF_buff,18
0008a7 e0a0      	LDI  R26,LOW(0)
0008a8 91e0 09a1 	__GETB1MN __FF_buff,17
0008aa e0f0      	LDI  R31,0
0008ab 2bea      	OR   R30,R26
0008ac 2bfb      	OR   R31,R27
0008ad 93e0 0b9c 	STS  _BPB_RootEntCnt,R30
0008af 93f0 0b9d 	STS  _BPB_RootEntCnt+1,R31
                 ;    1622 	BPB_FATSz16 = ((int) _FF_buff[0x17] << 8) | (int) _FF_buff[0x16];
0008b1 91b0 09a7 	__GETBRMN 27,__FF_buff,23
0008b3 e0a0      	LDI  R26,LOW(0)
0008b4 91e0 09a6 	__GETB1MN __FF_buff,22
0008b6 e0f0      	LDI  R31,0
0008b7 2bea      	OR   R30,R26
0008b8 2bfb      	OR   R31,R27
0008b9 93e0 0b9e 	STS  _BPB_FATSz16,R30
0008bb 93f0 0b9f 	STS  _BPB_FATSz16+1,R31
                 ;    1623 	BPB_TotSec = ((unsigned int) _FF_buff[0x14] << 8) | (unsigned int) _FF_buff[0x13];
0008bd 91b0 09a4 	__GETBRMN 27,__FF_buff,20
0008bf e0a0      	LDI  R26,LOW(0)
0008c0 91e0 09a3 	__GETB1MN __FF_buff,19
0008c2 e0f0      	LDI  R31,0
0008c3 2bea      	OR   R30,R26
0008c4 2bfb      	OR   R31,R27
0008c5 2766      	CLR  R22
0008c6 2777      	CLR  R23
0008c7 93e0 0ba1 	STS  _BPB_TotSec,R30
0008c9 93f0 0ba2 	STS  _BPB_TotSec+1,R31
0008cb 9360 0ba3 	STS  _BPB_TotSec+2,R22
0008cd 9370 0ba4 	STS  _BPB_TotSec+3,R23
                 ;    1624 	if (BPB_TotSec==0)
0008cf 940e 1f0c 	CALL __CPD10
0008d1 f5d1      	BRNE _0x107
                 ;    1625 		BPB_TotSec = ((unsigned long) _FF_buff[0x23] << 24) | ((unsigned long) _FF_buff[0x22] << 16)
                 ;    1626 					| ((unsigned long) _FF_buff[0x21] << 8) | ((unsigned long) _FF_buff[0x20]);
0008d2 91e0 09b3 	__GETB1MN __FF_buff,35
0008d4 27ff      	CLR  R31
0008d5 2766      	CLR  R22
0008d6 2777      	CLR  R23
0008d7 01df      	MOVW R26,R30
0008d8 01cb      	MOVW R24,R22
0008d9 e1e8      	LDI  R30,LOW(24)
0008da 940e 1df0 	CALL __LSLD12
0008dc 01df      	MOVW R26,R30
0008dd 01cb      	MOVW R24,R22
0008de 91e0 09b2 	__GETB1MN __FF_buff,34
0008e0 27ff      	CLR  R31
0008e1 2766      	CLR  R22
0008e2 2777      	CLR  R23
0008e3 940e 1e16 	CALL __LSLD16
0008e5 940e 1dde 	CALL __ORD12
0008e7 937f      	PUSH R23
0008e8 936f      	PUSH R22
0008e9 93ff      	PUSH R31
0008ea 93ef      	PUSH R30
0008eb 91e0 09b1 	__GETB1MN __FF_buff,33
0008ed 27ff      	CLR  R31
0008ee 2766      	CLR  R22
0008ef 2777      	CLR  R23
0008f0 01df      	MOVW R26,R30
0008f1 01cb      	MOVW R24,R22
0008f2 e0e8      	LDI  R30,LOW(8)
0008f3 940e 1df0 	CALL __LSLD12
0008f5 91af      	POP  R26
0008f6 91bf      	POP  R27
0008f7 918f      	POP  R24
0008f8 919f      	POP  R25
0008f9 940e 1dde 	CALL __ORD12
0008fb 01df      	MOVW R26,R30
0008fc 01cb      	MOVW R24,R22
0008fd 91e0 09b0 	__GETB1MN __FF_buff,32
0008ff 27ff      	CLR  R31
000900 2766      	CLR  R22
000901 2777      	CLR  R23
000902 940e 1dde 	CALL __ORD12
000904 93e0 0ba1 	STS  _BPB_TotSec,R30
000906 93f0 0ba2 	STS  _BPB_TotSec+1,R31
000908 9360 0ba3 	STS  _BPB_TotSec+2,R22
00090a 9370 0ba4 	STS  _BPB_TotSec+3,R23
                 ;    1627 	BS_VolSerial = ((unsigned long) _FF_buff[0x2A] << 24) | ((unsigned long) _FF_buff[0x29] << 16)
                 _0x107:
                 ;    1628 				| ((unsigned long) _FF_buff[0x28] << 8) | ((unsigned long) _FF_buff[0x27]);
00090c 91e0 09ba 	__GETB1MN __FF_buff,42
00090e 27ff      	CLR  R31
00090f 2766      	CLR  R22
000910 2777      	CLR  R23
000911 01df      	MOVW R26,R30
000912 01cb      	MOVW R24,R22
000913 e1e8      	LDI  R30,LOW(24)
000914 940e 1df0 	CALL __LSLD12
000916 01df      	MOVW R26,R30
000917 01cb      	MOVW R24,R22
000918 91e0 09b9 	__GETB1MN __FF_buff,41
00091a 27ff      	CLR  R31
00091b 2766      	CLR  R22
00091c 2777      	CLR  R23
00091d 940e 1e16 	CALL __LSLD16
00091f 940e 1dde 	CALL __ORD12
000921 937f      	PUSH R23
000922 936f      	PUSH R22
000923 93ff      	PUSH R31
000924 93ef      	PUSH R30
000925 91e0 09b8 	__GETB1MN __FF_buff,40
000927 27ff      	CLR  R31
000928 2766      	CLR  R22
000929 2777      	CLR  R23
00092a 01df      	MOVW R26,R30
00092b 01cb      	MOVW R24,R22
00092c e0e8      	LDI  R30,LOW(8)
00092d 940e 1df0 	CALL __LSLD12
00092f 91af      	POP  R26
000930 91bf      	POP  R27
000931 918f      	POP  R24
000932 919f      	POP  R25
000933 940e 1dde 	CALL __ORD12
000935 01df      	MOVW R26,R30
000936 01cb      	MOVW R24,R22
000937 91e0 09b7 	__GETB1MN __FF_buff,39
000939 27ff      	CLR  R31
00093a 2766      	CLR  R22
00093b 2777      	CLR  R23
00093c 940e 1dde 	CALL __ORD12
00093e 93e0 0ba5 	STS  _BS_VolSerial,R30
000940 93f0 0ba6 	STS  _BS_VolSerial+1,R31
000942 9360 0ba7 	STS  _BS_VolSerial+2,R22
000944 9370 0ba8 	STS  _BS_VolSerial+3,R23
                 ;    1629 	for (n=0; n<11; n++)
000946 e0e0
000947 83e9
000948 83ea
000949 83eb
00094a 83ec      	__CLRD1S 1
                 _0x109:
00094b 81a9
00094c 81ba
00094d 818b
00094e 819c      	__GETD2S 1
00094f 30ab
000950 e0e0
000951 07be
000952 e0e0
000953 078e
000954 e0e0
000955 079e      	__CPD2N 0xB
000956 f500      	BRSH _0x10A
                 ;    1630 		BS_VolLab[n] = _FF_buff[0x2B+n];
000957 81e9
000958 81fa
000959 816b
00095a 817c      	__GETD1S 1
00095b 55e7      	SUBI R30,LOW(-_BS_VolLab)
00095c 4ff4      	SBCI R31,HIGH(-_BS_VolLab)
00095d 01df      	MOVW R26,R30
00095e 81e9
00095f 81fa
000960 816b
000961 817c      	__GETD1S 1
000962 5de5
000963 4fff
000964 4f6f
000965 4f7f      	__ADDD1N 43
000966 57e0      	SUBI R30,LOW(-__FF_buff)
000967 4ff6      	SBCI R31,HIGH(-__FF_buff)
000968 81e0      	LD   R30,Z
000969 93ec      	ST   X,R30
                 ;    1631 	BS_VolLab[11] = 0;		// Terminate the string
00096a 81e9
00096b 81fa
00096c 816b
00096d 817c      	__GETD1S 1
00096e 5fef
00096f 4fff
000970 4f6f
000971 4f7f      	__SUBD1N -1
000972 83e9
000973 83fa
000974 836b
000975 837c      	__PUTD1S 1
000976 cfd4      	RJMP _0x109
                 _0x10A:
000977 e0e0      	LDI  R30,LOW(0)
000978 93e0 0bb4 	__PUTB1MN _BS_VolLab,11
                 ;    1632 	_FF_FAT1_ADDR = _FF_PART_ADDR + ((long) BPB_RsvdSecCnt * (long) BPB_BytsPerSec); 
00097a 91e0 0b99 	LDS  R30,_BPB_RsvdSecCnt
00097c 91f0 0b9a 	LDS  R31,_BPB_RsvdSecCnt+1
00097e 2766      	CLR  R22
00097f 2777      	CLR  R23
000980 01df      	MOVW R26,R30
000981 01cb      	MOVW R24,R22
000982 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000984 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000986 2766      	CLR  R22
000987 2777      	CLR  R23
000988 940e 1e4d 	CALL __MULD12
00098a 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
00098c 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
00098e 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
000990 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
000992 940e 1dca 	CALL __ADDD12
000994 93e0 0bc1 	STS  __FF_FAT1_ADDR,R30
000996 93f0 0bc2 	STS  __FF_FAT1_ADDR+1,R31
000998 9360 0bc3 	STS  __FF_FAT1_ADDR+2,R22
00099a 9370 0bc4 	STS  __FF_FAT1_ADDR+3,R23
                 ;    1633 	_FF_FAT2_ADDR = _FF_FAT1_ADDR + ((long) BPB_FATSz16 * (long) BPB_BytsPerSec);
00099c 91e0 0b9e 	LDS  R30,_BPB_FATSz16
00099e 91f0 0b9f 	LDS  R31,_BPB_FATSz16+1
0009a0 2766      	CLR  R22
0009a1 2777      	CLR  R23
0009a2 01df      	MOVW R26,R30
0009a3 01cb      	MOVW R24,R22
0009a4 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0009a6 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0009a8 2766      	CLR  R22
0009a9 2777      	CLR  R23
0009aa 940e 1e4d 	CALL __MULD12
0009ac 91a0 0bc1 	LDS  R26,__FF_FAT1_ADDR
0009ae 91b0 0bc2 	LDS  R27,__FF_FAT1_ADDR+1
0009b0 9180 0bc3 	LDS  R24,__FF_FAT1_ADDR+2
0009b2 9190 0bc4 	LDS  R25,__FF_FAT1_ADDR+3
0009b4 940e 1dca 	CALL __ADDD12
0009b6 93e0 0bc5 	STS  __FF_FAT2_ADDR,R30
0009b8 93f0 0bc6 	STS  __FF_FAT2_ADDR+1,R31
0009ba 9360 0bc7 	STS  __FF_FAT2_ADDR+2,R22
0009bc 9370 0bc8 	STS  __FF_FAT2_ADDR+3,R23
                 ;    1634 	_FF_ROOT_ADDR = ((long) BPB_NumFATs * (long) BPB_FATSz16) + (long) BPB_RsvdSecCnt;
0009be 91e0 0b9b 	LDS  R30,_BPB_NumFATs
0009c0 27ff      	CLR  R31
0009c1 2766      	CLR  R22
0009c2 2777      	CLR  R23
0009c3 01df      	MOVW R26,R30
0009c4 01cb      	MOVW R24,R22
0009c5 91e0 0b9e 	LDS  R30,_BPB_FATSz16
0009c7 91f0 0b9f 	LDS  R31,_BPB_FATSz16+1
0009c9 2766      	CLR  R22
0009ca 2777      	CLR  R23
0009cb 940e 1e4d 	CALL __MULD12
0009cd 01df      	MOVW R26,R30
0009ce 01cb      	MOVW R24,R22
0009cf 91e0 0b99 	LDS  R30,_BPB_RsvdSecCnt
0009d1 91f0 0b9a 	LDS  R31,_BPB_RsvdSecCnt+1
0009d3 2766      	CLR  R22
0009d4 2777      	CLR  R23
0009d5 940e 1dca 	CALL __ADDD12
0009d7 93e0 0bb9 	STS  __FF_ROOT_ADDR,R30
0009d9 93f0 0bba 	STS  __FF_ROOT_ADDR+1,R31
0009db 9360 0bbb 	STS  __FF_ROOT_ADDR+2,R22
0009dd 9370 0bbc 	STS  __FF_ROOT_ADDR+3,R23
                 ;    1635 	_FF_ROOT_ADDR *= BPB_BytsPerSec;
0009df 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0009e1 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0009e3 91a0 0bb9 	LDS  R26,__FF_ROOT_ADDR
0009e5 91b0 0bba 	LDS  R27,__FF_ROOT_ADDR+1
0009e7 9180 0bbb 	LDS  R24,__FF_ROOT_ADDR+2
0009e9 9190 0bbc 	LDS  R25,__FF_ROOT_ADDR+3
0009eb 2766      	CLR  R22
0009ec 2777      	CLR  R23
0009ed 940e 1e28 	CALL __MULD12U
0009ef 93e0 0bb9 	STS  __FF_ROOT_ADDR,R30
0009f1 93f0 0bba 	STS  __FF_ROOT_ADDR+1,R31
0009f3 9360 0bbb 	STS  __FF_ROOT_ADDR+2,R22
0009f5 9370 0bbc 	STS  __FF_ROOT_ADDR+3,R23
                 ;    1636 	_FF_ROOT_ADDR += _FF_PART_ADDR;
0009f7 91e0 0bb5 	LDS  R30,__FF_PART_ADDR
0009f9 91f0 0bb6 	LDS  R31,__FF_PART_ADDR+1
0009fb 9160 0bb7 	LDS  R22,__FF_PART_ADDR+2
0009fd 9170 0bb8 	LDS  R23,__FF_PART_ADDR+3
0009ff 91a0 0bb9 	LDS  R26,__FF_ROOT_ADDR
000a01 91b0 0bba 	LDS  R27,__FF_ROOT_ADDR+1
000a03 9180 0bbb 	LDS  R24,__FF_ROOT_ADDR+2
000a05 9190 0bbc 	LDS  R25,__FF_ROOT_ADDR+3
000a07 940e 1dca 	CALL __ADDD12
000a09 93e0 0bb9 	STS  __FF_ROOT_ADDR,R30
000a0b 93f0 0bba 	STS  __FF_ROOT_ADDR+1,R31
000a0d 9360 0bbb 	STS  __FF_ROOT_ADDR+2,R22
000a0f 9370 0bbc 	STS  __FF_ROOT_ADDR+3,R23
                 ;    1637 	
                 ;    1638 	_FF_RootDirSectors = ((BPB_RootEntCnt * 32) + BPB_BytsPerSec - 1) / BPB_BytsPerSec;
000a11 91e0 0b9c 	LDS  R30,_BPB_RootEntCnt
000a13 91f0 0b9d 	LDS  R31,_BPB_RootEntCnt+1
000a15 0fee      	LSL  R30
000a16 1fff      	ROL  R31
000a17 940e 1e08 	CALL __LSLW4
000a19 91a0 0b96 	LDS  R26,_BPB_BytsPerSec
000a1b 91b0 0b97 	LDS  R27,_BPB_BytsPerSec+1
000a1d 0fae      	ADD  R26,R30
000a1e 1fbf      	ADC  R27,R31
000a1f 9711      	SBIW R26,1
000a20 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000a22 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000a24 940e 1e52 	CALL __DIVW21U
000a26 2766      	CLR  R22
000a27 2777      	CLR  R23
000a28 93e0 0bc9 	STS  __FF_RootDirSectors,R30
000a2a 93f0 0bca 	STS  __FF_RootDirSectors+1,R31
000a2c 9360 0bcb 	STS  __FF_RootDirSectors+2,R22
000a2e 9370 0bcc 	STS  __FF_RootDirSectors+3,R23
                 ;    1639 	FirstDataSector = (BPB_NumFATs * BPB_FATSz16) + BPB_RsvdSecCnt + _FF_RootDirSectors; 
000a30 91e0 0b9e 	LDS  R30,_BPB_FATSz16
000a32 91f0 0b9f 	LDS  R31,_BPB_FATSz16+1
000a34 91a0 0b9b 	LDS  R26,_BPB_NumFATs
000a36 e0b0      	LDI  R27,0
000a37 940e 1e20 	CALL __MULW12U
000a39 91a0 0b99 	LDS  R26,_BPB_RsvdSecCnt
000a3b 91b0 0b9a 	LDS  R27,_BPB_RsvdSecCnt+1
000a3d 0fae      	ADD  R26,R30
000a3e 1fbf      	ADC  R27,R31
000a3f 91e0 0bc9 	LDS  R30,__FF_RootDirSectors
000a41 91f0 0bca 	LDS  R31,__FF_RootDirSectors+1
000a43 9160 0bcb 	LDS  R22,__FF_RootDirSectors+2
000a45 9170 0bcc 	LDS  R23,__FF_RootDirSectors+3
000a47 2788      	CLR  R24
000a48 2799      	CLR  R25
000a49 940e 1dca 	CALL __ADDD12
000a4b 93e0 0bcd 	STS  _FirstDataSector,R30
000a4d 93f0 0bce 	STS  _FirstDataSector+1,R31
                 ;    1640 	
                 ;    1641 	DataClusTot = BPB_TotSec - FirstDataSector;
000a4f 91a0 0ba1 	LDS  R26,_BPB_TotSec
000a51 91b0 0ba2 	LDS  R27,_BPB_TotSec+1
000a53 9180 0ba3 	LDS  R24,_BPB_TotSec+2
000a55 9190 0ba4 	LDS  R25,_BPB_TotSec+3
000a57 2766      	CLR  R22
000a58 2777      	CLR  R23
000a59 940e 1dd9 	CALL __SUBD21
000a5b 93a0 0bd8 	STS  _DataClusTot,R26
000a5d 93b0 0bd9 	STS  _DataClusTot+1,R27
000a5f 9380 0bda 	STS  _DataClusTot+2,R24
000a61 9390 0bdb 	STS  _DataClusTot+3,R25
                 ;    1642 	DataClusTot /= BPB_SecPerClus;
000a63 91e0 0b98 	LDS  R30,_BPB_SecPerClus
000a65 91a0 0bd8 	LDS  R26,_DataClusTot
000a67 91b0 0bd9 	LDS  R27,_DataClusTot+1
000a69 9180 0bda 	LDS  R24,_DataClusTot+2
000a6b 9190 0bdb 	LDS  R25,_DataClusTot+3
000a6d 27ff      	CLR  R31
000a6e 2766      	CLR  R22
000a6f 2777      	CLR  R23
000a70 940e 1e65 	CALL __DIVD21U
000a72 93e0 0bd8 	STS  _DataClusTot,R30
000a74 93f0 0bd9 	STS  _DataClusTot+1,R31
000a76 9360 0bda 	STS  _DataClusTot+2,R22
000a78 9370 0bdb 	STS  _DataClusTot+3,R23
                 ;    1643 	clus_0_addr = 0;		// Reset Empty Cluster table location
000a7a e0e0      	LDI  R30,0
000a7b 93e0 0be3 	STS  _clus_0_addr,R30
000a7d 93e0 0be4 	STS  _clus_0_addr+1,R30
000a7f 93e0 0be5 	STS  _clus_0_addr+2,R30
000a81 93e0 0be6 	STS  _clus_0_addr+3,R30
                 ;    1644 	c_counter = 1;
000a83 e0e1      	LDI  R30,LOW(1)
000a84 e0f0      	LDI  R31,HIGH(1)
000a85 93e0 0beb 	STS  _c_counter,R30
000a87 93f0 0bec 	STS  _c_counter+1,R31
                 ;    1645 	
                 ;    1646 	if (DataClusTot < 4085)				// FAT12
000a89 91a0 0bd8 	LDS  R26,_DataClusTot
000a8b 91b0 0bd9 	LDS  R27,_DataClusTot+1
000a8d 9180 0bda 	LDS  R24,_DataClusTot+2
000a8f 9190 0bdb 	LDS  R25,_DataClusTot+3
000a91 3fa5
000a92 e0ef
000a93 07be
000a94 e0e0
000a95 078e
000a96 e0e0
000a97 079e      	__CPD2N 0xFF5
000a98 f420      	BRSH _0x10B
                 ;    1647 		BPB_FATType = 0x32;
000a99 e3e2      	LDI  R30,LOW(50)
000a9a 93e0 0ba0 	STS  _BPB_FATType,R30
                 ;    1648 	else if (DataClusTot < 65525)		// FAT16
000a9c c01c      	RJMP _0x10C
                 _0x10B:
000a9d 91a0 0bd8 	LDS  R26,_DataClusTot
000a9f 91b0 0bd9 	LDS  R27,_DataClusTot+1
000aa1 9180 0bda 	LDS  R24,_DataClusTot+2
000aa3 9190 0bdb 	LDS  R25,_DataClusTot+3
000aa5 3fa5
000aa6 efef
000aa7 07be
000aa8 e0e0
000aa9 078e
000aaa e0e0
000aab 079e      	__CPD2N 0xFFF5
000aac f420      	BRSH _0x10D
                 ;    1649 		BPB_FATType = 0x36;
000aad e3e6      	LDI  R30,LOW(54)
000aae 93e0 0ba0 	STS  _BPB_FATType,R30
                 ;    1650 	else
000ab0 c008      	RJMP _0x10E
                 _0x10D:
                 ;    1651 	{
                 ;    1652 		BPB_FATType = 0;
000ab1 e0e0      	LDI  R30,LOW(0)
000ab2 93e0 0ba0 	STS  _BPB_FATType,R30
                 ;    1653 		_FF_error = FAT_ERR;
000ab4 e0ec      	LDI  R30,LOW(12)
000ab5 93e0 0bd3 	STS  __FF_error,R30
                 ;    1654 		return (0);
000ab7 e0e0      	LDI  R30,LOW(0)
000ab8 c017      	RJMP _0x42B
                 ;    1655 	}
                 _0x10E:
                 _0x10C:
                 ;    1656     
                 ;    1657 	_FF_DIR_ADDR = _FF_ROOT_ADDR;		// Set current directory to root address
000ab9 91e0 0bb9 	LDS  R30,__FF_ROOT_ADDR
000abb 91f0 0bba 	LDS  R31,__FF_ROOT_ADDR+1
000abd 9160 0bbb 	LDS  R22,__FF_ROOT_ADDR+2
000abf 9170 0bbc 	LDS  R23,__FF_ROOT_ADDR+3
000ac1 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
000ac3 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
000ac5 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
000ac7 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    1658 
                 ;    1659 	_FF_FULL_PATH[0] = 0x5C;	// a '\'
000ac9 e5ec      	LDI  R30,LOW(92)
000aca 93e0 0bed 	STS  __FF_FULL_PATH,R30
                 ;    1660 	_FF_FULL_PATH[1] = 0;
000acc e0e0      	LDI  R30,LOW(0)
000acd 93e0 0bee 	__PUTB1MN __FF_FULL_PATH,1
                 ;    1661 	
                 ;    1662 	#ifdef _DEBUG_ON_
                 ;    1663 		printf("\n\rPart Address:  %lX", _FF_PART_ADDR);
                 ;    1664 		printf("\n\rBS_jmpBoot:  %lX", BS_jmpBoot);
                 ;    1665 		printf("\n\rBPB_BytsPerSec:  %X", BPB_BytsPerSec);
                 ;    1666 		printf("\n\rBPB_SecPerClus:  %X", BPB_SecPerClus);
                 ;    1667 		printf("\n\rBPB_RsvdSecCnt:  %X", BPB_RsvdSecCnt);
                 ;    1668 		printf("\n\rBPB_NumFATs:  %X", BPB_NumFATs);
                 ;    1669 		printf("\n\rBPB_RootEntCnt:  %X", BPB_RootEntCnt);
                 ;    1670 		printf("\n\rBPB_FATSz16:  %X", BPB_FATSz16);
                 ;    1671 		printf("\n\rBPB_TotSec16:  %lX", BPB_TotSec);
                 ;    1672 		if (BPB_FATType == 0x32)
                 ;    1673 			printf("\n\rBPB_FATType:  FAT12");
                 ;    1674 		else if (BPB_FATType == 0x36)
                 ;    1675 			printf("\n\rBPB_FATType:  FAT16");
                 ;    1676 		else
                 ;    1677 			printf("\n\rBPB_FATType:  FAT ERROR!!");
                 ;    1678 		printf("\n\rClusterCnt:  %lX", DataClusTot);
                 ;    1679 		printf("\n\rROOT_ADDR:  %lX", _FF_ROOT_ADDR);
                 ;    1680 		printf("\n\rFAT2_ADDR:  %lX", _FF_FAT2_ADDR);
                 ;    1681 		printf("\n\rRootDirSectors:  %X", _FF_RootDirSectors);
                 ;    1682 		printf("\n\rFirstDataSector:  %X", FirstDataSector);
                 ;    1683 	#endif
                 ;    1684 	
                 ;    1685 	return (1);	
000acf e0e1      	LDI  R30,LOW(1)
                 _0x42B:
000ad0 8108      	LDD  R16,Y+0
000ad1 9625      	ADIW R28,5
000ad2 9508      	RET
                 ;    1686 }
                 ;    1687 
                 ;    1688 unsigned char spi_speedset(void)
                 ;    1689 {
                 _spi_speedset:
                 ;    1690 	if (SPCR == 0x50)
000ad3 b1ed      	IN   R30,0xD
000ad4 35e0      	CPI  R30,LOW(0x50)
000ad5 f419      	BRNE _0x10F
                 ;    1691 		SPCR = 0x51;
000ad6 e5e1      	LDI  R30,LOW(81)
000ad7 b9ed      	OUT  0xD,R30
                 ;    1692 	else if (SPCR == 0x51)
000ad8 c010      	RJMP _0x110
                 _0x10F:
000ad9 b1ed      	IN   R30,0xD
000ada 35e1      	CPI  R30,LOW(0x51)
000adb f419      	BRNE _0x111
                 ;    1693 		SPCR = 0x52;
000adc e5e2      	LDI  R30,LOW(82)
000add b9ed      	OUT  0xD,R30
                 ;    1694 	else if (SPCR == 0x52)
000ade c00a      	RJMP _0x112
                 _0x111:
000adf b1ed      	IN   R30,0xD
000ae0 35e2      	CPI  R30,LOW(0x52)
000ae1 f419      	BRNE _0x113
                 ;    1695 		SPCR = 0x53;
000ae2 e5e3      	LDI  R30,LOW(83)
000ae3 b9ed      	OUT  0xD,R30
                 ;    1696 	else
000ae4 c004      	RJMP _0x114
                 _0x113:
                 ;    1697 	{
                 ;    1698 		SPCR = 0x50;
000ae5 e5e0      	LDI  R30,LOW(80)
000ae6 b9ed      	OUT  0xD,R30
                 ;    1699 		return (0);
000ae7 e0e0      	LDI  R30,LOW(0)
000ae8 9508      	RET
                 ;    1700 	}
                 _0x114:
                 _0x112:
                 _0x110:
                 ;    1701 	return (1);
000ae9 e0e1      	LDI  R30,LOW(1)
000aea 9508      	RET
                 ;    1702 }
                 ;    1703 
                 ;    1704 unsigned char reset_sd(void)
                 ;    1705 {
                 _reset_sd:
                 ;    1706 	unsigned char resp, n, c;
                 ;    1707 
                 ;    1708 	#ifdef _DEBUG_ON_
                 ;    1709 		printf("\n\rReset CMD:  ");	
                 ;    1710 	#endif
                 ;    1711 
                 ;    1712 	for (c=0; c<4; c++)		// try reset command 3 times if needed
000aeb 940e 1f27 	CALL __SAVELOCR3
                 ;	resp -> R16
                 ;	n -> R17
                 ;	c -> R18
000aed e020      	LDI  R18,LOW(0)
                 _0x116:
000aee 3024      	CPI  R18,4
000aef f578      	BRSH _0x117
                 ;    1713 	{
                 ;    1714 		SD_CS_OFF();
000af0 9ac4      	SBI  0x18,4
                 ;    1715 		for (n=0; n<10; n++)	// initialize clk signal to sync card
000af1 e010      	LDI  R17,LOW(0)
                 _0x119:
000af2 301a      	CPI  R17,10
000af3 f430      	BRSH _0x11A
                 ;    1716 			_FF_spi(0xFF);
000af4 efef      	LDI  R30,LOW(255)
000af5 93ea      	ST   -Y,R30
000af6 940e 0603 	CALL __FF_spi
                 ;    1717 		resp = send_cmd(CMD0,0);
000af8 5f1f      	SUBI R17,-1
000af9 cff8      	RJMP _0x119
                 _0x11A:
000afa e0e0      	LDI  R30,LOW(0)
000afb 93ea      	ST   -Y,R30
000afc e0e0
000afd e0f0
000afe e060
000aff e070      	__GETD1N 0x0
000b00 940e 1ecb 	CALL __PUTPARD1
000b02 940e 0609 	CALL _send_cmd
000b04 2f0e      	MOV  R16,R30
                 ;    1718 		for (n=0; n<200; n++)
000b05 e010      	LDI  R17,LOW(0)
                 _0x11C:
000b06 3c18      	CPI  R17,200
000b07 f470      	BRSH _0x11D
                 ;    1719 		{
                 ;    1720 			if (resp == 0x1)
000b08 3001      	CPI  R16,1
000b09 f429      	BRNE _0x11E
                 ;    1721 			{
                 ;    1722 				SD_CS_OFF();
000b0a 9ac4      	SBI  0x18,4
                 ;    1723     			#ifdef _DEBUG_ON_
                 ;    1724 					printf("OK!!!");
                 ;    1725 				#endif
                 ;    1726 				SPCR = 0x50;
000b0b e5e0      	LDI  R30,LOW(80)
000b0c b9ed      	OUT  0xD,R30
                 ;    1727 				return(1);
000b0d e0e1      	LDI  R30,LOW(1)
000b0e c03f      	RJMP _0x42A
                 ;    1728 			}
                 ;    1729 	      	resp = _FF_spi(0xFF);
                 _0x11E:
000b0f efef      	LDI  R30,LOW(255)
000b10 93ea      	ST   -Y,R30
000b11 940e 0603 	CALL __FF_spi
000b13 2f0e      	MOV  R16,R30
                 ;    1730 		}
000b14 5f1f      	SUBI R17,-1
000b15 cff0      	RJMP _0x11C
                 _0x11D:
                 ;    1731 		#ifdef _DEBUG_ON_
                 ;    1732 			printf("ERROR!!!");
                 ;    1733 		#endif
                 ;    1734  		if (spi_speedset()==0)
000b16 940e 0ad3 	CALL _spi_speedset
000b18 30e0      	CPI  R30,0
000b19 f419      	BRNE _0x11F
                 ;    1735  		{
                 ;    1736 		    SD_CS_OFF();
000b1a 9ac4      	SBI  0x18,4
                 ;    1737  			return (0);
000b1b e0e0      	LDI  R30,LOW(0)
000b1c c031      	RJMP _0x42A
                 ;    1738  		}
                 ;    1739 	}
                 _0x11F:
000b1d 5f2f      	SUBI R18,-1
000b1e cfcf      	RJMP _0x116
                 _0x117:
                 ;    1740 	return (0);
000b1f e0e0      	LDI  R30,LOW(0)
000b20 c02d      	RJMP _0x42A
                 ;    1741 }
                 ;    1742 
                 ;    1743 unsigned char init_sd(void)
                 ;    1744 {
                 _init_sd:
                 ;    1745 	unsigned char resp;
                 ;    1746 	unsigned int c;
                 ;    1747 	
                 ;    1748 	clear_sd_buff();
000b21 940e 1f27 	CALL __SAVELOCR3
                 ;	resp -> R16
                 ;	c -> R17,R18
000b23 940e 077f 	CALL _clear_sd_buff
                 ;    1749 
                 ;    1750     #ifdef _DEBUG_ON_
                 ;    1751 		printf("\r\nInitialization:  ");
                 ;    1752 	#endif
                 ;    1753     for (c=0; c<1000; c++)
000b25 e010
000b26 e020      	__GETWRN 17,18,0
                 _0x121:
000b27 3e18
000b28 e0e3
000b29 072e      	__CPWRN 17,18,1000
000b2a f4f0      	BRSH _0x122
                 ;    1754     {
                 ;    1755     	resp = send_cmd(CMD1, 0);
000b2b e0e1      	LDI  R30,LOW(1)
000b2c 93ea      	ST   -Y,R30
000b2d e0e0
000b2e e0f0
000b2f e060
000b30 e070      	__GETD1N 0x0
000b31 940e 1ecb 	CALL __PUTPARD1
000b33 940e 0609 	CALL _send_cmd
000b35 2f0e      	MOV  R16,R30
                 ;    1756     	if (resp == 0)
000b36 3000      	CPI  R16,0
000b37 f089      	BREQ _0x122
                 ;    1757     		break;
                 ;    1758    		resp = _FF_spi(0xFF);
000b38 efef      	LDI  R30,LOW(255)
000b39 93ea      	ST   -Y,R30
000b3a 940e 0603 	CALL __FF_spi
000b3c 2f0e      	MOV  R16,R30
                 ;    1759    		if (resp == 0)
000b3d 3000      	CPI  R16,0
000b3e f051      	BREQ _0x122
                 ;    1760    			break;
                 ;    1761    		resp = _FF_spi(0xFF);
000b3f efef      	LDI  R30,LOW(255)
000b40 93ea      	ST   -Y,R30
000b41 940e 0603 	CALL __FF_spi
000b43 2f0e      	MOV  R16,R30
                 ;    1762    		if (resp == 0)
000b44 3000      	CPI  R16,0
000b45 f019      	BREQ _0x122
                 ;    1763    			break;
                 ;    1764 	}
000b46 5f1f
000b47 4f2f      	__ADDWRN 17,18,1
000b48 cfde      	RJMP _0x121
                 _0x122:
                 ;    1765    	if (resp == 0)
000b49 3000      	CPI  R16,0
000b4a f411      	BRNE _0x126
                 ;    1766 	{
                 ;    1767 		#ifdef _DEBUG_ON_
                 ;    1768    			printf("OK!");
                 ;    1769 	   	#endif
                 ;    1770 		return (1);
000b4b e0e1      	LDI  R30,LOW(1)
000b4c c001      	RJMP _0x42A
                 ;    1771 	}
                 ;    1772 	else
                 _0x126:
                 ;    1773 	{
                 ;    1774 		#ifdef _DEBUG_ON_
                 ;    1775    			printf("ERROR-%x  ", resp);
                 ;    1776 	   	#endif
                 ;    1777 		return (0);
000b4d e0e0      	LDI  R30,LOW(0)
                 ;    1778  	}        		
                 ;    1779 }
                 _0x42A:
000b4e 940e 1f2e 	CALL __LOADLOCR3
000b50 9623      	ADIW R28,3
000b51 9508      	RET
                 ;    1780 
                 ;    1781 unsigned char _FF_read_disp(unsigned long sd_addr)
                 ;    1782 {
                 ;    1783 	unsigned char resp;
                 ;    1784 	unsigned long n, remainder;
                 ;    1785 	
                 ;    1786 	if (sd_addr % 0x200)
                 ;	sd_addr -> Y+9
                 ;	resp -> R16
                 ;	n -> Y+5
                 ;	remainder -> Y+1
                 ;    1787 	{	// Not a valid read address, return 0
                 ;    1788 		_FF_error = READ_ERR;
                 ;    1789 		return (0);
                 ;    1790 	}
                 ;    1791 
                 ;    1792 	clear_sd_buff();
                 ;    1793 	resp = send_cmd(CMD17, sd_addr);		// Send read request
                 ;    1794 	
                 ;    1795 	while(resp!=0xFE)
                 ;    1796 		resp = _FF_spi(0xFF);
                 ;    1797 	for (n=0; n<512; n++)
                 ;    1798 	{
                 ;    1799 		remainder = n % 0x10;
                 ;    1800 		if (remainder == 0)
                 ;    1801 			printf("\n\r");
                 ;    1802 		_FF_buff[n] = _FF_spi(0xFF);
                 ;    1803 		if (_FF_buff[n]<0x10)
                 ;    1804 			putchar(0x30);
                 ;    1805 		printf("%X ", _FF_buff[n]);
                 ;    1806 	}
                 ;    1807 	_FF_spi(0xFF);
                 ;    1808 	_FF_spi(0xFF);
                 ;    1809 	_FF_spi(0xFF);
                 ;    1810 	SD_CS_OFF();
                 ;    1811 	return (1);
                 ;    1812 }
                 ;    1813 
                 ;    1814 // Read data from a SD card @ address
                 ;    1815 unsigned char _FF_read(unsigned long sd_addr)
                 ;    1816 {
                 __FF_read:
                 ;    1817 	unsigned char resp;
                 ;    1818 	unsigned long n;
                 ;    1819 //printf("\r\nReadin ADDR [0x%lX]", sd_addr);
                 ;    1820 	
                 ;    1821 	if (sd_addr % BPB_BytsPerSec)
000b52 9724      	SBIW R28,4
000b53 930a      	ST   -Y,R16
                 ;	sd_addr -> Y+5
                 ;	resp -> R16
                 ;	n -> Y+1
000b54 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000b56 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000b58 81ad
000b59 81be
000b5a 818f
000b5b 8598      	__GETD2S 5
000b5c 2766      	CLR  R22
000b5d 2777      	CLR  R23
000b5e 940e 1e93 	CALL __MODD21U
000b60 940e 1f0c 	CALL __CPD10
000b62 f029      	BREQ _0x131
                 ;    1822 	{	// Not a valid read address, return 0
                 ;    1823 		_FF_error = READ_ERR;
000b63 e0e4      	LDI  R30,LOW(4)
000b64 93e0 0bd3 	STS  __FF_error,R30
                 ;    1824 		return (0);
000b66 e0e0      	LDI  R30,LOW(0)
000b67 c08e      	RJMP _0x429
                 ;    1825 	}
                 ;    1826 		
                 ;    1827 	for (;;)
                 _0x131:
                 _0x133:
                 ;    1828 	{
                 ;    1829 		clear_sd_buff();
000b68 940e 077f 	CALL _clear_sd_buff
                 ;    1830 		resp = send_cmd(CMD17, sd_addr);	// read block command
000b6a e0e7      	LDI  R30,LOW(7)
000b6b 93ea      	ST   -Y,R30
000b6c 81ee
000b6d 81ff
000b6e 8568
000b6f 8579      	__GETD1S 6
000b70 940e 1ecb 	CALL __PUTPARD1
000b72 940e 0609 	CALL _send_cmd
000b74 2f0e      	MOV  R16,R30
                 ;    1831 		for (n=0; n<1000; n++)
000b75 e0e0
000b76 83e9
000b77 83ea
000b78 83eb
000b79 83ec      	__CLRD1S 1
                 _0x136:
000b7a 81a9
000b7b 81ba
000b7c 818b
000b7d 819c      	__GETD2S 1
000b7e 3ea8
000b7f e0e3
000b80 07be
000b81 e0e0
000b82 078e
000b83 e0e0
000b84 079e      	__CPD2N 0x3E8
000b85 f4a0      	BRSH _0x137
                 ;    1832 		{
                 ;    1833 			if (resp==0xFE)
000b86 3f0e      	CPI  R16,254
000b87 f091      	BREQ _0x137
                 ;    1834 			{	// waiting for start byte
                 ;    1835 				break;
                 ;    1836 			}
                 ;    1837 			resp = _FF_spi(0xFF);
000b88 efef      	LDI  R30,LOW(255)
000b89 93ea      	ST   -Y,R30
000b8a 940e 0603 	CALL __FF_spi
000b8c 2f0e      	MOV  R16,R30
                 ;    1838 		}
000b8d 81e9
000b8e 81fa
000b8f 816b
000b90 817c      	__GETD1S 1
000b91 5fef
000b92 4fff
000b93 4f6f
000b94 4f7f      	__SUBD1N -1
000b95 83e9
000b96 83fa
000b97 836b
000b98 837c      	__PUTD1S 1
000b99 cfe0      	RJMP _0x136
                 _0x137:
                 ;    1839 		if (resp==0xFE)
000b9a 3f0e      	CPI  R16,254
000b9b f011      	BREQ PC+3
000b9c 940c 0bec 	JMP _0x139
                 ;    1840 		{	// if it is a valid start byte => start reading SD Card
                 ;    1841 			for (n=0; n<BPB_BytsPerSec; n++)
000b9e e0e0
000b9f 83e9
000ba0 83ea
000ba1 83eb
000ba2 83ec      	__CLRD1S 1
                 _0x13B:
000ba3 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000ba5 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000ba7 81a9
000ba8 81ba
000ba9 818b
000baa 819c      	__GETD2S 1
000bab 2766      	CLR  R22
000bac 2777      	CLR  R23
000bad 940e 1f1f 	CALL __CPD21
000baf f4e0      	BRSH _0x13C
                 ;    1842 				_FF_buff[n] = _FF_spi(0xFF);
000bb0 81e9
000bb1 81fa
000bb2 816b
000bb3 817c      	__GETD1S 1
000bb4 57e0      	SUBI R30,LOW(-__FF_buff)
000bb5 4ff6      	SBCI R31,HIGH(-__FF_buff)
000bb6 93ff      	PUSH R31
000bb7 93ef      	PUSH R30
000bb8 efef      	LDI  R30,LOW(255)
000bb9 93ea      	ST   -Y,R30
000bba 940e 0603 	CALL __FF_spi
000bbc 91af      	POP  R26
000bbd 91bf      	POP  R27
000bbe 93ec      	ST   X,R30
                 ;    1843 			_FF_spi(0xFF);
000bbf 81e9
000bc0 81fa
000bc1 816b
000bc2 817c      	__GETD1S 1
000bc3 5fef
000bc4 4fff
000bc5 4f6f
000bc6 4f7f      	__SUBD1N -1
000bc7 83e9
000bc8 83fa
000bc9 836b
000bca 837c      	__PUTD1S 1
000bcb cfd7      	RJMP _0x13B
                 _0x13C:
000bcc efef      	LDI  R30,LOW(255)
000bcd 93ea      	ST   -Y,R30
000bce 940e 0603 	CALL __FF_spi
                 ;    1844 			_FF_spi(0xFF);
000bd0 efef      	LDI  R30,LOW(255)
000bd1 93ea      	ST   -Y,R30
000bd2 940e 0603 	CALL __FF_spi
                 ;    1845 			_FF_spi(0xFF);
000bd4 efef      	LDI  R30,LOW(255)
000bd5 93ea      	ST   -Y,R30
000bd6 940e 0603 	CALL __FF_spi
                 ;    1846 			SD_CS_OFF();
000bd8 9ac4      	SBI  0x18,4
                 ;    1847 			_FF_error = NO_ERR;
000bd9 e0e0      	LDI  R30,LOW(0)
000bda 93e0 0bd3 	STS  __FF_error,R30
                 ;    1848 			_FF_buff_addr = sd_addr;
000bdc 81ed
000bdd 81fe
000bde 816f
000bdf 8578      	__GETD1S 5
000be0 93e0 0bd4 	STS  __FF_buff_addr,R30
000be2 93f0 0bd5 	STS  __FF_buff_addr+1,R31
000be4 9360 0bd6 	STS  __FF_buff_addr+2,R22
000be6 9370 0bd7 	STS  __FF_buff_addr+3,R23
                 ;    1849 			SPCR = 0x50;
000be8 e5e0      	LDI  R30,LOW(80)
000be9 b9ed      	OUT  0xD,R30
                 ;    1850 			return (1);
000bea e0e1      	LDI  R30,LOW(1)
000beb c00a      	RJMP _0x429
                 ;    1851 		}
                 ;    1852 
                 ;    1853 		SD_CS_OFF();
                 _0x139:
000bec 9ac4      	SBI  0x18,4
                 ;    1854 
                 ;    1855 		if (spi_speedset()==0)
000bed 940e 0ad3 	CALL _spi_speedset
000bef 30e0      	CPI  R30,0
000bf0 f009      	BREQ _0x134
                 ;    1856 			break;
                 ;    1857 	}	
000bf1 cf76      	RJMP _0x133
                 _0x134:
                 ;    1858 	_FF_error = READ_ERR;    
000bf2 e0e4      	LDI  R30,LOW(4)
000bf3 93e0 0bd3 	STS  __FF_error,R30
                 ;    1859 	return(0);
000bf5 e0e0      	LDI  R30,LOW(0)
                 _0x429:
000bf6 8108      	LDD  R16,Y+0
000bf7 9629      	ADIW R28,9
000bf8 9508      	RET
                 ;    1860 }
                 ;    1861 
                 ;    1862 
                 ;    1863 #ifndef _READ_ONLY_
                 ;    1864 unsigned char _FF_write(unsigned long sd_addr)
                 ;    1865 {
                 __FF_write:
                 ;    1866 	unsigned char resp, calc, valid_flag;
                 ;    1867 	unsigned int n;
                 ;    1868 	
                 ;    1869 	if ((sd_addr%BPB_BytsPerSec) || (sd_addr <= _FF_PART_ADDR))
000bf9 940e 1f25 	CALL __SAVELOCR5
                 ;	sd_addr -> Y+5
                 ;	resp -> R16
                 ;	calc -> R17
                 ;	valid_flag -> R18
                 ;	n -> R19,R20
000bfb 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000bfd 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000bff 81ad
000c00 81be
000c01 818f
000c02 8598      	__GETD2S 5
000c03 2766      	CLR  R22
000c04 2777      	CLR  R23
000c05 940e 1e93 	CALL __MODD21U
000c07 940e 1f0c 	CALL __CPD10
000c09 f479      	BRNE _0x13F
000c0a 91e0 0bb5 	LDS  R30,__FF_PART_ADDR
000c0c 91f0 0bb6 	LDS  R31,__FF_PART_ADDR+1
000c0e 9160 0bb7 	LDS  R22,__FF_PART_ADDR+2
000c10 9170 0bb8 	LDS  R23,__FF_PART_ADDR+3
000c12 81ad
000c13 81be
000c14 818f
000c15 8598      	__GETD2S 5
000c16 940e 1f1a 	CALL __CPD12
000c18 f028      	BRLO _0x13E
                 _0x13F:
                 ;    1870 	{	// Not a valid write address, return 0
                 ;    1871 		_FF_error = WRITE_ERR;
000c19 e0e3      	LDI  R30,LOW(3)
000c1a 93e0 0bd3 	STS  __FF_error,R30
                 ;    1872 		return (0);
000c1c e0e0      	LDI  R30,LOW(0)
000c1d c066      	RJMP _0x428
                 ;    1873 	}
                 ;    1874 
                 ;    1875 //printf("\r\nWriting to address:  %lX", sd_addr);
                 ;    1876 	for (;;)
                 _0x13E:
                 _0x142:
                 ;    1877 	{
                 ;    1878 		clear_sd_buff();
000c1e 940e 077f 	CALL _clear_sd_buff
                 ;    1879 		resp = send_cmd(CMD24, sd_addr);
000c20 e0e9      	LDI  R30,LOW(9)
000c21 93ea      	ST   -Y,R30
000c22 81ee
000c23 81ff
000c24 8568
000c25 8579      	__GETD1S 6
000c26 940e 1ecb 	CALL __PUTPARD1
000c28 940e 0609 	CALL _send_cmd
000c2a 2f0e      	MOV  R16,R30
                 ;    1880 		valid_flag = 0;
000c2b e020      	LDI  R18,LOW(0)
                 ;    1881 		for (n=0; n<1000; n++)
000c2c e030
000c2d e040      	__GETWRN 19,20,0
                 _0x145:
000c2e 3e38
000c2f e0e3
000c30 074e      	__CPWRN 19,20,1000
000c31 f460      	BRSH _0x146
                 ;    1882 		{
                 ;    1883 			if (resp == 0x00)
000c32 3000      	CPI  R16,0
000c33 f411      	BRNE _0x147
                 ;    1884 			{
                 ;    1885 				valid_flag = 1;
000c34 e021      	LDI  R18,LOW(1)
                 ;    1886 				break;
000c35 c008      	RJMP _0x146
                 ;    1887 			}
                 ;    1888 			resp = _FF_spi(0xFF);
                 _0x147:
000c36 efef      	LDI  R30,LOW(255)
000c37 93ea      	ST   -Y,R30
000c38 940e 0603 	CALL __FF_spi
000c3a 2f0e      	MOV  R16,R30
                 ;    1889 		}
000c3b 5f3f
000c3c 4f4f      	__ADDWRN 19,20,1
000c3d cff0      	RJMP _0x145
                 _0x146:
                 ;    1890 	
                 ;    1891 		if (valid_flag)
000c3e 3020      	CPI  R18,0
000c3f f1d1      	BREQ _0x148
                 ;    1892 		{
                 ;    1893 			_FF_spi(0xFF);
000c40 efef      	LDI  R30,LOW(255)
000c41 93ea      	ST   -Y,R30
000c42 940e 0603 	CALL __FF_spi
                 ;    1894 			_FF_spi(0xFE);					// Start Block Token
000c44 efee      	LDI  R30,LOW(254)
000c45 93ea      	ST   -Y,R30
000c46 940e 0603 	CALL __FF_spi
                 ;    1895 			for (n=0; n<BPB_BytsPerSec; n++)		// Write Data in buffer to card
000c48 e030
000c49 e040      	__GETWRN 19,20,0
                 _0x14A:
000c4a 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000c4c 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000c4e 173e      	CP   R19,R30
000c4f 074f      	CPC  R20,R31
000c50 f458      	BRSH _0x14B
                 ;    1896 				_FF_spi(_FF_buff[n]);
000c51 e9a0      	LDI  R26,LOW(__FF_buff)
000c52 e0b9      	LDI  R27,HIGH(__FF_buff)
000c53 0fa3      	ADD  R26,R19
000c54 1fb4      	ADC  R27,R20
000c55 91ec      	LD   R30,X
000c56 93ea      	ST   -Y,R30
000c57 940e 0603 	CALL __FF_spi
                 ;    1897 			_FF_spi(0xFF);					// Send 2 blank CRC bytes
000c59 5f3f
000c5a 4f4f      	__ADDWRN 19,20,1
000c5b cfee      	RJMP _0x14A
                 _0x14B:
000c5c efef      	LDI  R30,LOW(255)
000c5d 93ea      	ST   -Y,R30
000c5e 940e 0603 	CALL __FF_spi
                 ;    1898 			_FF_spi(0xFF);
000c60 efef      	LDI  R30,LOW(255)
000c61 93ea      	ST   -Y,R30
000c62 940e 0603 	CALL __FF_spi
                 ;    1899 			resp = _FF_spi(0xFF);			// Response should be 0bXXX00101
000c64 efef      	LDI  R30,LOW(255)
000c65 93ea      	ST   -Y,R30
000c66 940e 0603 	CALL __FF_spi
000c68 2f0e      	MOV  R16,R30
                 ;    1900 			calc = resp | 0xE0;
000c69 2fe0      	MOV  R30,R16
000c6a 6ee0      	ORI  R30,LOW(0xE0)
000c6b 2f1e      	MOV  R17,R30
                 ;    1901 			if (calc==0xE5)
000c6c 3e15      	CPI  R17,229
000c6d f461      	BRNE _0x14C
                 ;    1902 			{
                 ;    1903 				while(_FF_spi(0xFF)==0)
                 _0x14D:
000c6e efef      	LDI  R30,LOW(255)
000c6f 93ea      	ST   -Y,R30
000c70 940e 0603 	CALL __FF_spi
000c72 30e0      	CPI  R30,0
000c73 f3d1      	BREQ _0x14D
                 ;    1904 					;	// Clear Buffer before returning 'OK'
                 ;    1905 				SD_CS_OFF();
000c74 9ac4      	SBI  0x18,4
                 ;    1906 //				SPCR = 0x50;			// Reset SPI bus Speed
                 ;    1907 				_FF_error = NO_ERR;
000c75 e0e0      	LDI  R30,LOW(0)
000c76 93e0 0bd3 	STS  __FF_error,R30
                 ;    1908 				return(1);
000c78 e0e1      	LDI  R30,LOW(1)
000c79 c00a      	RJMP _0x428
                 ;    1909 			}
                 ;    1910 		}
                 _0x14C:
                 ;    1911 		SD_CS_OFF(); 
                 _0x148:
000c7a 9ac4      	SBI  0x18,4
                 ;    1912 
                 ;    1913 		if (spi_speedset()==0)
000c7b 940e 0ad3 	CALL _spi_speedset
000c7d 30e0      	CPI  R30,0
000c7e f009      	BREQ _0x143
                 ;    1914 			break;
                 ;    1915 		// delay_ms(100);		
                 ;    1916 	}
000c7f cf9e      	RJMP _0x142
                 _0x143:
                 ;    1917 	_FF_error = WRITE_ERR;
000c80 e0e3      	LDI  R30,LOW(3)
000c81 93e0 0bd3 	STS  __FF_error,R30
                 ;    1918 	return(0x0);
000c83 e0e0      	LDI  R30,LOW(0)
                 _0x428:
000c84 940e 1f2c 	CALL __LOADLOCR5
000c86 9629      	ADIW R28,9
000c87 9508      	RET
                 ;    1919 }
                 ;    1920 #endif
                 ;    1921 /*
                 ;    1922 	Progressive Resources LLC
                 ;    1923                                     
                 ;    1924 			FlashFile
                 ;    1925 	
                 ;    1926 	Version : 	1.32
                 ;    1927 	Date: 		12/31/2003
                 ;    1928 	Author: 	Erick M. Higa
                 ;    1929 	
                 ;    1930 	Revision History:
                 ;    1931 	12/31/2003 - EMH - v1.00 
                 ;    1932 			   	 	 - Initial Release
                 ;    1933 	01/19/2004 - EMH - v1.10
                 ;    1934 			   	 	 - fixed FAT access errors by allowing both FAT tables to be updated
                 ;    1935 					 - fixed erase_cluster chain to stop if chain goes to '0'
                 ;    1936 					 - fixed #include's so other non m128 processors could be used
                 ;    1937 					 - fixed fcreate to match 'C' standard for function "creat"
                 ;    1938 					 - fixed fseek so it would not error when in "READ" mode
                 ;    1939 					 - modified SPI interface to use _FF_spi() so it is more universal
                 ;    1940 					   (see the "sd_cmd.c" file for the function used)
                 ;    1941 					 - redifined global variables and #defines for more unique names
                 ;    1942 					 - added string functions fputs, fputsc, & fgets
                 ;    1943 					 - added functions fquickformat, fgetfileinfo, & GetVolID()
                 ;    1944 					 - added directory support
                 ;    1945 					 - modified delays in "sd_cmd.c" to increase transfer speed to max
                 ;    1946 					 - updated "options.h" to include additions, and to make #defines 
                 ;    1947 					   more universal to multiple platforms
                 ;    1948 	01/21/2004 - EMH - v1.20
                 ;    1949 			   	 	 - Added ICC Support to the FlashFileSD
                 ;    1950 					 - fixed card initialization error for MMC/SD's that have only a boot 
                 ;    1951 			   	 	   sector and no partition table
                 ;    1952 					 - Fixed intermittant error on fcreate when creating existing file
                 ;    1953 					 - changed "options.h" to #include all required files
                 ;    1954 	02/19/2004 - EMH - v1.21
                 ;    1955 					 - Replaced all "const" refrances to "flash" to support CodeVision 1.24.1b
                 ;    1956 	03/02/2004 - EMH - v1.22 (unofficial release)
                 ;    1957 					 - Changed Directory Functions to allow for multi-cluster directory entries
                 ;    1958 					 - Added function addr_to_clust() to support long directories
                 ;    1959 					 - Fixed FAT table address calculation to support multiple reserved sectors
                 ;    1960 					   (previously) assumed one reserved sector, if XP formats card sometimes 
                 ;    1961 					   multiple reserved sectors - thanks YW
                 ;    1962 	03/10/2004 - EMH - v1.30
                 ;    1963 					 - Added support for a Compact Flash package
                 ;    1964 					 - Renamed read and write to flash function names for multiple media support	
                 ;    1965 	03/26/2004 - EMH - v1.31
                 ;    1966 					 - Added define for easy MEGA128Dev board setup
                 ;    1967 					 - Changed demo projects so "option.h" is in the project directory	
                 ;    1968 	04/01/2004 - EMH - v1.32
                 ;    1969 					 - Fixed bug in "prev_cluster()" that didn't use updated FAT table address
                 ;    1970 					   calculations.  (effects XP formatted cards see v1.22 notes)
                 ;    1971                                            
                 ;    1972 	Software License
                 ;    1973 	The use of Progressive Resources LLC FlashFile Source Package indicates 
                 ;    1974 	your understanding and acceptance of the following terms and conditions. 
                 ;    1975 	This license shall supersede any verbal or prior verbal or written, statement 
                 ;    1976 	or agreement to the contrary. If you do not understand or accept these terms, 
                 ;    1977 	or your local regulations prohibit "after sale" license agreements or limited 
                 ;    1978 	disclaimers, you must cease and desist using this product immediately.
                 ;    1979 	This product is © Copyright 2003 by Progressive Resources LLC, all rights 
                 ;    1980 	reserved. International copyright laws, international treaties and all other 
                 ;    1981 	applicable national or international laws protect this product. This software 
                 ;    1982 	product and documentation may not, in whole or in part, be copied, photocopied, 
                 ;    1983 	translated, or reduced to any electronic medium or machine readable form, without 
                 ;    1984 	prior consent in writing, from Progressive Resources LLC and according to all 
                 ;    1985 	applicable laws. The sole owner of this product is Progressive Resources LLC.
                 ;    1986 
                 ;    1987 	Operating License
                 ;    1988 	You have the non-exclusive right to use any enclosed product but have no right 
                 ;    1989 	to distribute it as a source code product without the express written permission 
                 ;    1990 	of Progressive Resources LLC. Use over a "local area network" (within the same 
                 ;    1991 	locale) is permitted provided that only a single person, on a single computer 
                 ;    1992 	uses the product at a time. Use over a "wide area network" (outside the same 
                 ;    1993 	locale) is strictly prohibited under any and all circumstances.
                 ;    1994                                            
                 ;    1995 	Liability Disclaimer
                 ;    1996 	This product and/or license is provided as is, without any representation or 
                 ;    1997 	warranty of any kind, either express or implied, including without limitation 
                 ;    1998 	any representations or endorsements regarding the use of, the results of, or 
                 ;    1999 	performance of the product, Its appropriateness, accuracy, reliability, or 
                 ;    2000 	correctness. The user and/or licensee assume the entire risk as to the use of 
                 ;    2001 	this product. Progressive Resources LLC does not assume liability for the use 
                 ;    2002 	of this product beyond the original purchase price of the software. In no event 
                 ;    2003 	will Progressive Resources LLC be liable for additional direct or indirect 
                 ;    2004 	damages including any lost profits, lost savings, or other incidental or 
                 ;    2005 	consequential damages arising from any defects, or the use or inability to 
                 ;    2006 	use these products, even if Progressive Resources LLC have been advised of 
                 ;    2007 	the possibility of such damages.
                 ;    2008 */                                 
                 ;    2009 
                 ;    2010 	#include <coding.h>
                 ;    2011 
                 ;    2012 extern unsigned long OCR_REG;
                 ;    2013 extern unsigned char _FF_buff[512];
                 ;    2014 extern unsigned int PT_SecStart;
                 ;    2015 extern unsigned long BS_jmpBoot;
                 ;    2016 extern unsigned int BPB_BytsPerSec;
                 ;    2017 extern unsigned char BPB_SecPerClus;
                 ;    2018 extern unsigned int BPB_RsvdSecCnt;
                 ;    2019 extern unsigned char BPB_NumFATs;
                 ;    2020 extern unsigned int BPB_RootEntCnt;
                 ;    2021 extern unsigned int BPB_FATSz16;
                 ;    2022 extern unsigned char BPB_FATType;
                 ;    2023 extern unsigned long BPB_TotSec;
                 ;    2024 extern unsigned long BS_VolSerial;
                 ;    2025 extern unsigned char BS_VolLab[12];
                 ;    2026 extern unsigned long _FF_PART_ADDR, _FF_ROOT_ADDR, _FF_DIR_ADDR;
                 ;    2027 extern unsigned long _FF_FAT1_ADDR, _FF_FAT2_ADDR;
                 ;    2028 extern unsigned int FirstDataSector;
                 ;    2029 extern unsigned long FirstSectorofCluster;
                 ;    2030 extern unsigned char _FF_error;
                 ;    2031 extern unsigned long _FF_buff_addr;
                 ;    2032 extern unsigned long DataClusTot;
                 ;    2033 unsigned char rtc_hour, rtc_min, rtc_sec;
                 
                 	.DSEG
                 _rtc_hour:
000bdc           	.BYTE 0x1
                 _rtc_min:
000bdd           	.BYTE 0x1
                 _rtc_sec:
000bde           	.BYTE 0x1
                 ;    2034 unsigned char rtc_date, rtc_month;
                 _rtc_date:
000bdf           	.BYTE 0x1
                 _rtc_month:
000be0           	.BYTE 0x1
                 ;    2035 unsigned int rtc_year;
                 _rtc_year:
000be1           	.BYTE 0x2
                 ;    2036 unsigned long clus_0_addr, _FF_n_temp;
                 _clus_0_addr:
000be3           	.BYTE 0x4
                 __FF_n_temp:
000be7           	.BYTE 0x4
                 ;    2037 unsigned int c_counter;
                 _c_counter:
000beb           	.BYTE 0x2
                 ;    2038 unsigned char _FF_FULL_PATH[_FF_PATH_LENGTH];
                 __FF_FULL_PATH:
000bed           	.BYTE 0x64
                 ;    2039 unsigned char FILENAME[12];
                 _FILENAME:
000c51           	.BYTE 0xC
                 ;    2040 
                 ;    2041 // Conversion file to change an ASCII valued character into the calculated value
                 ;    2042 unsigned char ascii_to_char(unsigned char ascii_char)
                 ;    2043 {
                 
                 	.CSEG
                 ;    2044 	unsigned char temp_char;
                 ;    2045 	
                 ;    2046 	if (ascii_char < 0x30)		// invalid, return error
                 ;	ascii_char -> Y+1
                 ;	temp_char -> R16
                 ;    2047 		return (0xFF);
                 ;    2048 	else if (ascii_char < 0x3A)
                 ;    2049 	{	//number, subtract 0x30, retrun value
                 ;    2050 		temp_char = ascii_char - 0x30;
                 ;    2051 		return (temp_char);
                 ;    2052 	}
                 ;    2053 	else if (ascii_char < 0x41)	// invalid, return error
                 ;    2054 		return (0xFF);
                 ;    2055 	else if (ascii_char < 0x47)
                 ;    2056 	{	// lower case a-f, subtract 0x37, return value
                 ;    2057 		temp_char = ascii_char - 0x37;
                 ;    2058 		return (temp_char);
                 ;    2059 	}
                 ;    2060 	else if (ascii_char < 0x61)	// invalid, return error
                 ;    2061 		return (0xFF);
                 ;    2062 	else if (ascii_char < 0x67)
                 ;    2063 	{	// upper case A-F, subtract 0x57, return value
                 ;    2064 		temp_char = ascii_char - 0x57;
                 ;    2065 		return (temp_char);
                 ;    2066 	}
                 ;    2067 	else	// invalid, return error
                 ;    2068 		return (0xFF);
                 ;    2069 }
                 ;    2070 
                 ;    2071 // Function to see if the character is a valid FILENAME character
                 ;    2072 int valid_file_char(unsigned char file_char)
                 ;    2073 {
                 _valid_file_char:
                 ;    2074 	if (file_char < 0x20)
000c88 81a8      	LD   R26,Y
000c89 32a0      	CPI  R26,LOW(0x20)
000c8a f418      	BRSH _0x15D
                 ;    2075 		return (EOF);
000c8b efef      	LDI  R30,LOW(65535)
000c8c efff      	LDI  R31,HIGH(65535)
000c8d c020      	RJMP _0x427
                 ;    2076 	else if ((file_char==0x22) || (file_char==0x2A) || (file_char==0x2B) || (file_char==0x2C) ||
                 _0x15D:
                 ;    2077 			(file_char==0x2E) || (file_char==0x2F) || ((file_char>=0x3A)&&(file_char<=0x3F)) ||
                 ;    2078 			((file_char>=0x5B)&&(file_char<=0x5D)) || (file_char==0x7C) || (file_char==0xE5))
000c8e 81a8      	LD   R26,Y
000c8f 32a2      	CPI  R26,LOW(0x22)
000c90 f0c1      	BREQ _0x160
000c91 32aa      	CPI  R26,LOW(0x2A)
000c92 f0b1      	BREQ _0x160
000c93 32ab      	CPI  R26,LOW(0x2B)
000c94 f0a1      	BREQ _0x160
000c95 32ac      	CPI  R26,LOW(0x2C)
000c96 f091      	BREQ _0x160
000c97 32ae      	CPI  R26,LOW(0x2E)
000c98 f081      	BREQ _0x160
000c99 32af      	CPI  R26,LOW(0x2F)
000c9a f071      	BREQ _0x160
000c9b 33aa      	CPI  R26,LOW(0x3A)
000c9c f010      	BRLO _0x161
000c9d 34a0      	CPI  R26,LOW(0x40)
000c9e f050      	BRLO _0x160
                 _0x161:
000c9f 81a8      	LD   R26,Y
000ca0 35ab      	CPI  R26,LOW(0x5B)
000ca1 f010      	BRLO _0x163
000ca2 35ae      	CPI  R26,LOW(0x5E)
000ca3 f028      	BRLO _0x160
                 _0x163:
000ca4 81a8      	LD   R26,Y
000ca5 37ac      	CPI  R26,LOW(0x7C)
000ca6 f011      	BREQ _0x160
000ca7 3ea5      	CPI  R26,LOW(0xE5)
000ca8 f419      	BRNE _0x15F
                 _0x160:
                 ;    2079 		return (EOF);
000ca9 efef      	LDI  R30,LOW(65535)
000caa efff      	LDI  R31,HIGH(65535)
000cab c002      	RJMP _0x427
                 ;    2080 	else
                 _0x15F:
                 ;    2081 		return (0);
000cac e0e0      	LDI  R30,LOW(0)
000cad e0f0      	LDI  R31,HIGH(0)
                 ;    2082 }
                 _0x427:
000cae 9621      	ADIW R28,1
000caf 9508      	RET
                 ;    2083 
                 ;    2084 // Function will scan the directory @VALID_ADDR and return a
                 ;    2085 // '0' if successful (w/ VALID_ADDR changing to location of entry avaliable),
                 ;    2086 // and a '-1' if file or folder exists (w/ VALID_ADDR changing to location of
                 ;    2087 // entry of exisiting file/folder) or if no more entry space (VALID_ADDR would
                 ;    2088 // change to 0).
                 ;    2089 int scan_directory(unsigned long *VALID_ADDR, unsigned char *NAME)
                 ;    2090 {
                 _scan_directory:
                 ;    2091 	unsigned int ent_cntr, ent_max, n, c, dir_clus;
                 ;    2092 	unsigned long temp_addr;
                 ;    2093 	unsigned char *sp, *qp, aval_flag, name_store[14];
                 ;    2094 	
                 ;    2095 	aval_flag = 0;
000cb0 976b      	SBIW R28,27
000cb1 940e 1f24 	CALL __SAVELOCR6
                 ;	*VALID_ADDR -> Y+35
                 ;	*NAME -> Y+33
                 ;	ent_cntr -> R16,R17
                 ;	ent_max -> R18,R19
                 ;	n -> R20,R21
                 ;	c -> Y+31
                 ;	dir_clus -> Y+29
                 ;	temp_addr -> Y+25
                 ;	*sp -> Y+23
                 ;	*qp -> Y+21
                 ;	aval_flag -> Y+20
                 ;	name_store -> Y+6
000cb3 e0e0      	LDI  R30,LOW(0)
000cb4 8bec      	STD  Y+20,R30
                 ;    2096 	ent_cntr = 0;	// set to 0
000cb5 e000
000cb6 e010      	__GETWRN 16,17,0
                 ;    2097 	
                 ;    2098 	qp = NAME;
000cb7 a1e9      	LDD  R30,Y+33
000cb8 a1fa      	LDD  R31,Y+33+1
000cb9 8bed      	STD  Y+21,R30
000cba 8bfe      	STD  Y+21+1,R31
                 ;    2099 	for (c=0; c<11; c++)
000cbb e0e0      	LDI  R30,0
000cbc 8fef      	STD  Y+31,R30
000cbd a3e8      	STD  Y+31+1,R30
                 _0x168:
000cbe 8daf      	LDD  R26,Y+31
000cbf a1b8      	LDD  R27,Y+31+1
000cc0 971b      	SBIW R26,11
000cc1 f010      	BRLO PC+3
000cc2 940c 0d2c 	JMP _0x169
                 ;    2100 	{
                 ;    2101 		if (valid_file_char(*qp)==0)
000cc4 89ad      	LDD  R26,Y+21
000cc5 89be      	LDD  R27,Y+21+1
000cc6 91ec      	LD   R30,X
000cc7 93ea      	ST   -Y,R30
000cc8 940e 0c88 	CALL _valid_file_char
000cca 9730      	SBIW R30,0
000ccb f4a1      	BRNE _0x16A
                 ;    2102 			name_store[c] = toupper(*qp++);
000ccc 8def      	LDD  R30,Y+31
000ccd a1f8      	LDD  R31,Y+31+1
000cce 01de      	MOVW R26,R28
000ccf 9616      	ADIW R26,6
000cd0 0fea      	ADD  R30,R26
000cd1 1ffb      	ADC  R31,R27
000cd2 93ff      	PUSH R31
000cd3 93ef      	PUSH R30
000cd4 89ad      	LDD  R26,Y+21
000cd5 89be      	LDD  R27,Y+21+1
000cd6 91ed      	LD   R30,X+
000cd7 8bad      	STD  Y+21,R26
000cd8 8bbe      	STD  Y+21+1,R27
000cd9 93ea      	ST   -Y,R30
000cda 940e 1db7 	CALL _toupper
000cdc 91af      	POP  R26
000cdd 91bf      	POP  R27
000cde 93ec      	ST   X,R30
                 ;    2103 		else if (*qp == '.')
000cdf c046      	RJMP _0x16B
                 _0x16A:
000ce0 89ad      	LDD  R26,Y+21
000ce1 89be      	LDD  R27,Y+21+1
000ce2 91ac      	LD   R26,X
000ce3 32ae      	CPI  R26,LOW(0x2E)
000ce4 f4f9      	BRNE _0x16C
                 ;    2104 		{
                 ;    2105 			while (c<8)
                 _0x16D:
000ce5 8daf      	LDD  R26,Y+31
000ce6 a1b8      	LDD  R27,Y+31+1
000ce7 9718      	SBIW R26,8
000ce8 f468      	BRSH _0x16F
                 ;    2106 				name_store[c++] = 0x20;
000ce9 8def      	LDD  R30,Y+31
000cea a1f8      	LDD  R31,Y+31+1
000ceb 9631      	ADIW R30,1
000cec 8fef      	STD  Y+31,R30
000ced a3f8      	STD  Y+31+1,R31
000cee 9731      	SBIW R30,1
000cef 01de      	MOVW R26,R28
000cf0 9616      	ADIW R26,6
000cf1 0fae      	ADD  R26,R30
000cf2 1fbf      	ADC  R27,R31
000cf3 e2e0      	LDI  R30,LOW(32)
000cf4 93ec      	ST   X,R30
                 ;    2107 			c--;
000cf5 cfef      	RJMP _0x16D
                 _0x16F:
000cf6 8def      	LDD  R30,Y+31
000cf7 a1f8      	LDD  R31,Y+31+1
000cf8 9731      	SBIW R30,1
000cf9 8fef      	STD  Y+31,R30
000cfa a3f8      	STD  Y+31+1,R31
                 ;    2108 			
                 ;    2109 			qp++;
000cfb 89ed      	LDD  R30,Y+21
000cfc 89fe      	LDD  R31,Y+21+1
000cfd 9631      	ADIW R30,1
000cfe 8bed      	STD  Y+21,R30
000cff 8bfe      	STD  Y+21+1,R31
                 ;    2110 			aval_flag |= 1;
000d00 89ec      	LDD  R30,Y+20
000d01 60e1      	ORI  R30,1
000d02 8bec      	STD  Y+20,R30
                 ;    2111 		}
                 ;    2112 		else if (*qp == 0)
000d03 c022      	RJMP _0x170
                 _0x16C:
000d04 89ad      	LDD  R26,Y+21
000d05 89be      	LDD  R27,Y+21+1
000d06 91ec      	LD   R30,X
000d07 30e0      	CPI  R30,0
000d08 f491      	BRNE _0x171
                 ;    2113 		{
                 ;    2114 			while (c<11)
                 _0x172:
000d09 8daf      	LDD  R26,Y+31
000d0a a1b8      	LDD  R27,Y+31+1
000d0b 971b      	SBIW R26,11
000d0c f468      	BRSH _0x174
                 ;    2115 				name_store[c++] = 0x20;
000d0d 8def      	LDD  R30,Y+31
000d0e a1f8      	LDD  R31,Y+31+1
000d0f 9631      	ADIW R30,1
000d10 8fef      	STD  Y+31,R30
000d11 a3f8      	STD  Y+31+1,R31
000d12 9731      	SBIW R30,1
000d13 01de      	MOVW R26,R28
000d14 9616      	ADIW R26,6
000d15 0fae      	ADD  R26,R30
000d16 1fbf      	ADC  R27,R31
000d17 e2e0      	LDI  R30,LOW(32)
000d18 93ec      	ST   X,R30
                 ;    2116 		}
000d19 cfef      	RJMP _0x172
                 _0x174:
                 ;    2117 		else
000d1a c00b      	RJMP _0x175
                 _0x171:
                 ;    2118 		{
                 ;    2119 			*VALID_ADDR = 0;
000d1b a1ab      	LDD  R26,Y+35
000d1c a1bc      	LDD  R27,Y+35+1
000d1d e0e0
000d1e e0f0
000d1f e060
000d20 e070      	__GETD1N 0x0
000d21 940e 1ec2 	CALL __PUTDP1
                 ;    2120 			return (EOF);
000d23 efef      	LDI  R30,LOW(65535)
000d24 efff      	LDI  R31,HIGH(65535)
000d25 c1b5      	RJMP _0x426
                 ;    2121 		}
                 _0x175:
                 _0x170:
                 _0x16B:
                 ;    2122 	}
000d26 8def      	LDD  R30,Y+31
000d27 a1f8      	LDD  R31,Y+31+1
000d28 9631      	ADIW R30,1
000d29 8fef      	STD  Y+31,R30
000d2a a3f8      	STD  Y+31+1,R31
000d2b cf92      	RJMP _0x168
                 _0x169:
                 ;    2123 	name_store[11] = 0;
000d2c e0e0      	LDI  R30,LOW(0)
000d2d 8be9      	STD  Y+17,R30
                 ;    2124 	
                 ;    2125 	if (*VALID_ADDR == _FF_ROOT_ADDR)
000d2e a1ab      	LDD  R26,Y+35
000d2f a1bc      	LDD  R27,Y+35+1
000d30 940e 1ebc 	CALL __GETD1P
000d32 91a0 0bb9 	LDS  R26,__FF_ROOT_ADDR
000d34 91b0 0bba 	LDS  R27,__FF_ROOT_ADDR+1
000d36 9180 0bbb 	LDS  R24,__FF_ROOT_ADDR+2
000d38 9190 0bbc 	LDS  R25,__FF_ROOT_ADDR+3
000d3a 940e 1f1a 	CALL __CPD12
000d3c f429      	BRNE _0x176
                 ;    2126 		ent_max = BPB_RootEntCnt;
000d3d 9120 0b9c
000d3f 9130 0b9d 	__GETWRMN 18,19,0,_BPB_RootEntCnt
                 ;    2127 	else
000d41 c026      	RJMP _0x177
                 _0x176:
                 ;    2128 	{
                 ;    2129 		dir_clus = addr_to_clust(*VALID_ADDR);
000d42 a1ab      	LDD  R26,Y+35
000d43 a1bc      	LDD  R27,Y+35+1
000d44 940e 1ebc 	CALL __GETD1P
000d46 940e 1ecb 	CALL __PUTPARD1
000d48 d1d5      	RCALL _addr_to_clust
000d49 8fed      	STD  Y+29,R30
000d4a 8ffe      	STD  Y+29+1,R31
                 ;    2130 		if (dir_clus != 0)
000d4b 9730      	SBIW R30,0
000d4c f019      	BREQ _0x178
                 ;    2131 			aval_flag |= 0x80;
000d4d 89ec      	LDD  R30,Y+20
000d4e 68e0      	ORI  R30,0x80
000d4f 8bec      	STD  Y+20,R30
                 ;    2132 		ent_max = ((long) BPB_BytsPerSec * (long) BPB_SecPerClus) / 0x20;
                 _0x178:
000d50 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000d52 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000d54 2766      	CLR  R22
000d55 2777      	CLR  R23
000d56 01df      	MOVW R26,R30
000d57 01cb      	MOVW R24,R22
000d58 91e0 0b98 	LDS  R30,_BPB_SecPerClus
000d5a 27ff      	CLR  R31
000d5b 2766      	CLR  R22
000d5c 2777      	CLR  R23
000d5d 940e 1e4d 	CALL __MULD12
000d5f 01df      	MOVW R26,R30
000d60 01cb      	MOVW R24,R22
000d61 e2e0
000d62 e0f0
000d63 e060
000d64 e070      	__GETD1N 0x20
000d65 940e 1e8b 	CALL __DIVD21
000d67 019f      	MOVW R18,R30
                 ;    2133     }
                 _0x177:
                 ;    2134 	c = 0;
000d68 e0e0      	LDI  R30,0
000d69 8fef      	STD  Y+31,R30
000d6a a3e8      	STD  Y+31+1,R30
                 ;    2135 	while (ent_cntr < ent_max)	
                 _0x179:
000d6b 1702
000d6c 0713      	__CPWRR 16,17,18,19
000d6d f010      	BRLO PC+3
000d6e 940c 0ed1 	JMP _0x17B
                 ;    2136 	{
                 ;    2137 		if (_FF_read(*VALID_ADDR+((long)c*BPB_BytsPerSec))==0)
000d70 a1ab      	LDD  R26,Y+35
000d71 a1bc      	LDD  R27,Y+35+1
000d72 940e 1ebc 	CALL __GETD1P
000d74 937f      	PUSH R23
000d75 936f      	PUSH R22
000d76 93ff      	PUSH R31
000d77 93ef      	PUSH R30
000d78 8def      	LDD  R30,Y+31
000d79 a1f8      	LDD  R31,Y+31+1
000d7a 2766      	CLR  R22
000d7b 2777      	CLR  R23
000d7c 01df      	MOVW R26,R30
000d7d 01cb      	MOVW R24,R22
000d7e 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000d80 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000d82 2766      	CLR  R22
000d83 2777      	CLR  R23
000d84 940e 1e4d 	CALL __MULD12
000d86 91af      	POP  R26
000d87 91bf      	POP  R27
000d88 918f      	POP  R24
000d89 919f      	POP  R25
000d8a 940e 1dca 	CALL __ADDD12
000d8c 940e 1ecb 	CALL __PUTPARD1
000d8e 940e 0b52 	CALL __FF_read
000d90 30e0      	CPI  R30,0
000d91 f409      	BRNE _0x17C
                 ;    2138 			break;
000d92 c13e      	RJMP _0x17B
                 ;    2139 		for (n=0; n<16; n++)
                 _0x17C:
000d93 e040
000d94 e050      	__GETWRN 20,21,0
                 _0x17E:
000d95 3140
000d96 e0e0
000d97 075e      	__CPWRN 20,21,16
000d98 f010      	BRLO PC+3
000d99 940c 0ea4 	JMP _0x17F
                 ;    2140 		{
                 ;    2141 			sp = &_FF_buff[n*0x20];
000d9b 01fa      	MOVW R30,R20
000d9c 0fee      	LSL  R30
000d9d 1fff      	ROL  R31
000d9e 940e 1e08 	CALL __LSLW4
000da0 57e0      	SUBI R30,LOW(-__FF_buff)
000da1 4ff6      	SBCI R31,HIGH(-__FF_buff)
000da2 8bef      	STD  Y+23,R30
000da3 8ff8      	STD  Y+23+1,R31
                 ;    2142 			qp = name_store;
000da4 01fe      	MOVW R30,R28
000da5 9636      	ADIW R30,6
000da6 8bed      	STD  Y+21,R30
000da7 8bfe      	STD  Y+21+1,R31
                 ;    2143 			if (*sp==0)
000da8 89af      	LDD  R26,Y+23
000da9 8db8      	LDD  R27,Y+23+1
000daa 91ec      	LD   R30,X
000dab 30e0      	CPI  R30,0
000dac f5b9      	BRNE _0x180
                 ;    2144 			{
                 ;    2145 				if ((aval_flag&0x10)==0)
000dad 89ec      	LDD  R30,Y+20
000dae 71e0      	ANDI R30,LOW(0x10)
000daf f549      	BRNE _0x181
                 ;    2146 					temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000db0 a1ab      	LDD  R26,Y+35
000db1 a1bc      	LDD  R27,Y+35+1
000db2 940e 1ebc 	CALL __GETD1P
000db4 937f      	PUSH R23
000db5 936f      	PUSH R22
000db6 93ff      	PUSH R31
000db7 93ef      	PUSH R30
000db8 8def      	LDD  R30,Y+31
000db9 a1f8      	LDD  R31,Y+31+1
000dba 2766      	CLR  R22
000dbb 2777      	CLR  R23
000dbc 01df      	MOVW R26,R30
000dbd 01cb      	MOVW R24,R22
000dbe 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000dc0 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000dc2 2766      	CLR  R22
000dc3 2777      	CLR  R23
000dc4 940e 1e4d 	CALL __MULD12
000dc6 91af      	POP  R26
000dc7 91bf      	POP  R27
000dc8 918f      	POP  R24
000dc9 919f      	POP  R25
000dca 940e 1dcf 	CALL __ADDD21
000dcc 01fa      	MOVW R30,R20
000dcd 0fee      	LSL  R30
000dce 1fff      	ROL  R31
000dcf 940e 1e08 	CALL __LSLW4
000dd1 2766      	CLR  R22
000dd2 2777      	CLR  R23
000dd3 940e 1dca 	CALL __ADDD12
000dd5 8fe9
000dd6 8ffa
000dd7 8f6b
000dd8 8f7c      	__PUTD1S 25
                 ;    2147 				*VALID_ADDR = temp_addr;
                 _0x181:
000dd9 8de9
000dda 8dfa
000ddb 8d6b
000ddc 8d7c      	__GETD1S 25
000ddd a1ab      	LDD  R26,Y+35
000dde a1bc      	LDD  R27,Y+35+1
000ddf 940e 1ec2 	CALL __PUTDP1
                 ;    2148 				return (0);
000de1 e0e0      	LDI  R30,LOW(0)
000de2 e0f0      	LDI  R31,HIGH(0)
000de3 c0f7      	RJMP _0x426
                 ;    2149 			}
                 ;    2150 			else if (*sp==0xE5)
                 _0x180:
000de4 89af      	LDD  R26,Y+23
000de5 8db8      	LDD  R27,Y+23+1
000de6 91ac      	LD   R26,X
000de7 3ea5      	CPI  R26,LOW(0xE5)
000de8 f569      	BRNE _0x183
                 ;    2151 			{
                 ;    2152 				temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000de9 a1ab      	LDD  R26,Y+35
000dea a1bc      	LDD  R27,Y+35+1
000deb 940e 1ebc 	CALL __GETD1P
000ded 937f      	PUSH R23
000dee 936f      	PUSH R22
000def 93ff      	PUSH R31
000df0 93ef      	PUSH R30
000df1 8def      	LDD  R30,Y+31
000df2 a1f8      	LDD  R31,Y+31+1
000df3 2766      	CLR  R22
000df4 2777      	CLR  R23
000df5 01df      	MOVW R26,R30
000df6 01cb      	MOVW R24,R22
000df7 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000df9 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000dfb 2766      	CLR  R22
000dfc 2777      	CLR  R23
000dfd 940e 1e4d 	CALL __MULD12
000dff 91af      	POP  R26
000e00 91bf      	POP  R27
000e01 918f      	POP  R24
000e02 919f      	POP  R25
000e03 940e 1dcf 	CALL __ADDD21
000e05 01fa      	MOVW R30,R20
000e06 0fee      	LSL  R30
000e07 1fff      	ROL  R31
000e08 940e 1e08 	CALL __LSLW4
000e0a 2766      	CLR  R22
000e0b 2777      	CLR  R23
000e0c 940e 1dca 	CALL __ADDD12
000e0e 8fe9
000e0f 8ffa
000e10 8f6b
000e11 8f7c      	__PUTD1S 25
                 ;    2153 				aval_flag |= 0x10;
000e12 89ec      	LDD  R30,Y+20
000e13 61e0      	ORI  R30,0x10
000e14 8bec      	STD  Y+20,R30
                 ;    2154 			}
                 ;    2155 			else
000e15 c089      	RJMP _0x184
                 _0x183:
                 ;    2156 			{
                 ;    2157 				if (aval_flag & 0x01)	// file
000e16 89ec      	LDD  R30,Y+20
000e17 70e1      	ANDI R30,LOW(0x1)
000e18 f411      	BRNE PC+3
000e19 940c 0e5a 	JMP _0x185
                 ;    2158 				{
                 ;    2159 					if (strncmp(qp, sp, 11)==0)
000e1b 89ed      	LDD  R30,Y+21
000e1c 89fe      	LDD  R31,Y+21+1
000e1d 93fa      	ST   -Y,R31
000e1e 93ea      	ST   -Y,R30
000e1f 8de9      	LDD  R30,Y+25
000e20 8dfa      	LDD  R31,Y+25+1
000e21 93fa      	ST   -Y,R31
000e22 93ea      	ST   -Y,R30
000e23 e0eb      	LDI  R30,LOW(11)
000e24 93ea      	ST   -Y,R30
000e25 940e 1d92 	CALL _strncmp
000e27 30e0      	CPI  R30,0
000e28 f581      	BRNE _0x186
                 ;    2160 					{
                 ;    2161 						temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000e29 a1ab      	LDD  R26,Y+35
000e2a a1bc      	LDD  R27,Y+35+1
000e2b 940e 1ebc 	CALL __GETD1P
000e2d 937f      	PUSH R23
000e2e 936f      	PUSH R22
000e2f 93ff      	PUSH R31
000e30 93ef      	PUSH R30
000e31 8def      	LDD  R30,Y+31
000e32 a1f8      	LDD  R31,Y+31+1
000e33 2766      	CLR  R22
000e34 2777      	CLR  R23
000e35 01df      	MOVW R26,R30
000e36 01cb      	MOVW R24,R22
000e37 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000e39 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000e3b 2766      	CLR  R22
000e3c 2777      	CLR  R23
000e3d 940e 1e4d 	CALL __MULD12
000e3f 91af      	POP  R26
000e40 91bf      	POP  R27
000e41 918f      	POP  R24
000e42 919f      	POP  R25
000e43 940e 1dcf 	CALL __ADDD21
000e45 01fa      	MOVW R30,R20
000e46 0fee      	LSL  R30
000e47 1fff      	ROL  R31
000e48 940e 1e08 	CALL __LSLW4
000e4a 2766      	CLR  R22
000e4b 2777      	CLR  R23
000e4c 940e 1dca 	CALL __ADDD12
000e4e 8fe9
000e4f 8ffa
000e50 8f6b
000e51 8f7c      	__PUTD1S 25
                 ;    2162 						*VALID_ADDR = temp_addr;
000e52 a1ab      	LDD  R26,Y+35
000e53 a1bc      	LDD  R27,Y+35+1
000e54 940e 1ec2 	CALL __PUTDP1
                 ;    2163 						return (EOF);	// file exists @ temp_addr
000e56 efef      	LDI  R30,LOW(65535)
000e57 efff      	LDI  R31,HIGH(65535)
000e58 c082      	RJMP _0x426
                 ;    2164 					}
                 ;    2165 				}
                 _0x186:
                 ;    2166 				else					// folder
000e59 c045      	RJMP _0x187
                 _0x185:
                 ;    2167 				{
                 ;    2168 					if ((strncmp(qp, sp, 11)==0)&&(*(sp+11)&0x10))
000e5a 89ed      	LDD  R30,Y+21
000e5b 89fe      	LDD  R31,Y+21+1
000e5c 93fa      	ST   -Y,R31
000e5d 93ea      	ST   -Y,R30
000e5e 8de9      	LDD  R30,Y+25
000e5f 8dfa      	LDD  R31,Y+25+1
000e60 93fa      	ST   -Y,R31
000e61 93ea      	ST   -Y,R30
000e62 e0eb      	LDI  R30,LOW(11)
000e63 93ea      	ST   -Y,R30
000e64 940e 1d92 	CALL _strncmp
000e66 30e0      	CPI  R30,0
000e67 f431      	BRNE _0x189
000e68 89af      	LDD  R26,Y+23
000e69 8db8      	LDD  R27,Y+23+1
000e6a 961b      	ADIW R26,11
000e6b 91ec      	LD   R30,X
000e6c 71e0      	ANDI R30,LOW(0x10)
000e6d f409      	BRNE _0x18A
                 _0x189:
000e6e c030      	RJMP _0x188
                 _0x18A:
                 ;    2169 					{
                 ;    2170 						temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000e6f a1ab      	LDD  R26,Y+35
000e70 a1bc      	LDD  R27,Y+35+1
000e71 940e 1ebc 	CALL __GETD1P
000e73 937f      	PUSH R23
000e74 936f      	PUSH R22
000e75 93ff      	PUSH R31
000e76 93ef      	PUSH R30
000e77 8def      	LDD  R30,Y+31
000e78 a1f8      	LDD  R31,Y+31+1
000e79 2766      	CLR  R22
000e7a 2777      	CLR  R23
000e7b 01df      	MOVW R26,R30
000e7c 01cb      	MOVW R24,R22
000e7d 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000e7f 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000e81 2766      	CLR  R22
000e82 2777      	CLR  R23
000e83 940e 1e4d 	CALL __MULD12
000e85 91af      	POP  R26
000e86 91bf      	POP  R27
000e87 918f      	POP  R24
000e88 919f      	POP  R25
000e89 940e 1dcf 	CALL __ADDD21
000e8b 01fa      	MOVW R30,R20
000e8c 0fee      	LSL  R30
000e8d 1fff      	ROL  R31
000e8e 940e 1e08 	CALL __LSLW4
000e90 2766      	CLR  R22
000e91 2777      	CLR  R23
000e92 940e 1dca 	CALL __ADDD12
000e94 8fe9
000e95 8ffa
000e96 8f6b
000e97 8f7c      	__PUTD1S 25
                 ;    2171 						*VALID_ADDR = temp_addr;
000e98 a1ab      	LDD  R26,Y+35
000e99 a1bc      	LDD  R27,Y+35+1
000e9a 940e 1ec2 	CALL __PUTDP1
                 ;    2172 						return (EOF);	// file exists @ temp_addr
000e9c efef      	LDI  R30,LOW(65535)
000e9d efff      	LDI  R31,HIGH(65535)
000e9e c03c      	RJMP _0x426
                 ;    2173 					}
                 ;    2174 				}
                 _0x188:
                 _0x187:
                 ;    2175 			}
                 _0x184:
                 ;    2176 			ent_cntr++;
000e9f 5f0f
000ea0 4f1f      	__ADDWRN 16,17,1
                 ;    2177 		}
000ea1 5f4f
000ea2 4f5f      	__ADDWRN 20,21,1
000ea3 cef1      	RJMP _0x17E
                 _0x17F:
                 ;    2178 		c++;
000ea4 8def      	LDD  R30,Y+31
000ea5 a1f8      	LDD  R31,Y+31+1
000ea6 9631      	ADIW R30,1
000ea7 8fef      	STD  Y+31,R30
000ea8 a3f8      	STD  Y+31+1,R31
                 ;    2179 		if (ent_cntr == ent_max)
000ea9 1720
000eaa 0731      	__CPWRR 18,19,16,17
000eab f521      	BRNE _0x18B
                 ;    2180 		{
                 ;    2181 			if (aval_flag & 0x80)		// a folder @ a valid cluster
000eac 89ec      	LDD  R30,Y+20
000ead 78e0      	ANDI R30,LOW(0x80)
000eae f109      	BREQ _0x18C
                 ;    2182 			{
                 ;    2183 				c = next_cluster(dir_clus, SINGLE);
000eaf 8ded      	LDD  R30,Y+29
000eb0 8dfe      	LDD  R31,Y+29+1
000eb1 93fa      	ST   -Y,R31
000eb2 93ea      	ST   -Y,R30
000eb3 e0e1      	LDI  R30,LOW(1)
000eb4 93ea      	ST   -Y,R30
000eb5 d0e5      	RCALL _next_cluster
000eb6 8fef      	STD  Y+31,R30
000eb7 a3f8      	STD  Y+31+1,R31
                 ;    2184 				if (c != EOF)
000eb8 8daf      	LDD  R26,Y+31
000eb9 a1b8      	LDD  R27,Y+31+1
000eba 3faf      	CPI  R26,LOW(0xFFFF)
000ebb efef      	LDI  R30,HIGH(0xFFFF)
000ebc 07be      	CPC  R27,R30
000ebd f091      	BREQ _0x18D
                 ;    2185 				{	// another dir cluster exists
                 ;    2186 					*VALID_ADDR = clust_to_addr(c);
000ebe 8def      	LDD  R30,Y+31
000ebf a1f8      	LDD  R31,Y+31+1
000ec0 93fa      	ST   -Y,R31
000ec1 93ea      	ST   -Y,R30
000ec2 d01c      	RCALL _clust_to_addr
000ec3 a1ab      	LDD  R26,Y+35
000ec4 a1bc      	LDD  R27,Y+35+1
000ec5 940e 1ec2 	CALL __PUTDP1
                 ;    2187 					dir_clus = c;
000ec7 8def      	LDD  R30,Y+31
000ec8 a1f8      	LDD  R31,Y+31+1
000ec9 8fed      	STD  Y+29,R30
000eca 8ffe      	STD  Y+29+1,R31
                 ;    2188 					ent_cntr = 0;
000ecb e000
000ecc e010      	__GETWRN 16,17,0
                 ;    2189 					c = 0;
000ecd e0e0      	LDI  R30,0
000ece 8fef      	STD  Y+31,R30
000ecf a3e8      	STD  Y+31+1,R30
                 ;    2190 				}
                 ;    2191 			}
                 _0x18D:
                 ;    2192 		}
                 _0x18C:
                 ;    2193 	}
                 _0x18B:
000ed0 ce9a      	RJMP _0x179
                 _0x17B:
                 ;    2194 	*VALID_ADDR = 0;
000ed1 a1ab      	LDD  R26,Y+35
000ed2 a1bc      	LDD  R27,Y+35+1
000ed3 e0e0
000ed4 e0f0
000ed5 e060
000ed6 e070      	__GETD1N 0x0
000ed7 940e 1ec2 	CALL __PUTDP1
                 ;    2195 	return (EOF);	
000ed9 efef      	LDI  R30,LOW(65535)
000eda efff      	LDI  R31,HIGH(65535)
                 _0x426:
000edb 940e 1f2b 	CALL __LOADLOCR6
000edd 96a5      	ADIW R28,37
000ede 9508      	RET
                 ;    2196 }
                 ;    2197 
                 ;    2198 #ifdef _DEBUG_ON_
                 ;    2199 // Function to display all files and folders in the root directory, 
                 ;    2200 // with the size of the file in bytes within the [brakets]
                 ;    2201 void read_directory(void)
                 ;    2202 {
                 ;    2203 	unsigned char valid_flag, attribute_temp;
                 ;    2204 	unsigned int c, n, d, m, dir_clus;
                 ;    2205 	unsigned long calc, calc_clus, dir_addr;
                 ;    2206 	
                 ;    2207 	if (_FF_DIR_ADDR != _FF_ROOT_ADDR)
                 ;    2208 	{
                 ;    2209 		dir_clus = addr_to_clust(_FF_DIR_ADDR);
                 ;    2210 		if (dir_clus == 0)
                 ;    2211 			return;
                 ;    2212 	}
                 ;    2213 
                 ;    2214 	printf("\r\nFile Listing for:  ROOT\\");
                 ;    2215 	for (d=0; d<_FF_PATH_LENGTH; d++)
                 ;    2216 	{
                 ;    2217 		if (_FF_FULL_PATH[d])
                 ;    2218 			putchar(_FF_FULL_PATH[d]);
                 ;    2219 		else
                 ;    2220 			break;
                 ;    2221 	}
                 ;    2222 	
                 ;    2223     
                 ;    2224     dir_addr = _FF_DIR_ADDR;
                 ;    2225 	d = 0;
                 ;    2226 	m = 0;
                 ;    2227 	while (d<BPB_RootEntCnt)
                 ;    2228 	{
                 ;    2229     	if (_FF_read(dir_addr+(m*0x200))==0)
                 ;    2230     		break;
                 ;    2231 		for (n=0; n<16; n++)
                 ;    2232 		{
                 ;    2233 			for (c=0; c<11; c++)
                 ;    2234 			{
                 ;    2235 				if (_FF_buff[(n*0x20)]==0)
                 ;    2236 				{
                 ;    2237 					n=16;
                 ;    2238 					d=BPB_RootEntCnt;
                 ;    2239 					valid_flag = 0;
                 ;    2240 					break;
                 ;    2241 				}
                 ;    2242 				valid_flag = 1;
                 ;    2243 				if (valid_file_char(_FF_buff[(n*0x20)+c]))
                 ;    2244 				{
                 ;    2245 					valid_flag = 0;
                 ;    2246 					break;
                 ;    2247 				}
                 ;    2248 		    }   
                 ;    2249 		    if (valid_flag)
                 ;    2250 	  		{
                 ;    2251 		  		calc = (n * 0x20) + 0xB;
                 ;    2252 		  		attribute_temp = _FF_buff[calc];
                 ;    2253 		  		putchar('\n');
                 ;    2254 				putchar('\r');
                 ;    2255 				c = (n * 0x20);
                 ;    2256 			  	calc = ((long) _FF_buff[c+0x1F] << 24) | ((long) _FF_buff[c+0x1E] << 16) |
                 ;    2257 			  			((long) _FF_buff[c+0x1D] << 8) | ((long) _FF_buff[c+0x1C]);
                 ;    2258 			  	calc_clus = ((int) _FF_buff[c+0x1B] << 8) | (int) _FF_buff[c+0x1A];
                 ;    2259 				if (attribute_temp & 0x10)
                 ;    2260 					printf("  [");
                 ;    2261 				else
                 ;    2262 			  		printf("                [%ld] bytes      (%X)\r  ", calc, calc_clus);		  		
                 ;    2263 				for (c=0; c<8; c++)
                 ;    2264 				{
                 ;    2265 					calc = (n * 0x20) + c;
                 ;    2266 					if (_FF_buff[calc]==0x20)
                 ;    2267 						break;
                 ;    2268 					putchar(_FF_buff[calc]);
                 ;    2269 				}
                 ;    2270 				if (attribute_temp & 0x10)
                 ;    2271 				{
                 ;    2272 					printf("]      (%X)", calc_clus);
                 ;    2273 				}
                 ;    2274 				else
                 ;    2275 				{
                 ;    2276 					putchar('.');
                 ;    2277 					for (c=8; c<11; c++)
                 ;    2278 					{
                 ;    2279 						calc = (n * 0x20) + c;
                 ;    2280 						if (_FF_buff[calc]==0x20)
                 ;    2281 							break;
                 ;    2282 						putchar(_FF_buff[calc]);
                 ;    2283 					}
                 ;    2284 				}
                 ;    2285 		  	}
                 ;    2286 		  	d++;		  		
                 ;    2287 		}
                 ;    2288 		m++;
                 ;    2289 		if (_FF_ROOT_ADDR!=_FF_DIR_ADDR)
                 ;    2290 		{
                 ;    2291 		   	if (m==BPB_SecPerClus)
                 ;    2292 		   	{
                 ;    2293 
                 ;    2294 				m = next_cluster(dir_clus, SINGLE);
                 ;    2295 				if (m != EOF)
                 ;    2296 				{	// another dir cluster exists
                 ;    2297 					dir_addr = clust_to_addr(m);
                 ;    2298 					dir_clus = m;
                 ;    2299 					d = 0;
                 ;    2300 					m = 0;
                 ;    2301 				}
                 ;    2302 				else
                 ;    2303 					break;
                 ;    2304 		   		
                 ;    2305 		   	}
                 ;    2306 		}
                 ;    2307 	}
                 ;    2308 	putchar('\n');
                 ;    2309 	putchar('\r');	
                 ;    2310 } 
                 ;    2311 
                 ;    2312 void GetVolID(void)
                 ;    2313 {
                 ;    2314 	printf("\r\n  Volume Serial:  [0x%lX]", BS_VolSerial);
                 ;    2315 	printf("\r\n  Volume Label:  [%s]\r\n", BS_VolLab);
                 ;    2316 }
                 ;    2317 #endif
                 ;    2318 
                 ;    2319 // Convert a cluster number into a read address
                 ;    2320 unsigned long clust_to_addr(unsigned int clust_no)
                 ;    2321 {
                 _clust_to_addr:
                 ;    2322 	unsigned long clust_addr;
                 ;    2323 	
                 ;    2324 	FirstSectorofCluster = ((clust_no - 2) * (long) BPB_SecPerClus) + (long) FirstDataSector;
000edf 9724      	SBIW R28,4
                 ;	clust_no -> Y+4
                 ;	clust_addr -> Y+0
000ee0 81ac      	LDD  R26,Y+4
000ee1 81bd      	LDD  R27,Y+4+1
000ee2 9712      	SBIW R26,2
000ee3 91e0 0b98 	LDS  R30,_BPB_SecPerClus
000ee5 27ff      	CLR  R31
000ee6 2766      	CLR  R22
000ee7 2777      	CLR  R23
000ee8 2788      	CLR  R24
000ee9 2799      	CLR  R25
000eea 940e 1e4d 	CALL __MULD12
000eec 01df      	MOVW R26,R30
000eed 01cb      	MOVW R24,R22
000eee 91e0 0bcd 	LDS  R30,_FirstDataSector
000ef0 91f0 0bce 	LDS  R31,_FirstDataSector+1
000ef2 2766      	CLR  R22
000ef3 2777      	CLR  R23
000ef4 940e 1dca 	CALL __ADDD12
000ef6 93e0 0bcf 	STS  _FirstSectorofCluster,R30
000ef8 93f0 0bd0 	STS  _FirstSectorofCluster+1,R31
000efa 9360 0bd1 	STS  _FirstSectorofCluster+2,R22
000efc 9370 0bd2 	STS  _FirstSectorofCluster+3,R23
                 ;    2325 	clust_addr = (long) FirstSectorofCluster * (long) BPB_BytsPerSec + _FF_PART_ADDR;
000efe 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000f00 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000f02 2766      	CLR  R22
000f03 2777      	CLR  R23
000f04 91a0 0bcf 	LDS  R26,_FirstSectorofCluster
000f06 91b0 0bd0 	LDS  R27,_FirstSectorofCluster+1
000f08 9180 0bd1 	LDS  R24,_FirstSectorofCluster+2
000f0a 9190 0bd2 	LDS  R25,_FirstSectorofCluster+3
000f0c 940e 1e4d 	CALL __MULD12
000f0e 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
000f10 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
000f12 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
000f14 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
000f16 940e 1dca 	CALL __ADDD12
000f18 83e8
000f19 83f9
000f1a 836a
000f1b 837b      	__PUTD1S 0
                 ;    2326 
                 ;    2327 	return (clust_addr);
000f1c 9626      	ADIW R28,6
000f1d 9508      	RET
                 ;    2328 }
                 ;    2329 
                 ;    2330 // Converts an address into a cluster number
                 ;    2331 unsigned int addr_to_clust(unsigned long clus_addr)
                 ;    2332 {
                 _addr_to_clust:
                 ;    2333 	if (clus_addr <= _FF_PART_ADDR)
000f1e 91e0 0bb5 	LDS  R30,__FF_PART_ADDR
000f20 91f0 0bb6 	LDS  R31,__FF_PART_ADDR+1
000f22 9160 0bb7 	LDS  R22,__FF_PART_ADDR+2
000f24 9170 0bb8 	LDS  R23,__FF_PART_ADDR+3
000f26 81a8
000f27 81b9
000f28 818a
000f29 819b      	__GETD2S 0
000f2a 940e 1f1a 	CALL __CPD12
000f2c f018      	BRLO _0x18E
                 ;    2334 		return (0);
000f2d e0e0      	LDI  R30,LOW(0)
000f2e e0f0      	LDI  R31,HIGH(0)
000f2f c470      	RJMP _0x421
                 ;    2335 	clus_addr -= _FF_PART_ADDR;
                 _0x18E:
000f30 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
000f32 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
000f34 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
000f36 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
000f38 81e8
000f39 81f9
000f3a 816a
000f3b 817b      	__GETD1S 0
000f3c 940e 1dd4 	CALL __SUBD12
000f3e 83e8
000f3f 83f9
000f40 836a
000f41 837b      	__PUTD1S 0
                 ;    2336 	clus_addr /= BPB_BytsPerSec;
000f42 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000f44 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000f46 81a8
000f47 81b9
000f48 818a
000f49 819b      	__GETD2S 0
000f4a 2766      	CLR  R22
000f4b 2777      	CLR  R23
000f4c 940e 1e65 	CALL __DIVD21U
000f4e 83e8
000f4f 83f9
000f50 836a
000f51 837b      	__PUTD1S 0
                 ;    2337 	if (clus_addr <= (unsigned long) FirstDataSector)
000f52 91e0 0bcd 	LDS  R30,_FirstDataSector
000f54 91f0 0bce 	LDS  R31,_FirstDataSector+1
000f56 2766      	CLR  R22
000f57 2777      	CLR  R23
000f58 81a8
000f59 81b9
000f5a 818a
000f5b 819b      	__GETD2S 0
000f5c 940e 1f1a 	CALL __CPD12
000f5e f018      	BRLO _0x18F
                 ;    2338 		return (0);
000f5f e0e0      	LDI  R30,LOW(0)
000f60 e0f0      	LDI  R31,HIGH(0)
000f61 c43e      	RJMP _0x421
                 ;    2339 	clus_addr -= FirstDataSector;
                 _0x18F:
000f62 91e0 0bcd 	LDS  R30,_FirstDataSector
000f64 91f0 0bce 	LDS  R31,_FirstDataSector+1
000f66 81a8
000f67 81b9
000f68 818a
000f69 819b      	__GETD2S 0
000f6a 2766      	CLR  R22
000f6b 2777      	CLR  R23
000f6c 940e 1dd9 	CALL __SUBD21
000f6e 83a8
000f6f 83b9
000f70 838a
000f71 839b      	__PUTD2S 0
                 ;    2340 	clus_addr /= BPB_SecPerClus;
000f72 91e0 0b98 	LDS  R30,_BPB_SecPerClus
000f74 81a8
000f75 81b9
000f76 818a
000f77 819b      	__GETD2S 0
000f78 27ff      	CLR  R31
000f79 2766      	CLR  R22
000f7a 2777      	CLR  R23
000f7b 940e 1e65 	CALL __DIVD21U
000f7d 83e8
000f7e 83f9
000f7f 836a
000f80 837b      	__PUTD1S 0
                 ;    2341 	clus_addr += 2;
000f81 5fee
000f82 4fff
000f83 4f6f
000f84 4f7f      	__ADDD1N 2
000f85 83e8
000f86 83f9
000f87 836a
000f88 837b      	__PUTD1S 0
                 ;    2342 	if (clus_addr > 0xFFFF)
000f89 81a8
000f8a 81b9
000f8b 818a
000f8c 819b      	__GETD2S 0
000f8d 30a0
000f8e e0e0
000f8f 07be
000f90 e0e1
000f91 078e
000f92 e0e0
000f93 079e      	__CPD2N 0x10000
000f94 f018      	BRLO _0x190
                 ;    2343 		return (0);
000f95 e0e0      	LDI  R30,LOW(0)
000f96 e0f0      	LDI  R31,HIGH(0)
000f97 c408      	RJMP _0x421
                 ;    2344 	
                 ;    2345 	return ((int) clus_addr);	
                 _0x190:
000f98 81e8      	LD   R30,Y
000f99 81f9      	LDD  R31,Y+1
000f9a c405      	RJMP _0x421
                 ;    2346 }
                 ;    2347 
                 ;    2348 // Find the cluster that the current cluster is pointing to
                 ;    2349 unsigned int next_cluster(unsigned int current_cluster, unsigned char mode)
                 ;    2350 {
                 _next_cluster:
                 ;    2351 	unsigned int calc_sec, calc_offset, calc_remainder, next_clust;
                 ;    2352 	unsigned long addr_temp;
                 ;    2353 	
                 ;    2354 	if (current_cluster<=1)		// If cluster is 0 or 1, its the wrong cluster
000f9b 9726      	SBIW R28,6
000f9c 940e 1f24 	CALL __SAVELOCR6
                 ;	current_cluster -> Y+13
                 ;	mode -> Y+12
                 ;	calc_sec -> R16,R17
                 ;	calc_offset -> R18,R19
                 ;	calc_remainder -> R20,R21
                 ;	next_clust -> Y+10
                 ;	addr_temp -> Y+6
000f9e 85ad      	LDD  R26,Y+13
000f9f 85be      	LDD  R27,Y+13+1
000fa0 9712      	SBIW R26,2
000fa1 f418      	BRSH _0x191
                 ;    2355 		return (EOF);
000fa2 efef      	LDI  R30,LOW(65535)
000fa3 efff      	LDI  R31,HIGH(65535)
000fa4 c0c7      	RJMP _0x425
                 ;    2356 		
                 ;    2357 	if (BPB_FATType == 0x36)		// if FAT16
                 _0x191:
000fa5 91a0 0ba0 	LDS  R26,_BPB_FATType
000fa7 33a6      	CPI  R26,LOW(0x36)
000fa8 f011      	BREQ PC+3
000fa9 940c 1067 	JMP _0x192
                 ;    2358 	{
                 ;    2359 		// FAT16 table address calculations
                 ;    2360 		calc_sec = current_cluster / (BPB_BytsPerSec / 2) + BPB_RsvdSecCnt;
000fab 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000fad 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000faf 95f6      	LSR  R31
000fb0 95e7      	ROR  R30
000fb1 85ad      	LDD  R26,Y+13
000fb2 85be      	LDD  R27,Y+13+1
000fb3 940e 1e52 	CALL __DIVW21U
000fb5 91a0 0b99 	LDS  R26,_BPB_RsvdSecCnt
000fb7 91b0 0b9a 	LDS  R27,_BPB_RsvdSecCnt+1
000fb9 0fea      	ADD  R30,R26
000fba 1ffb      	ADC  R31,R27
000fbb 018f      	MOVW R16,R30
                 ;    2361 		calc_offset = 2 * (current_cluster % (BPB_BytsPerSec / 2));
000fbc 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
000fbe 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
000fc0 95f6      	LSR  R31
000fc1 95e7      	ROR  R30
000fc2 85ad      	LDD  R26,Y+13
000fc3 85be      	LDD  R27,Y+13+1
000fc4 940e 1e90 	CALL __MODW21U
000fc6 0fee      	LSL  R30
000fc7 1fff      	ROL  R31
000fc8 019f      	MOVW R18,R30
                 ;    2362 	    
                 ;    2363 	 	addr_temp = _FF_PART_ADDR+(calc_sec*0x200);
000fc9 01f8      	MOVW R30,R16
000fca 0fee      	LSL  R30
000fcb 1fff      	ROL  R31
000fcc 2ffe      	MOV  R31,R30
000fcd e0e0      	LDI  R30,0
000fce 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
000fd0 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
000fd2 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
000fd4 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
000fd6 2766      	CLR  R22
000fd7 2777      	CLR  R23
000fd8 940e 1dca 	CALL __ADDD12
000fda 83ee
000fdb 83ff
000fdc 8768
000fdd 8779      	__PUTD1S 6
                 ;    2364 		if (mode==SINGLE)
000fde 85ac      	LDD  R26,Y+12
000fdf 30a1      	CPI  R26,LOW(0x1)
000fe0 f451      	BRNE _0x193
                 ;    2365 		{	// This is a single cluster lookup
                 ;    2366 			if (_FF_read(addr_temp)==0)
000fe1 940e 1ecb 	CALL __PUTPARD1
000fe3 940e 0b52 	CALL __FF_read
000fe5 30e0      	CPI  R30,0
000fe6 f419      	BRNE _0x194
                 ;    2367 				return(EOF);
000fe7 efef      	LDI  R30,LOW(65535)
000fe8 efff      	LDI  R31,HIGH(65535)
000fe9 c082      	RJMP _0x425
                 ;    2368 		}
                 _0x194:
                 ;    2369 		else if ((mode==CHAIN) || (mode==END_CHAIN))
000fea c06a      	RJMP _0x195
                 _0x193:
000feb 85ac      	LDD  R26,Y+12
000fec 30a0      	CPI  R26,LOW(0x0)
000fed f019      	BREQ _0x197
000fee 30a2      	CPI  R26,LOW(0x2)
000fef f009      	BREQ _0x197
000ff0 c064      	RJMP _0x196
                 _0x197:
                 ;    2370 		{	// Mupltiple clusters to lookup
                 ;    2371 			if (addr_temp!=_FF_buff_addr)
000ff1 91e0 0bd4 	LDS  R30,__FF_buff_addr
000ff3 91f0 0bd5 	LDS  R31,__FF_buff_addr+1
000ff5 9160 0bd6 	LDS  R22,__FF_buff_addr+2
000ff7 9170 0bd7 	LDS  R23,__FF_buff_addr+3
000ff9 81ae
000ffa 81bf
000ffb 8588
000ffc 8599      	__GETD2S 6
000ffd 940e 1f1a 	CALL __CPD12
000fff f411      	BRNE PC+3
001000 940c 1055 	JMP _0x199
                 ;    2372 			{	// Is the address of lookup is different then the current buffere address
                 ;    2373 				#ifndef _READ_ONLY_
                 ;    2374 				if (_FF_buff_addr)	// if the buffer address is 0, don't write
001002 940e 1f0c 	CALL __CPD10
001004 f411      	BRNE PC+3
001005 940c 1048 	JMP _0x19A
                 ;    2375 				{
                 ;    2376 					#ifdef _SECOND_FAT_ON_
                 ;    2377 						if (_FF_buff_addr < _FF_FAT2_ADDR)
001007 91e0 0bc5 	LDS  R30,__FF_FAT2_ADDR
001009 91f0 0bc6 	LDS  R31,__FF_FAT2_ADDR+1
00100b 9160 0bc7 	LDS  R22,__FF_FAT2_ADDR+2
00100d 9170 0bc8 	LDS  R23,__FF_FAT2_ADDR+3
00100f 91a0 0bd4 	LDS  R26,__FF_buff_addr
001011 91b0 0bd5 	LDS  R27,__FF_buff_addr+1
001013 9180 0bd6 	LDS  R24,__FF_buff_addr+2
001015 9190 0bd7 	LDS  R25,__FF_buff_addr+3
001017 940e 1f1f 	CALL __CPD21
001019 f4e8      	BRSH _0x19B
                 ;    2378 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
00101a 91a0 0bc1 	LDS  R26,__FF_FAT1_ADDR
00101c 91b0 0bc2 	LDS  R27,__FF_FAT1_ADDR+1
00101e 9180 0bc3 	LDS  R24,__FF_FAT1_ADDR+2
001020 9190 0bc4 	LDS  R25,__FF_FAT1_ADDR+3
001022 940e 1dd4 	CALL __SUBD12
001024 91a0 0bd4 	LDS  R26,__FF_buff_addr
001026 91b0 0bd5 	LDS  R27,__FF_buff_addr+1
001028 9180 0bd6 	LDS  R24,__FF_buff_addr+2
00102a 9190 0bd7 	LDS  R25,__FF_buff_addr+3
00102c 940e 1dca 	CALL __ADDD12
00102e 940e 1ecb 	CALL __PUTPARD1
001030 940e 0bf9 	CALL __FF_write
001032 30e0      	CPI  R30,0
001033 f419      	BRNE _0x19C
                 ;    2379 								return(EOF);
001034 efef      	LDI  R30,LOW(65535)
001035 efff      	LDI  R31,HIGH(65535)
001036 c035      	RJMP _0x425
                 ;    2380 					#endif
                 ;    2381 					if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
                 _0x19C:
                 _0x19B:
001037 91e0 0bd4 	LDS  R30,__FF_buff_addr
001039 91f0 0bd5 	LDS  R31,__FF_buff_addr+1
00103b 9160 0bd6 	LDS  R22,__FF_buff_addr+2
00103d 9170 0bd7 	LDS  R23,__FF_buff_addr+3
00103f 940e 1ecb 	CALL __PUTPARD1
001041 940e 0bf9 	CALL __FF_write
001043 30e0      	CPI  R30,0
001044 f419      	BRNE _0x19D
                 ;    2382 						return(EOF);
001045 efef      	LDI  R30,LOW(65535)
001046 efff      	LDI  R31,HIGH(65535)
001047 c024      	RJMP _0x425
                 ;    2383 				}
                 _0x19D:
                 ;    2384 				#endif
                 ;    2385 				if (_FF_read(addr_temp)==0)	// Read new table info
                 _0x19A:
001048 81ee
001049 81ff
00104a 8568
00104b 8579      	__GETD1S 6
00104c 940e 1ecb 	CALL __PUTPARD1
00104e 940e 0b52 	CALL __FF_read
001050 30e0      	CPI  R30,0
001051 f419      	BRNE _0x19E
                 ;    2386 					return(EOF);
001052 efef      	LDI  R30,LOW(65535)
001053 efff      	LDI  R31,HIGH(65535)
001054 c017      	RJMP _0x425
                 ;    2387 			}
                 _0x19E:
                 ;    2388 		}
                 _0x199:
                 ;    2389 		next_clust = ((int) _FF_buff[calc_offset+1] << 8) | _FF_buff[calc_offset];
                 _0x196:
                 _0x195:
001055 01f9      	MOVW R30,R18
001056 56ef
001057 4ff6      	__ADDW1MN __FF_buff,1
001058 81f0      	LD   R31,Z
001059 e0e0      	LDI  R30,LOW(0)
00105a 010f      	MOVW R0,R30
00105b e9a0      	LDI  R26,LOW(__FF_buff)
00105c e0b9      	LDI  R27,HIGH(__FF_buff)
00105d 0fa2      	ADD  R26,R18
00105e 1fb3      	ADC  R27,R19
00105f 91ec      	LD   R30,X
001060 01d0      	MOVW R26,R0
001061 e0f0      	LDI  R31,0
001062 2bea      	OR   R30,R26
001063 2bfb      	OR   R31,R27
001064 87ea      	STD  Y+10,R30
001065 87fb      	STD  Y+10+1,R31
                 ;    2390 	}
                 ;    2391 	#ifdef _FAT12_ON_
                 ;    2392 	else if (BPB_FATType == 0x32)	// if FAT12
                 ;    2393 	{
                 ;    2394 		// FAT12 table address calculations
                 ;    2395 		calc_offset = (current_cluster * 3) / 2;
                 ;    2396 		calc_remainder = (current_cluster * 3) % 2;
                 ;    2397 		calc_sec = (calc_offset / BPB_BytsPerSec) + BPB_RsvdSecCnt;
                 ;    2398 		calc_offset %= BPB_BytsPerSec;
                 ;    2399 
                 ;    2400 	 	addr_temp = _FF_PART_ADDR+(calc_sec*BPB_BytsPerSec);
                 ;    2401 		if (mode==SINGLE)
                 ;    2402 		{	// This is a single cluster lookup
                 ;    2403 			if (_FF_read(addr_temp)==0)
                 ;    2404 				return(EOF);
                 ;    2405 		}
                 ;    2406 		else if ((mode==CHAIN) || (mode==END_CHAIN))
                 ;    2407 		{	// Mupltiple clusters to lookup
                 ;    2408 			if (addr_temp!=_FF_buff_addr)
                 ;    2409 			{	// Is the address of lookup is different then the current buffere address
                 ;    2410 				#ifndef _READ_ONLY_
                 ;    2411 				if (_FF_buff_addr)	// if the buffer address is 0, don't write
                 ;    2412 				{
                 ;    2413 					#ifdef _SECOND_FAT_ON_
                 ;    2414 						if (_FF_buff_addr < _FF_FAT2_ADDR)
                 ;    2415 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2416 								return(EOF);
                 ;    2417 					#endif
                 ;    2418 					if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
                 ;    2419 						return(EOF);
                 ;    2420 				}
                 ;    2421 				#endif
                 ;    2422 				if (_FF_read(addr_temp)==0)	// Read new table info
                 ;    2423 					return(EOF);
                 ;    2424 			}
                 ;    2425 		}
                 ;    2426 		next_clust = _FF_buff[calc_offset];
                 ;    2427 		if (calc_offset == (BPB_BytsPerSec-1))
                 ;    2428 		{	// Is the FAT12 record accross more than one sector?
                 ;    2429 			addr_temp = _FF_PART_ADDR+((calc_sec+1)*0x200);
                 ;    2430 			if ((mode==CHAIN) || (mode==END_CHAIN))
                 ;    2431 			{	// multiple chain lookup
                 ;    2432 				#ifndef _READ_ONLY_
                 ;    2433 					#ifdef _SECOND_FAT_ON_
                 ;    2434 						if (_FF_buff_addr < _FF_FAT2_ADDR)
                 ;    2435 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2436 								return(EOF);
                 ;    2437 					#endif
                 ;    2438 				if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
                 ;    2439 					return(EOF);
                 ;    2440 				#endif
                 ;    2441 				_FF_buff_addr = addr_temp;		// Save new buffer address
                 ;    2442 			}
                 ;    2443 			if (_FF_read(addr_temp)==0)
                 ;    2444 				return(EOF);
                 ;    2445 			next_clust |= ((int) _FF_buff[0] << 8);
                 ;    2446 		}
                 ;    2447 		else
                 ;    2448 			next_clust |= ((int) _FF_buff[calc_offset+1] << 8);
                 ;    2449 
                 ;    2450 		if (calc_remainder)
                 ;    2451 			next_clust >>= 4;
                 ;    2452 		else
                 ;    2453 			next_clust &= 0x0FFF;
                 ;    2454 			
                 ;    2455 		if (next_clust >= 0xFF8)
                 ;    2456 			next_clust |= 0xF000;			
                 ;    2457 	}
                 ;    2458 	#endif
                 ;    2459 	else		// not FAT12 or FAT16, return 0
001066 c003      	RJMP _0x19F
                 _0x192:
                 ;    2460 		return (EOF);
001067 efef      	LDI  R30,LOW(65535)
001068 efff      	LDI  R31,HIGH(65535)
001069 c002      	RJMP _0x425
                 ;    2461 	return (next_clust);
                 _0x19F:
00106a 85ea      	LDD  R30,Y+10
00106b 85fb      	LDD  R31,Y+10+1
                 _0x425:
00106c 940e 1f2b 	CALL __LOADLOCR6
00106e 962f      	ADIW R28,15
00106f 9508      	RET
                 ;    2462 }
                 ;    2463 
                 ;    2464 // Convert a constant string file name into the proper 8.3 FAT format
                 ;    2465 unsigned char *file_name_conversion(unsigned char *current_file)
                 ;    2466 {
                 _file_name_conversion:
                 ;    2467 	unsigned char n, c;
                 ;    2468 		
                 ;    2469 	c = 0;
001070 931a      	ST   -Y,R17
001071 930a      	ST   -Y,R16
                 ;	*current_file -> Y+2
                 ;	n -> R16
                 ;	c -> R17
001072 e010      	LDI  R17,LOW(0)
                 ;    2470 	
                 ;    2471 	for (n=0; n<14; n++)
001073 e000      	LDI  R16,LOW(0)
                 _0x1A1:
001074 300e      	CPI  R16,14
001075 f010      	BRLO PC+3
001076 940c 10cf 	JMP _0x1A2
                 ;    2472 	{
                 ;    2473 		if (valid_file_char(current_file[n])==0)
001078 2fe0      	MOV  R30,R16
001079 81aa      	LDD  R26,Y+2
00107a 81bb      	LDD  R27,Y+2+1
00107b e0f0      	LDI  R31,0
00107c 0fae      	ADD  R26,R30
00107d 1fbf      	ADC  R27,R31
00107e 91ec      	LD   R30,X
00107f 93ea      	ST   -Y,R30
001080 940e 0c88 	CALL _valid_file_char
001082 9730      	SBIW R30,0
001083 f4a9      	BRNE _0x1A3
                 ;    2474 			// If the character is valid, save in uppercase to file name buffer
                 ;    2475 			FILENAME[c++] = toupper(current_file[n]);
001084 2fe1      	MOV  R30,R17
001085 5f1f      	SUBI R17,-1
001086 e0f0      	LDI  R31,0
001087 5aef      	SUBI R30,LOW(-_FILENAME)
001088 4ff3      	SBCI R31,HIGH(-_FILENAME)
001089 93ff      	PUSH R31
00108a 93ef      	PUSH R30
00108b 2fe0      	MOV  R30,R16
00108c 81aa      	LDD  R26,Y+2
00108d 81bb      	LDD  R27,Y+2+1
00108e e0f0      	LDI  R31,0
00108f 0fae      	ADD  R26,R30
001090 1fbf      	ADC  R27,R31
001091 91ec      	LD   R30,X
001092 93ea      	ST   -Y,R30
001093 940e 1db7 	CALL _toupper
001095 91af      	POP  R26
001096 91bf      	POP  R27
001097 93ec      	ST   X,R30
                 ;    2476 		else if (current_file[n]=='.')
001098 c032      	RJMP _0x1A4
                 _0x1A3:
001099 2fe0      	MOV  R30,R16
00109a 81aa      	LDD  R26,Y+2
00109b 81bb      	LDD  R27,Y+2+1
00109c e0f0      	LDI  R31,0
00109d 0fae      	ADD  R26,R30
00109e 1fbf      	ADC  R27,R31
00109f 91ac      	LD   R26,X
0010a0 32ae      	CPI  R26,LOW(0x2E)
0010a1 f461      	BRNE _0x1A5
                 ;    2477 			// If it is a period, back fill buffer with [spaces], till 8 characters deep
                 ;    2478 			while (c<8)
                 _0x1A6:
0010a2 3018      	CPI  R17,8
0010a3 f448      	BRSH _0x1A8
                 ;    2479 				FILENAME[c++] = 0x20;
0010a4 2fe1      	MOV  R30,R17
0010a5 5f1f      	SUBI R17,-1
0010a6 e0f0      	LDI  R31,0
0010a7 5aef      	SUBI R30,LOW(-_FILENAME)
0010a8 4ff3      	SBCI R31,HIGH(-_FILENAME)
0010a9 01df      	MOVW R26,R30
0010aa e2e0      	LDI  R30,LOW(32)
0010ab 93ec      	ST   X,R30
                 ;    2480 		else if (current_file[n]==0)
0010ac cff5      	RJMP _0x1A6
                 _0x1A8:
0010ad c01d      	RJMP _0x1A9
                 _0x1A5:
0010ae 2fe0      	MOV  R30,R16
0010af 81aa      	LDD  R26,Y+2
0010b0 81bb      	LDD  R27,Y+2+1
0010b1 e0f0      	LDI  R31,0
0010b2 0fae      	ADD  R26,R30
0010b3 1fbf      	ADC  R27,R31
0010b4 91ec      	LD   R30,X
0010b5 30e0      	CPI  R30,0
0010b6 f461      	BRNE _0x1AA
                 ;    2481 		{	// If it is NULL, back fill buffer with [spaces], till 11 characters deep
                 ;    2482 			while (c<11)
                 _0x1AB:
0010b7 301b      	CPI  R17,11
0010b8 f448      	BRSH _0x1AD
                 ;    2483 				FILENAME[c++] = 0x20;
0010b9 2fe1      	MOV  R30,R17
0010ba 5f1f      	SUBI R17,-1
0010bb e0f0      	LDI  R31,0
0010bc 5aef      	SUBI R30,LOW(-_FILENAME)
0010bd 4ff3      	SBCI R31,HIGH(-_FILENAME)
0010be 01df      	MOVW R26,R30
0010bf e2e0      	LDI  R30,LOW(32)
0010c0 93ec      	ST   X,R30
                 ;    2484 			break;
0010c1 cff5      	RJMP _0x1AB
                 _0x1AD:
0010c2 c00c      	RJMP _0x1A2
                 ;    2485 		}
                 ;    2486 		else
                 _0x1AA:
                 ;    2487 		{
                 ;    2488 			_FF_error = NAME_ERR;
0010c3 e0e5      	LDI  R30,LOW(5)
0010c4 93e0 0bd3 	STS  __FF_error,R30
                 ;    2489 			return (0);
0010c6 e0e0      	LDI  R30,LOW(0)
0010c7 e0f0      	LDI  R31,HIGH(0)
0010c8 8119      	LDD  R17,Y+1
0010c9 8108      	LDD  R16,Y+0
0010ca c2d5      	RJMP _0x421
                 ;    2490 		}
                 _0x1A9:
                 _0x1A4:
                 ;    2491 		if (c>=11)
0010cb 301b      	CPI  R17,11
0010cc f410      	BRSH _0x1A2
                 ;    2492 			break;
                 ;    2493 	}
0010cd 5f0f      	SUBI R16,-1
0010ce cfa5      	RJMP _0x1A1
                 _0x1A2:
                 ;    2494 	FILENAME[c] = 0;
0010cf 2fa1      	MOV  R26,R17
0010d0 e0b0      	LDI  R27,0
0010d1 5aaf      	SUBI R26,LOW(-_FILENAME)
0010d2 4fb3      	SBCI R27,HIGH(-_FILENAME)
0010d3 e0e0      	LDI  R30,LOW(0)
0010d4 93ec      	ST   X,R30
                 ;    2495 	// Return the pointer of the filename
                 ;    2496 	return (FILENAME);		
0010d5 e5e1      	LDI  R30,LOW(_FILENAME)
0010d6 e0fc      	LDI  R31,HIGH(_FILENAME)
0010d7 8119      	LDD  R17,Y+1
0010d8 8108      	LDD  R16,Y+0
0010d9 c2c6      	RJMP _0x421
                 ;    2497 }
                 ;    2498 
                 ;    2499 // Find the first cluster that is pointing to clus_no
                 ;    2500 unsigned int prev_cluster(unsigned int clus_no)
                 ;    2501 {
                 ;    2502 	unsigned char read_flag;
                 ;    2503 	unsigned int calc_temp, n, c, n_temp;
                 ;    2504 	unsigned long calc_clus, addr_temp;
                 ;    2505 	
                 ;    2506 	addr_temp = _FF_FAT1_ADDR;
                 ;	clus_no -> Y+17
                 ;	read_flag -> R16
                 ;	calc_temp -> R17,R18
                 ;	n -> R19,R20
                 ;	c -> Y+15
                 ;	n_temp -> Y+13
                 ;	calc_clus -> Y+9
                 ;	addr_temp -> Y+5
                 ;    2507 	c = 1;
                 ;    2508 	if ((clus_no==0) && (BPB_FATType==0x36))
                 ;    2509 	{
                 ;    2510 		if (clus_0_addr>addr_temp)
                 ;    2511 		{
                 ;    2512 			addr_temp = clus_0_addr;
                 ;    2513 			c = c_counter;
                 ;    2514 		}
                 ;    2515 	}
                 ;    2516 
                 ;    2517 	read_flag = 1;
                 ;    2518 	
                 ;    2519 	while (addr_temp<_FF_FAT2_ADDR)
                 ;    2520 	{
                 ;    2521 		if (BPB_FATType == 0x36)		// if FAT16
                 ;    2522 		{
                 ;    2523 			if (clus_no==0)
                 ;    2524 			{
                 ;    2525 				clus_0_addr = addr_temp;
                 ;    2526 				c_counter = c;
                 ;    2527 			}
                 ;    2528 			if (_FF_read(addr_temp)==0)		// Read error ==> break
                 ;    2529 				return(0);
                 ;    2530 			if (_FF_n_temp)
                 ;    2531 			{
                 ;    2532 				n_temp = _FF_n_temp;
                 ;    2533 				_FF_n_temp = 0;
                 ;    2534 			}
                 ;    2535 			else
                 ;    2536 				n_temp = 0;
                 ;    2537 			for (n=n_temp; n<(BPB_BytsPerSec/2); n++)
                 ;    2538 			{
                 ;    2539 				calc_clus = ((unsigned int) _FF_buff[(n*2)+1] << 8) | ((unsigned int) _FF_buff[n*2]);
                 ;    2540 				calc_temp = (unsigned long) n + (((unsigned long) BPB_BytsPerSec/2) * ((unsigned long) c - 1));
                 ;    2541 				if (calc_clus==clus_no)
                 ;    2542 				{
                 ;    2543 					if (calc_clus==0)
                 ;    2544 						_FF_n_temp = n;
                 ;    2545 					return(calc_temp);
                 ;    2546 				}
                 ;    2547 				else if (calc_temp > DataClusTot)
                 ;    2548 				{
                 ;    2549 					_FF_error = DISK_FULL;
                 ;    2550 					return (0);
                 ;    2551 				}
                 ;    2552 			}
                 ;    2553 			addr_temp += 0x200;
                 ;    2554 			c++;
                 ;    2555 		}
                 ;    2556 		#ifdef _FAT12_ON_
                 ;    2557 		else if (BPB_FATType == 0x32)	// if FAT12
                 ;    2558 		{
                 ;    2559 			if (read_flag)
                 ;    2560 			{
                 ;    2561 				if (_FF_read(addr_temp)==0)
                 ;    2562 					return (0);	// if the read fails return 0
                 ;    2563 				read_flag = 0;
                 ;    2564 			}
                 ;    2565 			calc_temp = ((unsigned long) c * 3) / 2;
                 ;    2566 			calc_temp %= BPB_BytsPerSec;
                 ;    2567 			calc_clus = _FF_buff[calc_temp++];
                 ;    2568 			if (calc_temp == BPB_BytsPerSec)
                 ;    2569 			{	// Is the FAT12 record accross a sector?
                 ;    2570 				addr_temp += 0x200;
                 ;    2571 				if (_FF_read(addr_temp)==0)
                 ;    2572 					return (0);
                 ;    2573 				calc_clus |= ((unsigned int) _FF_buff[0] << 8);
                 ;    2574 				calc_temp = 0;
                 ;    2575 			}
                 ;    2576 			else
                 ;    2577 				calc_clus |= ((unsigned int) _FF_buff[calc_temp++] << 8);
                 ;    2578                           	
                 ;    2579 			if (c % 2)
                 ;    2580 				calc_clus >>= 4;
                 ;    2581 			else
                 ;    2582 				calc_clus &= 0x0FFF;
                 ;    2583 			
                 ;    2584 			if (calc_clus == clus_no)
                 ;    2585 				return (c);
                 ;    2586 			else if (c > DataClusTot)
                 ;    2587 			{
                 ;    2588 				_FF_error = DISK_FULL;
                 ;    2589 				return (0);
                 ;    2590 			}
                 ;    2591 			if ((calc_temp == BPB_BytsPerSec) && (c % 2))
                 ;    2592 			{
                 ;    2593 				addr_temp += 0x200;
                 ;    2594 				read_flag = 1;
                 ;    2595 			}                                                           
                 ;    2596 			
                 ;    2597 			c++;			
                 ;    2598 		}
                 ;    2599 		#endif
                 ;    2600 		else
                 ;    2601 			return (0);
                 ;    2602 	}
                 ;    2603 	_FF_error = DISK_FULL;
                 ;    2604 	return (0);
                 ;    2605 }
                 ;    2606 
                 ;    2607 #ifndef _READ_ONLY_
                 ;    2608 // Update cluster table to point to new cluster
                 ;    2609 unsigned char write_clus_table(unsigned int current_cluster, unsigned int next_value, unsigned char mode)
                 ;    2610 {
                 _write_clus_table:
                 ;    2611 	unsigned long addr_temp;
                 ;    2612 	unsigned int calc_sec, calc_offset, calc_temp, calc_remainder;
                 ;    2613 	unsigned char nibble[3];
                 ;    2614 	
                 ;    2615 	if (current_cluster <=1)		// Should never be writing to cluster 0 or 1
0010da 9729      	SBIW R28,9
0010db 940e 1f24 	CALL __SAVELOCR6
                 ;	current_cluster -> Y+18
                 ;	next_value -> Y+16
                 ;	mode -> Y+15
                 ;	addr_temp -> Y+11
                 ;	calc_sec -> R16,R17
                 ;	calc_offset -> R18,R19
                 ;	calc_temp -> R20,R21
                 ;	calc_remainder -> Y+9
                 ;	nibble -> Y+6
0010dd 89aa      	LDD  R26,Y+18
0010de 89bb      	LDD  R27,Y+18+1
0010df 9712      	SBIW R26,2
0010e0 f410      	BRSH _0x1C4
                 ;    2616 	{
                 ;    2617 		return (0);
0010e1 e0e0      	LDI  R30,LOW(0)
0010e2 c0f1      	RJMP _0x424
                 ;    2618 	}
                 ;    2619 	if (BPB_FATType == 0x36)		// if FAT16
                 _0x1C4:
0010e3 91a0 0ba0 	LDS  R26,_BPB_FATType
0010e5 33a6      	CPI  R26,LOW(0x36)
0010e6 f011      	BREQ PC+3
0010e7 940c 11d1 	JMP _0x1C5
                 ;    2620 	{
                 ;    2621 		calc_sec = current_cluster / (BPB_BytsPerSec / 2) + BPB_RsvdSecCnt;
0010e9 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0010eb 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0010ed 95f6      	LSR  R31
0010ee 95e7      	ROR  R30
0010ef 89aa      	LDD  R26,Y+18
0010f0 89bb      	LDD  R27,Y+18+1
0010f1 940e 1e52 	CALL __DIVW21U
0010f3 91a0 0b99 	LDS  R26,_BPB_RsvdSecCnt
0010f5 91b0 0b9a 	LDS  R27,_BPB_RsvdSecCnt+1
0010f7 0fea      	ADD  R30,R26
0010f8 1ffb      	ADC  R31,R27
0010f9 018f      	MOVW R16,R30
                 ;    2622 		calc_offset = 2 * (current_cluster % (BPB_BytsPerSec / 2));
0010fa 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0010fc 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0010fe 95f6      	LSR  R31
0010ff 95e7      	ROR  R30
001100 89aa      	LDD  R26,Y+18
001101 89bb      	LDD  R27,Y+18+1
001102 940e 1e90 	CALL __MODW21U
001104 0fee      	LSL  R30
001105 1fff      	ROL  R31
001106 019f      	MOVW R18,R30
                 ;    2623 		addr_temp = _FF_PART_ADDR + ((long) calc_sec*0x200);
001107 01f8      	MOVW R30,R16
001108 2766      	CLR  R22
001109 2777      	CLR  R23
00110a e0a0
00110b e0b2
00110c e080
00110d e090      	__GETD2N 0x200
00110e 940e 1e4d 	CALL __MULD12
001110 91a0 0bb5 	LDS  R26,__FF_PART_ADDR
001112 91b0 0bb6 	LDS  R27,__FF_PART_ADDR+1
001114 9180 0bb7 	LDS  R24,__FF_PART_ADDR+2
001116 9190 0bb8 	LDS  R25,__FF_PART_ADDR+3
001118 940e 1dca 	CALL __ADDD12
00111a 87eb
00111b 87fc
00111c 876d
00111d 877e      	__PUTD1S 11
                 ;    2624 		if (mode==SINGLE)
00111e 85af      	LDD  R26,Y+15
00111f 30a1      	CPI  R26,LOW(0x1)
001120 f449      	BRNE _0x1C6
                 ;    2625 		{	// Updating a single cluster (like writing or saving a file)
                 ;    2626 			if (_FF_read(addr_temp)==0)
001121 940e 1ecb 	CALL __PUTPARD1
001123 940e 0b52 	CALL __FF_read
001125 30e0      	CPI  R30,0
001126 f411      	BRNE _0x1C7
                 ;    2627 				return(0);
001127 e0e0      	LDI  R30,LOW(0)
001128 c0ab      	RJMP _0x424
                 ;    2628 		}
                 _0x1C7:
                 ;    2629 		else if ((mode==CHAIN) || (mode==END_CHAIN))
001129 c067      	RJMP _0x1C8
                 _0x1C6:
00112a 85af      	LDD  R26,Y+15
00112b 30a0      	CPI  R26,LOW(0x0)
00112c f019      	BREQ _0x1CA
00112d 30a2      	CPI  R26,LOW(0x2)
00112e f009      	BREQ _0x1CA
00112f c061      	RJMP _0x1C9
                 _0x1CA:
                 ;    2630 		{	// Multiple table access operation
                 ;    2631 			if (addr_temp!=_FF_buff_addr)
001130 91e0 0bd4 	LDS  R30,__FF_buff_addr
001132 91f0 0bd5 	LDS  R31,__FF_buff_addr+1
001134 9160 0bd6 	LDS  R22,__FF_buff_addr+2
001136 9170 0bd7 	LDS  R23,__FF_buff_addr+3
001138 85ab
001139 85bc
00113a 858d
00113b 859e      	__GETD2S 11
00113c 940e 1f1a 	CALL __CPD12
00113e f411      	BRNE PC+3
00113f 940c 1191 	JMP _0x1CC
                 ;    2632 			{	// if the desired address is already in the buffer => skip loading buffer
                 ;    2633 				if (_FF_buff_addr)	// if new table address, write buffered, and load new
001141 940e 1f0c 	CALL __CPD10
001143 f411      	BRNE PC+3
001144 940c 1185 	JMP _0x1CD
                 ;    2634 				{
                 ;    2635 					#ifdef _SECOND_FAT_ON_
                 ;    2636 						if (_FF_buff_addr < _FF_FAT2_ADDR)
001146 91e0 0bc5 	LDS  R30,__FF_FAT2_ADDR
001148 91f0 0bc6 	LDS  R31,__FF_FAT2_ADDR+1
00114a 9160 0bc7 	LDS  R22,__FF_FAT2_ADDR+2
00114c 9170 0bc8 	LDS  R23,__FF_FAT2_ADDR+3
00114e 91a0 0bd4 	LDS  R26,__FF_buff_addr
001150 91b0 0bd5 	LDS  R27,__FF_buff_addr+1
001152 9180 0bd6 	LDS  R24,__FF_buff_addr+2
001154 9190 0bd7 	LDS  R25,__FF_buff_addr+3
001156 940e 1f1f 	CALL __CPD21
001158 f4e0      	BRSH _0x1CE
                 ;    2637 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
001159 91a0 0bc1 	LDS  R26,__FF_FAT1_ADDR
00115b 91b0 0bc2 	LDS  R27,__FF_FAT1_ADDR+1
00115d 9180 0bc3 	LDS  R24,__FF_FAT1_ADDR+2
00115f 9190 0bc4 	LDS  R25,__FF_FAT1_ADDR+3
001161 940e 1dd4 	CALL __SUBD12
001163 91a0 0bd4 	LDS  R26,__FF_buff_addr
001165 91b0 0bd5 	LDS  R27,__FF_buff_addr+1
001167 9180 0bd6 	LDS  R24,__FF_buff_addr+2
001169 9190 0bd7 	LDS  R25,__FF_buff_addr+3
00116b 940e 1dca 	CALL __ADDD12
00116d 940e 1ecb 	CALL __PUTPARD1
00116f 940e 0bf9 	CALL __FF_write
001171 30e0      	CPI  R30,0
001172 f411      	BRNE _0x1CF
                 ;    2638 								return(0);
001173 e0e0      	LDI  R30,LOW(0)
001174 c05f      	RJMP _0x424
                 ;    2639 					#endif
                 ;    2640 					if (_FF_write(_FF_buff_addr)==0)
                 _0x1CF:
                 _0x1CE:
001175 91e0 0bd4 	LDS  R30,__FF_buff_addr
001177 91f0 0bd5 	LDS  R31,__FF_buff_addr+1
001179 9160 0bd6 	LDS  R22,__FF_buff_addr+2
00117b 9170 0bd7 	LDS  R23,__FF_buff_addr+3
00117d 940e 1ecb 	CALL __PUTPARD1
00117f 940e 0bf9 	CALL __FF_write
001181 30e0      	CPI  R30,0
001182 f411      	BRNE _0x1D0
                 ;    2641 						return(0);
001183 e0e0      	LDI  R30,LOW(0)
001184 c04f      	RJMP _0x424
                 ;    2642 				}
                 _0x1D0:
                 ;    2643 				if (_FF_read(addr_temp)==0)
                 _0x1CD:
001185 85eb
001186 85fc
001187 856d
001188 857e      	__GETD1S 11
001189 940e 1ecb 	CALL __PUTPARD1
00118b 940e 0b52 	CALL __FF_read
00118d 30e0      	CPI  R30,0
00118e f411      	BRNE _0x1D1
                 ;    2644 					return(0);
00118f e0e0      	LDI  R30,LOW(0)
001190 c043      	RJMP _0x424
                 ;    2645 			}
                 _0x1D1:
                 ;    2646 		}
                 _0x1CC:
                 ;    2647 				
                 ;    2648 		_FF_buff[calc_offset+1] = (next_value >> 8); 
                 _0x1C9:
                 _0x1C8:
001191 01f9      	MOVW R30,R18
001192 56ef
001193 4ff6      	__ADDW1MN __FF_buff,1
001194 01df      	MOVW R26,R30
001195 89e9      	LDD  R30,Y+17
001196 70f0      	ANDI R31,HIGH(0x0)
001197 93ec      	ST   X,R30
                 ;    2649 		_FF_buff[calc_offset] = (next_value & 0xFF);
001198 01d9      	MOVW R26,R18
001199 57a0      	SUBI R26,LOW(-__FF_buff)
00119a 4fb6      	SBCI R27,HIGH(-__FF_buff)
00119b 89e8      	LDD  R30,Y+16
00119c 89f9      	LDD  R31,Y+16+1
00119d 70f0      	ANDI R31,HIGH(0xFF)
00119e 93ec      	ST   X,R30
                 ;    2650 		if ((mode==SINGLE) || (mode==END_CHAIN))
00119f 85af      	LDD  R26,Y+15
0011a0 30a1      	CPI  R26,LOW(0x1)
0011a1 f011      	BREQ _0x1D3
0011a2 30a2      	CPI  R26,LOW(0x2)
0011a3 f561      	BRNE _0x1D2
                 _0x1D3:
                 ;    2651 		{
                 ;    2652 			#ifdef _SECOND_FAT_ON_
                 ;    2653 				if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
0011a4 91a0 0bc1 	LDS  R26,__FF_FAT1_ADDR
0011a6 91b0 0bc2 	LDS  R27,__FF_FAT1_ADDR+1
0011a8 9180 0bc3 	LDS  R24,__FF_FAT1_ADDR+2
0011aa 9190 0bc4 	LDS  R25,__FF_FAT1_ADDR+3
0011ac 91e0 0bc5 	LDS  R30,__FF_FAT2_ADDR
0011ae 91f0 0bc6 	LDS  R31,__FF_FAT2_ADDR+1
0011b0 9160 0bc7 	LDS  R22,__FF_FAT2_ADDR+2
0011b2 9170 0bc8 	LDS  R23,__FF_FAT2_ADDR+3
0011b4 940e 1dd4 	CALL __SUBD12
0011b6 85ab
0011b7 85bc
0011b8 858d
0011b9 859e      	__GETD2S 11
0011ba 940e 1dca 	CALL __ADDD12
0011bc 940e 1ecb 	CALL __PUTPARD1
0011be 940e 0bf9 	CALL __FF_write
0011c0 30e0      	CPI  R30,0
0011c1 f411      	BRNE _0x1D5
                 ;    2654 					return(0);
0011c2 e0e0      	LDI  R30,LOW(0)
0011c3 c010      	RJMP _0x424
                 ;    2655 			#endif
                 ;    2656 			if (_FF_write(addr_temp)==0)
                 _0x1D5:
0011c4 85eb
0011c5 85fc
0011c6 856d
0011c7 857e      	__GETD1S 11
0011c8 940e 1ecb 	CALL __PUTPARD1
0011ca 940e 0bf9 	CALL __FF_write
0011cc 30e0      	CPI  R30,0
0011cd f411      	BRNE _0x1D6
                 ;    2657 			{
                 ;    2658 				return(0);
0011ce e0e0      	LDI  R30,LOW(0)
0011cf c004      	RJMP _0x424
                 ;    2659 			}
                 ;    2660 		}
                 _0x1D6:
                 ;    2661 	}
                 _0x1D2:
                 ;    2662 	#ifdef _FAT12_ON_
                 ;    2663 		else if (BPB_FATType == 0x32)		// if FAT12
                 ;    2664 		{
                 ;    2665 			calc_offset = (current_cluster * 3) / 2;
                 ;    2666 			calc_remainder = (current_cluster * 3) % 2;
                 ;    2667 			calc_sec = calc_offset / BPB_BytsPerSec + BPB_RsvdSecCnt;
                 ;    2668 			calc_offset %= BPB_BytsPerSec;
                 ;    2669 			addr_temp = _FF_PART_ADDR + ((long) calc_sec * (long) BPB_BytsPerSec);
                 ;    2670 
                 ;    2671 			if (mode==SINGLE)
                 ;    2672 			{
                 ;    2673 				if (_FF_read(addr_temp)==0)
                 ;    2674 					return(0);
                 ;    2675  			}
                 ;    2676  			else if ((mode==CHAIN) || (mode==END_CHAIN))
                 ;    2677   			{
                 ;    2678 				if (addr_temp!=_FF_buff_addr)
                 ;    2679 				{
                 ;    2680 					if (_FF_buff_addr)
                 ;    2681 					{
                 ;    2682 					#ifdef _SECOND_FAT_ON_
                 ;    2683 						if (_FF_buff_addr < _FF_FAT2_ADDR)
                 ;    2684 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2685 								return(0);
                 ;    2686 					#endif
                 ;    2687 						if (_FF_write(_FF_buff_addr)==0)
                 ;    2688 							return(0);
                 ;    2689 					}
                 ;    2690 					if (_FF_read(addr_temp)==0)
                 ;    2691 						return(0);
                 ;    2692 				}
                 ;    2693 			}
                 ;    2694 			nibble[0] = next_value & 0x00F;
                 ;    2695 			nibble[1] = (next_value >> 4) & 0x00F;
                 ;    2696 			nibble[2] = (next_value >> 8) & 0x00F;
                 ;    2697     	
                 ;    2698 			if (calc_offset == (BPB_BytsPerSec-1))
                 ;    2699 			{	// Is the FAT12 record accross a sector?
                 ;    2700 				if (calc_remainder)
                 ;    2701 				{	// Record table uses 1 nibble of last byte
                 ;    2702 					calc_temp = _FF_buff[calc_offset] & 0x0F;	// Mask to add new value
                 ;    2703 					_FF_buff[calc_offset] = calc_temp | (nibble[0] << 4);	// store nibble in correct location
                 ;    2704 					#ifdef _SECOND_FAT_ON_
                 ;    2705 						if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2706 							return(0);
                 ;    2707 					#endif
                 ;    2708 					if (_FF_write(addr_temp)==0)
                 ;    2709 						return(0);
                 ;    2710 					addr_temp += BPB_BytsPerSec;
                 ;    2711 					if (_FF_read(addr_temp)==0)
                 ;    2712 						return(0);	// if the read fails return 0
                 ;    2713 					_FF_buff[0] = (nibble[2] << 4) | nibble[1];
                 ;    2714 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2715 					{
                 ;    2716 						#ifdef _SECOND_FAT_ON_
                 ;    2717 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2718 								return(0);
                 ;    2719 						#endif
                 ;    2720 						if (_FF_write(addr_temp)==0)
                 ;    2721 							return(0);
                 ;    2722 					}
                 ;    2723 				}
                 ;    2724 				else
                 ;    2725 				{	// Record table uses whole last byte
                 ;    2726 					_FF_buff[calc_offset] = (nibble[1] << 4) | nibble[0];
                 ;    2727 					#ifdef _SECOND_FAT_ON_
                 ;    2728 						if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2729 							return(0);
                 ;    2730 					#endif
                 ;    2731 					if (_FF_write(addr_temp)==0)
                 ;    2732 						return(0);
                 ;    2733 					addr_temp += BPB_BytsPerSec;
                 ;    2734 					if (_FF_read(addr_temp)==0)
                 ;    2735 						return(0);	// if the read fails return 0
                 ;    2736 					calc_temp = _FF_buff[0] & 0xF0;		// Mask to add new value
                 ;    2737 					_FF_buff[0] = calc_temp | nibble[2];	// store nibble in correct location
                 ;    2738 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2739 					{
                 ;    2740 						#ifdef _SECOND_FAT_ON_
                 ;    2741 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2742 								return(0);
                 ;    2743 						#endif
                 ;    2744 						if (_FF_write(addr_temp)==0)
                 ;    2745 							return(0);
                 ;    2746 					}
                 ;    2747 				}
                 ;    2748 			}
                 ;    2749 			else
                 ;    2750 			{
                 ;    2751 				if (calc_remainder)
                 ;    2752 				{	// Record table uses 1 nibble of current byte
                 ;    2753 					calc_temp = _FF_buff[calc_offset] & 0x0F;	// Mask to add new value
                 ;    2754 					_FF_buff[calc_offset] = calc_temp | (nibble[0] << 4);	// store nibble in correct location
                 ;    2755 					_FF_buff[calc_offset+1] = (nibble[2] << 4) | nibble[1];
                 ;    2756 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2757 					{
                 ;    2758 						#ifdef _SECOND_FAT_ON_
                 ;    2759 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2760 								return(0);
                 ;    2761 						#endif
                 ;    2762 						if (_FF_write(addr_temp)==0)
                 ;    2763 							return(0);
                 ;    2764 					}
                 ;    2765 				}
                 ;    2766 				else
                 ;    2767 				{	// Record table uses whole current byte
                 ;    2768 					_FF_buff[calc_offset] = (nibble[1] << 4) | nibble[0];
                 ;    2769 					calc_temp = _FF_buff[calc_offset+1] & 0xF0;		// Mask to add new value
                 ;    2770 					_FF_buff[calc_offset+1] = calc_temp | nibble[2];	// store nibble in correct location
                 ;    2771 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2772 					{
                 ;    2773 						#ifdef _SECOND_FAT_ON_
                 ;    2774 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2775 								return(0);
                 ;    2776 						#endif
                 ;    2777 						if (_FF_write(addr_temp)==0)
                 ;    2778 							return(0);
                 ;    2779 					}
                 ;    2780 				}
                 ;    2781 			}
                 ;    2782 		}
                 ;    2783 	#endif
                 ;    2784 	else		// not FAT12 or FAT16, return 0
0011d0 c002      	RJMP _0x1D7
                 _0x1C5:
                 ;    2785 		return (0);
0011d1 e0e0      	LDI  R30,LOW(0)
0011d2 c001      	RJMP _0x424
                 ;    2786 		
                 ;    2787 	return(1);	
                 _0x1D7:
0011d3 e0e1      	LDI  R30,LOW(1)
                 _0x424:
0011d4 940e 1f2b 	CALL __LOADLOCR6
0011d6 9664      	ADIW R28,20
0011d7 9508      	RET
                 ;    2788 }
                 ;    2789 #endif
                 ;    2790 
                 ;    2791 #ifndef _READ_ONLY_
                 ;    2792 // Save new entry data to FAT entry
                 ;    2793 unsigned char append_toc(FILE *rp)
                 ;    2794 {
                 _append_toc:
                 ;    2795 	unsigned long file_data;
                 ;    2796 	unsigned char n;
                 ;    2797 	unsigned char *fp;
                 ;    2798 	unsigned int calc_temp, calc_date;
                 ;    2799 	
                 ;    2800 	if (rp==NULL)
0011d8 9726      	SBIW R28,6
0011d9 940e 1f25 	CALL __SAVELOCR5
                 ;	*rp -> Y+11
                 ;	file_data -> Y+7
                 ;	n -> R16
                 ;	*fp -> R17,R18
                 ;	calc_temp -> R19,R20
                 ;	calc_date -> Y+5
0011db 85eb      	LDD  R30,Y+11
0011dc 85fc      	LDD  R31,Y+11+1
0011dd 9730      	SBIW R30,0
0011de f411      	BRNE _0x1D8
                 ;    2801 		return (0);
0011df e0e0      	LDI  R30,LOW(0)
0011e0 c0c1      	RJMP _0x423
                 ;    2802 
                 ;    2803 	file_data = rp->length;
                 _0x1D8:
0011e1 85ab      	LDD  R26,Y+11
0011e2 85bc      	LDD  R27,Y+11+1
0011e3 5ea4      	SUBI R26,LOW(-540)
0011e4 4fbd      	SBCI R27,HIGH(-540)
0011e5 940e 1ebc 	CALL __GETD1P
0011e7 83ef
0011e8 87f8
0011e9 8769
0011ea 877a      	__PUTD1S 7
                 ;    2804 	if (_FF_read(rp->entry_sec_addr)==0)
0011eb 85eb      	LDD  R30,Y+11
0011ec 85fc      	LDD  R31,Y+11+1
0011ed 89a6
0011ee 89b7
0011ef 8d80
0011f0 8d91      	__GETD2Z 22
0011f1 940e 1ed0 	CALL __PUTPARD2
0011f3 940e 0b52 	CALL __FF_read
0011f5 30e0      	CPI  R30,0
0011f6 f411      	BRNE _0x1D9
                 ;    2805 		return (0);
0011f7 e0e0      	LDI  R30,LOW(0)
0011f8 c0a9      	RJMP _0x423
                 ;    2806 	
                 ;    2807 	// Update Starting Cluster 
                 ;    2808 	fp = &_FF_buff[rp->entry_offset+0x1a];
                 _0x1D9:
0011f9 85ab      	LDD  R26,Y+11
0011fa 85bc      	LDD  R27,Y+11+1
0011fb 965a      	ADIW R26,26
0011fc 940e 1eb8 	CALL __GETW1P
0011fe 55e6
0011ff 4ff6      	__ADDW1MN __FF_buff,26
001200 2f1e
001201 2f2f      	__PUTW1R 17,18
                 ;    2809 	*fp++ = rp->clus_start & 0xFF;
001202 932f      	PUSH R18
001203 931f      	PUSH R17
001204 5f1f
001205 4f2f      	__ADDWRN 17,18,1
001206 85ab      	LDD  R26,Y+11
001207 85bc      	LDD  R27,Y+11+1
001208 961c      	ADIW R26,12
001209 940e 1eb8 	CALL __GETW1P
00120b 70f0      	ANDI R31,HIGH(0xFF)
00120c 91af      	POP  R26
00120d 91bf      	POP  R27
00120e 93ec      	ST   X,R30
                 ;    2810 	*fp++ = rp->clus_start >> 8;
00120f 932f      	PUSH R18
001210 931f      	PUSH R17
001211 5f1f
001212 4f2f      	__ADDWRN 17,18,1
001213 85ab      	LDD  R26,Y+11
001214 85bc      	LDD  R27,Y+11+1
001215 961c      	ADIW R26,12
001216 940e 1eb8 	CALL __GETW1P
001218 2fef      	MOV  R30,R31
001219 e0f0      	LDI  R31,0
00121a 91af      	POP  R26
00121b 91bf      	POP  R27
00121c 93ec      	ST   X,R30
                 ;    2811 	
                 ;    2812 	// Update the File Size
                 ;    2813 	for (n=0; n<4; n++)
00121d e000      	LDI  R16,LOW(0)
                 _0x1DB:
00121e 3004      	CPI  R16,4
00121f f4d0      	BRSH _0x1DC
                 ;    2814 	{
                 ;    2815 		*fp = file_data & 0xFF;
001220 81ef
001221 85f8
001222 8569
001223 857a      	__GETD1S 7
001224 7fef
001225 70f0
001226 7060
001227 7070      	__ANDD1N 0xFF
001228 2fa1
001229 2fb2      	__GETW2R 17,18
00122a 93ec      	ST   X,R30
                 ;    2816 		file_data >>= 8;
00122b 81af
00122c 85b8
00122d 8589
00122e 859a      	__GETD2S 7
00122f e0e8      	LDI  R30,LOW(8)
001230 940e 1dfc 	CALL __LSRD12
001232 83ef
001233 87f8
001234 8769
001235 877a      	__PUTD1S 7
                 ;    2817 		fp++;
001236 5f1f
001237 4f2f      	__ADDWRN 17,18,1
                 ;    2818 	}
001238 5f0f      	SUBI R16,-1
001239 cfe4      	RJMP _0x1DB
                 _0x1DC:
                 ;    2819 	
                 ;    2820 	
                 ;    2821 	fp = &_FF_buff[rp->entry_offset+0x16];
00123a 85ab      	LDD  R26,Y+11
00123b 85bc      	LDD  R27,Y+11+1
00123c 965a      	ADIW R26,26
00123d 940e 1eb8 	CALL __GETW1P
00123f 55ea
001240 4ff6      	__ADDW1MN __FF_buff,22
001241 2f1e
001242 2f2f      	__PUTW1R 17,18
                 ;    2822 	#ifdef _RTC_ON_ 	// Date/Time Stamp file w/ RTC
                 ;    2823 		rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
                 ;    2824 		calc_temp = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
                 ;    2825 		*fp++ = calc_temp&0x00FF;	// File create Time 
                 ;    2826 		*fp++ = (calc_temp&0xFF00) >> 8;
                 ;    2827 		calc_date = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
                 ;    2828 		*fp++ = calc_date&0x00FF;	// File create Date
                 ;    2829 		*fp++ = (calc_date&0xFF00) >> 8;
                 ;    2830 	#else		// Increment Date Code, no RTC used 
                 ;    2831 		file_data = 0;
001243 e0e0
001244 83ef
001245 87e8
001246 87e9
001247 87ea      	__CLRD1S 7
                 ;    2832 		for (n=0; n<4; n++)
001248 e000      	LDI  R16,LOW(0)
                 _0x1DE:
001249 3004      	CPI  R16,4
00124a f4f8      	BRSH _0x1DF
                 ;    2833 		{
                 ;    2834 			file_data <<= 8;
00124b 81af
00124c 85b8
00124d 8589
00124e 859a      	__GETD2S 7
00124f e0e8      	LDI  R30,LOW(8)
001250 940e 1df0 	CALL __LSLD12
001252 83ef
001253 87f8
001254 8769
001255 877a      	__PUTD1S 7
                 ;    2835 			file_data |= *fp;
001256 2fa1
001257 2fb2      	__GETW2R 17,18
001258 91ec      	LD   R30,X
001259 81af
00125a 85b8
00125b 8589
00125c 859a      	__GETD2S 7
00125d 27ff      	CLR  R31
00125e 2766      	CLR  R22
00125f 2777      	CLR  R23
001260 940e 1dde 	CALL __ORD12
001262 83ef
001263 87f8
001264 8769
001265 877a      	__PUTD1S 7
                 ;    2836 			fp--;
001266 5011
001267 4020      	__SUBWRN 17,18,1
                 ;    2837 		}
001268 5f0f      	SUBI R16,-1
001269 cfdf      	RJMP _0x1DE
                 _0x1DF:
                 ;    2838 		file_data++;
00126a 81ef
00126b 85f8
00126c 8569
00126d 857a      	__GETD1S 7
00126e 5fef
00126f 4fff
001270 4f6f
001271 4f7f      	__SUBD1N -1
001272 83ef
001273 87f8
001274 8769
001275 877a      	__PUTD1S 7
                 ;    2839 		for (n=0; n<4; n++)
001276 e000      	LDI  R16,LOW(0)
                 _0x1E1:
001277 3004      	CPI  R16,4
001278 f4d0      	BRSH _0x1E2
                 ;    2840 		{
                 ;    2841 			fp++;
001279 5f1f
00127a 4f2f      	__ADDWRN 17,18,1
                 ;    2842 			*fp = file_data & 0xFF;
00127b 81ef
00127c 85f8
00127d 8569
00127e 857a      	__GETD1S 7
00127f 7fef
001280 70f0
001281 7060
001282 7070      	__ANDD1N 0xFF
001283 2fa1
001284 2fb2      	__GETW2R 17,18
001285 93ec      	ST   X,R30
                 ;    2843 			file_data >>=8;
001286 81af
001287 85b8
001288 8589
001289 859a      	__GETD2S 7
00128a e0e8      	LDI  R30,LOW(8)
00128b 940e 1dfc 	CALL __LSRD12
00128d 83ef
00128e 87f8
00128f 8769
001290 877a      	__PUTD1S 7
                 ;    2844 		}
001291 5f0f      	SUBI R16,-1
001292 cfe4      	RJMP _0x1E1
                 _0x1E2:
                 ;    2845 	#endif
                 ;    2846 	if (_FF_write(rp->entry_sec_addr)==0)
001293 85eb      	LDD  R30,Y+11
001294 85fc      	LDD  R31,Y+11+1
001295 89a6
001296 89b7
001297 8d80
001298 8d91      	__GETD2Z 22
001299 940e 1ed0 	CALL __PUTPARD2
00129b 940e 0bf9 	CALL __FF_write
00129d 30e0      	CPI  R30,0
00129e f411      	BRNE _0x1E3
                 ;    2847 		return(0);
00129f e0e0      	LDI  R30,LOW(0)
0012a0 c001      	RJMP _0x423
                 ;    2848 	
                 ;    2849 	return(1);
                 _0x1E3:
0012a1 e0e1      	LDI  R30,LOW(1)
                 _0x423:
0012a2 940e 1f2c 	CALL __LOADLOCR5
0012a4 962d      	ADIW R28,13
0012a5 9508      	RET
                 ;    2850 }
                 ;    2851 #endif
                 ;    2852 
                 ;    2853 #ifndef _READ_ONLY_
                 ;    2854 // Erase a chain of clusters (set table entries to 0 for clusters in chain)
                 ;    2855 unsigned char erase_clus_chain(unsigned int start_clus)
                 ;    2856 {
                 _erase_clus_chain:
                 ;    2857 	unsigned int clus_temp, clus_use;
                 ;    2858 	
                 ;    2859 	if (start_clus==0)
0012a6 940e 1f26 	CALL __SAVELOCR4
                 ;	start_clus -> Y+4
                 ;	clus_temp -> R16,R17
                 ;	clus_use -> R18,R19
0012a8 81ec      	LDD  R30,Y+4
0012a9 81fd      	LDD  R31,Y+4+1
0012aa 9730      	SBIW R30,0
0012ab f411      	BRNE _0x1E4
                 ;    2860 		return (0);
0012ac e0e0      	LDI  R30,LOW(0)
0012ad c04c      	RJMP _0x422
                 ;    2861 	clus_use = start_clus;
                 _0x1E4:
0012ae 812c
0012af 813d      	__GETWRS 18,19,4
                 ;    2862 	_FF_buff_addr = 0;
0012b0 e0e0      	LDI  R30,0
0012b1 93e0 0bd4 	STS  __FF_buff_addr,R30
0012b3 93e0 0bd5 	STS  __FF_buff_addr+1,R30
0012b5 93e0 0bd6 	STS  __FF_buff_addr+2,R30
0012b7 93e0 0bd7 	STS  __FF_buff_addr+3,R30
                 ;    2863 	while(clus_use <= 0xFFF8)
                 _0x1E5:
0012b9 3f29
0012ba efef
0012bb 073e      	__CPWRN 18,19,65529
0012bc f500      	BRSH _0x1E7
                 ;    2864 	{
                 ;    2865 		clus_temp = next_cluster(clus_use, CHAIN);
0012bd 933a      	ST   -Y,R19
0012be 932a      	ST   -Y,R18
0012bf e0e0      	LDI  R30,LOW(0)
0012c0 93ea      	ST   -Y,R30
0012c1 940e 0f9b 	CALL _next_cluster
0012c3 018f      	MOVW R16,R30
                 ;    2866 		if ((clus_temp >= 0xFFF8) || (clus_temp == 0))
0012c4 3f08
0012c5 efef
0012c6 071e      	__CPWRN 16,17,65528
0012c7 f420      	BRSH _0x1E9
0012c8 2400      	CLR  R0
0012c9 1600      	CP   R0,R16
0012ca 0601      	CPC  R0,R17
0012cb f409      	BRNE _0x1E8
                 _0x1E9:
                 ;    2867 			break;
0012cc c010      	RJMP _0x1E7
                 ;    2868 		if (write_clus_table(clus_use, 0, CHAIN) == 0)
                 _0x1E8:
0012cd 933a      	ST   -Y,R19
0012ce 932a      	ST   -Y,R18
0012cf e0e0      	LDI  R30,LOW(0)
0012d0 e0f0      	LDI  R31,HIGH(0)
0012d1 93fa      	ST   -Y,R31
0012d2 93ea      	ST   -Y,R30
0012d3 93ea      	ST   -Y,R30
0012d4 940e 10da 	CALL _write_clus_table
0012d6 30e0      	CPI  R30,0
0012d7 f411      	BRNE _0x1EB
                 ;    2869 			return (0);
0012d8 e0e0      	LDI  R30,LOW(0)
0012d9 c020      	RJMP _0x422
                 ;    2870 		clus_use = clus_temp;
                 _0x1EB:
0012da 2f20
0012db 2f31      	__MOVEWRR 18,19,16,17
                 ;    2871 	}
0012dc cfdc      	RJMP _0x1E5
                 _0x1E7:
                 ;    2872 	if (write_clus_table(clus_use, 0, END_CHAIN) == 0)
0012dd 933a      	ST   -Y,R19
0012de 932a      	ST   -Y,R18
0012df e0e0      	LDI  R30,LOW(0)
0012e0 e0f0      	LDI  R31,HIGH(0)
0012e1 93fa      	ST   -Y,R31
0012e2 93ea      	ST   -Y,R30
0012e3 e0e2      	LDI  R30,LOW(2)
0012e4 93ea      	ST   -Y,R30
0012e5 940e 10da 	CALL _write_clus_table
0012e7 30e0      	CPI  R30,0
0012e8 f411      	BRNE _0x1EC
                 ;    2873 		return (0);
0012e9 e0e0      	LDI  R30,LOW(0)
0012ea c00f      	RJMP _0x422
                 ;    2874 	clus_0_addr = 0;
                 _0x1EC:
0012eb e0e0      	LDI  R30,0
0012ec 93e0 0be3 	STS  _clus_0_addr,R30
0012ee 93e0 0be4 	STS  _clus_0_addr+1,R30
0012f0 93e0 0be5 	STS  _clus_0_addr+2,R30
0012f2 93e0 0be6 	STS  _clus_0_addr+3,R30
                 ;    2875 	c_counter = 0;
0012f4 e0e0      	LDI  R30,0
0012f5 93e0 0beb 	STS  _c_counter,R30
0012f7 93e0 0bec 	STS  _c_counter+1,R30
                 ;    2876 	
                 ;    2877 	return (1);	
0012f9 e0e1      	LDI  R30,LOW(1)
                 _0x422:
0012fa 940e 1f2d 	CALL __LOADLOCR4
0012fc 9626      	ADIW R28,6
0012fd 9508      	RET
                 ;    2878 }
                 ;    2879 
                 ;    2880 // Quickformat of a card (erase cluster table and root directory
                 ;    2881 int fquickformat(void)
                 ;    2882 {
                 _fquickformat:
                 ;    2883 	long c;
                 ;    2884 	
                 ;    2885 	for (c=0; c<BPB_BytsPerSec; c++)
0012fe 9724      	SBIW R28,4
                 ;	c -> Y+0
0012ff e0e0
001300 83e8
001301 83e9
001302 83ea
001303 83eb      	__CLRD1S 0
                 _0x1EE:
001304 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001306 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001308 81a8
001309 81b9
00130a 818a
00130b 819b      	__GETD2S 0
00130c 2766      	CLR  R22
00130d 2777      	CLR  R23
00130e 940e 1f1f 	CALL __CPD21
001310 f4b4      	BRGE _0x1EF
                 ;    2886 		_FF_buff[c] = 0;
001311 81e8
001312 81f9
001313 816a
001314 817b      	__GETD1S 0
001315 57e0      	SUBI R30,LOW(-__FF_buff)
001316 4ff6      	SBCI R31,HIGH(-__FF_buff)
001317 01df      	MOVW R26,R30
001318 e0e0      	LDI  R30,LOW(0)
001319 93ec      	ST   X,R30
                 ;    2887 	
                 ;    2888 	c = _FF_FAT1_ADDR + 0x200;
00131a 81e8
00131b 81f9
00131c 816a
00131d 817b      	__GETD1S 0
00131e 5fef
00131f 4fff
001320 4f6f
001321 4f7f      	__SUBD1N -1
001322 83e8
001323 83f9
001324 836a
001325 837b      	__PUTD1S 0
001326 cfdd      	RJMP _0x1EE
                 _0x1EF:
001327 91e0 0bc1 	LDS  R30,__FF_FAT1_ADDR
001329 91f0 0bc2 	LDS  R31,__FF_FAT1_ADDR+1
00132b 9160 0bc3 	LDS  R22,__FF_FAT1_ADDR+2
00132d 9170 0bc4 	LDS  R23,__FF_FAT1_ADDR+3
00132f 50e0
001330 4ffe
001331 4f6f
001332 4f7f      	__ADDD1N 512
001333 83e8
001334 83f9
001335 836a
001336 837b      	__PUTD1S 0
                 ;    2889 	while (c < (_FF_ROOT_ADDR + (0x400 * BPB_SecPerClus)))
                 _0x1F0:
001337 91e0 0b98 	LDS  R30,_BPB_SecPerClus
001339 e0a0      	LDI  R26,LOW(1024)
00133a e0b4      	LDI  R27,HIGH(1024)
00133b e0f0      	LDI  R31,0
00133c 940e 1e48 	CALL __MULW12
00133e 91a0 0bb9 	LDS  R26,__FF_ROOT_ADDR
001340 91b0 0bba 	LDS  R27,__FF_ROOT_ADDR+1
001342 9180 0bbb 	LDS  R24,__FF_ROOT_ADDR+2
001344 9190 0bbc 	LDS  R25,__FF_ROOT_ADDR+3
001346 940e 1e1b 	CALL __CWD1
001348 940e 1dca 	CALL __ADDD12
00134a 81a8
00134b 81b9
00134c 818a
00134d 819b      	__GETD2S 0
00134e 940e 1f1f 	CALL __CPD21
001350 f4e8      	BRSH _0x1F2
                 ;    2890 	{
                 ;    2891 		if (_FF_write(c)==0)
001351 81e8
001352 81f9
001353 816a
001354 817b      	__GETD1S 0
001355 940e 1ecb 	CALL __PUTPARD1
001357 940e 0bf9 	CALL __FF_write
001359 30e0      	CPI  R30,0
00135a f431      	BRNE _0x1F3
                 ;    2892 		{
                 ;    2893 			_FF_error = WRITE_ERR;
00135b e0e3      	LDI  R30,LOW(3)
00135c 93e0 0bd3 	STS  __FF_error,R30
                 ;    2894 			return (EOF);
00135e efef      	LDI  R30,LOW(65535)
00135f efff      	LDI  R31,HIGH(65535)
001360 c03f      	RJMP _0x421
                 ;    2895 		}
                 ;    2896 		c += 0x200;
                 _0x1F3:
001361 81e8
001362 81f9
001363 816a
001364 817b      	__GETD1S 0
001365 50e0
001366 4ffe
001367 4f6f
001368 4f7f      	__ADDD1N 512
001369 83e8
00136a 83f9
00136b 836a
00136c 837b      	__PUTD1S 0
                 ;    2897 	}	
00136d cfc9      	RJMP _0x1F0
                 _0x1F2:
                 ;    2898 	_FF_buff[0] = 0xF8;
00136e efe8      	LDI  R30,LOW(248)
00136f 93e0 0990 	STS  __FF_buff,R30
                 ;    2899 	_FF_buff[1] = 0xFF;
001371 efef      	LDI  R30,LOW(255)
001372 93e0 0991 	__PUTB1MN __FF_buff,1
                 ;    2900 	_FF_buff[2] = 0xFF;
001374 93e0 0992 	__PUTB1MN __FF_buff,2
                 ;    2901 	if (BPB_FATType == 0x36)
001376 91a0 0ba0 	LDS  R26,_BPB_FATType
001378 33a6      	CPI  R26,LOW(0x36)
001379 f411      	BRNE _0x1F4
                 ;    2902 		_FF_buff[3] = 0xFF;
00137a 93e0 0993 	__PUTB1MN __FF_buff,3
                 ;    2903 	if ((_FF_write(_FF_FAT1_ADDR)==0) || (_FF_write(_FF_FAT2_ADDR)==0))
                 _0x1F4:
00137c 91e0 0bc1 	LDS  R30,__FF_FAT1_ADDR
00137e 91f0 0bc2 	LDS  R31,__FF_FAT1_ADDR+1
001380 9160 0bc3 	LDS  R22,__FF_FAT1_ADDR+2
001382 9170 0bc4 	LDS  R23,__FF_FAT1_ADDR+3
001384 940e 1ecb 	CALL __PUTPARD1
001386 940e 0bf9 	CALL __FF_write
001388 30e0      	CPI  R30,0
001389 f071      	BREQ _0x1F6
00138a 91e0 0bc5 	LDS  R30,__FF_FAT2_ADDR
00138c 91f0 0bc6 	LDS  R31,__FF_FAT2_ADDR+1
00138e 9160 0bc7 	LDS  R22,__FF_FAT2_ADDR+2
001390 9170 0bc8 	LDS  R23,__FF_FAT2_ADDR+3
001392 940e 1ecb 	CALL __PUTPARD1
001394 940e 0bf9 	CALL __FF_write
001396 30e0      	CPI  R30,0
001397 f431      	BRNE _0x1F5
                 _0x1F6:
                 ;    2904 	{
                 ;    2905 		_FF_error = WRITE_ERR;
001398 e0e3      	LDI  R30,LOW(3)
001399 93e0 0bd3 	STS  __FF_error,R30
                 ;    2906 		return (EOF);
00139b efef      	LDI  R30,LOW(65535)
00139c efff      	LDI  R31,HIGH(65535)
00139d c002      	RJMP _0x421
                 ;    2907 	}
                 ;    2908 	return (0);
                 _0x1F5:
00139e e0e0      	LDI  R30,LOW(0)
00139f e0f0      	LDI  R31,HIGH(0)
                 _0x421:
0013a0 9624      	ADIW R28,4
0013a1 9508      	RET
                 ;    2909 }
                 ;    2910 #endif
                 ;    2911 
                 ;    2912 // function that checks for directory changes then gets into a working form
                 ;    2913 int _FF_checkdir(char *F_PATH, unsigned long *SAVE_ADDR, char *path_temp)
                 ;    2914 {
                 __FF_checkdir:
                 ;    2915 	unsigned char *sp, *qp;
                 ;    2916     
                 ;    2917     *SAVE_ADDR = _FF_DIR_ADDR;	// save local dir addr
0013a2 940e 1f26 	CALL __SAVELOCR4
                 ;	*F_PATH -> Y+8
                 ;	*SAVE_ADDR -> Y+6
                 ;	*path_temp -> Y+4
                 ;	*sp -> R16,R17
                 ;	*qp -> R18,R19
0013a4 91e0 0bbd 	LDS  R30,__FF_DIR_ADDR
0013a6 91f0 0bbe 	LDS  R31,__FF_DIR_ADDR+1
0013a8 9160 0bbf 	LDS  R22,__FF_DIR_ADDR+2
0013aa 9170 0bc0 	LDS  R23,__FF_DIR_ADDR+3
0013ac 81ae      	LDD  R26,Y+6
0013ad 81bf      	LDD  R27,Y+6+1
0013ae 940e 1ec2 	CALL __PUTDP1
                 ;    2918     
                 ;    2919     qp = F_PATH;
0013b0 8528
0013b1 8539      	__GETWRS 18,19,8
                 ;    2920     if (*qp=='\\')
0013b2 01d9      	MOVW R26,R18
0013b3 91ac      	LD   R26,X
0013b4 35ac      	CPI  R26,LOW(0x5C)
0013b5 f491      	BRNE _0x1F8
                 ;    2921     {
                 ;    2922     	_FF_DIR_ADDR = _FF_ROOT_ADDR;
0013b6 91e0 0bb9 	LDS  R30,__FF_ROOT_ADDR
0013b8 91f0 0bba 	LDS  R31,__FF_ROOT_ADDR+1
0013ba 9160 0bbb 	LDS  R22,__FF_ROOT_ADDR+2
0013bc 9170 0bbc 	LDS  R23,__FF_ROOT_ADDR+3
0013be 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0013c0 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0013c2 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0013c4 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    2923 		qp++;
0013c6 5f2f
0013c7 4f3f      	__ADDWRN 18,19,1
                 ;    2924 	}
                 ;    2925 
                 ;    2926 	sp = path_temp;
                 _0x1F8:
0013c8 810c
0013c9 811d      	__GETWRS 16,17,4
                 ;    2927 	while(*qp)
                 _0x1F9:
0013ca 01d9      	MOVW R26,R18
0013cb 91ec      	LD   R30,X
0013cc 30e0      	CPI  R30,0
0013cd f191      	BREQ _0x1FB
                 ;    2928 	{
                 ;    2929 		if ((valid_file_char(*qp)==0) || (*qp=='.'))
0013ce 93ea      	ST   -Y,R30
0013cf 940e 0c88 	CALL _valid_file_char
0013d1 9730      	SBIW R30,0
0013d2 f021      	BREQ _0x1FD
0013d3 01d9      	MOVW R26,R18
0013d4 91ac      	LD   R26,X
0013d5 32ae      	CPI  R26,LOW(0x2E)
0013d6 f479      	BRNE _0x1FC
                 _0x1FD:
                 ;    2930 			*sp++ = toupper(*qp++);
0013d7 931f      	PUSH R17
0013d8 930f      	PUSH R16
0013d9 5f0f
0013da 4f1f      	__ADDWRN 16,17,1
0013db 01d9      	MOVW R26,R18
0013dc 5f2f
0013dd 4f3f      	__ADDWRN 18,19,1
0013de 91ec      	LD   R30,X
0013df 93ea      	ST   -Y,R30
0013e0 940e 1db7 	CALL _toupper
0013e2 91af      	POP  R26
0013e3 91bf      	POP  R27
0013e4 93ec      	ST   X,R30
                 ;    2931 		else if (*qp=='\\')
0013e5 c019      	RJMP _0x1FF
                 _0x1FC:
0013e6 01d9      	MOVW R26,R18
0013e7 91ac      	LD   R26,X
0013e8 35ac      	CPI  R26,LOW(0x5C)
0013e9 f491      	BRNE _0x200
                 ;    2932 		{
                 ;    2933 			*sp = 0;	// terminate string
0013ea 01d8      	MOVW R26,R16
0013eb e0e0      	LDI  R30,LOW(0)
0013ec 93ec      	ST   X,R30
                 ;    2934 			if (_FF_chdir(path_temp))
0013ed 81ec      	LDD  R30,Y+4
0013ee 81fd      	LDD  R31,Y+4+1
0013ef 93fa      	ST   -Y,R31
0013f0 93ea      	ST   -Y,R30
0013f1 d017      	RCALL __FF_chdir
0013f2 9730      	SBIW R30,0
0013f3 f019      	BREQ _0x201
                 ;    2935 			{
                 ;    2936 				return (EOF);
0013f4 efef      	LDI  R30,LOW(65535)
0013f5 efff      	LDI  R31,HIGH(65535)
0013f6 c00e      	RJMP _0x420
                 ;    2937 			}
                 ;    2938 			sp = path_temp;
                 _0x201:
0013f7 810c
0013f8 811d      	__GETWRS 16,17,4
                 ;    2939 			qp++;
0013f9 5f2f
0013fa 4f3f      	__ADDWRN 18,19,1
                 ;    2940 		}
                 ;    2941 		else
0013fb c003      	RJMP _0x202
                 _0x200:
                 ;    2942 			return (EOF);
0013fc efef      	LDI  R30,LOW(65535)
0013fd efff      	LDI  R31,HIGH(65535)
0013fe c006      	RJMP _0x420
                 ;    2943 	}
                 _0x202:
                 _0x1FF:
0013ff cfca      	RJMP _0x1F9
                 _0x1FB:
                 ;    2944 	
                 ;    2945 	*sp = 0;		// terminate string
001400 01d8      	MOVW R26,R16
001401 e0e0      	LDI  R30,LOW(0)
001402 93ec      	ST   X,R30
                 ;    2946 	return (0);
001403 e0e0      	LDI  R30,LOW(0)
001404 e0f0      	LDI  R31,HIGH(0)
                 _0x420:
001405 940e 1f2d 	CALL __LOADLOCR4
001407 962a      	ADIW R28,10
001408 9508      	RET
                 ;    2947 }
                 ;    2948 
                 ;    2949 #ifndef _READ_ONLY_
                 ;    2950 int mkdir(char *F_PATH)
                 ;    2951 {
                 ;    2952 	unsigned char *sp, *qp;
                 ;    2953 	unsigned char fpath[14];
                 ;    2954 	unsigned int c, calc_temp, clus_temp, calc_time, calc_date;
                 ;    2955 	int s;
                 ;    2956 	unsigned long addr_temp, path_addr_temp;
                 ;    2957     
                 ;    2958     addr_temp = 0;	// save local dir addr
                 ;	*F_PATH -> Y+38
                 ;	*sp -> R16,R17
                 ;	*qp -> R18,R19
                 ;	fpath -> Y+24
                 ;	c -> R20,R21
                 ;	calc_temp -> Y+22
                 ;	clus_temp -> Y+20
                 ;	calc_time -> Y+18
                 ;	calc_date -> Y+16
                 ;	s -> Y+14
                 ;	addr_temp -> Y+10
                 ;	path_addr_temp -> Y+6
                 ;    2959     
                 ;    2960     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
                 ;    2961 	{
                 ;    2962 		_FF_DIR_ADDR = addr_temp;
                 ;    2963 		return (EOF);
                 ;    2964 	}
                 ;    2965     
                 ;    2966 	path_addr_temp = _FF_DIR_ADDR;
                 ;    2967 	s = scan_directory(&path_addr_temp, fpath);
                 ;    2968 	if ((s) || (path_addr_temp==0))
                 ;    2969 	{
                 ;    2970 		_FF_DIR_ADDR = addr_temp;
                 ;    2971 		return (EOF);
                 ;    2972 	}
                 ;    2973 	clus_temp = prev_cluster(0);				
                 ;    2974 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    2975 	path_addr_temp -= calc_temp;
                 ;    2976 	if (_FF_read(path_addr_temp)==0)	
                 ;    2977 	{
                 ;    2978 		_FF_DIR_ADDR = addr_temp;
                 ;    2979 		return (EOF);
                 ;    2980 	}
                 ;    2981 	
                 ;    2982 	sp = &_FF_buff[calc_temp];
                 ;    2983 	qp = fpath;
                 ;    2984 
                 ;    2985 	for (c=0; c<11; c++)	// Write Folder name
                 ;    2986 	{
                 ;    2987 	 	if (*qp)
                 ;    2988 		 	*sp++ = *qp++;
                 ;    2989 		else 
                 ;    2990 			*sp++ = 0x20;	// '0' pad
                 ;    2991 	}
                 ;    2992 	*sp++ = 0x10;				// Attribute bit auto set to "Directory"
                 ;    2993 	*sp++ = 0;					// Reserved for WinNT
                 ;    2994 	*sp++ = 0;					// Mili-second stamp for create
                 ;    2995 	for (c=0; c<4; c++)			// set create and modify time to '0'
                 ;    2996 		*sp++ = 0;
                 ;    2997 	*sp++ = 0;					// File access date (2 bytes)
                 ;    2998 	*sp++ = 0;
                 ;    2999 	*sp++ = 0;					// 0 for FAT12/16 (2 bytes)
                 ;    3000 	*sp++ = 0;
                 ;    3001 	#ifdef _RTC_ON_
                 ;    3002 		rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
                 ;    3003 		calc_time = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
                 ;    3004 		*sp++ = calc_time&0x00FF;	// File modify Time 
                 ;    3005 		*sp++ = (calc_time&0xFF00) >> 8;
                 ;    3006 		calc_date = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
                 ;    3007 		*sp++ = calc_date&0x00FF;	// File modify Date
                 ;    3008 		*sp++ = (calc_date&0xFF00) >> 8;
                 ;    3009 	#else
                 ;    3010 		for (c=0; c<4; c++)			// set file create and modify time to '0'
                 ;    3011 			*sp++ = 0;
                 ;    3012 	#endif
                 ;    3013 	
                 ;    3014 	*sp++ = clus_temp & 0xFF;				// Starting cluster (2 bytes)
                 ;    3015 	*sp++ = (clus_temp >> 8) & 0xFF;
                 ;    3016 	for (c=0; c<4; c++)
                 ;    3017 		*sp++ = 0;			// File length (0 for folder)
                 ;    3018 
                 ;    3019 	
                 ;    3020 	if (_FF_write(path_addr_temp)==0)	// write entry to card
                 ;    3021 	{
                 ;    3022 		_FF_DIR_ADDR = addr_temp;
                 ;    3023 		return (EOF);
                 ;    3024 	}
                 ;    3025 	if (write_clus_table(clus_temp, 0xFFFF, SINGLE)==0)
                 ;    3026 	{
                 ;    3027 		_FF_DIR_ADDR = addr_temp;
                 ;    3028 		return (EOF);
                 ;    3029 	}
                 ;    3030 	if (_FF_read(_FF_DIR_ADDR)==0)	
                 ;    3031 	{
                 ;    3032 		_FF_DIR_ADDR = addr_temp;
                 ;    3033 		return (EOF);
                 ;    3034 	}
                 ;    3035 	if (_FF_DIR_ADDR != _FF_ROOT_ADDR)
                 ;    3036 	{
                 ;    3037 		sp = &_FF_buff[0];
                 ;    3038 		qp = &_FF_buff[0x20];
                 ;    3039 		for (c=0; c<0x20; c++)
                 ;    3040 			*qp++ = *sp++;
                 ;    3041 		_FF_buff[1] = ' ';
                 ;    3042 		for (c=0x3C; c<0x40; c++)
                 ;    3043 			_FF_buff[c] = 0;
                 ;    3044 	}
                 ;    3045 	else
                 ;    3046 	{
                 ;    3047 		for (c=0x01; c<0x0B; c++)
                 ;    3048 			_FF_buff[c] = 0x20;
                 ;    3049 		for (c=0x0C; c<0x20; c++)
                 ;    3050 			_FF_buff[c] = 0;
                 ;    3051 		_FF_buff[0] = '.';
                 ;    3052 		_FF_buff[0x0B] = 0x10;
                 ;    3053 		#ifdef _RTC_ON_
                 ;    3054 			_FF_buff[0x0E] = calc_time&0x00FF;	// File modify Time 
                 ;    3055 			_FF_buff[0x0F] = (calc_time&0xFF00) >> 8;
                 ;    3056 			_FF_buff[0x10] = calc_date&0x00FF;	// File modify Date
                 ;    3057 			_FF_buff[0x11] = (calc_date&0xFF00) >> 8;
                 ;    3058 			_FF_buff[0x16] = calc_time&0x00FF;	// File modify Time 
                 ;    3059 			_FF_buff[0x17] = (calc_time&0xFF00) >> 8;
                 ;    3060 			_FF_buff[0x18] = calc_date&0x00FF;	// File modify Date
                 ;    3061 			_FF_buff[0x19] = (calc_date&0xFF00) >> 8;
                 ;    3062 		#endif
                 ;    3063 		for (c=0x3A; c<0x40; c++)
                 ;    3064 			_FF_buff[c] = 0;
                 ;    3065 	}
                 ;    3066 	for (c=0x22; c<0x2B; c++)
                 ;    3067 		_FF_buff[c] = 0x20;
                 ;    3068 	#ifdef _RTC_ON_
                 ;    3069 		_FF_buff[0x2E] = calc_time&0x00FF;	// File modify Time 
                 ;    3070 		_FF_buff[0x2F] = (calc_time&0xFF00) >> 8;
                 ;    3071 		_FF_buff[0x30] = calc_date&0x00FF;	// File modify Date
                 ;    3072 		_FF_buff[0x31] = (calc_date&0xFF00) >> 8;
                 ;    3073 		_FF_buff[0x36] = calc_time&0x00FF;	// File modify Time 
                 ;    3074 		_FF_buff[0x37] = (calc_time&0xFF00) >> 8;
                 ;    3075 		_FF_buff[0x38] = calc_date&0x00FF;	// File modify Date
                 ;    3076 		_FF_buff[0x39] = (calc_date&0xFF00) >> 8;
                 ;    3077 	#endif
                 ;    3078 	_FF_buff[0x20] = '.';
                 ;    3079 	_FF_buff[0x21] = '.';
                 ;    3080 	_FF_buff[0x2B] = 0x10;
                 ;    3081 
                 ;    3082 	_FF_buff[0x1A] = clus_temp & 0xFF;				// Starting cluster (2 bytes)
                 ;    3083 	_FF_buff[0x1B] = (clus_temp >> 8) & 0xFF;
                 ;    3084 	for (c=0x40; c<BPB_BytsPerSec; c++)
                 ;    3085 		_FF_buff[c] = 0;
                 ;    3086 	path_addr_temp = clust_to_addr(clus_temp);
                 ;    3087 
                 ;    3088 	_FF_DIR_ADDR = addr_temp;	// reset dir addr
                 ;    3089 	if (_FF_write(path_addr_temp)==0)	
                 ;    3090 		return (EOF);
                 ;    3091 	for (c=0; c<0x40; c++)
                 ;    3092 		_FF_buff[c] = 0;
                 ;    3093 	for (c=1; c<BPB_SecPerClus; c++)
                 ;    3094 	{
                 ;    3095 		if (_FF_write(path_addr_temp+((long)c*0x200))==0)	
                 ;    3096 			return (EOF);
                 ;    3097 	}
                 ;    3098 	return (0);		
                 ;    3099 }
                 ;    3100 
                 ;    3101 int rmdir(char *F_PATH)
                 ;    3102 {
                 ;    3103 	unsigned char *sp;
                 ;    3104 	unsigned char fpath[14];
                 ;    3105 	unsigned int c, n, calc_temp, clus_temp;
                 ;    3106 	int s;
                 ;    3107 	unsigned long addr_temp, path_addr_temp;
                 ;    3108 	
                 ;    3109 	addr_temp = 0;	// save local dir addr
                 ;	*F_PATH -> Y+34
                 ;	*sp -> R16,R17
                 ;	fpath -> Y+20
                 ;	c -> R18,R19
                 ;	n -> R20,R21
                 ;	calc_temp -> Y+18
                 ;	clus_temp -> Y+16
                 ;	s -> Y+14
                 ;	addr_temp -> Y+10
                 ;	path_addr_temp -> Y+6
                 ;    3110     
                 ;    3111     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
                 ;    3112 	{
                 ;    3113 		_FF_DIR_ADDR = addr_temp;
                 ;    3114 		return (EOF);
                 ;    3115 	}
                 ;    3116 	if (fpath[0]==0)
                 ;    3117 	{
                 ;    3118 		_FF_DIR_ADDR = addr_temp;
                 ;    3119 		return (EOF);
                 ;    3120 	}
                 ;    3121 
                 ;    3122     path_addr_temp = _FF_DIR_ADDR;	// save addr for later
                 ;    3123 	
                 ;    3124 	if (_FF_chdir(fpath))	// Change directory to dir to be deleted
                 ;    3125 	{	
                 ;    3126 		_FF_DIR_ADDR = addr_temp;
                 ;    3127 		return (EOF);
                 ;    3128 	}
                 ;    3129 	if ((_FF_DIR_ADDR==_FF_ROOT_ADDR)||(_FF_DIR_ADDR==addr_temp))
                 ;    3130 	{	// if trying to delete root, or current dir error
                 ;    3131 		_FF_DIR_ADDR = addr_temp;
                 ;    3132 		return (EOF);
                 ;    3133 	}
                 ;    3134 	
                 ;    3135 	for (c=0; c<BPB_SecPerClus; c++)
                 ;    3136 	{	// scan through dir to see if it is empty
                 ;    3137 		if (_FF_read(_FF_DIR_ADDR+((long)c*0x200))==0)
                 ;    3138 		{	// read sectors 	
                 ;    3139 			_FF_DIR_ADDR = addr_temp;
                 ;    3140 			return (EOF);
                 ;    3141 		}
                 ;    3142 		for (n=0; n<0x10; n++)
                 ;    3143 		{
                 ;    3144 			if ((c==0)&&(n==0))	// skip first 2 entries 
                 ;    3145 				n=2;
                 ;    3146 			sp = &_FF_buff[n*0x20];
                 ;    3147 			if (*sp==0)
                 ;    3148 			{	// 
                 ;    3149 				c = BPB_SecPerClus;
                 ;    3150 				break;
                 ;    3151 			}
                 ;    3152 			while (valid_file_char(*sp)==0)
                 ;    3153 			{
                 ;    3154 				sp++;
                 ;    3155 				if (sp == &_FF_buff[(n*0x20)+0x0A])
                 ;    3156 				{	// a valid file or folder found
                 ;    3157 					_FF_DIR_ADDR = addr_temp;
                 ;    3158 					return (EOF);
                 ;    3159 				}
                 ;    3160 			}
                 ;    3161 		}
                 ;    3162 	}
                 ;    3163 	// directory empty, delete dir
                 ;    3164 	_FF_DIR_ADDR = path_addr_temp;	// go back to previous directory 
                 ;    3165 
                 ;    3166 	s = scan_directory(&path_addr_temp, fpath);
                 ;    3167 
                 ;    3168 	_FF_DIR_ADDR = addr_temp;	// reset address
                 ;    3169 
                 ;    3170 	if (s == 0)
                 ;    3171 		return (EOF);
                 ;    3172 	
                 ;    3173 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    3174 	path_addr_temp -= calc_temp;
                 ;    3175 
                 ;    3176 	if (_FF_read(path_addr_temp)==0)	
                 ;    3177 		return (EOF);
                 ;    3178     
                 ;    3179 	clus_temp = ((int) _FF_buff[calc_temp+0x1B] << 8) | _FF_buff[calc_temp+0x1A];
                 ;    3180 	_FF_buff[calc_temp] = 0xE5;
                 ;    3181 	
                 ;    3182 	if (_FF_buff[calc_temp+0x0B]&0x02)
                 ;    3183 		return (EOF);
                 ;    3184 	if (_FF_write(path_addr_temp)==0) 
                 ;    3185 		return (EOF);
                 ;    3186 	if (erase_clus_chain(clus_temp)==0)
                 ;    3187 		return (EOF);
                 ;    3188 	
                 ;    3189     return (0);
                 ;    3190 }
                 ;    3191 #endif
                 ;    3192 
                 ;    3193 int chdirc(char flash *F_PATH)
                 ;    3194 {
                 ;    3195 	unsigned char fpath[_FF_PATH_LENGTH];
                 ;    3196 	int c;
                 ;    3197 	
                 ;    3198 	for (c=0; c<_FF_PATH_LENGTH; c++)
                 ;	*F_PATH -> Y+102
                 ;	fpath -> Y+2
                 ;	c -> R16,R17
                 ;    3199 	{
                 ;    3200 		fpath[c] = F_PATH[c];
                 ;    3201 		if (F_PATH[c]==0)
                 ;    3202 			break;
                 ;    3203 	}
                 ;    3204 	return (chdir(fpath));
                 ;    3205 }
                 ;    3206 
                 ;    3207 int chdir(char *F_PATH)
                 ;    3208 {
                 ;    3209 	unsigned char *qp, *sp, fpath[14], valid_flag;
                 ;    3210 	unsigned int m, n, c, d, calc;
                 ;    3211 	unsigned long addr_temp;
                 ;    3212 
                 ;    3213     
                 ;    3214     addr_temp = 0;	// save local dir addr
                 ;	*F_PATH -> Y+33
                 ;	*qp -> R16,R17
                 ;	*sp -> R18,R19
                 ;	fpath -> Y+19
                 ;	valid_flag -> R20
                 ;	m -> Y+17
                 ;	n -> Y+15
                 ;	c -> Y+13
                 ;	d -> Y+11
                 ;	calc -> Y+9
                 ;	addr_temp -> Y+5
                 ;    3215     
                 ;    3216 	if ((F_PATH[0]=='\\') && (F_PATH[1]==0))
                 ;    3217 	{
                 ;    3218 		_FF_DIR_ADDR = _FF_ROOT_ADDR;
                 ;    3219 		_FF_FULL_PATH[1] = 0;
                 ;    3220 		return (0);
                 ;    3221 	}
                 ;    3222 	
                 ;    3223     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
                 ;    3224 	{
                 ;    3225 		_FF_DIR_ADDR = addr_temp;
                 ;    3226 		return (EOF);
                 ;    3227 	}
                 ;    3228 	if (fpath[0]==0)
                 ;    3229 		return (EOF);
                 ;    3230 
                 ;    3231 	if ((fpath[0]=='.') && (fpath[1]=='.') && (fpath[2]==0))
                 ;    3232 	{	// trying to get back to prev dir
                 ;    3233 		if (_FF_DIR_ADDR == _FF_ROOT_ADDR)		// already as far back as can go
                 ;    3234 			return (EOF);
                 ;    3235 		if (_FF_read(_FF_DIR_ADDR)==0)
                 ;    3236 			return (EOF);
                 ;    3237 		m = ((unsigned int) _FF_buff[0x3B] << 8) | (unsigned int) _FF_buff[0x3A];
                 ;    3238 		if (m)
                 ;    3239 			_FF_DIR_ADDR = clust_to_addr(m);
                 ;    3240 		else
                 ;    3241 			_FF_DIR_ADDR = _FF_ROOT_ADDR;
                 ;    3242 		
                 ;    3243 					sp = F_PATH;
                 ;    3244 					qp = _FF_FULL_PATH + strlen(_FF_FULL_PATH);
                 ;    3245 					while (*sp)
                 ;    3246 					{
                 ;    3247 						if ((*sp=='.')&&(*(sp+1)=='.'))
                 ;    3248 						{
                 ;    3249 							#ifdef _ICCAVR_
                 ;    3250 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3251 								if (qp==0)
                 ;    3252 								   return (EOF);
                 ;    3253 								*qp = 0;
                 ;    3254 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3255 								if (qp==0)
                 ;    3256 								   return (EOF);
                 ;    3257 								qp++;
                 ;    3258 							#endif
                 ;    3259 							#ifdef _CVAVR_
                 ;    3260 								_FF_FULL_PATH[strrpos(_FF_FULL_PATH, '\\')] = 0;
                 ;    3261 							    c = strrpos(_FF_FULL_PATH, '\\');
                 ;    3262 								if (c==EOF)
                 ;    3263 									return (EOF);
                 ;    3264 								qp = _FF_FULL_PATH + c;
                 ;    3265 							#endif
                 ;    3266 							*qp = 0;
                 ;    3267 							sp += 2;
                 ;    3268 						}
                 ;    3269 						else 
                 ;    3270 							*qp++ = toupper(*sp++);
                 ;    3271 					}
                 ;    3272 					*qp++ = '\\';
                 ;    3273 					*qp = 0;
                 ;    3274 
                 ;    3275 		return (0);
                 ;    3276 	}
                 ;    3277 		
                 ;    3278 	qp = fpath;
                 ;    3279 	sp = fpath;
                 ;    3280 	while(sp < (fpath+11))
                 ;    3281 	{
                 ;    3282 		if (*qp)
                 ;    3283 			*sp++ = toupper(*qp++);
                 ;    3284 		else	// (*qp==0)
                 ;    3285 			*sp++ = 0x20;
                 ;    3286 	}     
                 ;    3287 	*sp = 0;
                 ;    3288 
                 ;    3289 	qp = fpath;
                 ;    3290 	m = 0;
                 ;    3291 	d = 0;
                 ;    3292 	valid_flag = 0;
                 ;    3293 	while (d<BPB_RootEntCnt)
                 ;    3294 	{
                 ;    3295     	_FF_read(_FF_DIR_ADDR+(m*0x200));
                 ;    3296 		for (n=0; n<16; n++)
                 ;    3297 		{
                 ;    3298 			if (_FF_buff[n*0x20] == 0)	// no more entries in dir
                 ;    3299 			{
                 ;    3300 				_FF_DIR_ADDR = addr_temp;
                 ;    3301 				return (EOF);
                 ;    3302 			}
                 ;    3303 			calc = (n*0x20);
                 ;    3304 			for (c=0; c<11; c++)
                 ;    3305 			{	// check for name match
                 ;    3306 				if (fpath[c] == _FF_buff[calc+c])
                 ;    3307 					valid_flag = 1;
                 ;    3308 				else if (fpath[c] == 0)
                 ;    3309 				{
                 ;    3310 					if (_FF_buff[calc+c]==0x20)
                 ;    3311 						break;
                 ;    3312 				}
                 ;    3313 				else
                 ;    3314 				{
                 ;    3315 					valid_flag = 0;	
                 ;    3316 					break;
                 ;    3317 				}
                 ;    3318 		    }   
                 ;    3319 		    if (valid_flag)
                 ;    3320 	  		{
                 ;    3321 	  			if (_FF_buff[calc+0xB] != 0x10)	// not a directory
                 ;    3322 	  				valid_flag = 0;
                 ;    3323 	  			else
                 ;    3324 	  			{
                 ;    3325 	  				c = ((int) _FF_buff[calc+0x1B] << 8) | ((int) _FF_buff[calc+0x1A]);
                 ;    3326 					_FF_DIR_ADDR = clust_to_addr(c);
                 ;    3327 					sp = F_PATH;
                 ;    3328 					if (*sp=='\\')
                 ;    3329 					{	// Restart String @root
                 ;    3330 						qp = _FF_FULL_PATH + 1;
                 ;    3331 						*qp = 0;
                 ;    3332 						sp++;
                 ;    3333 					}
                 ;    3334 					else
                 ;    3335 						qp = _FF_FULL_PATH + strlen(_FF_FULL_PATH);
                 ;    3336 					while (*sp)
                 ;    3337 					{
                 ;    3338 						if ((*sp=='.')&&(*(sp+1)=='.'))
                 ;    3339 						{
                 ;    3340 							#ifdef _ICCAVR_
                 ;    3341 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3342 								if (qp==0)
                 ;    3343 								   return (EOF);
                 ;    3344 								*qp = 0;
                 ;    3345 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3346 								if (qp==0)
                 ;    3347 								   return (EOF);
                 ;    3348 								qp++;
                 ;    3349 							#endif
                 ;    3350 							#ifdef _CVAVR_
                 ;    3351 								_FF_FULL_PATH[strrpos(_FF_FULL_PATH, '\\')] = 0;
                 ;    3352 								c = strrpos(_FF_FULL_PATH, '\\');
                 ;    3353 								if (c==EOF)
                 ;    3354 								   return (EOF);
                 ;    3355 								qp = _FF_FULL_PATH + c;
                 ;    3356 							#endif
                 ;    3357 							*qp = 0;
                 ;    3358 							sp += 2;
                 ;    3359 						}
                 ;    3360 						else 
                 ;    3361 							*qp++ = toupper(*sp++);
                 ;    3362 					}
                 ;    3363 					*qp++ = '\\';
                 ;    3364 					*qp = 0;
                 ;    3365 					return (0);
                 ;    3366 				}
                 ;    3367 			}
                 ;    3368 		  	d++;		  		
                 ;    3369 		}
                 ;    3370 		m++;
                 ;    3371 	}
                 ;    3372 	_FF_DIR_ADDR = addr_temp;
                 ;    3373 	return (EOF);
                 ;    3374 }
                 ;    3375 
                 ;    3376 // Function to change directories one at a time, not effecting the working dir string
                 ;    3377 int _FF_chdir(char *F_PATH)
                 ;    3378 {
                 __FF_chdir:
                 ;    3379 	unsigned char *qp, *sp, valid_flag, fpath[14];
                 ;    3380 	unsigned int m, n, c, d, calc;
                 ;    3381     
                 ;    3382 	if ((F_PATH[0]=='.') && (F_PATH[1]=='.') && (F_PATH[2]==0))
001409 9768      	SBIW R28,24
00140a 940e 1f25 	CALL __SAVELOCR5
                 ;	*F_PATH -> Y+29
                 ;	*qp -> R16,R17
                 ;	*sp -> R18,R19
                 ;	valid_flag -> R20
                 ;	fpath -> Y+15
                 ;	m -> Y+13
                 ;	n -> Y+11
                 ;	c -> Y+9
                 ;	d -> Y+7
                 ;	calc -> Y+5
00140c 8dad      	LDD  R26,Y+29
00140d 8dbe      	LDD  R27,Y+29+1
00140e 91ac      	LD   R26,X
00140f 32ae      	CPI  R26,LOW(0x2E)
001410 f461      	BRNE _0x28C
001411 8dad      	LDD  R26,Y+29
001412 8dbe      	LDD  R27,Y+29+1
001413 9611      	ADIW R26,1
001414 91ac      	LD   R26,X
001415 32ae      	CPI  R26,LOW(0x2E)
001416 f431      	BRNE _0x28C
001417 8dad      	LDD  R26,Y+29
001418 8dbe      	LDD  R27,Y+29+1
001419 9612      	ADIW R26,2
00141a 91ac      	LD   R26,X
00141b 30a0      	CPI  R26,LOW(0x0)
00141c f009      	BREQ _0x28D
                 _0x28C:
00141d c04b      	RJMP _0x28B
                 _0x28D:
                 ;    3383 	{	// trying to get back to prev dir
                 ;    3384 		if (_FF_DIR_ADDR == _FF_ROOT_ADDR)		// already as far back as can go
00141e 91e0 0bb9 	LDS  R30,__FF_ROOT_ADDR
001420 91f0 0bba 	LDS  R31,__FF_ROOT_ADDR+1
001422 9160 0bbb 	LDS  R22,__FF_ROOT_ADDR+2
001424 9170 0bbc 	LDS  R23,__FF_ROOT_ADDR+3
001426 91a0 0bbd 	LDS  R26,__FF_DIR_ADDR
001428 91b0 0bbe 	LDS  R27,__FF_DIR_ADDR+1
00142a 9180 0bbf 	LDS  R24,__FF_DIR_ADDR+2
00142c 9190 0bc0 	LDS  R25,__FF_DIR_ADDR+3
00142e 940e 1f1a 	CALL __CPD12
001430 f419      	BRNE _0x28E
                 ;    3385 			return (EOF);
001431 efef      	LDI  R30,LOW(65535)
001432 efff      	LDI  R31,HIGH(65535)
001433 c109      	RJMP _0x41F
                 ;    3386 		if (_FF_read(_FF_DIR_ADDR)==0)
                 _0x28E:
001434 91e0 0bbd 	LDS  R30,__FF_DIR_ADDR
001436 91f0 0bbe 	LDS  R31,__FF_DIR_ADDR+1
001438 9160 0bbf 	LDS  R22,__FF_DIR_ADDR+2
00143a 9170 0bc0 	LDS  R23,__FF_DIR_ADDR+3
00143c 940e 1ecb 	CALL __PUTPARD1
00143e 940e 0b52 	CALL __FF_read
001440 30e0      	CPI  R30,0
001441 f419      	BRNE _0x28F
                 ;    3387 			return (EOF);
001442 efef      	LDI  R30,LOW(65535)
001443 efff      	LDI  R31,HIGH(65535)
001444 c0f8      	RJMP _0x41F
                 ;    3388 		m = ((unsigned int) _FF_buff[0x3B] << 8) | (unsigned int) _FF_buff[0x3A];
                 _0x28F:
001445 91b0 09cb 	__GETBRMN 27,__FF_buff,59
001447 e0a0      	LDI  R26,LOW(0)
001448 91e0 09ca 	__GETB1MN __FF_buff,58
00144a e0f0      	LDI  R31,0
00144b 2bea      	OR   R30,R26
00144c 2bfb      	OR   R31,R27
00144d 87ed      	STD  Y+13,R30
00144e 87fe      	STD  Y+13+1,R31
                 ;    3389 		if (m)
00144f 9730      	SBIW R30,0
001450 f029      	BREQ _0x290
                 ;    3390 			_FF_DIR_ADDR = clust_to_addr(m);
001451 93fa      	ST   -Y,R31
001452 93ea      	ST   -Y,R30
001453 940e 0edf 	CALL _clust_to_addr
001455 c008      	RJMP _0x43B
                 ;    3391 		else
                 _0x290:
                 ;    3392 			_FF_DIR_ADDR = _FF_ROOT_ADDR;
001456 91e0 0bb9 	LDS  R30,__FF_ROOT_ADDR
001458 91f0 0bba 	LDS  R31,__FF_ROOT_ADDR+1
00145a 9160 0bbb 	LDS  R22,__FF_ROOT_ADDR+2
00145c 9170 0bbc 	LDS  R23,__FF_ROOT_ADDR+3
                 _0x43B:
00145e 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001460 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001462 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001464 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3393 		return (0);
001466 e0e0      	LDI  R30,LOW(0)
001467 e0f0      	LDI  R31,HIGH(0)
001468 c0d4      	RJMP _0x41F
                 ;    3394 	}
                 ;    3395 		
                 ;    3396 	qp = F_PATH;
                 _0x28B:
001469 8d0d
00146a 8d1e      	__GETWRS 16,17,29
                 ;    3397 	sp = fpath;
00146b 01fe      	MOVW R30,R28
00146c 963f      	ADIW R30,15
00146d 019f      	MOVW R18,R30
                 ;    3398 	while(sp < (fpath+11))
                 _0x292:
00146e 01fe      	MOVW R30,R28
00146f 967a      	ADIW R30,26
001470 172e      	CP   R18,R30
001471 073f      	CPC  R19,R31
001472 f520      	BRSH _0x294
                 ;    3399 	{
                 ;    3400 		if (valid_file_char(*qp)==0)
001473 01d8      	MOVW R26,R16
001474 91ec      	LD   R30,X
001475 93ea      	ST   -Y,R30
001476 940e 0c88 	CALL _valid_file_char
001478 9730      	SBIW R30,0
001479 f479      	BRNE _0x295
                 ;    3401 			*sp++ = toupper(*qp++);
00147a 933f      	PUSH R19
00147b 932f      	PUSH R18
00147c 5f2f
00147d 4f3f      	__ADDWRN 18,19,1
00147e 01d8      	MOVW R26,R16
00147f 5f0f
001480 4f1f      	__ADDWRN 16,17,1
001481 91ec      	LD   R30,X
001482 93ea      	ST   -Y,R30
001483 940e 1db7 	CALL _toupper
001485 91af      	POP  R26
001486 91bf      	POP  R27
001487 93ec      	ST   X,R30
                 ;    3402 		else if (*qp==0)
001488 c00d      	RJMP _0x296
                 _0x295:
001489 01d8      	MOVW R26,R16
00148a 91ec      	LD   R30,X
00148b 30e0      	CPI  R30,0
00148c f431      	BRNE _0x297
                 ;    3403 			*sp++ = 0x20;
00148d 01d9      	MOVW R26,R18
00148e 5f2f
00148f 4f3f      	__ADDWRN 18,19,1
001490 e2e0      	LDI  R30,LOW(32)
001491 93ec      	ST   X,R30
                 ;    3404 		else
001492 c003      	RJMP _0x298
                 _0x297:
                 ;    3405 			return (EOF);
001493 efef      	LDI  R30,LOW(65535)
001494 efff      	LDI  R31,HIGH(65535)
001495 c0a7      	RJMP _0x41F
                 ;    3406 	}     
                 _0x298:
                 _0x296:
001496 cfd7      	RJMP _0x292
                 _0x294:
                 ;    3407 	*sp = 0;
001497 01d9      	MOVW R26,R18
001498 e0e0      	LDI  R30,LOW(0)
001499 93ec      	ST   X,R30
                 ;    3408 	m = 0;
00149a e0e0      	LDI  R30,0
00149b 87ed      	STD  Y+13,R30
00149c 87ee      	STD  Y+13+1,R30
                 ;    3409 	d = 0;
00149d e0e0      	LDI  R30,0
00149e 83ef      	STD  Y+7,R30
00149f 87e8      	STD  Y+7+1,R30
                 ;    3410 	valid_flag = 0;
0014a0 e040      	LDI  R20,LOW(0)
                 ;    3411 	while (d<BPB_RootEntCnt)
                 _0x299:
0014a1 91e0 0b9c 	LDS  R30,_BPB_RootEntCnt
0014a3 91f0 0b9d 	LDS  R31,_BPB_RootEntCnt+1
0014a5 81af      	LDD  R26,Y+7
0014a6 85b8      	LDD  R27,Y+7+1
0014a7 17ae      	CP   R26,R30
0014a8 07bf      	CPC  R27,R31
0014a9 f010      	BRLO PC+3
0014aa 940c 153b 	JMP _0x29B
                 ;    3412 	{
                 ;    3413     	_FF_read(_FF_DIR_ADDR+(m*0x200));
0014ac 85ed      	LDD  R30,Y+13
0014ad 85fe      	LDD  R31,Y+13+1
0014ae 0fee      	LSL  R30
0014af 1fff      	ROL  R31
0014b0 2ffe      	MOV  R31,R30
0014b1 e0e0      	LDI  R30,0
0014b2 91a0 0bbd 	LDS  R26,__FF_DIR_ADDR
0014b4 91b0 0bbe 	LDS  R27,__FF_DIR_ADDR+1
0014b6 9180 0bbf 	LDS  R24,__FF_DIR_ADDR+2
0014b8 9190 0bc0 	LDS  R25,__FF_DIR_ADDR+3
0014ba 2766      	CLR  R22
0014bb 2777      	CLR  R23
0014bc 940e 1dca 	CALL __ADDD12
0014be 940e 1ecb 	CALL __PUTPARD1
0014c0 940e 0b52 	CALL __FF_read
                 ;    3414 		for (n=0; n<16; n++)
0014c2 e0e0      	LDI  R30,0
0014c3 87eb      	STD  Y+11,R30
0014c4 87ec      	STD  Y+11+1,R30
                 _0x29D:
0014c5 85ab      	LDD  R26,Y+11
0014c6 85bc      	LDD  R27,Y+11+1
0014c7 9750      	SBIW R26,16
0014c8 f010      	BRLO PC+3
0014c9 940c 1535 	JMP _0x29E
                 ;    3415 		{
                 ;    3416 			calc = (n*0x20);
0014cb 85eb      	LDD  R30,Y+11
0014cc 85fc      	LDD  R31,Y+11+1
0014cd 0fee      	LSL  R30
0014ce 1fff      	ROL  R31
0014cf 940e 1e08 	CALL __LSLW4
0014d1 83ed      	STD  Y+5,R30
0014d2 83fe      	STD  Y+5+1,R31
                 ;    3417 			if (_FF_buff[calc] == 0)	// no more entries in dir
0014d3 57e0      	SUBI R30,LOW(-__FF_buff)
0014d4 4ff6      	SBCI R31,HIGH(-__FF_buff)
0014d5 81e0      	LD   R30,Z
0014d6 30e0      	CPI  R30,0
0014d7 f419      	BRNE _0x29F
                 ;    3418 				return (EOF);
0014d8 efef      	LDI  R30,LOW(65535)
0014d9 efff      	LDI  R31,HIGH(65535)
0014da c062      	RJMP _0x41F
                 ;    3419 			for (c=0; c<11; c++)
                 _0x29F:
0014db e0e0      	LDI  R30,0
0014dc 87e9      	STD  Y+9,R30
0014dd 87ea      	STD  Y+9+1,R30
                 _0x2A1:
0014de 85a9      	LDD  R26,Y+9
0014df 85ba      	LDD  R27,Y+9+1
0014e0 971b      	SBIW R26,11
0014e1 f4e8      	BRSH _0x2A2
                 ;    3420 			{	// check for name match
                 ;    3421 				if (fpath[c] == _FF_buff[calc+c])
0014e2 85e9      	LDD  R30,Y+9
0014e3 85fa      	LDD  R31,Y+9+1
0014e4 01de      	MOVW R26,R28
0014e5 961f      	ADIW R26,15
0014e6 0fae      	ADD  R26,R30
0014e7 1fbf      	ADC  R27,R31
0014e8 900c      	LD   R0,X
0014e9 81ad      	LDD  R26,Y+5
0014ea 81be      	LDD  R27,Y+5+1
0014eb 0fea      	ADD  R30,R26
0014ec 1ffb      	ADC  R31,R27
0014ed 57e0      	SUBI R30,LOW(-__FF_buff)
0014ee 4ff6      	SBCI R31,HIGH(-__FF_buff)
0014ef 81e0      	LD   R30,Z
0014f0 15e0      	CP   R30,R0
0014f1 f411      	BRNE _0x2A3
                 ;    3422 					valid_flag = 1;
0014f2 e041      	LDI  R20,LOW(1)
                 ;    3423 				else
0014f3 c005      	RJMP _0x2A4
                 _0x2A3:
                 ;    3424 				{
                 ;    3425 					valid_flag = 0;	
0014f4 e040      	LDI  R20,LOW(0)
                 ;    3426 					c = 11;
0014f5 e0eb      	LDI  R30,LOW(11)
0014f6 e0f0      	LDI  R31,HIGH(11)
0014f7 87e9      	STD  Y+9,R30
0014f8 87fa      	STD  Y+9+1,R31
                 ;    3427 				}
                 _0x2A4:
                 ;    3428 		    }   
0014f9 85e9      	LDD  R30,Y+9
0014fa 85fa      	LDD  R31,Y+9+1
0014fb 9631      	ADIW R30,1
0014fc 87e9      	STD  Y+9,R30
0014fd 87fa      	STD  Y+9+1,R31
0014fe cfdf      	RJMP _0x2A1
                 _0x2A2:
                 ;    3429 		    if (valid_flag)
0014ff 3040      	CPI  R20,0
001500 f149      	BREQ _0x2A5
                 ;    3430 	  		{
                 ;    3431 	  			if (_FF_buff[calc+0xB] != 0x10)	// not a directory
001501 81ed      	LDD  R30,Y+5
001502 81fe      	LDD  R31,Y+5+1
001503 56e5
001504 4ff6      	__ADDW1MN __FF_buff,11
001505 81e0      	LD   R30,Z
001506 31e0      	CPI  R30,LOW(0x10)
001507 f011      	BREQ _0x2A6
                 ;    3432 	  				valid_flag = 0;
001508 e040      	LDI  R20,LOW(0)
                 ;    3433 	  			else
001509 c020      	RJMP _0x2A7
                 _0x2A6:
                 ;    3434 	  			{
                 ;    3435 	  				c = ((int) _FF_buff[calc+0x1B] << 8) | ((int) _FF_buff[calc+0x1A]);
00150a 81ed      	LDD  R30,Y+5
00150b 81fe      	LDD  R31,Y+5+1
00150c 55e5
00150d 4ff6      	__ADDW1MN __FF_buff,27
00150e 81f0      	LD   R31,Z
00150f e0e0      	LDI  R30,LOW(0)
001510 01df      	MOVW R26,R30
001511 81ed      	LDD  R30,Y+5
001512 81fe      	LDD  R31,Y+5+1
001513 55e6
001514 4ff6      	__ADDW1MN __FF_buff,26
001515 81e0      	LD   R30,Z
001516 e0f0      	LDI  R31,0
001517 2bea      	OR   R30,R26
001518 2bfb      	OR   R31,R27
001519 87e9      	STD  Y+9,R30
00151a 87fa      	STD  Y+9+1,R31
                 ;    3436 					_FF_DIR_ADDR = clust_to_addr(c);
00151b 93fa      	ST   -Y,R31
00151c 93ea      	ST   -Y,R30
00151d 940e 0edf 	CALL _clust_to_addr
00151f 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001521 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001523 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001525 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3437 					return (0);
001527 e0e0      	LDI  R30,LOW(0)
001528 e0f0      	LDI  R31,HIGH(0)
001529 c013      	RJMP _0x41F
                 ;    3438 				}
                 _0x2A7:
                 ;    3439 			}
                 ;    3440 		  	d++;		  		
                 _0x2A5:
00152a 81ef      	LDD  R30,Y+7
00152b 85f8      	LDD  R31,Y+7+1
00152c 9631      	ADIW R30,1
00152d 83ef      	STD  Y+7,R30
00152e 87f8      	STD  Y+7+1,R31
                 ;    3441 		}
00152f 85eb      	LDD  R30,Y+11
001530 85fc      	LDD  R31,Y+11+1
001531 9631      	ADIW R30,1
001532 87eb      	STD  Y+11,R30
001533 87fc      	STD  Y+11+1,R31
001534 cf90      	RJMP _0x29D
                 _0x29E:
                 ;    3442 		m++;
001535 85ed      	LDD  R30,Y+13
001536 85fe      	LDD  R31,Y+13+1
001537 9631      	ADIW R30,1
001538 87ed      	STD  Y+13,R30
001539 87fe      	STD  Y+13+1,R31
                 ;    3443 	}
00153a cf66      	RJMP _0x299
                 _0x29B:
                 ;    3444 	return (EOF);
00153b efef      	LDI  R30,LOW(65535)
00153c efff      	LDI  R31,HIGH(65535)
                 _0x41F:
00153d 940e 1f2c 	CALL __LOADLOCR5
00153f 966f      	ADIW R28,31
001540 9508      	RET
                 ;    3445 }
                 ;    3446 
                 ;    3447 #ifndef _SECOND_FAT_ON_
                 ;    3448 // Function that clears the secondary FAT table
                 ;    3449 int clear_second_FAT(void)
                 ;    3450 {
                 ;    3451 	unsigned int c, d;
                 ;    3452 	unsigned long n;
                 ;    3453 	
                 ;    3454 	for (n=1; n<BPB_FATSz16; n++)
                 ;    3455 	{
                 ;    3456 		if (_FF_read(_FF_FAT2_ADDR+(n*0x200))==0)
                 ;    3457 			return (EOF);
                 ;    3458 		for (c=0; c<BPB_BytsPerSec; c++)
                 ;    3459 		{
                 ;    3460 			if (_FF_buff[c] != 0)
                 ;    3461 			{
                 ;    3462 				for (d=0; d<BPB_BytsPerSec; d++)
                 ;    3463 					_FF_buff[d] = 0;
                 ;    3464 				if (_FF_write(_FF_FAT2_ADDR+(n*0x200))==0)
                 ;    3465 					return (EOF);
                 ;    3466 				break;
                 ;    3467 			}
                 ;    3468 		}
                 ;    3469 	}
                 ;    3470 	for (d=2; d<BPB_BytsPerSec; d++)
                 ;    3471 		_FF_buff[d] = 0;
                 ;    3472 	_FF_buff[0] = 0xF8;
                 ;    3473 	_FF_buff[1] = 0xFF;
                 ;    3474 	_FF_buff[2] = 0xFF;
                 ;    3475 	if (BPB_FATType == 0x36)
                 ;    3476 		_FF_buff[3] = 0xFF;
                 ;    3477 	if (_FF_write(_FF_FAT2_ADDR)==0)
                 ;    3478 		return (EOF);
                 ;    3479 	
                 ;    3480 	return (1);
                 ;    3481 }
                 ;    3482 #endif
                 ;    3483  
                 ;    3484 // Open a file, name stored in string fileopen
                 ;    3485 FILE *fopenc(unsigned char flash *NAMEC, unsigned char MODEC)
                 ;    3486 {
                 ;    3487 	unsigned char c, temp_data[12];
                 ;    3488 	FILE *tp;
                 ;    3489 	
                 ;    3490 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+16
                 ;	MODEC -> Y+15
                 ;	c -> R16
                 ;	temp_data -> Y+3
                 ;	*tp -> R17,R18
                 ;    3491 		temp_data[c] = NAMEC[c];
                 ;    3492 	
                 ;    3493 	tp = fopen(temp_data, MODEC);
                 ;    3494 	return(tp);
                 ;    3495 }
                 ;    3496 
                 ;    3497 FILE *fopen(unsigned char *NAME, unsigned char MODE)
                 ;    3498 {
                 _fopen:
                 ;    3499 	unsigned char fpath[14];
                 ;    3500 	unsigned int c, s, calc_temp;
                 ;    3501 	unsigned char *sp, *qp;
                 ;    3502 	unsigned long addr_temp, path_addr_temp;
                 ;    3503 	FILE *rp;
                 ;    3504 	
                 ;    3505 	#ifdef _READ_ONLY_
                 ;    3506 		if (MODE!=READ)
                 ;    3507 			return (0);
                 ;    3508 	#endif
                 ;    3509 	
                 ;    3510     addr_temp = 0;	// save local dir addr
001541 976c      	SBIW R28,28
001542 940e 1f24 	CALL __SAVELOCR6
                 ;	*NAME -> Y+35
                 ;	MODE -> Y+34
                 ;	fpath -> Y+20
                 ;	c -> R16,R17
                 ;	s -> R18,R19
                 ;	calc_temp -> R20,R21
                 ;	*sp -> Y+18
                 ;	*qp -> Y+16
                 ;	addr_temp -> Y+12
                 ;	path_addr_temp -> Y+8
                 ;	*rp -> Y+6
001544 e0e0
001545 87ec
001546 87ed
001547 87ee
001548 87ef      	__CLRD1S 12
                 ;    3511     
                 ;    3512     if (_FF_checkdir(NAME, &addr_temp, fpath))
001549 a1eb      	LDD  R30,Y+35
00154a a1fc      	LDD  R31,Y+35+1
00154b 93fa      	ST   -Y,R31
00154c 93ea      	ST   -Y,R30
00154d 01fe      	MOVW R30,R28
00154e 963e      	ADIW R30,14
00154f 93fa      	ST   -Y,R31
001550 93ea      	ST   -Y,R30
001551 01fe      	MOVW R30,R28
001552 9678      	ADIW R30,24
001553 93fa      	ST   -Y,R31
001554 93ea      	ST   -Y,R30
001555 940e 13a2 	CALL __FF_checkdir
001557 9730      	SBIW R30,0
001558 f079      	BREQ _0x2AB
                 ;    3513 	{
                 ;    3514 		_FF_DIR_ADDR = addr_temp;
001559 85ec
00155a 85fd
00155b 856e
00155c 857f      	__GETD1S 12
00155d 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00155f 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001561 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001563 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3515 		return (0);
001565 e0e0      	LDI  R30,LOW(0)
001566 e0f0      	LDI  R31,HIGH(0)
001567 c4aa      	RJMP _0x41E
                 ;    3516 	}
                 ;    3517 	if (fpath[0]==0)
                 _0x2AB:
001568 89ec      	LDD  R30,Y+20
001569 30e0      	CPI  R30,0
00156a f479      	BRNE _0x2AC
                 ;    3518 	{
                 ;    3519 		_FF_DIR_ADDR = addr_temp;
00156b 85ec
00156c 85fd
00156d 856e
00156e 857f      	__GETD1S 12
00156f 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001571 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001573 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001575 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3520 		return (0);
001577 e0e0      	LDI  R30,LOW(0)
001578 e0f0      	LDI  R31,HIGH(0)
001579 c498      	RJMP _0x41E
                 ;    3521 	}
                 ;    3522     
                 ;    3523 	path_addr_temp = _FF_DIR_ADDR;
                 _0x2AC:
00157a 91e0 0bbd 	LDS  R30,__FF_DIR_ADDR
00157c 91f0 0bbe 	LDS  R31,__FF_DIR_ADDR+1
00157e 9160 0bbf 	LDS  R22,__FF_DIR_ADDR+2
001580 9170 0bc0 	LDS  R23,__FF_DIR_ADDR+3
001582 87e8
001583 87f9
001584 876a
001585 877b      	__PUTD1S 8
                 ;    3524 	s = scan_directory(&path_addr_temp, fpath);
001586 01fe      	MOVW R30,R28
001587 9638      	ADIW R30,8
001588 93fa      	ST   -Y,R31
001589 93ea      	ST   -Y,R30
00158a 01fe      	MOVW R30,R28
00158b 9676      	ADIW R30,22
00158c 93fa      	ST   -Y,R31
00158d 93ea      	ST   -Y,R30
00158e 940e 0cb0 	CALL _scan_directory
001590 019f      	MOVW R18,R30
                 ;    3525 	if ((path_addr_temp==0) || (s==0))
001591 85a8
001592 85b9
001593 858a
001594 859b      	__GETD2S 8
001595 940e 1f14 	CALL __CPD02
001597 f021      	BREQ _0x2AE
001598 2400      	CLR  R0
001599 1602      	CP   R0,R18
00159a 0603      	CPC  R0,R19
00159b f479      	BRNE _0x2AD
                 _0x2AE:
                 ;    3526 	{
                 ;    3527 		_FF_DIR_ADDR = addr_temp;
00159c 85ec
00159d 85fd
00159e 856e
00159f 857f      	__GETD1S 12
0015a0 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0015a2 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0015a4 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0015a6 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3528 		return (0);
0015a8 e0e0      	LDI  R30,LOW(0)
0015a9 e0f0      	LDI  R31,HIGH(0)
0015aa c467      	RJMP _0x41E
                 ;    3529 	}
                 ;    3530 
                 ;    3531 	rp = 0;
                 _0x2AD:
0015ab e0e0      	LDI  R30,0
0015ac 83ee      	STD  Y+6,R30
0015ad 83ef      	STD  Y+6+1,R30
                 ;    3532 	rp = malloc(sizeof(FILE));
0015ae e2e9      	LDI  R30,LOW(553)
0015af e0f2      	LDI  R31,HIGH(553)
0015b0 93fa      	ST   -Y,R31
0015b1 93ea      	ST   -Y,R30
0015b2 940e 1d2a 	CALL _malloc
0015b4 83ee      	STD  Y+6,R30
0015b5 83ff      	STD  Y+6+1,R31
                 ;    3533 	if (rp == 0)
0015b6 9730      	SBIW R30,0
0015b7 f491      	BRNE _0x2B0
                 ;    3534 	{	// Could not allocate requested memory
                 ;    3535 		_FF_error = ALLOC_ERR;
0015b8 e0e9      	LDI  R30,LOW(9)
0015b9 93e0 0bd3 	STS  __FF_error,R30
                 ;    3536 		_FF_DIR_ADDR = addr_temp;
0015bb 85ec
0015bc 85fd
0015bd 856e
0015be 857f      	__GETD1S 12
0015bf 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0015c1 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0015c3 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0015c5 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3537 		return (0);
0015c7 e0e0      	LDI  R30,LOW(0)
0015c8 e0f0      	LDI  R31,HIGH(0)
0015c9 c448      	RJMP _0x41E
                 ;    3538 	}
                 ;    3539 	rp->length = 0x46344456;
                 _0x2B0:
0015ca 81ae      	LDD  R26,Y+6
0015cb 81bf      	LDD  R27,Y+6+1
0015cc 5ea4      	SUBI R26,LOW(-540)
0015cd 4fbd      	SBCI R27,HIGH(-540)
0015ce e5e6
0015cf e4f4
0015d0 e364
0015d1 e476      	__GETD1N 0x46344456
0015d2 940e 1ec2 	CALL __PUTDP1
                 ;    3540 	rp->clus_start = 0xe4;
0015d4 81ae      	LDD  R26,Y+6
0015d5 81bf      	LDD  R27,Y+6+1
0015d6 961c      	ADIW R26,12
0015d7 eee4      	LDI  R30,LOW(228)
0015d8 e0f0      	LDI  R31,HIGH(228)
0015d9 93ed      	ST   X+,R30
0015da 93fc      	ST   X,R31
                 ;    3541 	rp->position = 0x45664446;
0015db 81ae      	LDD  R26,Y+6
0015dc 81bf      	LDD  R27,Y+6+1
0015dd 5ea0      	SUBI R26,LOW(-544)
0015de 4fbd      	SBCI R27,HIGH(-544)
0015df e4e6
0015e0 e4f4
0015e1 e666
0015e2 e475      	__GETD1N 0x45664446
0015e3 940e 1ec2 	CALL __PUTDP1
                 ;    3542 
                 ;    3543 	calc_temp = path_addr_temp % BPB_BytsPerSec;
0015e5 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0015e7 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0015e9 85a8
0015ea 85b9
0015eb 858a
0015ec 859b      	__GETD2S 8
0015ed 2766      	CLR  R22
0015ee 2777      	CLR  R23
0015ef 940e 1e93 	CALL __MODD21U
0015f1 01af      	MOVW R20,R30
                 ;    3544 	path_addr_temp -= calc_temp;
0015f2 01fa      	MOVW R30,R20
0015f3 85a8
0015f4 85b9
0015f5 858a
0015f6 859b      	__GETD2S 8
0015f7 2766      	CLR  R22
0015f8 2777      	CLR  R23
0015f9 940e 1dd9 	CALL __SUBD21
0015fb 87a8
0015fc 87b9
0015fd 878a
0015fe 879b      	__PUTD2S 8
                 ;    3545 	if (_FF_read(path_addr_temp)==0)	
0015ff 85e8
001600 85f9
001601 856a
001602 857b      	__GETD1S 8
001603 940e 1ecb 	CALL __PUTPARD1
001605 940e 0b52 	CALL __FF_read
001607 30e0      	CPI  R30,0
001608 f479      	BRNE _0x2B1
                 ;    3546 	{
                 ;    3547 		_FF_DIR_ADDR = addr_temp;
001609 85ec
00160a 85fd
00160b 856e
00160c 857f      	__GETD1S 12
00160d 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00160f 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001611 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001613 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3548 		return (0);
001615 e0e0      	LDI  R30,LOW(0)
001616 e0f0      	LDI  R31,HIGH(0)
001617 c3fa      	RJMP _0x41E
                 ;    3549 	}
                 ;    3550 	
                 ;    3551 	// Get the filename into a form we can use to compare
                 ;    3552 	qp = file_name_conversion(fpath);
                 _0x2B1:
001618 01fe      	MOVW R30,R28
001619 9674      	ADIW R30,20
00161a 93fa      	ST   -Y,R31
00161b 93ea      	ST   -Y,R30
00161c 940e 1070 	CALL _file_name_conversion
00161e 8be8      	STD  Y+16,R30
00161f 8bf9      	STD  Y+16+1,R31
                 ;    3553 	if (qp==0)
001620 9730      	SBIW R30,0
001621 f4a9      	BRNE _0x2B2
                 ;    3554 	{	// If File name entered is NOT valid, return 0
                 ;    3555 		free(rp);
001622 81ee      	LDD  R30,Y+6
001623 81ff      	LDD  R31,Y+6+1
001624 93fa      	ST   -Y,R31
001625 93ea      	ST   -Y,R30
001626 940e 1d47 	CALL _free
                 ;    3556 		_FF_DIR_ADDR = addr_temp;
001628 85ec
001629 85fd
00162a 856e
00162b 857f      	__GETD1S 12
00162c 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00162e 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001630 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001632 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3557 		return (0);
001634 e0e0      	LDI  R30,LOW(0)
001635 e0f0      	LDI  R31,HIGH(0)
001636 c3db      	RJMP _0x41E
                 ;    3558 	}
                 ;    3559 	
                 ;    3560 	sp = &_FF_buff[calc_temp];
                 _0x2B2:
001637 01fa      	MOVW R30,R20
001638 57e0      	SUBI R30,LOW(-__FF_buff)
001639 4ff6      	SBCI R31,HIGH(-__FF_buff)
00163a 8bea      	STD  Y+18,R30
00163b 8bfb      	STD  Y+18+1,R31
                 ;    3561 
                 ;    3562 	if (s)
00163c 2e02      	MOV  R0,R18
00163d 2a03      	OR   R0,R19
00163e f411      	BRNE PC+3
00163f 940c 1821 	JMP _0x2B3
                 ;    3563 	{	// File exists, open 
                 ;    3564 		if (((MODE==WRITE) || (MODE==APPEND)) && (_FF_buff[calc_temp+0x0B]&0x01))
001641 a1aa      	LDD  R26,Y+34
001642 30a2      	CPI  R26,LOW(0x2)
001643 f011      	BREQ _0x2B5
001644 30a3      	CPI  R26,LOW(0x3)
001645 f431      	BRNE _0x2B7
                 _0x2B5:
001646 01fa      	MOVW R30,R20
001647 56e5
001648 4ff6      	__ADDW1MN __FF_buff,11
001649 81e0      	LD   R30,Z
00164a 70e1      	ANDI R30,LOW(0x1)
00164b f409      	BRNE _0x2B8
                 _0x2B7:
00164c c018      	RJMP _0x2B4
                 _0x2B8:
                 ;    3565 		{	// if writing to file verify it is not "READ ONLY"
                 ;    3566 			_FF_error = MODE_ERR;
00164d e0eb      	LDI  R30,LOW(11)
00164e 93e0 0bd3 	STS  __FF_error,R30
                 ;    3567 			free(rp);
001650 81ee      	LDD  R30,Y+6
001651 81ff      	LDD  R31,Y+6+1
001652 93fa      	ST   -Y,R31
001653 93ea      	ST   -Y,R30
001654 940e 1d47 	CALL _free
                 ;    3568 			_FF_DIR_ADDR = addr_temp;
001656 85ec
001657 85fd
001658 856e
001659 857f      	__GETD1S 12
00165a 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00165c 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00165e 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001660 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3569 			return (0);
001662 e0e0      	LDI  R30,LOW(0)
001663 e0f0      	LDI  R31,HIGH(0)
001664 c3ad      	RJMP _0x41E
                 ;    3570 		}
                 ;    3571 		for (c=0; c<12; c++)	// Save Filename to Buffer
                 _0x2B4:
001665 e000
001666 e010      	__GETWRN 16,17,0
                 _0x2BA:
001667 300c
001668 e0e0
001669 071e      	__CPWRN 16,17,12
00166a f480      	BRSH _0x2BB
                 ;    3572 			rp->name[c] = FILENAME[c];
00166b 01f8      	MOVW R30,R16
00166c 81ae      	LDD  R26,Y+6
00166d 81bf      	LDD  R27,Y+6+1
00166e 0fea      	ADD  R30,R26
00166f 1ffb      	ADC  R31,R27
001670 010f      	MOVW R0,R30
001671 e5a1      	LDI  R26,LOW(_FILENAME)
001672 e0bc      	LDI  R27,HIGH(_FILENAME)
001673 0fa0      	ADD  R26,R16
001674 1fb1      	ADC  R27,R17
001675 91ec      	LD   R30,X
001676 01d0      	MOVW R26,R0
001677 93ec      	ST   X,R30
                 ;    3573 		// Save Starting Cluster
                 ;    3574 		rp->clus_start = ((int) _FF_buff[calc_temp+0x1B] << 8) | (int) _FF_buff[calc_temp+0x1A];
001678 5f0f
001679 4f1f      	__ADDWRN 16,17,1
00167a cfec      	RJMP _0x2BA
                 _0x2BB:
00167b 01fa      	MOVW R30,R20
00167c 55e5
00167d 4ff6      	__ADDW1MN __FF_buff,27
00167e 81f0      	LD   R31,Z
00167f e0e0      	LDI  R30,LOW(0)
001680 01df      	MOVW R26,R30
001681 01fa      	MOVW R30,R20
001682 55e6
001683 4ff6      	__ADDW1MN __FF_buff,26
001684 81e0      	LD   R30,Z
001685 e0f0      	LDI  R31,0
001686 2bea      	OR   R30,R26
001687 2bfb      	OR   R31,R27
001688 81ae
001689 81bf
00168a 961c
00168b 93ed
00168c 93fc      	__PUTW1SNS 6,12
                 ;    3575 		// Set Current Cluster
                 ;    3576 		rp->clus_current = rp->clus_start;
00168d 81ae      	LDD  R26,Y+6
00168e 81bf      	LDD  R27,Y+6+1
00168f 961c      	ADIW R26,12
001690 940e 1eb8 	CALL __GETW1P
001692 81ae
001693 81bf
001694 961e
001695 93ed
001696 93fc      	__PUTW1SNS 6,14
                 ;    3577 		// Set Previous Cluster to 0 (indicating @start)
                 ;    3578 		rp->clus_prev = 0;
001697 81ae      	LDD  R26,Y+6
001698 81bf      	LDD  R27,Y+6+1
001699 9652      	ADIW R26,18
00169a e0e0      	LDI  R30,LOW(0)
00169b e0f0      	LDI  R31,HIGH(0)
00169c 93ed      	ST   X+,R30
00169d 93fc      	ST   X,R31
                 ;    3579 		// Save file length
                 ;    3580 		rp->length = 0;
00169e 81ae      	LDD  R26,Y+6
00169f 81bf      	LDD  R27,Y+6+1
0016a0 5ea4      	SUBI R26,LOW(-540)
0016a1 4fbd      	SBCI R27,HIGH(-540)
0016a2 e0e0
0016a3 e0f0
0016a4 e060
0016a5 e070      	__GETD1N 0x0
0016a6 940e 1ec2 	CALL __PUTDP1
                 ;    3581 		sp = _FF_buff + calc_temp + 0x1F;
0016a8 01fa      	MOVW R30,R20
0016a9 57e0      	SUBI R30,LOW(-__FF_buff)
0016aa 4ff6      	SBCI R31,HIGH(-__FF_buff)
0016ab 967f      	ADIW R30,31
0016ac 8bea      	STD  Y+18,R30
0016ad 8bfb      	STD  Y+18+1,R31
                 ;    3582 		for (c=0; c<4; c++)
0016ae e000
0016af e010      	__GETWRN 16,17,0
                 _0x2BD:
0016b0 3004
0016b1 e0e0
0016b2 071e      	__CPWRN 16,17,4
0016b3 f5a0      	BRSH _0x2BE
                 ;    3583 		{
                 ;    3584 			rp->length <<= 8;
0016b4 81ee      	LDD  R30,Y+6
0016b5 81ff      	LDD  R31,Y+6+1
0016b6 5ee4      	SUBI R30,LOW(-540)
0016b7 4ffd      	SBCI R31,HIGH(-540)
0016b8 93ff      	PUSH R31
0016b9 93ef      	PUSH R30
0016ba 01df      	MOVW R26,R30
0016bb 940e 1ebc 	CALL __GETD1P
0016bd 01df      	MOVW R26,R30
0016be 01cb      	MOVW R24,R22
0016bf e0e8      	LDI  R30,LOW(8)
0016c0 940e 1df0 	CALL __LSLD12
0016c2 91af      	POP  R26
0016c3 91bf      	POP  R27
0016c4 940e 1ec2 	CALL __PUTDP1
                 ;    3585 			rp->length |= *sp--;
0016c6 81ee      	LDD  R30,Y+6
0016c7 81ff      	LDD  R31,Y+6+1
0016c8 5ee4      	SUBI R30,LOW(-540)
0016c9 4ffd      	SBCI R31,HIGH(-540)
0016ca 010f      	MOVW R0,R30
0016cb 01df      	MOVW R26,R30
0016cc 940e 1ebc 	CALL __GETD1P
0016ce 937f      	PUSH R23
0016cf 936f      	PUSH R22
0016d0 93ff      	PUSH R31
0016d1 93ef      	PUSH R30
0016d2 89aa      	LDD  R26,Y+18
0016d3 89bb      	LDD  R27,Y+18+1
0016d4 9711      	SBIW R26,1
0016d5 8baa      	STD  Y+18,R26
0016d6 8bbb      	STD  Y+18+1,R27
0016d7 9611      	ADIW R26,1
0016d8 91ec      	LD   R30,X
0016d9 91af      	POP  R26
0016da 91bf      	POP  R27
0016db 918f      	POP  R24
0016dc 919f      	POP  R25
0016dd 27ff      	CLR  R31
0016de 2766      	CLR  R22
0016df 2777      	CLR  R23
0016e0 940e 1dde 	CALL __ORD12
0016e2 01d0      	MOVW R26,R0
0016e3 940e 1ec2 	CALL __PUTDP1
                 ;    3586 		}
0016e5 5f0f
0016e6 4f1f      	__ADDWRN 16,17,1
0016e7 cfc8      	RJMP _0x2BD
                 _0x2BE:
                 ;    3587 		// Set Current Position to 0
                 ;    3588 		rp->position = 0;
0016e8 81ae      	LDD  R26,Y+6
0016e9 81bf      	LDD  R27,Y+6+1
0016ea 5ea0      	SUBI R26,LOW(-544)
0016eb 4fbd      	SBCI R27,HIGH(-544)
0016ec e0e0
0016ed e0f0
0016ee e060
0016ef e070      	__GETD1N 0x0
0016f0 940e 1ec2 	CALL __PUTDP1
                 ;    3589 		#ifndef _READ_ONLY_
                 ;    3590 			if (MODE==WRITE)
0016f2 a1aa      	LDD  R26,Y+34
0016f3 30a2      	CPI  R26,LOW(0x2)
0016f4 f011      	BREQ PC+3
0016f5 940c 175e 	JMP _0x2BF
                 ;    3591 			{	// Change file to blank
                 ;    3592 				sp = _FF_buff + calc_temp + 0x1F;
0016f7 01fa      	MOVW R30,R20
0016f8 57e0      	SUBI R30,LOW(-__FF_buff)
0016f9 4ff6      	SBCI R31,HIGH(-__FF_buff)
0016fa 967f      	ADIW R30,31
0016fb 8bea      	STD  Y+18,R30
0016fc 8bfb      	STD  Y+18+1,R31
                 ;    3593 				for (c=0; c<6; c++)
0016fd e000
0016fe e010      	__GETWRN 16,17,0
                 _0x2C1:
0016ff 3006
001700 e0e0
001701 071e      	__CPWRN 16,17,6
001702 f458      	BRSH _0x2C2
                 ;    3594 					*sp-- = 0;
001703 89aa      	LDD  R26,Y+18
001704 89bb      	LDD  R27,Y+18+1
001705 9711      	SBIW R26,1
001706 8baa      	STD  Y+18,R26
001707 8bbb      	STD  Y+18+1,R27
001708 9611      	ADIW R26,1
001709 e0e0      	LDI  R30,LOW(0)
00170a 93ec      	ST   X,R30
                 ;    3595 				if (rp->length)
00170b 5f0f
00170c 4f1f      	__ADDWRN 16,17,1
00170d cff1      	RJMP _0x2C1
                 _0x2C2:
00170e 81ae      	LDD  R26,Y+6
00170f 81bf      	LDD  R27,Y+6+1
001710 5ea4      	SUBI R26,LOW(-540)
001711 4fbd      	SBCI R27,HIGH(-540)
001712 940e 1ebc 	CALL __GETD1P
001714 940e 1f0c 	CALL __CPD10
001716 f411      	BRNE PC+3
001717 940c 175e 	JMP _0x2C3
                 ;    3596 				{
                 ;    3597 					if (_FF_write(_FF_DIR_ADDR + (0x200 * s))==0)
001719 01f9      	MOVW R30,R18
00171a 0fee      	LSL  R30
00171b 1fff      	ROL  R31
00171c 2ffe      	MOV  R31,R30
00171d e0e0      	LDI  R30,0
00171e 91a0 0bbd 	LDS  R26,__FF_DIR_ADDR
001720 91b0 0bbe 	LDS  R27,__FF_DIR_ADDR+1
001722 9180 0bbf 	LDS  R24,__FF_DIR_ADDR+2
001724 9190 0bc0 	LDS  R25,__FF_DIR_ADDR+3
001726 2766      	CLR  R22
001727 2777      	CLR  R23
001728 940e 1dca 	CALL __ADDD12
00172a 940e 1ecb 	CALL __PUTPARD1
00172c 940e 0bf9 	CALL __FF_write
00172e 30e0      	CPI  R30,0
00172f f4a9      	BRNE _0x2C4
                 ;    3598 					{
                 ;    3599 						free(rp);
001730 81ee      	LDD  R30,Y+6
001731 81ff      	LDD  R31,Y+6+1
001732 93fa      	ST   -Y,R31
001733 93ea      	ST   -Y,R30
001734 940e 1d47 	CALL _free
                 ;    3600 						_FF_DIR_ADDR = addr_temp;
001736 85ec
001737 85fd
001738 856e
001739 857f      	__GETD1S 12
00173a 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00173c 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00173e 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001740 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3601 						return (0);
001742 e0e0      	LDI  R30,LOW(0)
001743 e0f0      	LDI  R31,HIGH(0)
001744 c2cd      	RJMP _0x41E
                 ;    3602 					}
                 ;    3603 					rp->length = 0;
                 _0x2C4:
001745 81ae      	LDD  R26,Y+6
001746 81bf      	LDD  R27,Y+6+1
001747 5ea4      	SUBI R26,LOW(-540)
001748 4fbd      	SBCI R27,HIGH(-540)
001749 e0e0
00174a e0f0
00174b e060
00174c e070      	__GETD1N 0x0
00174d 940e 1ec2 	CALL __PUTDP1
                 ;    3604 					erase_clus_chain(rp->clus_start);
00174f 81ee      	LDD  R30,Y+6
001750 81ff      	LDD  R31,Y+6+1
001751 85a4      	LDD  R26,Z+12
001752 85b5      	LDD  R27,Z+13
001753 93ba      	ST   -Y,R27
001754 93aa      	ST   -Y,R26
001755 940e 12a6 	CALL _erase_clus_chain
                 ;    3605 					rp->clus_start = 0;
001757 81ae      	LDD  R26,Y+6
001758 81bf      	LDD  R27,Y+6+1
001759 961c      	ADIW R26,12
00175a e0e0      	LDI  R30,LOW(0)
00175b e0f0      	LDI  R31,HIGH(0)
00175c 93ed      	ST   X+,R30
00175d 93fc      	ST   X,R31
                 ;    3606 				}
                 ;    3607 			}
                 _0x2C3:
                 ;    3608 		#endif
                 ;    3609 		// Set and save next cluster #
                 ;    3610 		rp->clus_next = next_cluster(rp->clus_current, SINGLE);
                 _0x2BF:
00175e 81ee      	LDD  R30,Y+6
00175f 81ff      	LDD  R31,Y+6+1
001760 85a6      	LDD  R26,Z+14
001761 85b7      	LDD  R27,Z+15
001762 93ba      	ST   -Y,R27
001763 93aa      	ST   -Y,R26
001764 e0e1      	LDI  R30,LOW(1)
001765 93ea      	ST   -Y,R30
001766 940e 0f9b 	CALL _next_cluster
001768 81ae
001769 81bf
00176a 9650
00176b 93ed
00176c 93fc      	__PUTW1SNS 6,16
                 ;    3611 		if ((rp->length==0) && (rp->clus_start==0))
00176d 81ae      	LDD  R26,Y+6
00176e 81bf      	LDD  R27,Y+6+1
00176f 5ea4      	SUBI R26,LOW(-540)
001770 4fbd      	SBCI R27,HIGH(-540)
001771 940e 1ebc 	CALL __GETD1P
001773 940e 1f0c 	CALL __CPD10
001775 f439      	BRNE _0x2C6
001776 81ae      	LDD  R26,Y+6
001777 81bf      	LDD  R27,Y+6+1
001778 961c      	ADIW R26,12
001779 940e 1eb8 	CALL __GETW1P
00177b 9730      	SBIW R30,0
00177c f009      	BREQ _0x2C7
                 _0x2C6:
00177d c01d      	RJMP _0x2C5
                 _0x2C7:
                 ;    3612 		{	// Check for Blank File 
                 ;    3613 			if (MODE==READ)
00177e a1aa      	LDD  R26,Y+34
00177f 30a1      	CPI  R26,LOW(0x1)
001780 f4c1      	BRNE _0x2C8
                 ;    3614 			{	// IF trying to open a blank file to read, ERROR
                 ;    3615 				_FF_error = MODE_ERR;
001781 e0eb      	LDI  R30,LOW(11)
001782 93e0 0bd3 	STS  __FF_error,R30
                 ;    3616 				free(rp);
001784 81ee      	LDD  R30,Y+6
001785 81ff      	LDD  R31,Y+6+1
001786 93fa      	ST   -Y,R31
001787 93ea      	ST   -Y,R30
001788 940e 1d47 	CALL _free
                 ;    3617 				_FF_DIR_ADDR = addr_temp;
00178a 85ec
00178b 85fd
00178c 856e
00178d 857f      	__GETD1S 12
00178e 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001790 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001792 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001794 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3618 				return (0);
001796 e0e0      	LDI  R30,LOW(0)
001797 e0f0      	LDI  R31,HIGH(0)
001798 c279      	RJMP _0x41E
                 ;    3619 			}
                 ;    3620 			//Setup blank FILE characteristics
                 ;    3621 			#ifndef _READ_ONLY_
                 ;    3622 				MODE = WRITE; 
                 _0x2C8:
001799 e0e2      	LDI  R30,LOW(2)
00179a a3ea      	STD  Y+34,R30
                 ;    3623 			#endif
                 ;    3624 		}
                 ;    3625 		// Save the file offset to read entry
                 ;    3626 		rp->entry_sec_addr = path_addr_temp;
                 _0x2C5:
00179b 85e8
00179c 85f9
00179d 856a
00179e 857b      	__GETD1S 8
00179f 81ae
0017a0 81bf
0017a1 9656
0017a2 940e 1ec2 	__PUTD1SNS 6,22
                 ;    3627 		rp->entry_offset =  calc_temp;
0017a4 01fa      	MOVW R30,R20
0017a5 81ae
0017a6 81bf
0017a7 965a
0017a8 93ed
0017a9 93fc      	__PUTW1SNS 6,26
                 ;    3628 		// Set sector offset to 1
                 ;    3629 		rp->sec_offset = 1;
0017aa 81ae      	LDD  R26,Y+6
0017ab 81bf      	LDD  R27,Y+6+1
0017ac 9654      	ADIW R26,20
0017ad e0e1      	LDI  R30,LOW(1)
0017ae e0f0      	LDI  R31,HIGH(1)
0017af 93ed      	ST   X+,R30
0017b0 93fc      	ST   X,R31
                 ;    3630 		if (MODE==APPEND)
0017b1 a1aa      	LDD  R26,Y+34
0017b2 30a3      	CPI  R26,LOW(0x3)
0017b3 f539      	BRNE _0x2C9
                 ;    3631 		{
                 ;    3632 			if (fseek(rp, 0,SEEK_END)==EOF)
0017b4 81ee      	LDD  R30,Y+6
0017b5 81ff      	LDD  R31,Y+6+1
0017b6 93fa      	ST   -Y,R31
0017b7 93ea      	ST   -Y,R30
0017b8 e0e0
0017b9 e0f0
0017ba e060
0017bb e070      	__GETD1N 0x0
0017bc 940e 1ecb 	CALL __PUTPARD1
0017be e0e1      	LDI  R30,LOW(1)
0017bf 93ea      	ST   -Y,R30
0017c0 d2ed      	RCALL _fseek
0017c1 3fef      	CPI  R30,LOW(0xFFFF)
0017c2 efaf      	LDI  R26,HIGH(0xFFFF)
0017c3 07fa      	CPC  R31,R26
0017c4 f4a9      	BRNE _0x2CA
                 ;    3633 			{
                 ;    3634 				free(rp);
0017c5 81ee      	LDD  R30,Y+6
0017c6 81ff      	LDD  R31,Y+6+1
0017c7 93fa      	ST   -Y,R31
0017c8 93ea      	ST   -Y,R30
0017c9 940e 1d47 	CALL _free
                 ;    3635 				_FF_DIR_ADDR = addr_temp;
0017cb 85ec
0017cc 85fd
0017cd 856e
0017ce 857f      	__GETD1S 12
0017cf 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0017d1 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0017d3 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0017d5 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3636 				return (0);
0017d7 e0e0      	LDI  R30,LOW(0)
0017d8 e0f0      	LDI  R31,HIGH(0)
0017d9 c238      	RJMP _0x41E
                 ;    3637 			}
                 ;    3638 		}
                 _0x2CA:
                 ;    3639 		else
0017da c02e      	RJMP _0x2CB
                 _0x2C9:
                 ;    3640 		{	// Set pointer to the begining of the file
                 ;    3641 			_FF_read(clust_to_addr(rp->clus_current));
0017db 81ee      	LDD  R30,Y+6
0017dc 81ff      	LDD  R31,Y+6+1
0017dd 85a6      	LDD  R26,Z+14
0017de 85b7      	LDD  R27,Z+15
0017df 93ba      	ST   -Y,R27
0017e0 93aa      	ST   -Y,R26
0017e1 940e 0edf 	CALL _clust_to_addr
0017e3 940e 1ecb 	CALL __PUTPARD1
0017e5 940e 0b52 	CALL __FF_read
                 ;    3642 			for (c=0; c<BPB_BytsPerSec; c++)
0017e7 e000
0017e8 e010      	__GETWRN 16,17,0
                 _0x2CD:
0017e9 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0017eb 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0017ed 170e      	CP   R16,R30
0017ee 071f      	CPC  R17,R31
0017ef f480      	BRSH _0x2CE
                 ;    3643 				rp->buff[c] = _FF_buff[c];
0017f0 81ee      	LDD  R30,Y+6
0017f1 81ff      	LDD  R31,Y+6+1
0017f2 967c      	ADIW R30,28
0017f3 0fe0      	ADD  R30,R16
0017f4 1ff1      	ADC  R31,R17
0017f5 010f      	MOVW R0,R30
0017f6 e9a0      	LDI  R26,LOW(__FF_buff)
0017f7 e0b9      	LDI  R27,HIGH(__FF_buff)
0017f8 0fa0      	ADD  R26,R16
0017f9 1fb1      	ADC  R27,R17
0017fa 91ec      	LD   R30,X
0017fb 01d0      	MOVW R26,R0
0017fc 93ec      	ST   X,R30
                 ;    3644 			rp->pntr = &rp->buff[0];
0017fd 5f0f
0017fe 4f1f      	__ADDWRN 16,17,1
0017ff cfe9      	RJMP _0x2CD
                 _0x2CE:
001800 81ee      	LDD  R30,Y+6
001801 81ff      	LDD  R31,Y+6+1
001802 967c      	ADIW R30,28
001803 81ae
001804 81bf
001805 5da9
001806 4fbd
001807 93ed
001808 93fc      	__PUTW1SN 6,551
                 ;    3645 		}
                 _0x2CB:
                 ;    3646 		#ifndef _READ_ONLY_
                 ;    3647 			#ifndef _SECOND_FAT_ON_
                 ;    3648 				if ((MODE==WRITE) || (MODE==APPEND))
                 ;    3649 					clear_second_FAT();
                 ;    3650 			#endif
                 ;    3651     	#endif
                 ;    3652 		rp->mode = MODE;
001809 a1ea      	LDD  R30,Y+34
00180a 81ae
00180b 81bf
00180c 5dac
00180d 4fbd
00180e 93ec      	__PUTB1SN 6,548
                 ;    3653 		_FF_error = NO_ERR;
00180f e0e0      	LDI  R30,LOW(0)
001810 93e0 0bd3 	STS  __FF_error,R30
                 ;    3654 		_FF_DIR_ADDR = addr_temp;
001812 85ec
001813 85fd
001814 856e
001815 857f      	__GETD1S 12
001816 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001818 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00181a 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
00181c 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3655 		return(rp);
00181e 81ee      	LDD  R30,Y+6
00181f 81ff      	LDD  R31,Y+6+1
001820 c1f1      	RJMP _0x41E
                 ;    3656 	}
                 ;    3657 	else
                 _0x2B3:
                 ;    3658 	{                          		
                 ;    3659 		_FF_error = FILE_ERR;
001821 e0e2      	LDI  R30,LOW(2)
001822 93e0 0bd3 	STS  __FF_error,R30
                 ;    3660 		free(rp);
001824 81ee      	LDD  R30,Y+6
001825 81ff      	LDD  R31,Y+6+1
001826 93fa      	ST   -Y,R31
001827 93ea      	ST   -Y,R30
001828 940e 1d47 	CALL _free
                 ;    3661 		_FF_DIR_ADDR = addr_temp;
00182a 85ec
00182b 85fd
00182c 856e
00182d 857f      	__GETD1S 12
00182e 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001830 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001832 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001834 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3662 		return(0);
001836 e0e0      	LDI  R30,LOW(0)
001837 e0f0      	LDI  R31,HIGH(0)
001838 c1d9      	RJMP _0x41E
                 ;    3663 	}
                 ;    3664 }
                 ;    3665 
                 ;    3666 #ifndef _READ_ONLY_
                 ;    3667 // Create a file
                 ;    3668 FILE *fcreatec(unsigned char flash *NAMEC, unsigned char MODE)
                 ;    3669 {
                 ;    3670 	unsigned char sd_temp[12];
                 ;    3671 	int c;
                 ;    3672 
                 ;    3673 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+15
                 ;	MODE -> Y+14
                 ;	sd_temp -> Y+2
                 ;	c -> R16,R17
                 ;    3674 		sd_temp[c] = NAMEC[c];
                 ;    3675 	
                 ;    3676 	return (fcreate(sd_temp, MODE));
                 ;    3677 }
                 ;    3678 
                 ;    3679 FILE *fcreate(unsigned char *NAME, unsigned char MODE)
                 ;    3680 {
                 _fcreate:
                 ;    3681 	unsigned char fpath[14];
                 ;    3682 	unsigned int c, s, calc_temp;
                 ;    3683 	unsigned char *sp, *qp;
                 ;    3684 	unsigned long addr_temp, path_addr_temp;
                 ;    3685 	FILE *temp_file_pntr;
                 ;    3686 
                 ;    3687     addr_temp = 0;	// save local dir addr
001839 976c      	SBIW R28,28
00183a 940e 1f24 	CALL __SAVELOCR6
                 ;	*NAME -> Y+35
                 ;	MODE -> Y+34
                 ;	fpath -> Y+20
                 ;	c -> R16,R17
                 ;	s -> R18,R19
                 ;	calc_temp -> R20,R21
                 ;	*sp -> Y+18
                 ;	*qp -> Y+16
                 ;	addr_temp -> Y+12
                 ;	path_addr_temp -> Y+8
                 ;	*temp_file_pntr -> Y+6
00183c e0e0
00183d 87ec
00183e 87ed
00183f 87ee
001840 87ef      	__CLRD1S 12
                 ;    3688     
                 ;    3689     if (_FF_checkdir(NAME, &addr_temp, fpath))
001841 a1eb      	LDD  R30,Y+35
001842 a1fc      	LDD  R31,Y+35+1
001843 93fa      	ST   -Y,R31
001844 93ea      	ST   -Y,R30
001845 01fe      	MOVW R30,R28
001846 963e      	ADIW R30,14
001847 93fa      	ST   -Y,R31
001848 93ea      	ST   -Y,R30
001849 01fe      	MOVW R30,R28
00184a 9678      	ADIW R30,24
00184b 93fa      	ST   -Y,R31
00184c 93ea      	ST   -Y,R30
00184d 940e 13a2 	CALL __FF_checkdir
00184f 9730      	SBIW R30,0
001850 f091      	BREQ _0x2D3
                 ;    3690 	{
                 ;    3691 		_FF_error = PATH_ERR;
001851 e0ee      	LDI  R30,LOW(14)
001852 93e0 0bd3 	STS  __FF_error,R30
                 ;    3692 		_FF_DIR_ADDR = addr_temp;
001854 85ec
001855 85fd
001856 856e
001857 857f      	__GETD1S 12
001858 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00185a 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
00185c 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
00185e 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3693 		return (0);
001860 e0e0      	LDI  R30,LOW(0)
001861 e0f0      	LDI  R31,HIGH(0)
001862 c1af      	RJMP _0x41E
                 ;    3694 	}
                 ;    3695 	if (fpath[0]==0)
                 _0x2D3:
001863 89ec      	LDD  R30,Y+20
001864 30e0      	CPI  R30,0
001865 f491      	BRNE _0x2D4
                 ;    3696 	{
                 ;    3697 		_FF_error = NAME_ERR; 
001866 e0e5      	LDI  R30,LOW(5)
001867 93e0 0bd3 	STS  __FF_error,R30
                 ;    3698 		_FF_DIR_ADDR = addr_temp;
001869 85ec
00186a 85fd
00186b 856e
00186c 857f      	__GETD1S 12
00186d 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00186f 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001871 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001873 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3699 		return (0);
001875 e0e0      	LDI  R30,LOW(0)
001876 e0f0      	LDI  R31,HIGH(0)
001877 c19a      	RJMP _0x41E
                 ;    3700 	}
                 ;    3701     
                 ;    3702 	path_addr_temp = _FF_DIR_ADDR;
                 _0x2D4:
001878 91e0 0bbd 	LDS  R30,__FF_DIR_ADDR
00187a 91f0 0bbe 	LDS  R31,__FF_DIR_ADDR+1
00187c 9160 0bbf 	LDS  R22,__FF_DIR_ADDR+2
00187e 9170 0bc0 	LDS  R23,__FF_DIR_ADDR+3
001880 87e8
001881 87f9
001882 876a
001883 877b      	__PUTD1S 8
                 ;    3703 	s = scan_directory(&path_addr_temp, fpath);
001884 01fe      	MOVW R30,R28
001885 9638      	ADIW R30,8
001886 93fa      	ST   -Y,R31
001887 93ea      	ST   -Y,R30
001888 01fe      	MOVW R30,R28
001889 9676      	ADIW R30,22
00188a 93fa      	ST   -Y,R31
00188b 93ea      	ST   -Y,R30
00188c 940e 0cb0 	CALL _scan_directory
00188e 019f      	MOVW R18,R30
                 ;    3704 	if (path_addr_temp==0)
00188f 85e8
001890 85f9
001891 856a
001892 857b      	__GETD1S 8
001893 940e 1f0c 	CALL __CPD10
001895 f491      	BRNE _0x2D5
                 ;    3705 	{
                 ;    3706 		_FF_error = NO_ENTRY_AVAL;
001896 e0ef      	LDI  R30,LOW(15)
001897 93e0 0bd3 	STS  __FF_error,R30
                 ;    3707 		_FF_DIR_ADDR = addr_temp;
001899 85ec
00189a 85fd
00189b 856e
00189c 857f      	__GETD1S 12
00189d 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
00189f 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0018a1 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0018a3 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3708 		return (0);
0018a5 e0e0      	LDI  R30,LOW(0)
0018a6 e0f0      	LDI  R31,HIGH(0)
0018a7 c16a      	RJMP _0x41E
                 ;    3709 	}
                 ;    3710 
                 ;    3711 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 _0x2D5:
0018a8 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
0018aa 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
0018ac 85a8
0018ad 85b9
0018ae 858a
0018af 859b      	__GETD2S 8
0018b0 2766      	CLR  R22
0018b1 2777      	CLR  R23
0018b2 940e 1e93 	CALL __MODD21U
0018b4 01af      	MOVW R20,R30
                 ;    3712 	path_addr_temp -= calc_temp;
0018b5 01fa      	MOVW R30,R20
0018b6 85a8
0018b7 85b9
0018b8 858a
0018b9 859b      	__GETD2S 8
0018ba 2766      	CLR  R22
0018bb 2777      	CLR  R23
0018bc 940e 1dd9 	CALL __SUBD21
0018be 87a8
0018bf 87b9
0018c0 878a
0018c1 879b      	__PUTD2S 8
                 ;    3713 	if (_FF_read(path_addr_temp)==0)	
0018c2 85e8
0018c3 85f9
0018c4 856a
0018c5 857b      	__GETD1S 8
0018c6 940e 1ecb 	CALL __PUTPARD1
0018c8 940e 0b52 	CALL __FF_read
0018ca 30e0      	CPI  R30,0
0018cb f491      	BRNE _0x2D6
                 ;    3714 	{
                 ;    3715 		_FF_error = READ_ERR;
0018cc e0e4      	LDI  R30,LOW(4)
0018cd 93e0 0bd3 	STS  __FF_error,R30
                 ;    3716 		_FF_DIR_ADDR = addr_temp;
0018cf 85ec
0018d0 85fd
0018d1 856e
0018d2 857f      	__GETD1S 12
0018d3 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0018d5 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0018d7 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0018d9 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3717 		return (0);
0018db e0e0      	LDI  R30,LOW(0)
0018dc e0f0      	LDI  R31,HIGH(0)
0018dd c134      	RJMP _0x41E
                 ;    3718 	}
                 ;    3719 
                 ;    3720 	// Get the filename into a form we can use to compare
                 ;    3721 	qp = file_name_conversion(fpath);
                 _0x2D6:
0018de 01fe      	MOVW R30,R28
0018df 9674      	ADIW R30,20
0018e0 93fa      	ST   -Y,R31
0018e1 93ea      	ST   -Y,R30
0018e2 940e 1070 	CALL _file_name_conversion
0018e4 8be8      	STD  Y+16,R30
0018e5 8bf9      	STD  Y+16+1,R31
                 ;    3722 	if (qp==0)
0018e6 9730      	SBIW R30,0
0018e7 f491      	BRNE _0x2D7
                 ;    3723 	{
                 ;    3724 		_FF_error = NAME_ERR; 
0018e8 e0e5      	LDI  R30,LOW(5)
0018e9 93e0 0bd3 	STS  __FF_error,R30
                 ;    3725 		_FF_DIR_ADDR = addr_temp;
0018eb 85ec
0018ec 85fd
0018ed 856e
0018ee 857f      	__GETD1S 12
0018ef 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0018f1 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0018f3 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0018f5 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3726 		return (0);
0018f7 e0e0      	LDI  R30,LOW(0)
0018f8 e0f0      	LDI  R31,HIGH(0)
0018f9 c118      	RJMP _0x41E
                 ;    3727 	}
                 ;    3728 	sp = &_FF_buff[calc_temp];
                 _0x2D7:
0018fa 01fa      	MOVW R30,R20
0018fb 57e0      	SUBI R30,LOW(-__FF_buff)
0018fc 4ff6      	SBCI R31,HIGH(-__FF_buff)
0018fd 8bea      	STD  Y+18,R30
0018fe 8bfb      	STD  Y+18+1,R31
                 ;    3729 	
                 ;    3730 	if (s)
0018ff 2e02      	MOV  R0,R18
001900 2a03      	OR   R0,R19
001901 f0d1      	BREQ _0x2D8
                 ;    3731 	{
                 ;    3732 		if ((_FF_buff[calc_temp+0x0B]&0x1)==1)	// is file read only
001902 01fa      	MOVW R30,R20
001903 56e5
001904 4ff6      	__ADDW1MN __FF_buff,11
001905 81e0      	LD   R30,Z
001906 70e1      	ANDI R30,LOW(0x1)
001907 30e1      	CPI  R30,LOW(0x1)
001908 f491      	BRNE _0x2D9
                 ;    3733 		{
                 ;    3734 			_FF_error = READONLY_ERR;
001909 e0e6      	LDI  R30,LOW(6)
00190a 93e0 0bd3 	STS  __FF_error,R30
                 ;    3735 			_FF_DIR_ADDR = addr_temp;
00190c 85ec
00190d 85fd
00190e 856e
00190f 857f      	__GETD1S 12
001910 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
001912 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
001914 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
001916 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3736 			return (0);
001918 e0e0      	LDI  R30,LOW(0)
001919 e0f0      	LDI  R31,HIGH(0)
00191a c0f7      	RJMP _0x41E
                 ;    3737 		}
                 ;    3738 	}
                 _0x2D9:
                 ;    3739 	else
00191b c0aa      	RJMP _0x2DA
                 _0x2D8:
                 ;    3740 	{
                 ;    3741 		for (c=0; c<11; c++)	// Write Filename
00191c e000
00191d e010      	__GETWRN 16,17,0
                 _0x2DC:
00191e 300b
00191f e0e0
001920 071e      	__CPWRN 16,17,11
001921 f488      	BRSH _0x2DD
                 ;    3742 			*sp++ = *qp++;
001922 89ea      	LDD  R30,Y+18
001923 89fb      	LDD  R31,Y+18+1
001924 9631      	ADIW R30,1
001925 8bea      	STD  Y+18,R30
001926 8bfb      	STD  Y+18+1,R31
001927 9731      	SBIW R30,1
001928 010f      	MOVW R0,R30
001929 89a8      	LDD  R26,Y+16
00192a 89b9      	LDD  R27,Y+16+1
00192b 91ed      	LD   R30,X+
00192c 8ba8      	STD  Y+16,R26
00192d 8bb9      	STD  Y+16+1,R27
00192e 01d0      	MOVW R26,R0
00192f 93ec      	ST   X,R30
                 ;    3743 		*sp = 0x20;				// Attribute bit auto set to "ARCHIVE"
001930 5f0f
001931 4f1f      	__ADDWRN 16,17,1
001932 cfeb      	RJMP _0x2DC
                 _0x2DD:
001933 89aa      	LDD  R26,Y+18
001934 89bb      	LDD  R27,Y+18+1
001935 e2e0      	LDI  R30,LOW(32)
001936 93ec      	ST   X,R30
                 ;    3744 		sp++;		
001937 89ea      	LDD  R30,Y+18
001938 89fb      	LDD  R31,Y+18+1
001939 9631      	ADIW R30,1
00193a 8bea      	STD  Y+18,R30
00193b 8bfb      	STD  Y+18+1,R31
                 ;    3745 		*sp++ = 0;				// Reserved for WinNT
00193c 89aa      	LDD  R26,Y+18
00193d 89bb      	LDD  R27,Y+18+1
00193e 9611      	ADIW R26,1
00193f 8baa      	STD  Y+18,R26
001940 8bbb      	STD  Y+18+1,R27
001941 9711      	SBIW R26,1
001942 e0e0      	LDI  R30,LOW(0)
001943 93ec      	ST   X,R30
                 ;    3746 		*sp++ = 0;				// Mili-second stamp for create
001944 89aa      	LDD  R26,Y+18
001945 89bb      	LDD  R27,Y+18+1
001946 9611      	ADIW R26,1
001947 8baa      	STD  Y+18,R26
001948 8bbb      	STD  Y+18+1,R27
001949 9711      	SBIW R26,1
00194a 93ec      	ST   X,R30
                 ;    3747 	
                 ;    3748 		#ifdef _RTC_ON_
                 ;    3749 			rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
                 ;    3750     	    calc_temp = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
                 ;    3751 			*sp++ = calc_temp&0x00FF;	// File create Time 
                 ;    3752 			*sp++ = (calc_temp&0xFF00) >> 8;
                 ;    3753 			calc_temp = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
                 ;    3754 			*sp++ = calc_temp&0x00FF;	// File create Date
                 ;    3755 			*sp++ = (calc_temp&0xFF00) >> 8;
                 ;    3756 		#else
                 ;    3757 			for (c=0; c<4; c++)
00194b e000
00194c e010      	__GETWRN 16,17,0
                 _0x2DF:
00194d 3004
00194e e0e0
00194f 071e      	__CPWRN 16,17,4
001950 f458      	BRSH _0x2E0
                 ;    3758 				*sp++ = 0;
001951 89aa      	LDD  R26,Y+18
001952 89bb      	LDD  R27,Y+18+1
001953 9611      	ADIW R26,1
001954 8baa      	STD  Y+18,R26
001955 8bbb      	STD  Y+18+1,R27
001956 9711      	SBIW R26,1
001957 e0e0      	LDI  R30,LOW(0)
001958 93ec      	ST   X,R30
                 ;    3759 		#endif
                 ;    3760 
                 ;    3761 		*sp++ = 0;				// File access date (2 bytes)
001959 5f0f
00195a 4f1f      	__ADDWRN 16,17,1
00195b cff1      	RJMP _0x2DF
                 _0x2E0:
00195c 89aa      	LDD  R26,Y+18
00195d 89bb      	LDD  R27,Y+18+1
00195e 9611      	ADIW R26,1
00195f 8baa      	STD  Y+18,R26
001960 8bbb      	STD  Y+18+1,R27
001961 9711      	SBIW R26,1
001962 e0e0      	LDI  R30,LOW(0)
001963 93ec      	ST   X,R30
                 ;    3762 		*sp++ = 0;
001964 89aa      	LDD  R26,Y+18
001965 89bb      	LDD  R27,Y+18+1
001966 9611      	ADIW R26,1
001967 8baa      	STD  Y+18,R26
001968 8bbb      	STD  Y+18+1,R27
001969 9711      	SBIW R26,1
00196a 93ec      	ST   X,R30
                 ;    3763 		*sp++ = 0;				// 0 for FAT12/16 (2 bytes)
00196b 89aa      	LDD  R26,Y+18
00196c 89bb      	LDD  R27,Y+18+1
00196d 9611      	ADIW R26,1
00196e 8baa      	STD  Y+18,R26
00196f 8bbb      	STD  Y+18+1,R27
001970 9711      	SBIW R26,1
001971 93ec      	ST   X,R30
                 ;    3764 		*sp++ = 0;
001972 89aa      	LDD  R26,Y+18
001973 89bb      	LDD  R27,Y+18+1
001974 9611      	ADIW R26,1
001975 8baa      	STD  Y+18,R26
001976 8bbb      	STD  Y+18+1,R27
001977 9711      	SBIW R26,1
001978 93ec      	ST   X,R30
                 ;    3765 		for (c=0; c<4; c++)		// Modify time/date
001979 e000
00197a e010      	__GETWRN 16,17,0
                 _0x2E2:
00197b 3004
00197c e0e0
00197d 071e      	__CPWRN 16,17,4
00197e f458      	BRSH _0x2E3
                 ;    3766 			*sp++ = 0;
00197f 89aa      	LDD  R26,Y+18
001980 89bb      	LDD  R27,Y+18+1
001981 9611      	ADIW R26,1
001982 8baa      	STD  Y+18,R26
001983 8bbb      	STD  Y+18+1,R27
001984 9711      	SBIW R26,1
001985 e0e0      	LDI  R30,LOW(0)
001986 93ec      	ST   X,R30
                 ;    3767 		*sp++ = 0;				// Starting cluster (2 bytes)
001987 5f0f
001988 4f1f      	__ADDWRN 16,17,1
001989 cff1      	RJMP _0x2E2
                 _0x2E3:
00198a 89aa      	LDD  R26,Y+18
00198b 89bb      	LDD  R27,Y+18+1
00198c 9611      	ADIW R26,1
00198d 8baa      	STD  Y+18,R26
00198e 8bbb      	STD  Y+18+1,R27
00198f 9711      	SBIW R26,1
001990 e0e0      	LDI  R30,LOW(0)
001991 93ec      	ST   X,R30
                 ;    3768 		*sp++ = 0;
001992 89aa      	LDD  R26,Y+18
001993 89bb      	LDD  R27,Y+18+1
001994 9611      	ADIW R26,1
001995 8baa      	STD  Y+18,R26
001996 8bbb      	STD  Y+18+1,R27
001997 9711      	SBIW R26,1
001998 93ec      	ST   X,R30
                 ;    3769 		for (c=0; c<4; c++)
001999 e000
00199a e010      	__GETWRN 16,17,0
                 _0x2E5:
00199b 3004
00199c e0e0
00199d 071e      	__CPWRN 16,17,4
00199e f458      	BRSH _0x2E6
                 ;    3770 			*sp++ = 0;			// File length (0 for new)
00199f 89aa      	LDD  R26,Y+18
0019a0 89bb      	LDD  R27,Y+18+1
0019a1 9611      	ADIW R26,1
0019a2 8baa      	STD  Y+18,R26
0019a3 8bbb      	STD  Y+18+1,R27
0019a4 9711      	SBIW R26,1
0019a5 e0e0      	LDI  R30,LOW(0)
0019a6 93ec      	ST   X,R30
                 ;    3771 	
                 ;    3772 		if (_FF_write(path_addr_temp)==0)
0019a7 5f0f
0019a8 4f1f      	__ADDWRN 16,17,1
0019a9 cff1      	RJMP _0x2E5
                 _0x2E6:
0019aa 85e8
0019ab 85f9
0019ac 856a
0019ad 857b      	__GETD1S 8
0019ae 940e 1ecb 	CALL __PUTPARD1
0019b0 940e 0bf9 	CALL __FF_write
0019b2 30e0      	CPI  R30,0
0019b3 f491      	BRNE _0x2E7
                 ;    3773 		{
                 ;    3774 			_FF_error = WRITE_ERR;
0019b4 e0e3      	LDI  R30,LOW(3)
0019b5 93e0 0bd3 	STS  __FF_error,R30
                 ;    3775 			_FF_DIR_ADDR = addr_temp;
0019b7 85ec
0019b8 85fd
0019b9 856e
0019ba 857f      	__GETD1S 12
0019bb 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0019bd 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0019bf 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0019c1 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3776 			return (0);				
0019c3 e0e0      	LDI  R30,LOW(0)
0019c4 e0f0      	LDI  R31,HIGH(0)
0019c5 c04c      	RJMP _0x41E
                 ;    3777 		}
                 ;    3778 	}
                 _0x2E7:
                 _0x2DA:
                 ;    3779 	_FF_DIR_ADDR = addr_temp;
0019c6 85ec
0019c7 85fd
0019c8 856e
0019c9 857f      	__GETD1S 12
0019ca 93e0 0bbd 	STS  __FF_DIR_ADDR,R30
0019cc 93f0 0bbe 	STS  __FF_DIR_ADDR+1,R31
0019ce 9360 0bbf 	STS  __FF_DIR_ADDR+2,R22
0019d0 9370 0bc0 	STS  __FF_DIR_ADDR+3,R23
                 ;    3780 	temp_file_pntr = fopen(NAME, WRITE);
0019d2 a1eb      	LDD  R30,Y+35
0019d3 a1fc      	LDD  R31,Y+35+1
0019d4 93fa      	ST   -Y,R31
0019d5 93ea      	ST   -Y,R30
0019d6 e0e2      	LDI  R30,LOW(2)
0019d7 93ea      	ST   -Y,R30
0019d8 940e 1541 	CALL _fopen
0019da 83ee      	STD  Y+6,R30
0019db 83ff      	STD  Y+6+1,R31
                 ;    3781 	if (temp_file_pntr == 0)	// Will file open
0019dc 9730      	SBIW R30,0
0019dd f419      	BRNE _0x2E8
                 ;    3782 		return (0);				
0019de e0e0      	LDI  R30,LOW(0)
0019df e0f0      	LDI  R31,HIGH(0)
0019e0 c031      	RJMP _0x41E
                 ;    3783 	if (MODE)
                 _0x2E8:
0019e1 a1ea      	LDD  R30,Y+34
0019e2 30e0      	CPI  R30,0
0019e3 f149      	BREQ _0x2E9
                 ;    3784 	{
                 ;    3785 		if (_FF_read(addr_temp)==0)
0019e4 85ec
0019e5 85fd
0019e6 856e
0019e7 857f      	__GETD1S 12
0019e8 940e 1ecb 	CALL __PUTPARD1
0019ea 940e 0b52 	CALL __FF_read
0019ec 30e0      	CPI  R30,0
0019ed f431      	BRNE _0x2EA
                 ;    3786 		{
                 ;    3787 			_FF_error = READ_ERR;
0019ee e0e4      	LDI  R30,LOW(4)
0019ef 93e0 0bd3 	STS  __FF_error,R30
                 ;    3788 			return (0);
0019f1 e0e0      	LDI  R30,LOW(0)
0019f2 e0f0      	LDI  R31,HIGH(0)
0019f3 c01e      	RJMP _0x41E
                 ;    3789 		}
                 ;    3790 		_FF_buff[calc_temp+12] |= MODE;		
                 _0x2EA:
0019f4 01fa      	MOVW R30,R20
0019f5 56e4
0019f6 4ff6      	__ADDW1MN __FF_buff,12
0019f7 010f      	MOVW R0,R30
0019f8 81e0      	LD   R30,Z
0019f9 a1aa      	LDD  R26,Y+34
0019fa 2bea      	OR   R30,R26
0019fb 01d0      	MOVW R26,R0
0019fc 93ec      	ST   X,R30
                 ;    3791 		if (_FF_write(addr_temp)==0)
0019fd 85ec
0019fe 85fd
0019ff 856e
001a00 857f      	__GETD1S 12
001a01 940e 1ecb 	CALL __PUTPARD1
001a03 940e 0bf9 	CALL __FF_write
001a05 30e0      	CPI  R30,0
001a06 f431      	BRNE _0x2EB
                 ;    3792 		{
                 ;    3793 			_FF_error = WRITE_ERR;
001a07 e0e3      	LDI  R30,LOW(3)
001a08 93e0 0bd3 	STS  __FF_error,R30
                 ;    3794 			return (0);
001a0a e0e0      	LDI  R30,LOW(0)
001a0b e0f0      	LDI  R31,HIGH(0)
001a0c c005      	RJMP _0x41E
                 ;    3795 		}
                 ;    3796 	}
                 _0x2EB:
                 ;    3797 	_FF_error = NO_ERR;
                 _0x2E9:
001a0d e0e0      	LDI  R30,LOW(0)
001a0e 93e0 0bd3 	STS  __FF_error,R30
                 ;    3798 	return (temp_file_pntr);
001a10 81ee      	LDD  R30,Y+6
001a11 81ff      	LDD  R31,Y+6+1
                 _0x41E:
001a12 940e 1f2b 	CALL __LOADLOCR6
001a14 96a5      	ADIW R28,37
001a15 9508      	RET
                 ;    3799 }
                 ;    3800 #endif
                 ;    3801 
                 ;    3802 #ifndef _READ_ONLY_
                 ;    3803 // Open a file, name stored in string fileopen
                 ;    3804 int removec(unsigned char flash *NAMEC)
                 ;    3805 {
                 ;    3806 	int c;
                 ;    3807 	unsigned char sd_temp[12];
                 ;    3808 	
                 ;    3809 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+14
                 ;	c -> R16,R17
                 ;	sd_temp -> Y+2
                 ;    3810 		sd_temp[c] = NAMEC[c];
                 ;    3811 	
                 ;    3812 	c = remove(sd_temp);
                 ;    3813 	return (c);
                 ;    3814 }
                 ;    3815 
                 ;    3816 // Remove a file from the root directory
                 ;    3817 int remove(unsigned char *NAME)
                 ;    3818 {
                 ;    3819 	unsigned char fpath[14];
                 ;    3820 	unsigned int s, calc_temp;
                 ;    3821 	unsigned long addr_temp, path_addr_temp;
                 ;    3822 	
                 ;    3823 	#ifndef _SECOND_FAT_ON_
                 ;    3824 		clear_second_FAT();
                 ;    3825     #endif
                 ;    3826     
                 ;    3827     addr_temp = 0;	// save local dir addr
                 ;	*NAME -> Y+26
                 ;	fpath -> Y+12
                 ;	s -> R16,R17
                 ;	calc_temp -> R18,R19
                 ;	addr_temp -> Y+8
                 ;	path_addr_temp -> Y+4
                 ;    3828     
                 ;    3829     if (_FF_checkdir(NAME, &addr_temp, fpath))
                 ;    3830 	{
                 ;    3831 		_FF_error = PATH_ERR;
                 ;    3832 		_FF_DIR_ADDR = addr_temp;
                 ;    3833 		return (EOF);
                 ;    3834 	}
                 ;    3835 	if (fpath[0]==0)
                 ;    3836 	{
                 ;    3837 		_FF_error = NAME_ERR; 
                 ;    3838 		_FF_DIR_ADDR = addr_temp;
                 ;    3839 		return (EOF);
                 ;    3840 	}
                 ;    3841     
                 ;    3842 	path_addr_temp = _FF_DIR_ADDR;
                 ;    3843 	s = scan_directory(&path_addr_temp, fpath);
                 ;    3844 	if ((path_addr_temp==0) || (s==0))
                 ;    3845 	{
                 ;    3846 		_FF_error = NO_ENTRY_AVAL;
                 ;    3847 		_FF_DIR_ADDR = addr_temp;
                 ;    3848 		return (EOF);
                 ;    3849 	}
                 ;    3850 	_FF_DIR_ADDR = addr_temp;		// Reset current dir
                 ;    3851 
                 ;    3852 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    3853 	path_addr_temp -= calc_temp;
                 ;    3854 	if (_FF_read(path_addr_temp)==0)	
                 ;    3855 	{
                 ;    3856 		_FF_error = READ_ERR;
                 ;    3857 		return (EOF);
                 ;    3858 	}
                 ;    3859 	
                 ;    3860 	// Erase entry (put 0xE5 into start of the filename
                 ;    3861 	_FF_buff[calc_temp] = 0xE5;
                 ;    3862 	if (_FF_write(path_addr_temp)==0)
                 ;    3863 	{
                 ;    3864 		_FF_error = WRITE_ERR;
                 ;    3865 		return (EOF);
                 ;    3866 	}
                 ;    3867 	// Save Starting Cluster
                 ;    3868 	calc_temp = ((int) _FF_buff[calc_temp+0x1B] << 8) | (int) _FF_buff[calc_temp+0x1A];
                 ;    3869 	// Destroy cluster chain
                 ;    3870 	if (calc_temp)
                 ;    3871 		if (erase_clus_chain(calc_temp) == 0)
                 ;    3872 			return (EOF);
                 ;    3873 			
                 ;    3874 	return (1);
                 ;    3875 }
                 ;    3876 #endif
                 ;    3877 
                 ;    3878 #ifndef _READ_ONLY_
                 ;    3879 // Rename a file in the Root Directory
                 ;    3880 int rename(unsigned char *NAME_OLD, unsigned char *NAME_NEW)
                 ;    3881 {
                 ;    3882 	unsigned char c;
                 ;    3883 	unsigned int calc_temp;
                 ;    3884 	unsigned long addr_temp, path_addr_temp;
                 ;    3885 	unsigned char *sp, *qp;
                 ;    3886 	unsigned char fpath[14];
                 ;    3887 
                 ;    3888 	// Get the filename into a form we can use to compare
                 ;    3889 	qp = file_name_conversion(NAME_NEW);
                 ;	*NAME_OLD -> Y+31
                 ;	*NAME_NEW -> Y+29
                 ;	c -> R16
                 ;	calc_temp -> R17,R18
                 ;	addr_temp -> Y+25
                 ;	path_addr_temp -> Y+21
                 ;	*sp -> R19,R20
                 ;	*qp -> Y+19
                 ;	fpath -> Y+5
                 ;    3890 	if (qp==0)
                 ;    3891 	{
                 ;    3892 		_FF_error = NAME_ERR;
                 ;    3893 		return (EOF);
                 ;    3894 	}
                 ;    3895 	
                 ;    3896     addr_temp = 0;	// save local dir addr
                 ;    3897     
                 ;    3898     if (_FF_checkdir(NAME_OLD, &addr_temp, fpath))
                 ;    3899 	{
                 ;    3900 		_FF_error = PATH_ERR;
                 ;    3901 		_FF_DIR_ADDR = addr_temp;
                 ;    3902 		return (EOF);
                 ;    3903 	}
                 ;    3904 	if (fpath[0]==0)
                 ;    3905 	{
                 ;    3906 		_FF_error = NAME_ERR; 
                 ;    3907 		_FF_DIR_ADDR = addr_temp;
                 ;    3908 		return (EOF);
                 ;    3909 	}
                 ;    3910 
                 ;    3911 	path_addr_temp = _FF_DIR_ADDR;
                 ;    3912 	calc_temp = scan_directory(&path_addr_temp, NAME_NEW);
                 ;    3913 	if (calc_temp)
                 ;    3914 	{	// does new name alread exist?
                 ;    3915 		_FF_DIR_ADDR = addr_temp;
                 ;    3916 		_FF_error = EXIST_ERR;
                 ;    3917 		return (EOF);
                 ;    3918 	}
                 ;    3919 
                 ;    3920 	path_addr_temp = _FF_DIR_ADDR;
                 ;    3921 	calc_temp = scan_directory(&path_addr_temp, fpath);
                 ;    3922 	if ((path_addr_temp==0) || (calc_temp==0))
                 ;    3923 	{
                 ;    3924 		_FF_DIR_ADDR = addr_temp;
                 ;    3925 		_FF_error = EXIST_ERR;
                 ;    3926 		return (EOF);
                 ;    3927 	}
                 ;    3928 
                 ;    3929 
                 ;    3930 	_FF_DIR_ADDR = addr_temp;		// Reset current dir
                 ;    3931 
                 ;    3932 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    3933 	path_addr_temp -= calc_temp;
                 ;    3934 	if (_FF_read(path_addr_temp)==0)	
                 ;    3935 	{
                 ;    3936 		_FF_error = READ_ERR;
                 ;    3937 		return (EOF);
                 ;    3938 	}
                 ;    3939 	
                 ;    3940 	// Rename entry
                 ;    3941 	sp = &_FF_buff[calc_temp];
                 ;    3942 	for (c=0; c<11; c++)
                 ;    3943 		*sp++ = *qp++;
                 ;    3944 	if (_FF_write(path_addr_temp)==0)
                 ;    3945 		return (EOF);
                 ;    3946 
                 ;    3947 	return(0);
                 ;    3948 }
                 ;    3949 #endif
                 ;    3950 
                 ;    3951 #ifndef _READ_ONLY_
                 ;    3952 // Save Contents of file, w/o closing
                 ;    3953 int fflush(FILE *rp)	
                 ;    3954 {
                 _fflush:
                 ;    3955 	unsigned int  n;
                 ;    3956 	unsigned long addr_temp;
                 ;    3957 	
                 ;    3958 	if ((rp==NULL) || (rp->mode==READ))
001a16 9724      	SBIW R28,4
001a17 931a      	ST   -Y,R17
001a18 930a      	ST   -Y,R16
                 ;	*rp -> Y+6
                 ;	n -> R16,R17
                 ;	addr_temp -> Y+2
001a19 81ae      	LDD  R26,Y+6
001a1a 81bf      	LDD  R27,Y+6+1
001a1b 940e 1f10 	CALL __CPW02
001a1d f029      	BREQ _0x305
001a1e 5dac      	SUBI R26,LOW(-548)
001a1f 4fbd      	SBCI R27,HIGH(-548)
001a20 91ac      	LD   R26,X
001a21 30a1      	CPI  R26,LOW(0x1)
001a22 f419      	BRNE _0x304
                 _0x305:
                 ;    3959 		return (EOF);
001a23 efef      	LDI  R30,LOW(65535)
001a24 efff      	LDI  R31,HIGH(65535)
001a25 c063      	RJMP _0x41D
                 ;    3960 	
                 ;    3961 	if ((rp->mode==WRITE) || (rp->mode==APPEND))
                 _0x304:
001a26 81ae      	LDD  R26,Y+6
001a27 81bf      	LDD  R27,Y+6+1
001a28 5dac      	SUBI R26,LOW(-548)
001a29 4fbd      	SBCI R27,HIGH(-548)
001a2a 91ac      	LD   R26,X
001a2b 30a2      	CPI  R26,LOW(0x2)
001a2c f041      	BREQ _0x308
001a2d 81ae      	LDD  R26,Y+6
001a2e 81bf      	LDD  R27,Y+6+1
001a2f 5dac      	SUBI R26,LOW(-548)
001a30 4fbd      	SBCI R27,HIGH(-548)
001a31 91ac      	LD   R26,X
001a32 30a3      	CPI  R26,LOW(0x3)
001a33 f009      	BREQ _0x308
001a34 c052      	RJMP _0x307
                 _0x308:
                 ;    3962 	{
                 ;    3963 		addr_temp = (clust_to_addr(rp->clus_current) + ((rp->sec_offset-1)*BPB_BytsPerSec));
001a35 81ee      	LDD  R30,Y+6
001a36 81ff      	LDD  R31,Y+6+1
001a37 85a6      	LDD  R26,Z+14
001a38 85b7      	LDD  R27,Z+15
001a39 93ba      	ST   -Y,R27
001a3a 93aa      	ST   -Y,R26
001a3b 940e 0edf 	CALL _clust_to_addr
001a3d 937f      	PUSH R23
001a3e 936f      	PUSH R22
001a3f 93ff      	PUSH R31
001a40 93ef      	PUSH R30
001a41 81ae      	LDD  R26,Y+6
001a42 81bf      	LDD  R27,Y+6+1
001a43 9654      	ADIW R26,20
001a44 940e 1eb8 	CALL __GETW1P
001a46 9731      	SBIW R30,1
001a47 91a0 0b96 	LDS  R26,_BPB_BytsPerSec
001a49 91b0 0b97 	LDS  R27,_BPB_BytsPerSec+1
001a4b 940e 1e20 	CALL __MULW12U
001a4d 91af      	POP  R26
001a4e 91bf      	POP  R27
001a4f 918f      	POP  R24
001a50 919f      	POP  R25
001a51 2766      	CLR  R22
001a52 2777      	CLR  R23
001a53 940e 1dca 	CALL __ADDD12
001a55 83ea
001a56 83fb
001a57 836c
001a58 837d      	__PUTD1S 2
                 ;    3964 		for (n=0; n<BPB_BytsPerSec; n++)	// Save file buffer to SD buffer
001a59 e000
001a5a e010      	__GETWRN 16,17,0
                 _0x30B:
001a5b 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001a5d 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001a5f 170e      	CP   R16,R30
001a60 071f      	CPC  R17,R31
001a61 f468      	BRSH _0x30C
                 ;    3965 			_FF_buff[n] = rp->buff[n];
001a62 01d8      	MOVW R26,R16
001a63 57a0      	SUBI R26,LOW(-__FF_buff)
001a64 4fb6      	SBCI R27,HIGH(-__FF_buff)
001a65 81ee      	LDD  R30,Y+6
001a66 81ff      	LDD  R31,Y+6+1
001a67 967c      	ADIW R30,28
001a68 0fe0      	ADD  R30,R16
001a69 1ff1      	ADC  R31,R17
001a6a 81e0      	LD   R30,Z
001a6b 93ec      	ST   X,R30
                 ;    3966 		if (_FF_write(addr_temp)==0)	// Write SD buffer to disk
001a6c 5f0f
001a6d 4f1f      	__ADDWRN 16,17,1
001a6e cfec      	RJMP _0x30B
                 _0x30C:
001a6f 81ea
001a70 81fb
001a71 816c
001a72 817d      	__GETD1S 2
001a73 940e 1ecb 	CALL __PUTPARD1
001a75 940e 0bf9 	CALL __FF_write
001a77 30e0      	CPI  R30,0
001a78 f419      	BRNE _0x30D
                 ;    3967 			return (EOF);
001a79 efef      	LDI  R30,LOW(65535)
001a7a efff      	LDI  R31,HIGH(65535)
001a7b c00d      	RJMP _0x41D
                 ;    3968 		if (append_toc(rp)==0)	// Update Entry or Error
                 _0x30D:
001a7c 81ee      	LDD  R30,Y+6
001a7d 81ff      	LDD  R31,Y+6+1
001a7e 93fa      	ST   -Y,R31
001a7f 93ea      	ST   -Y,R30
001a80 940e 11d8 	CALL _append_toc
001a82 30e0      	CPI  R30,0
001a83 f419      	BRNE _0x30E
                 ;    3969 			return (EOF);
001a84 efef      	LDI  R30,LOW(65535)
001a85 efff      	LDI  R31,HIGH(65535)
001a86 c002      	RJMP _0x41D
                 ;    3970 	}
                 _0x30E:
                 ;    3971 	
                 ;    3972 	return (0);
                 _0x307:
001a87 e0e0      	LDI  R30,LOW(0)
001a88 e0f0      	LDI  R31,HIGH(0)
                 _0x41D:
001a89 8119      	LDD  R17,Y+1
001a8a 8108      	LDD  R16,Y+0
001a8b 9628      	ADIW R28,8
001a8c 9508      	RET
                 ;    3973 }
                 ;    3974 #endif		
                 ;    3975 
                 ;    3976 
                 ;    3977 // Close an open file
                 ;    3978 int fclose(FILE *rp)	
                 ;    3979 {
                 _fclose:
                 ;    3980 	#ifndef _READ_ONLY_
                 ;    3981 	if (rp->mode!=READ)
001a8d 81a8      	LD   R26,Y
001a8e 81b9      	LDD  R27,Y+1
001a8f 5dac      	SUBI R26,LOW(-548)
001a90 4fbd      	SBCI R27,HIGH(-548)
001a91 91ac      	LD   R26,X
001a92 30a1      	CPI  R26,LOW(0x1)
001a93 f069      	BREQ _0x30F
                 ;    3982 		if (fflush(rp)==EOF)
001a94 81e8      	LD   R30,Y
001a95 81f9      	LDD  R31,Y+1
001a96 93fa      	ST   -Y,R31
001a97 93ea      	ST   -Y,R30
001a98 940e 1a16 	CALL _fflush
001a9a 3fef      	CPI  R30,LOW(0xFFFF)
001a9b efaf      	LDI  R26,HIGH(0xFFFF)
001a9c 07fa      	CPC  R31,R26
001a9d f419      	BRNE _0x310
                 ;    3983 			return (EOF);
001a9e efef      	LDI  R30,LOW(65535)
001a9f efff      	LDI  R31,HIGH(65535)
001aa0 c00b      	RJMP _0x41C
                 ;    3984 	#endif	
                 ;    3985 	// Clear File Structure
                 ;    3986 	free(rp);
                 _0x310:
                 _0x30F:
001aa1 81e8      	LD   R30,Y
001aa2 81f9      	LDD  R31,Y+1
001aa3 93fa      	ST   -Y,R31
001aa4 93ea      	ST   -Y,R30
001aa5 940e 1d47 	CALL _free
                 ;    3987 	rp = 0;
001aa7 e0e0      	LDI  R30,0
001aa8 83e8      	STD  Y+0,R30
001aa9 83e9      	STD  Y+0+1,R30
                 ;    3988 	return(0);
001aaa e0e0      	LDI  R30,LOW(0)
001aab e0f0      	LDI  R31,HIGH(0)
                 _0x41C:
001aac 9622      	ADIW R28,2
001aad 9508      	RET
                 ;    3989 }
                 ;    3990 
                 ;    3991 int ffreemem(FILE *rp)	
                 ;    3992 {
                 ;    3993 	// Clear File Structure
                 ;    3994 	if (rp==0)
                 ;    3995 		return (EOF);
                 ;    3996 	free(rp);
                 ;    3997 	return(0);
                 ;    3998 }
                 ;    3999 
                 ;    4000 int fget_file_infoc(unsigned char flash *NAMEC, unsigned long *F_SIZE, unsigned char *F_CREATE,
                 ;    4001 				unsigned char *F_MODIFY, unsigned char *F_ATTRIBUTE, unsigned int *F_CLUS_START)
                 ;    4002 {
                 ;    4003 	int c;
                 ;    4004 	unsigned char sd_temp[12];
                 ;    4005 	
                 ;    4006 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+24
                 ;	*F_SIZE -> Y+22
                 ;	*F_CREATE -> Y+20
                 ;	*F_MODIFY -> Y+18
                 ;	*F_ATTRIBUTE -> Y+16
                 ;	*F_CLUS_START -> Y+14
                 ;	c -> R16,R17
                 ;	sd_temp -> Y+2
                 ;    4007 		sd_temp[c] = NAMEC[c];
                 ;    4008 	
                 ;    4009 	c = fget_file_info(sd_temp, F_SIZE, F_CREATE, F_MODIFY, F_ATTRIBUTE, F_CLUS_START);
                 ;    4010 	return (c);
                 ;    4011 }
                 ;    4012 
                 ;    4013 int fget_file_info(unsigned char *NAME, unsigned long *F_SIZE, unsigned char *F_CREATE,
                 ;    4014 				unsigned char *F_MODIFY, unsigned char *F_ATTRIBUTE, unsigned int *F_CLUS_START)
                 ;    4015 {
                 ;    4016 	unsigned char n;
                 ;    4017 	unsigned int s, calc_temp;
                 ;    4018 	unsigned long addr_temp, file_calc_temp;
                 ;    4019 	unsigned char *sp, *qp;
                 ;    4020 	
                 ;    4021 	// Get the filename into a form we can use to compare
                 ;    4022 	qp = file_name_conversion(NAME);
                 ;	*NAME -> Y+27
                 ;	*F_SIZE -> Y+25
                 ;	*F_CREATE -> Y+23
                 ;	*F_MODIFY -> Y+21
                 ;	*F_ATTRIBUTE -> Y+19
                 ;	*F_CLUS_START -> Y+17
                 ;	n -> R16
                 ;	s -> R17,R18
                 ;	calc_temp -> R19,R20
                 ;	addr_temp -> Y+13
                 ;	file_calc_temp -> Y+9
                 ;	*sp -> Y+7
                 ;	*qp -> Y+5
                 ;    4023 	if (qp==0)
                 ;    4024 	{
                 ;    4025 		_FF_error = NAME_ERR;
                 ;    4026 		return (EOF);
                 ;    4027 	}
                 ;    4028 	
                 ;    4029 	for (s=0; s<BPB_BytsPerSec; s++)
                 ;    4030 	{	// Scan through directory entries to find file
                 ;    4031 		addr_temp = _FF_DIR_ADDR + (0x200 * s);
                 ;    4032 		if (_FF_read(addr_temp)==0)
                 ;    4033 			return (EOF);
                 ;    4034 		for (n=0; n<16; n++)
                 ;    4035 		{
                 ;    4036 			calc_temp = (int) n * 0x20;
                 ;    4037 			qp = &FILENAME[0];
                 ;    4038 			sp = &_FF_buff[calc_temp];
                 ;    4039 			if (*sp == 0)
                 ;    4040 				return (EOF);
                 ;    4041 			if (strncmp(qp, sp, 11)==0)		// Does this entry == Filename
                 ;    4042 			{
                 ;    4043 				*F_ATTRIBUTE = _FF_buff[calc_temp+11];	// Save ATTRIBUTE Byte to location
                 ;    4044 				*F_SIZE = ((long) _FF_buff[calc_temp+31] << 24) | ((long) _FF_buff[calc_temp+30] << 16)
                 ;    4045 							| ((long) _FF_buff[calc_temp+29] << 8) | ((long) _FF_buff[calc_temp+28]);
                 ;    4046 							// Save SIZE of file to location
                 ;    4047                 *F_CLUS_START = ((unsigned int) _FF_buff[calc_temp+27] << 8) | ((unsigned int) _FF_buff[calc_temp+26]);
                 ;    4048 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+17] << 8) | ((unsigned int) _FF_buff[calc_temp+16]);
                 ;    4049 				qp = F_CREATE;
                 ;    4050 				*qp++ = (((file_calc_temp >> 5) & 0x0F) / 10) + '0';
                 ;    4051 				*qp++ = (((file_calc_temp >> 5) & 0x0F) % 10) + '0';
                 ;    4052 				*qp++ = '/';
                 ;    4053 				*qp++ = ((file_calc_temp & 0x1F) / 10) + '0';
                 ;    4054 				*qp++ = ((file_calc_temp & 0x1F) % 10) + '0';
                 ;    4055 				*qp++ = '/';
                 ;    4056 				file_calc_temp = ((file_calc_temp >> 9) & 0x7F) + 1980;
                 ;    4057 				*qp++ = (file_calc_temp / 1000) + '0';
                 ;    4058 				file_calc_temp %= 1000;
                 ;    4059 				*qp++ = (file_calc_temp / 100) + '0';
                 ;    4060 				file_calc_temp %= 100;
                 ;    4061 				*qp++ = (file_calc_temp / 10) + '0';
                 ;    4062 				*qp++ = (file_calc_temp % 10) + '0';
                 ;    4063 				*qp++ = ' ';
                 ;    4064 				*qp++ = ' ';
                 ;    4065 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+15] << 8) | ((unsigned int) _FF_buff[calc_temp+14]);
                 ;    4066 				*qp++ = (((file_calc_temp >> 11) & 0x1F) / 10) + '0';
                 ;    4067 				*qp++ = (((file_calc_temp >> 11) & 0x1F) % 10) + '0';
                 ;    4068 				*qp++ = ':';
                 ;    4069 				*qp++ = (((file_calc_temp >> 5) & 0x3F) / 10) + '0';
                 ;    4070 				*qp++ = (((file_calc_temp >> 5) & 0x3F) % 10) + '0';
                 ;    4071 				*qp++ = ':';
                 ;    4072 				*qp++ = (((file_calc_temp & 0x1F) * 2) / 10) + '0';
                 ;    4073 				*qp++ = (((file_calc_temp & 0x1F) * 2) % 10) + '0';
                 ;    4074 				*qp = 0;
                 ;    4075 				
                 ;    4076 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+25] << 8) | ((unsigned int) _FF_buff[calc_temp+24]);
                 ;    4077 				qp = F_MODIFY;
                 ;    4078 				*qp++ = (((file_calc_temp >> 5) & 0x0F) / 10) + '0';
                 ;    4079 				*qp++ = (((file_calc_temp >> 5) & 0x0F) % 10) + '0';
                 ;    4080 				*qp++ = '/';
                 ;    4081 				*qp++ = ((file_calc_temp & 0x1F) / 10) + '0';
                 ;    4082 				*qp++ = ((file_calc_temp & 0x1F) % 10) + '0';
                 ;    4083 				*qp++ = '/';
                 ;    4084 				file_calc_temp = ((file_calc_temp >> 9) & 0x7F) + 1980;
                 ;    4085 				*qp++ = (file_calc_temp / 1000) + '0';
                 ;    4086 				file_calc_temp %= 1000;
                 ;    4087 				*qp++ = (file_calc_temp / 100) + '0';
                 ;    4088 				file_calc_temp %= 100;
                 ;    4089 				*qp++ = (file_calc_temp / 10) + '0';
                 ;    4090 				*qp++ = (file_calc_temp % 10) + '0';
                 ;    4091 				*qp++ = ' ';
                 ;    4092 				*qp++ = ' ';
                 ;    4093 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+23] << 8) | ((unsigned int) _FF_buff[calc_temp+22]);
                 ;    4094 				*qp++ = (((file_calc_temp >> 11) & 0x1F) / 10) + '0';
                 ;    4095 				*qp++ = (((file_calc_temp >> 11) & 0x1F) % 10) + '0';
                 ;    4096 				*qp++ = ':';
                 ;    4097 				*qp++ = (((file_calc_temp >> 5) & 0x3F) / 10) + '0';
                 ;    4098 				*qp++ = (((file_calc_temp >> 5) & 0x3F) % 10) + '0';
                 ;    4099 				*qp++ = ':';
                 ;    4100 				*qp++ = (((file_calc_temp & 0x1F) * 2) / 10) + '0';
                 ;    4101 				*qp++ = (((file_calc_temp & 0x1F) * 2) % 10) + '0';
                 ;    4102 				*qp = 0;
                 ;    4103 				
                 ;    4104 				return (0);
                 ;    4105 			}
                 ;    4106 		}                          		
                 ;    4107 	}
                 ;    4108 	_FF_error = FILE_ERR;
                 ;    4109 	return(EOF);
                 ;    4110 }
                 ;    4111 
                 ;    4112 // Get File data and increment file pointer
                 ;    4113 int fgetc(FILE *rp)
                 ;    4114 {
                 ;    4115 	unsigned char get_data;
                 ;    4116 	unsigned int n;
                 ;    4117 	unsigned long addr_temp;
                 ;    4118 	
                 ;    4119 	if (rp==NULL)
                 ;	*rp -> Y+7
                 ;	get_data -> R16
                 ;	n -> R17,R18
                 ;	addr_temp -> Y+3
                 ;    4120 		return (EOF);
                 ;    4121 
                 ;    4122 	if (rp->position == rp->length)
                 ;    4123 	{
                 ;    4124 		rp->error = POS_ERR;
                 ;    4125 		return (EOF);
                 ;    4126 	}
                 ;    4127 	
                 ;    4128 	get_data = *rp->pntr;
                 ;    4129 	
                 ;    4130 	if ((rp->pntr)==(&rp->buff[BPB_BytsPerSec-1]))
                 ;    4131 	{	// Check to see if pointer is at the end of a sector
                 ;    4132 		#ifndef _READ_ONLY_
                 ;    4133 		if ((rp->mode==WRITE) || (rp->mode==APPEND))
                 ;    4134 		{	// if in write or append mode, update the current sector before loading next
                 ;    4135 			for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4136 				_FF_buff[n] = rp->buff[n];
                 ;    4137 			addr_temp = clust_to_addr(rp->clus_current) + (((rp->sec_offset)-1)*BPB_BytsPerSec);
                 ;    4138 			if (_FF_write(addr_temp)==0)
                 ;    4139 				return (EOF);
                 ;    4140 		}
                 ;    4141 		#endif
                 ;    4142 		if (rp->sec_offset < BPB_SecPerClus)
                 ;    4143 		{	// Goto next sector if not at the end of a cluster
                 ;    4144 			addr_temp = clust_to_addr(rp->clus_current) + (rp->sec_offset*BPB_BytsPerSec);
                 ;    4145 			rp->sec_offset++;
                 ;    4146 		}
                 ;    4147 		else
                 ;    4148 		{	// End of Cluster, find next
                 ;    4149 			if (rp->clus_next>=0xFFF8)	// No next cluster, EOF marker
                 ;    4150 			{
                 ;    4151 				rp->EOF_flag = 1;	// Set flag so Putchar knows to get new cluster
                 ;    4152 				rp->position++;		// Only time doing this, position + 1 should equal length
                 ;    4153 				return(get_data);
                 ;    4154 			}
                 ;    4155 			addr_temp = clust_to_addr(rp->clus_next);
                 ;    4156 			rp->sec_offset = 1;
                 ;    4157 			rp->clus_prev = rp->clus_current;
                 ;    4158 			rp->clus_current = rp->clus_next;
                 ;    4159 			rp->clus_next = next_cluster(rp->clus_current, SINGLE);
                 ;    4160 		}
                 ;    4161 		if (_FF_read(addr_temp)==0)
                 ;    4162 			return (EOF);
                 ;    4163 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4164 			rp->buff[n] = _FF_buff[n];
                 ;    4165 		rp->pntr = &rp->buff[0];
                 ;    4166 	}
                 ;    4167 	else
                 ;    4168 		rp->pntr++;
                 ;    4169 	
                 ;    4170 	rp->position++;	
                 ;    4171 	return(get_data);		
                 ;    4172 }
                 ;    4173 
                 ;    4174 char *fgets(char *buffer, int n, FILE *rp)
                 ;    4175 {
                 ;    4176 	int c, temp_data;
                 ;    4177 	
                 ;    4178 	for (c=0; c<n; c++)
                 ;	*buffer -> Y+8
                 ;	n -> Y+6
                 ;	*rp -> Y+4
                 ;	c -> R16,R17
                 ;	temp_data -> R18,R19
                 ;    4179 	{
                 ;    4180 		temp_data = fgetc(rp);
                 ;    4181 		*buffer = temp_data & 0xFF;
                 ;    4182 		if (temp_data == '\n')
                 ;    4183 			break;
                 ;    4184 		else if (temp_data == EOF)
                 ;    4185 			break;
                 ;    4186 		buffer++;
                 ;    4187 	}
                 ;    4188 	if (c==n)
                 ;    4189 		buffer++;
                 ;    4190 	*buffer-- = '\0';
                 ;    4191 	if (temp_data == EOF)
                 ;    4192 		return (NULL);
                 ;    4193 	return (buffer);
                 ;    4194 }
                 ;    4195 
                 ;    4196 #ifndef _READ_ONLY_
                 ;    4197 // Decrement file pointer, then get file data
                 ;    4198 int ungetc(unsigned char file_data, FILE *rp)
                 ;    4199 {
                 ;    4200 	unsigned int n;
                 ;    4201 	unsigned long addr_temp;
                 ;    4202 	
                 ;    4203 	if ((rp==NULL) || (rp->position==0))
                 ;	file_data -> Y+8
                 ;	*rp -> Y+6
                 ;	n -> R16,R17
                 ;	addr_temp -> Y+2
                 ;    4204 		return (EOF);
                 ;    4205 	if ((rp->mode!=APPEND) && (rp->mode!=WRITE))
                 ;    4206 		return (EOF);	// needs to be in WRITE or APPEND mode
                 ;    4207 
                 ;    4208 	if (((rp->position) == rp->length) && (rp->EOF_flag))
                 ;    4209 	{	// if the file posisition is equal to the length, return data, turn flag off
                 ;    4210 		rp->EOF_flag = 0;
                 ;    4211 		*rp->pntr = file_data;
                 ;    4212 		return (*rp->pntr);
                 ;    4213 	}
                 ;    4214 	if ((rp->pntr)==(&rp->buff[0]))
                 ;    4215 	{	// Check to see if pointer is at the beginning of a Sector
                 ;    4216 		// Update the current sector before loading next
                 ;    4217 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4218 			_FF_buff[n] = rp->buff[n];
                 ;    4219 		addr_temp = clust_to_addr(rp->clus_current) + (((rp->sec_offset)-1)*BPB_BytsPerSec);
                 ;    4220 		if (_FF_write(addr_temp)==0)
                 ;    4221 			return (EOF);
                 ;    4222 			
                 ;    4223 		if (rp->sec_offset > 1)
                 ;    4224 		{	// Goto previous sector if not at the beginning of a cluster
                 ;    4225 			addr_temp = clust_to_addr(rp->clus_current) + ((rp->sec_offset-2)*BPB_BytsPerSec);
                 ;    4226 			rp->sec_offset--;
                 ;    4227 		}
                 ;    4228 		else
                 ;    4229 		{	// Beginning of Cluster, find previous
                 ;    4230 			if (rp->clus_start==rp->clus_current)
                 ;    4231 			{	// Positioned @ Beginning of File
                 ;    4232 				_FF_error = SOF_ERR;
                 ;    4233 				return(EOF);
                 ;    4234 			}
                 ;    4235 			rp->sec_offset = BPB_SecPerClus;	// Set sector offset to last sector
                 ;    4236 			rp->clus_next = rp->clus_current;
                 ;    4237 			rp->clus_current = rp->clus_prev;
                 ;    4238 			if (rp->clus_current != rp->clus_start)
                 ;    4239 				rp->clus_prev = prev_cluster(rp->clus_current);
                 ;    4240 			else
                 ;    4241 				rp->clus_prev = 0;
                 ;    4242 			addr_temp = clust_to_addr(rp->clus_current) + (((long) BPB_SecPerClus-1) * (long) BPB_BytsPerSec);
                 ;    4243 		}
                 ;    4244 		_FF_read(addr_temp);
                 ;    4245 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4246 			rp->buff[n] = _FF_buff[n];
                 ;    4247 		rp->pntr = &rp->buff[511];
                 ;    4248 	}
                 ;    4249 	else
                 ;    4250 		rp->pntr--;
                 ;    4251 	
                 ;    4252 	rp->position--;
                 ;    4253 	*rp->pntr = file_data;	
                 ;    4254 	return(*rp->pntr);	// Get data	
                 ;    4255 }
                 ;    4256 #endif
                 ;    4257 
                 ;    4258 #ifndef _READ_ONLY_
                 ;    4259 int fputc(unsigned char file_data, FILE *rp)	
                 ;    4260 {
                 ;    4261 	unsigned int n;
                 ;    4262 	unsigned long addr_temp;
                 ;    4263 	
                 ;    4264 	if (rp==NULL)
                 ;	file_data -> Y+8
                 ;	*rp -> Y+6
                 ;	n -> R16,R17
                 ;	addr_temp -> Y+2
                 ;    4265 		return (EOF);
                 ;    4266 
                 ;    4267 	if (rp->mode == READ)
                 ;    4268 	{
                 ;    4269 		_FF_error = READONLY_ERR;
                 ;    4270 		return(EOF);
                 ;    4271 	}
                 ;    4272 	if (rp->length == 0)
                 ;    4273 	{	// Blank file start writing cluster table
                 ;    4274 		rp->clus_start = prev_cluster(0);
                 ;    4275 		rp->clus_next = 0xFFFF;
                 ;    4276 		rp->clus_current = rp->clus_start;
                 ;    4277 		if (write_clus_table(rp->clus_start, rp->clus_next, SINGLE)==0)
                 ;    4278 		{
                 ;    4279 			return (EOF);
                 ;    4280 		}
                 ;    4281 	}
                 ;    4282 	
                 ;    4283 	if ((rp->position==rp->length) && (rp->EOF_flag))
                 ;    4284 	{	// At end of file, and end of cluster, flagged
                 ;    4285 		rp->clus_prev = rp->clus_current;
                 ;    4286 		rp->clus_current = prev_cluster(0);	// Find first cluster pointing to '0'
                 ;    4287 		rp->clus_next = 0xFFFF;
                 ;    4288 		rp->sec_offset = 1;
                 ;    4289 		if (write_clus_table(rp->clus_prev, rp->clus_current, CHAIN)==0)
                 ;    4290 		{
                 ;    4291 			return (EOF);
                 ;    4292 		}
                 ;    4293 		if (write_clus_table(rp->clus_current, rp->clus_next, END_CHAIN)==0)
                 ;    4294 		{
                 ;    4295 			return (EOF);
                 ;    4296 		}
                 ;    4297 		if (append_toc(rp)==0)
                 ;    4298 		{
                 ;    4299 			return (EOF);
                 ;    4300 		}
                 ;    4301 		rp->EOF_flag = 0;
                 ;    4302 		rp->pntr = &rp->buff[0];		
                 ;    4303 	}
                 ;    4304 	
                 ;    4305 	*rp->pntr = file_data;
                 ;    4306 	
                 ;    4307 	if (rp->pntr == &rp->buff[BPB_BytsPerSec-1])
                 ;    4308 	{	// This is on the Sector Limit
                 ;    4309 		if (rp->position > rp->length)
                 ;    4310 		{	// ERROR, position should never be greater than length
                 ;    4311 			_FF_error = 0x10;		// file position ERROR
                 ;    4312 			return (EOF); 
                 ;    4313 		}
                 ;    4314 		// Position is at end of a sector?
                 ;    4315 		
                 ;    4316 		addr_temp = (clust_to_addr(rp->clus_current) + ((rp->sec_offset-1)*BPB_BytsPerSec));
                 ;    4317 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4318 			_FF_buff[n] = rp->buff[n];
                 ;    4319 		_FF_write(addr_temp);
                 ;    4320 			// Save MMC buffer to card, set pointer to begining of new buffer
                 ;    4321 		if (rp->sec_offset < BPB_SecPerClus)
                 ;    4322 		{	// Are there more sectors in this cluster?
                 ;    4323 			addr_temp = clust_to_addr(rp->clus_current) + (rp->sec_offset * BPB_BytsPerSec);
                 ;    4324 			rp->sec_offset++;
                 ;    4325 		}
                 ;    4326 		else
                 ;    4327 		{	// Find next cluster, load first sector into file.buff
                 ;    4328 			if (((rp->clus_next>=0xFFF8)&&(BPB_FATType==0x36)) ||
                 ;    4329 				((rp->clus_next>=0xFF8)&&(BPB_FATType==0x32)))
                 ;    4330 			{	// EOF, need to find new empty cluster
                 ;    4331 				if (rp->position != rp->length)
                 ;    4332 				{	// if not equal there's an error
                 ;    4333 					_FF_error = 0x20;		// EOF position error
                 ;    4334 					return (EOF);
                 ;    4335 				}
                 ;    4336 				rp->EOF_flag = 1;
                 ;    4337 			}
                 ;    4338 			else
                 ;    4339 			{	// Not EOF, find next cluster
                 ;    4340 				rp->clus_prev = rp->clus_current;
                 ;    4341 				rp->clus_current = rp->clus_next;
                 ;    4342 				rp->clus_next = next_cluster(rp->clus_current, SINGLE);
                 ;    4343 			}
                 ;    4344 			rp->sec_offset = 1;
                 ;    4345 			addr_temp = clust_to_addr(rp->clus_current);
                 ;    4346 		}
                 ;    4347 		
                 ;    4348 		if (rp->EOF_flag == 0)
                 ;    4349 		{
                 ;    4350 			if (_FF_read(addr_temp)==0)
                 ;    4351 				return(EOF);
                 ;    4352 			for (n=0; n<512; n++)
                 ;    4353 				rp->buff[n] = _FF_buff[n];
                 ;    4354 			rp->pntr = &rp->buff[0];	// Set pointer to next location				
                 ;    4355 		}
                 ;    4356 		if (rp->length==rp->position)
                 ;    4357 			rp->length++;
                 ;    4358 		if (append_toc(rp)==0)
                 ;    4359 			return(EOF);
                 ;    4360 	}
                 ;    4361 	else
                 ;    4362 	{
                 ;    4363 		rp->pntr++;
                 ;    4364 		if (rp->length==rp->position)
                 ;    4365 			rp->length++;
                 ;    4366 	}
                 ;    4367 	rp->position++;
                 ;    4368 	return(file_data);
                 ;    4369 }
                 ;    4370 
                 ;    4371 int fputs(unsigned char *file_data, FILE *rp)
                 ;    4372 {
                 ;    4373 	while(*file_data)
                 ;    4374 		if (fputc(*file_data++,rp) == EOF)
                 ;    4375 			return (EOF);
                 ;    4376 	if (fputc('\r',rp) == EOF)
                 ;    4377 		return (EOF);
                 ;    4378 	if (fputc('\n',rp) == EOF)
                 ;    4379 		return (EOF);
                 ;    4380 	return (0);
                 ;    4381 }
                 ;    4382 
                 ;    4383 int fputsc(flash unsigned char *file_data, FILE *rp)
                 ;    4384 {
                 ;    4385 	while(*file_data)
                 ;    4386 		if (fputc(*file_data++,rp) == EOF)
                 ;    4387 			return (EOF);
                 ;    4388 	if (fputc('\r',rp) == EOF)
                 ;    4389 		return (EOF);
                 ;    4390 	if (fputc('\n',rp) == EOF)
                 ;    4391 		return (EOF);
                 ;    4392 	return (0);
                 ;    4393 }
                 ;    4394 #endif
                 ;    4395 
                 ;    4396 //#ifndef _READ_ONLY_
                 ;    4397 #ifdef _CVAVR_
                 ;    4398 void fprintf(FILE *rp, unsigned char flash *pstr, ...)
                 ;    4399 {
                 ;    4400 	va_list arglist;
                 ;    4401 	unsigned char temp_buff[_FF_MAX_FPRINT], *fp;
                 ;    4402 	
                 ;    4403 	va_start(arglist, pstr);
                 ;	*rp -> Y+106
                 ;	*pstr -> Y+104
                 ;	*arglist -> R16,R17
                 ;	temp_buff -> Y+4
                 ;	*fp -> R18,R19
                 ;    4404 	vsprintf(temp_buff, pstr, arglist);
                 ;    4405 	va_end(arglist);
                 ;    4406 	
                 ;    4407 	fp = temp_buff;
                 ;    4408 	while (*fp)
                 ;    4409 		fputc(*fp++, rp);	
                 ;    4410 }
                 ;    4411 #endif
                 ;    4412 #ifdef _ICCAVR_
                 ;    4413 void fprintf(FILE *rp, unsigned char flash *pstr, long var)
                 ;    4414 {
                 ;    4415 	unsigned char temp_buff[_FF_MAX_FPRINT], *fp;
                 ;    4416 	
                 ;    4417 	csprintf(temp_buff, pstr, var);
                 ;    4418 	
                 ;    4419 	fp = temp_buff;
                 ;    4420 	while (*fp)
                 ;    4421 		fputc(*fp++, rp);	
                 ;    4422 }
                 ;    4423 #endif
                 ;    4424 //#endif
                 ;    4425 
                 ;    4426 // Set file pointer to the end of the file
                 ;    4427 int fend(FILE *rp)
                 ;    4428 {
                 ;    4429 	return (fseek(rp, 0, SEEK_END));	
                 ;    4430 }
                 ;    4431 
                 ;    4432 // Goto position "off_set" of a file
                 ;    4433 int fseek(FILE *rp, unsigned long off_set, unsigned char mode)
                 ;    4434 {
                 _fseek:
                 ;    4435 	unsigned int n, clus_temp;
                 ;    4436 	unsigned long length_check, addr_calc;
                 ;    4437 	
                 ;    4438 	if (rp==NULL)
001aae 9728      	SBIW R28,8
001aaf 940e 1f26 	CALL __SAVELOCR4
                 ;	*rp -> Y+17
                 ;	off_set -> Y+13
                 ;	mode -> Y+12
                 ;	n -> R16,R17
                 ;	clus_temp -> R18,R19
                 ;	length_check -> Y+8
                 ;	addr_calc -> Y+4
001ab1 89e9      	LDD  R30,Y+17
001ab2 89fa      	LDD  R31,Y+17+1
001ab3 9730      	SBIW R30,0
001ab4 f431      	BRNE _0x382
                 ;    4439 	{	// ERROR if FILE pointer is NULL
                 ;    4440 		_FF_error = FILE_ERR;
001ab5 e0e2      	LDI  R30,LOW(2)
001ab6 93e0 0bd3 	STS  __FF_error,R30
                 ;    4441 		return (EOF);
001ab8 efef      	LDI  R30,LOW(65535)
001ab9 efff      	LDI  R31,HIGH(65535)
001aba c1b1      	RJMP _0x41B
                 ;    4442 	}
                 ;    4443 	if (mode==SEEK_CUR)
                 _0x382:
001abb 85ec      	LDD  R30,Y+12
001abc 30e0      	CPI  R30,0
001abd f481      	BRNE _0x383
                 ;    4444 	{	// Trying to position pointer to offset from current position
                 ;    4445 		off_set += rp->position;
001abe 89a9      	LDD  R26,Y+17
001abf 89ba      	LDD  R27,Y+17+1
001ac0 5ea0      	SUBI R26,LOW(-544)
001ac1 4fbd      	SBCI R27,HIGH(-544)
001ac2 940e 1ebc 	CALL __GETD1P
001ac4 85ad
001ac5 85be
001ac6 858f
001ac7 8998      	__GETD2S 13
001ac8 940e 1dca 	CALL __ADDD12
001aca 87ed
001acb 87fe
001acc 876f
001acd 8b78      	__PUTD1S 13
                 ;    4446 	}
                 ;    4447 	if (off_set > rp->length)
                 _0x383:
001ace 89a9      	LDD  R26,Y+17
001acf 89ba      	LDD  R27,Y+17+1
001ad0 5ea4      	SUBI R26,LOW(-540)
001ad1 4fbd      	SBCI R27,HIGH(-540)
001ad2 940e 1ebc 	CALL __GETD1P
001ad4 85ad
001ad5 85be
001ad6 858f
001ad7 8998      	__GETD2S 13
001ad8 940e 1f1a 	CALL __CPD12
001ada f458      	BRSH _0x384
                 ;    4448 	{	// trying to position beyond or before file
                 ;    4449 		rp->error = POS_ERR;
001adb 89a9      	LDD  R26,Y+17
001adc 89ba      	LDD  R27,Y+17+1
001add 5dab      	SUBI R26,LOW(-549)
001ade 4fbd      	SBCI R27,HIGH(-549)
001adf e0ea      	LDI  R30,LOW(10)
001ae0 93ec      	ST   X,R30
                 ;    4450 		_FF_error = POS_ERR;
001ae1 93e0 0bd3 	STS  __FF_error,R30
                 ;    4451 		return (EOF);
001ae3 efef      	LDI  R30,LOW(65535)
001ae4 efff      	LDI  R31,HIGH(65535)
001ae5 c186      	RJMP _0x41B
                 ;    4452 	}
                 ;    4453 	if (mode==SEEK_END)
                 _0x384:
001ae6 85ac      	LDD  R26,Y+12
001ae7 30a1      	CPI  R26,LOW(0x1)
001ae8 f481      	BRNE _0x385
                 ;    4454 	{	// Trying to position pointer to offset from EOF
                 ;    4455 		off_set = rp->length - off_set;
001ae9 89a9      	LDD  R26,Y+17
001aea 89ba      	LDD  R27,Y+17+1
001aeb 5ea4      	SUBI R26,LOW(-540)
001aec 4fbd      	SBCI R27,HIGH(-540)
001aed 940e 1ebc 	CALL __GETD1P
001aef 85ad
001af0 85be
001af1 858f
001af2 8998      	__GETD2S 13
001af3 940e 1dd4 	CALL __SUBD12
001af5 87ed
001af6 87fe
001af7 876f
001af8 8b78      	__PUTD1S 13
                 ;    4456 	}
                 ;    4457 	#ifndef _READ_ONLY_
                 ;    4458 	if (rp->mode != READ)
                 _0x385:
001af9 89a9      	LDD  R26,Y+17
001afa 89ba      	LDD  R27,Y+17+1
001afb 5dac      	SUBI R26,LOW(-548)
001afc 4fbd      	SBCI R27,HIGH(-548)
001afd 91ac      	LD   R26,X
001afe 30a1      	CPI  R26,LOW(0x1)
001aff f059      	BREQ _0x386
                 ;    4459 		if (fflush(rp))
001b00 89e9      	LDD  R30,Y+17
001b01 89fa      	LDD  R31,Y+17+1
001b02 93fa      	ST   -Y,R31
001b03 93ea      	ST   -Y,R30
001b04 940e 1a16 	CALL _fflush
001b06 9730      	SBIW R30,0
001b07 f019      	BREQ _0x387
                 ;    4460 			return (EOF);
001b08 efef      	LDI  R30,LOW(65535)
001b09 efff      	LDI  R31,HIGH(65535)
001b0a c161      	RJMP _0x41B
                 ;    4461 	#endif
                 ;    4462 	clus_temp = rp->clus_start;
                 _0x387:
                 _0x386:
001b0b 89a9      	LDD  R26,Y+17
001b0c 89ba      	LDD  R27,Y+17+1
001b0d 961c      	ADIW R26,12
001b0e 912d      	LD   R18,X+
001b0f 913c      	LD   R19,X
                 ;    4463 	rp->clus_current = clus_temp;
001b10 01f9      	MOVW R30,R18
001b11 89a9
001b12 89ba
001b13 961e
001b14 93ed
001b15 93fc      	__PUTW1SNS 17,14
                 ;    4464 	rp->clus_next = next_cluster(clus_temp, SINGLE);
001b16 933a      	ST   -Y,R19
001b17 932a      	ST   -Y,R18
001b18 e0e1      	LDI  R30,LOW(1)
001b19 93ea      	ST   -Y,R30
001b1a 940e 0f9b 	CALL _next_cluster
001b1c 89a9
001b1d 89ba
001b1e 9650
001b1f 93ed
001b20 93fc      	__PUTW1SNS 17,16
                 ;    4465 	rp->clus_prev = 0;
001b21 89a9      	LDD  R26,Y+17
001b22 89ba      	LDD  R27,Y+17+1
001b23 9652      	ADIW R26,18
001b24 e0e0      	LDI  R30,LOW(0)
001b25 e0f0      	LDI  R31,HIGH(0)
001b26 93ed      	ST   X+,R30
001b27 93fc      	ST   X,R31
                 ;    4466 	
                 ;    4467 	addr_calc = off_set / ((long) BPB_BytsPerSec * (long) BPB_SecPerClus);
001b28 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001b2a 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001b2c 2766      	CLR  R22
001b2d 2777      	CLR  R23
001b2e 01df      	MOVW R26,R30
001b2f 01cb      	MOVW R24,R22
001b30 91e0 0b98 	LDS  R30,_BPB_SecPerClus
001b32 27ff      	CLR  R31
001b33 2766      	CLR  R22
001b34 2777      	CLR  R23
001b35 940e 1e4d 	CALL __MULD12
001b37 85ad
001b38 85be
001b39 858f
001b3a 8998      	__GETD2S 13
001b3b 940e 1e65 	CALL __DIVD21U
001b3d 83ec
001b3e 83fd
001b3f 836e
001b40 837f      	__PUTD1S 4
                 ;    4468 	length_check = off_set % ((long) BPB_BytsPerSec * (long) BPB_SecPerClus);
001b41 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001b43 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001b45 2766      	CLR  R22
001b46 2777      	CLR  R23
001b47 01df      	MOVW R26,R30
001b48 01cb      	MOVW R24,R22
001b49 91e0 0b98 	LDS  R30,_BPB_SecPerClus
001b4b 27ff      	CLR  R31
001b4c 2766      	CLR  R22
001b4d 2777      	CLR  R23
001b4e 940e 1e4d 	CALL __MULD12
001b50 85ad
001b51 85be
001b52 858f
001b53 8998      	__GETD2S 13
001b54 940e 1e93 	CALL __MODD21U
001b56 87e8
001b57 87f9
001b58 876a
001b59 877b      	__PUTD1S 8
                 ;    4469 	rp->EOF_flag = 0;
001b5a 89a9      	LDD  R26,Y+17
001b5b 89ba      	LDD  R27,Y+17+1
001b5c 5daa      	SUBI R26,LOW(-550)
001b5d 4fbd      	SBCI R27,HIGH(-550)
001b5e e0e0      	LDI  R30,LOW(0)
001b5f 93ec      	ST   X,R30
                 ;    4470 
                 ;    4471 	while (addr_calc)
                 _0x388:
001b60 81ec
001b61 81fd
001b62 816e
001b63 817f      	__GETD1S 4
001b64 940e 1f0c 	CALL __CPD10
001b66 f411      	BRNE PC+3
001b67 940c 1bc3 	JMP _0x38A
                 ;    4472 	{
                 ;    4473 		if (rp->clus_next >= 0xFFF8)
001b69 89e9      	LDD  R30,Y+17
001b6a 89fa      	LDD  R31,Y+17+1
001b6b 89a0      	LDD  R26,Z+16
001b6c 89b1      	LDD  R27,Z+17
001b6d 3fa8      	CPI  R26,LOW(0xFFF8)
001b6e efef      	LDI  R30,HIGH(0xFFF8)
001b6f 07be      	CPC  R27,R30
001b70 f130      	BRLO _0x38B
                 ;    4474 		{	// trying to position beyond or before file
                 ;    4475 			if ((addr_calc==1) && (length_check==0))
001b71 81ac
001b72 81bd
001b73 818e
001b74 819f      	__GETD2S 4
001b75 30a1
001b76 e0e0
001b77 07be
001b78 e0e0
001b79 078e
001b7a e0e0
001b7b 079e      	__CPD2N 0x1
001b7c f439      	BRNE _0x38D
001b7d 85a8
001b7e 85b9
001b7f 858a
001b80 859b      	__GETD2S 8
001b81 940e 1f14 	CALL __CPD02
001b83 f009      	BREQ _0x38E
                 _0x38D:
001b84 c007      	RJMP _0x38C
                 _0x38E:
                 ;    4476 			{
                 ;    4477 				rp->EOF_flag = 1;
001b85 89a9      	LDD  R26,Y+17
001b86 89ba      	LDD  R27,Y+17+1
001b87 5daa      	SUBI R26,LOW(-550)
001b88 4fbd      	SBCI R27,HIGH(-550)
001b89 e0e1      	LDI  R30,LOW(1)
001b8a 93ec      	ST   X,R30
                 ;    4478 				break;
001b8b c037      	RJMP _0x38A
                 ;    4479 			}				
                 ;    4480 			rp->error = POS_ERR;
                 _0x38C:
001b8c 89a9      	LDD  R26,Y+17
001b8d 89ba      	LDD  R27,Y+17+1
001b8e 5dab      	SUBI R26,LOW(-549)
001b8f 4fbd      	SBCI R27,HIGH(-549)
001b90 e0ea      	LDI  R30,LOW(10)
001b91 93ec      	ST   X,R30
                 ;    4481 			_FF_error = POS_ERR;
001b92 93e0 0bd3 	STS  __FF_error,R30
                 ;    4482 			return (EOF);
001b94 efef      	LDI  R30,LOW(65535)
001b95 efff      	LDI  R31,HIGH(65535)
001b96 c0d5      	RJMP _0x41B
                 ;    4483 		}
                 ;    4484 		clus_temp = rp->clus_next;
                 _0x38B:
001b97 89a9      	LDD  R26,Y+17
001b98 89ba      	LDD  R27,Y+17+1
001b99 9650      	ADIW R26,16
001b9a 912d      	LD   R18,X+
001b9b 913c      	LD   R19,X
                 ;    4485 		rp->clus_prev = rp->clus_current;
001b9c 89a9      	LDD  R26,Y+17
001b9d 89ba      	LDD  R27,Y+17+1
001b9e 961e      	ADIW R26,14
001b9f 940e 1eb8 	CALL __GETW1P
001ba1 89a9
001ba2 89ba
001ba3 9652
001ba4 93ed
001ba5 93fc      	__PUTW1SNS 17,18
                 ;    4486 		rp->clus_current = clus_temp;
001ba6 01f9      	MOVW R30,R18
001ba7 89a9
001ba8 89ba
001ba9 961e
001baa 93ed
001bab 93fc      	__PUTW1SNS 17,14
                 ;    4487 		rp->clus_next = next_cluster(clus_temp, CHAIN);
001bac 933a      	ST   -Y,R19
001bad 932a      	ST   -Y,R18
001bae e0e0      	LDI  R30,LOW(0)
001baf 93ea      	ST   -Y,R30
001bb0 940e 0f9b 	CALL _next_cluster
001bb2 89a9
001bb3 89ba
001bb4 9650
001bb5 93ed
001bb6 93fc      	__PUTW1SNS 17,16
                 ;    4488 		addr_calc--;
001bb7 81ec
001bb8 81fd
001bb9 816e
001bba 817f      	__GETD1S 4
001bbb 9731      	SBIW R30,1
001bbc 4060      	SBCI R22,0
001bbd 4070      	SBCI R23,0
001bbe 83ec
001bbf 83fd
001bc0 836e
001bc1 837f      	__PUTD1S 4
                 ;    4489 	}
001bc2 cf9d      	RJMP _0x388
                 _0x38A:
                 ;    4490 	
                 ;    4491 	addr_calc = clust_to_addr(rp->clus_current);
001bc3 89e9      	LDD  R30,Y+17
001bc4 89fa      	LDD  R31,Y+17+1
001bc5 85a6      	LDD  R26,Z+14
001bc6 85b7      	LDD  R27,Z+15
001bc7 93ba      	ST   -Y,R27
001bc8 93aa      	ST   -Y,R26
001bc9 940e 0edf 	CALL _clust_to_addr
001bcb 83ec
001bcc 83fd
001bcd 836e
001bce 837f      	__PUTD1S 4
                 ;    4492 	rp->sec_offset = 1;			// Reset Reading Sector
001bcf 89a9      	LDD  R26,Y+17
001bd0 89ba      	LDD  R27,Y+17+1
001bd1 9654      	ADIW R26,20
001bd2 e0e1      	LDI  R30,LOW(1)
001bd3 e0f0      	LDI  R31,HIGH(1)
001bd4 93ed      	ST   X+,R30
001bd5 93fc      	ST   X,R31
                 ;    4493 	while (length_check >= BPB_BytsPerSec)
                 _0x38F:
001bd6 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001bd8 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001bda 85a8
001bdb 85b9
001bdc 858a
001bdd 859b      	__GETD2S 8
001bde 2766      	CLR  R22
001bdf 2777      	CLR  R23
001be0 940e 1f1f 	CALL __CPD21
001be2 f148      	BRLO _0x391
                 ;    4494 	{
                 ;    4495 		addr_calc += BPB_BytsPerSec;
001be3 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001be5 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001be7 81ac
001be8 81bd
001be9 818e
001bea 819f      	__GETD2S 4
001beb 2766      	CLR  R22
001bec 2777      	CLR  R23
001bed 940e 1dca 	CALL __ADDD12
001bef 83ec
001bf0 83fd
001bf1 836e
001bf2 837f      	__PUTD1S 4
                 ;    4496 		length_check -= BPB_BytsPerSec;
001bf3 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001bf5 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001bf7 85a8
001bf8 85b9
001bf9 858a
001bfa 859b      	__GETD2S 8
001bfb 2766      	CLR  R22
001bfc 2777      	CLR  R23
001bfd 940e 1dd9 	CALL __SUBD21
001bff 87a8
001c00 87b9
001c01 878a
001c02 879b      	__PUTD2S 8
                 ;    4497 		rp->sec_offset++;
001c03 89a9      	LDD  R26,Y+17
001c04 89ba      	LDD  R27,Y+17+1
001c05 9654      	ADIW R26,20
001c06 940e 1eb8 	CALL __GETW1P
001c08 9631      	ADIW R30,1
001c09 93ed      	ST   X+,R30
001c0a 93fc      	ST   X,R31
                 ;    4498 	}
001c0b cfca      	RJMP _0x38F
                 _0x391:
                 ;    4499 	
                 ;    4500 	if (_FF_read(addr_calc)==0)		// Read Current Data Sector
001c0c 81ec
001c0d 81fd
001c0e 816e
001c0f 817f      	__GETD1S 4
001c10 940e 1ecb 	CALL __PUTPARD1
001c12 940e 0b52 	CALL __FF_read
001c14 30e0      	CPI  R30,0
001c15 f419      	BRNE _0x392
                 ;    4501 		return(EOF);		// Read Error  
001c16 efef      	LDI  R30,LOW(65535)
001c17 efff      	LDI  R31,HIGH(65535)
001c18 c053      	RJMP _0x41B
                 ;    4502 		
                 ;    4503 	for (n=0; n<BPB_BytsPerSec; n++)
                 _0x392:
001c19 e000
001c1a e010      	__GETWRN 16,17,0
                 _0x394:
001c1b 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001c1d 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001c1f 170e      	CP   R16,R30
001c20 071f      	CPC  R17,R31
001c21 f480      	BRSH _0x395
                 ;    4504 		rp->buff[n] = _FF_buff[n];
001c22 89e9      	LDD  R30,Y+17
001c23 89fa      	LDD  R31,Y+17+1
001c24 967c      	ADIW R30,28
001c25 0fe0      	ADD  R30,R16
001c26 1ff1      	ADC  R31,R17
001c27 010f      	MOVW R0,R30
001c28 e9a0      	LDI  R26,LOW(__FF_buff)
001c29 e0b9      	LDI  R27,HIGH(__FF_buff)
001c2a 0fa0      	ADD  R26,R16
001c2b 1fb1      	ADC  R27,R17
001c2c 91ec      	LD   R30,X
001c2d 01d0      	MOVW R26,R0
001c2e 93ec      	ST   X,R30
                 ;    4505     
                 ;    4506     if ((rp->EOF_flag == 1) && (length_check == 0))
001c2f 5f0f
001c30 4f1f      	__ADDWRN 16,17,1
001c31 cfe9      	RJMP _0x394
                 _0x395:
001c32 89a9      	LDD  R26,Y+17
001c33 89ba      	LDD  R27,Y+17+1
001c34 5daa      	SUBI R26,LOW(-550)
001c35 4fbd      	SBCI R27,HIGH(-550)
001c36 91ac      	LD   R26,X
001c37 30a1      	CPI  R26,LOW(0x1)
001c38 f439      	BRNE _0x397
001c39 85a8
001c3a 85b9
001c3b 858a
001c3c 859b      	__GETD2S 8
001c3d 940e 1f14 	CALL __CPD02
001c3f f009      	BREQ _0x398
                 _0x397:
001c40 c010      	RJMP _0x396
                 _0x398:
                 ;    4507     	rp->pntr = &rp->buff[BPB_BytsPerSec-1];
001c41 89a9      	LDD  R26,Y+17
001c42 89ba      	LDD  R27,Y+17+1
001c43 965c      	ADIW R26,28
001c44 91e0 0b96 	LDS  R30,_BPB_BytsPerSec
001c46 91f0 0b97 	LDS  R31,_BPB_BytsPerSec+1
001c48 9731      	SBIW R30,1
001c49 0fea      	ADD  R30,R26
001c4a 1ffb      	ADC  R31,R27
001c4b 89a9
001c4c 89ba
001c4d 5da9
001c4e 4fbd
001c4f 93ed
001c50 93fc      	__PUTW1SN 17,551
                 ;    4508 	rp->pntr = &rp->buff[length_check];
                 _0x396:
001c51 89a9      	LDD  R26,Y+17
001c52 89ba      	LDD  R27,Y+17+1
001c53 965c      	ADIW R26,28
001c54 85e8
001c55 85f9
001c56 856a
001c57 857b      	__GETD1S 8
001c58 0fea      	ADD  R30,R26
001c59 1ffb      	ADC  R31,R27
001c5a 89a9
001c5b 89ba
001c5c 5da9
001c5d 4fbd
001c5e 93ed
001c5f 93fc      	__PUTW1SN 17,551
                 ;    4509 	rp->position = off_set;
001c60 85ed
001c61 85fe
001c62 856f
001c63 8978      	__GETD1S 13
001c64 89a9
001c65 89ba
001c66 5ea0
001c67 4fbd
001c68 940e 1ec2 	__PUTD1SN 17,544
                 ;    4510 		
                 ;    4511 	return (0);	
001c6a e0e0      	LDI  R30,LOW(0)
001c6b e0f0      	LDI  R31,HIGH(0)
                 _0x41B:
001c6c 940e 1f2d 	CALL __LOADLOCR4
001c6e 9663      	ADIW R28,19
001c6f 9508      	RET
                 ;    4512 }
                 ;    4513 
                 ;    4514 // Return the current position of the file rp with respect to the begining of the file
                 ;    4515 long ftell(FILE *rp)
                 ;    4516 {
                 ;    4517 	if (rp==NULL)
                 ;    4518 		return (EOF);
                 ;    4519 	else
                 ;    4520 		return (rp->position);
                 ;    4521 }
                 ;    4522 
                 ;    4523 // Funtion that returns a '1' for @EOF, '0' otherwise
                 ;    4524 int feof(FILE *rp)
                 ;    4525 {
                 ;    4526 	if (rp==NULL)
                 ;    4527 		return (EOF);
                 ;    4528 	
                 ;    4529 	if (rp->length==rp->position)
                 ;    4530 		return (1);
                 ;    4531 	else
                 ;    4532 		return (0);
                 ;    4533 }
                 ;    4534 		
                 ;    4535 void dump_file_data_hex(FILE *rp)
                 ;    4536 {
                 ;    4537 	unsigned int n, c;
                 ;    4538 	
                 ;    4539 	if (rp==NULL)
                 ;	*rp -> Y+4
                 ;	n -> R16,R17
                 ;	c -> R18,R19
                 ;    4540 		return;
                 ;    4541 
                 ;    4542 	for (n=0; n<0x20; n++)
                 ;    4543 	{   
                 ;    4544 		printf("\n\r");
                 ;    4545 		for (c=0; c<0x10; c++)
                 ;    4546 			printf("%02X ", rp->buff[(n*0x20)+c]);
                 ;    4547 	}
                 ;    4548 }
                 ;    4549 
                 ;    4550 void dump_file_data_view(FILE *rp)
                 ;    4551 {
                 ;    4552 	unsigned int n;
                 ;    4553 	
                 ;    4554 	if (rp==NULL)
                 ;	*rp -> Y+2
                 ;	n -> R16,R17
                 ;    4555 		return;
                 ;    4556 
                 ;    4557 	printf("\n\r");
                 ;    4558 	for (n=0; n<512; n++)
                 ;    4559 		putchar(rp->buff[n]);
                 ;    4560 }
                 ;    4561 
                 
                 _getchar:
001c70 9b5f           sbis usr,rxc
001c71 cffe           rjmp _getchar
001c72 b1ec           in   r30,udr
001c73 9508      	RET
                 _putchar:
001c74 9b5d           sbis usr,udre
001c75 cffe           rjmp _putchar
001c76 81e8           ld   r30,y
001c77 b9ec           out  udr,r30
001c78 9621      	ADIW R28,1
001c79 9508      	RET
                 _allocate_block_G9:
001c7a 9722      	SBIW R28,2
001c7b 940e 1f24 	CALL __SAVELOCR6
001c7d ea08
001c7e e01c      	__GETWRN 16,17,3240
001c7f 01d8      	MOVW R26,R16
001c80 e0e0      	LDI  R30,LOW(0)
001c81 e0f0      	LDI  R31,HIGH(0)
001c82 93ed      	ST   X+,R30
001c83 93fc      	ST   X,R31
                 _0x407:
001c84 2e00      	MOV  R0,R16
001c85 2a01      	OR   R0,R17
001c86 f1a9      	BREQ _0x409
001c87 01d8      	MOVW R26,R16
001c88 940e 1eb8 	CALL __GETW1P
001c8a 0fe0      	ADD  R30,R16
001c8b 1ff1      	ADC  R31,R17
001c8c 9634      	ADIW R30,4
001c8d 01af      	MOVW R20,R30
001c8e 9612      	ADIW R26,2
001c8f 940e 1eb8 	CALL __GETW1P
001c91 019f      	MOVW R18,R30
001c92 9730      	SBIW R30,0
001c93 f019      	BREQ _0x40A
001c94 832e
001c95 833f      	__PUTWSR 18,19,6
001c96 c004      	RJMP _0x40B
                 _0x40A:
001c97 e0e0      	LDI  R30,LOW(4352)
001c98 e1f1      	LDI  R31,HIGH(4352)
001c99 83ee      	STD  Y+6,R30
001c9a 83ff      	STD  Y+6+1,R31
                 _0x40B:
001c9b 81ee      	LDD  R30,Y+6
001c9c 81ff      	LDD  R31,Y+6+1
001c9d 1be4      	SUB  R30,R20
001c9e 0bf5      	SBC  R31,R21
001c9f 01df      	MOVW R26,R30
001ca0 85e8      	LDD  R30,Y+8
001ca1 85f9      	LDD  R31,Y+8+1
001ca2 9634      	ADIW R30,4
001ca3 17ae      	CP   R26,R30
001ca4 07bf      	CPC  R27,R31
001ca5 f098      	BRLO _0x40C
001ca6 01fa      	MOVW R30,R20
001ca7 01d8
001ca8 9612
001ca9 93ed
001caa 93fc      	__PUTW1RNS 16,2
001cab 01f9      	MOVW R30,R18
001cac 01da
001cad 9612
001cae 93ed
001caf 93fc      	__PUTW1RNS 20,2
001cb0 85e8      	LDD  R30,Y+8
001cb1 85f9      	LDD  R31,Y+8+1
001cb2 01da      	MOVW R26,R20
001cb3 93ed      	ST   X+,R30
001cb4 93fc      	ST   X,R31
001cb5 5f4c
001cb6 4f5f      	__ADDWRN 20,21,4
001cb7 01fa      	MOVW R30,R20
001cb8 c005      	RJMP _0x41A
                 _0x40C:
001cb9 2f02
001cba 2f13      	__MOVEWRR 16,17,18,19
001cbb cfc8      	RJMP _0x407
                 _0x409:
001cbc e0e0      	LDI  R30,LOW(0)
001cbd e0f0      	LDI  R31,HIGH(0)
                 _0x41A:
001cbe 940e 1f2b 	CALL __LOADLOCR6
001cc0 962a      	ADIW R28,10
001cc1 9508      	RET
                 _find_prev_block_G9:
001cc2 940e 1f26 	CALL __SAVELOCR4
001cc4 ea08
001cc5 e01c      	__GETWRN 16,17,3240
                 _0x40D:
001cc6 2e00      	MOV  R0,R16
001cc7 2a01      	OR   R0,R17
001cc8 f081      	BREQ _0x40F
001cc9 01d8      	MOVW R26,R16
001cca 9612      	ADIW R26,2
001ccb 940e 1eb8 	CALL __GETW1P
001ccd 019f      	MOVW R18,R30
001cce 01df      	MOVW R26,R30
001ccf 81ec      	LDD  R30,Y+4
001cd0 81fd      	LDD  R31,Y+4+1
001cd1 17ea      	CP   R30,R26
001cd2 07fb      	CPC  R31,R27
001cd3 f411      	BRNE _0x410
001cd4 01f8      	MOVW R30,R16
001cd5 c005      	RJMP _0x419
                 _0x410:
001cd6 2f02
001cd7 2f13      	__MOVEWRR 16,17,18,19
001cd8 cfed      	RJMP _0x40D
                 _0x40F:
001cd9 e0e0      	LDI  R30,LOW(0)
001cda e0f0      	LDI  R31,HIGH(0)
                 _0x419:
001cdb 940e 1f2d 	CALL __LOADLOCR4
001cdd 9626      	ADIW R28,6
001cde 9508      	RET
                 _realloc:
001cdf 9722      	SBIW R28,2
001ce0 940e 1f24 	CALL __SAVELOCR6
001ce2 85ea      	LDD  R30,Y+10
001ce3 85fb      	LDD  R31,Y+10+1
001ce4 9730      	SBIW R30,0
001ce5 f411      	BRNE PC+3
001ce6 940c 1d24 	JMP _0x411
001ce8 9734      	SBIW R30,4
001ce9 018f      	MOVW R16,R30
001cea 931a      	ST   -Y,R17
001ceb 930a      	ST   -Y,R16
001cec dfd5      	RCALL _find_prev_block_G9
001ced 019f      	MOVW R18,R30
001cee 9730      	SBIW R30,0
001cef f1a1      	BREQ _0x412
001cf0 01d8      	MOVW R26,R16
001cf1 9612      	ADIW R26,2
001cf2 940e 1eb8 	CALL __GETW1P
001cf4 01d9
001cf5 9612
001cf6 93ed
001cf7 93fc      	__PUTW1RNS 18,2
001cf8 85e8      	LDD  R30,Y+8
001cf9 85f9      	LDD  R31,Y+8+1
001cfa 9730      	SBIW R30,0
001cfb f141      	BREQ _0x413
001cfc 93fa      	ST   -Y,R31
001cfd 93ea      	ST   -Y,R30
001cfe df7b      	RCALL _allocate_block_G9
001cff 01af      	MOVW R20,R30
001d00 9730      	SBIW R30,0
001d01 f0e9      	BREQ _0x414
001d02 01d8      	MOVW R26,R16
001d03 940e 1eb8 	CALL __GETW1P
001d05 83ee      	STD  Y+6,R30
001d06 83ff      	STD  Y+6+1,R31
001d07 01df      	MOVW R26,R30
001d08 85e8      	LDD  R30,Y+8
001d09 85f9      	LDD  R31,Y+8+1
001d0a 17ae      	CP   R26,R30
001d0b 07bf      	CPC  R27,R31
001d0c f420      	BRSH _0x415
001d0d 81ee      	LDD  R30,Y+6
001d0e 81ff      	LDD  R31,Y+6+1
001d0f 87e8      	STD  Y+8,R30
001d10 87f9      	STD  Y+8+1,R31
                 _0x415:
001d11 935a      	ST   -Y,R21
001d12 934a      	ST   -Y,R20
001d13 85ec      	LDD  R30,Y+12
001d14 85fd      	LDD  R31,Y+12+1
001d15 93fa      	ST   -Y,R31
001d16 93ea      	ST   -Y,R30
001d17 85ec      	LDD  R30,Y+12
001d18 85fd      	LDD  R31,Y+12+1
001d19 93fa      	ST   -Y,R31
001d1a 93ea      	ST   -Y,R30
001d1b 940e 1d52 	CALL _memmove
001d1d 01fa      	MOVW R30,R20
001d1e c007      	RJMP _0x418
                 _0x414:
001d1f 01f8      	MOVW R30,R16
001d20 01d9
001d21 9612
001d22 93ed
001d23 93fc      	__PUTW1RNS 18,2
                 _0x413:
                 _0x412:
                 _0x411:
001d24 e0e0      	LDI  R30,LOW(0)
001d25 e0f0      	LDI  R31,HIGH(0)
                 _0x418:
001d26 940e 1f2b 	CALL __LOADLOCR6
001d28 962c      	ADIW R28,12
001d29 9508      	RET
                 _malloc:
001d2a 931a      	ST   -Y,R17
001d2b 930a      	ST   -Y,R16
001d2c e000
001d2d e010      	__GETWRN 16,17,0
001d2e 81ea      	LDD  R30,Y+2
001d2f 81fb      	LDD  R31,Y+2+1
001d30 9730      	SBIW R30,0
001d31 f081      	BREQ _0x416
001d32 93fa      	ST   -Y,R31
001d33 93ea      	ST   -Y,R30
001d34 df45      	RCALL _allocate_block_G9
001d35 018f      	MOVW R16,R30
001d36 9730      	SBIW R30,0
001d37 f051      	BREQ _0x417
001d38 931a      	ST   -Y,R17
001d39 930a      	ST   -Y,R16
001d3a e0e0      	LDI  R30,LOW(0)
001d3b 93ea      	ST   -Y,R30
001d3c 81ed      	LDD  R30,Y+5
001d3d 81fe      	LDD  R31,Y+5+1
001d3e 93fa      	ST   -Y,R31
001d3f 93ea      	ST   -Y,R30
001d40 940e 1d6f 	CALL _memset
                 _0x417:
                 _0x416:
001d42 01f8      	MOVW R30,R16
001d43 8119      	LDD  R17,Y+1
001d44 8108      	LDD  R16,Y+0
001d45 9624      	ADIW R28,4
001d46 9508      	RET
                 _free:
001d47 81e8      	LD   R30,Y
001d48 81f9      	LDD  R31,Y+1
001d49 93fa      	ST   -Y,R31
001d4a 93ea      	ST   -Y,R30
001d4b e0e0      	LDI  R30,LOW(0)
001d4c e0f0      	LDI  R31,HIGH(0)
001d4d 93fa      	ST   -Y,R31
001d4e 93ea      	ST   -Y,R30
001d4f df8f      	RCALL _realloc
001d50 9622      	ADIW R28,2
001d51 9508      	RET
                 
                 _memmove:
001d52 8199      	ldd  r25,y+1
001d53 8188      	ld   r24,y
001d54 9600      	adiw r24,0
001d55 f0a9      	breq __memmove3
001d56 81bd      	ldd  r27,y+5
001d57 81ac      	ldd  r26,y+4
001d58 81fb      	ldd  r31,y+3
001d59 81ea      	ldd  r30,y+2
001d5a 17ea      	cp   r30,r26
001d5b 07fb      	cpc  r31,r27
001d5c f071      	breq __memmove3
001d5d f02c      	brlt __memmove1
                 __memmove0:
001d5e 9161      	ld   r22,z+
001d5f 936d      	st   x+,r22
001d60 9701      	sbiw r24,1
001d61 f7e1      	brne __memmove0
001d62 c008      	rjmp __memmove3
                 __memmove1:
001d63 0fa8      	add  r26,r24
001d64 1fb9      	adc  r27,r25
001d65 0fe8      	add  r30,r24
001d66 1ff9      	adc  r31,r25
                 __memmove2:
001d67 9162      	ld   r22,-z
001d68 936e      	st   -x,r22
001d69 9701      	sbiw r24,1
001d6a f7e1      	brne __memmove2
                 __memmove3:
001d6b 81fd      	ldd  r31,y+5
001d6c 81ec      	ldd  r30,y+4
001d6d 9626      	adiw r28,6
001d6e 9508      	ret
                 
                 _memset:
001d6f 81b9      	ldd  r27,y+1
001d70 81a8      	ld   r26,y
001d71 9610      	adiw r26,0
001d72 f031      	breq __memset1
001d73 81fc      	ldd  r31,y+4
001d74 81eb      	ldd  r30,y+3
001d75 816a      	ldd  r22,y+2
                 __memset0:
001d76 9361      	st   z+,r22
001d77 9711      	sbiw r26,1
001d78 f7e9      	brne __memset0
                 __memset1:
001d79 81eb      	ldd  r30,y+3
001d7a 81fc      	ldd  r31,y+4
001d7b 9625      	adiw r28,5
001d7c 9508      	ret
                 
                 _strlen:
001d7d 91a9      	ld   r26,y+
001d7e 91b9      	ld   r27,y+
001d7f 27ee      	clr  r30
001d80 27ff      	clr  r31
                 __strlen0:
001d81 916d      	ld   r22,x+
001d82 2366      	tst  r22
001d83 f011      	breq __strlen1
001d84 9631      	adiw r30,1
001d85 cffb      	rjmp __strlen0
                 __strlen1:
001d86 9508      	ret
                 
                 _strlenf:
001d87 27aa      	clr  r26
001d88 27bb      	clr  r27
001d89 91e9      	ld   r30,y+
001d8a 91f9      	ld   r31,y+
                 __strlenf0:
001d8b 9005      	lpm  r0,z+
001d8c 2000      	tst  r0
001d8d f011      	breq __strlenf1
001d8e 9611      	adiw r26,1
001d8f cffb      	rjmp __strlenf0
                 __strlenf1:
001d90 01fd      	movw r30,r26
001d91 9508      	ret
                 
                 _strncmp:
001d92 2766      	clr  r22
001d93 2777      	clr  r23
001d94 9189      	ld   r24,y+
001d95 91e9      	ld   r30,y+
001d96 91f9      	ld   r31,y+
001d97 91a9      	ld   r26,y+
001d98 91b9      	ld   r27,y+
                 __strncmp0:
001d99 2388      	tst  r24
001d9a f049      	breq __strncmp1
001d9b 958a      	dec  r24
001d9c 916d      	ld   r22,x+
001d9d 9171      	ld   r23,z+
001d9e 1767      	cp   r22,r23
001d9f f421      	brne __strncmp1
001da0 2366      	tst  r22
001da1 f7b9      	brne __strncmp0
                 __strncmp3:
001da2 27ee      	clr  r30
001da3 9508      	ret
                 __strncmp1:
001da4 1b67      	sub  r22,r23
001da5 f3e1      	breq __strncmp3
001da6 e0e1      	ldi  r30,1
001da7 f408      	brcc __strncmp2
001da8 50e2      	subi r30,2
                 __strncmp2:
001da9 9508      	ret
                 
                 _strrpos:
001daa 9169      	ld   r22,y+
001dab 91a9      	ld   r26,y+
001dac 91b9      	ld   r27,y+
001dad efef      	ldi  r30,-1
001dae 27ff      	clr  r31
                 __strrpos0:
001daf 917d      	ld   r23,x+
001db0 1767      	cp   r22,r23
001db1 f409      	brne __strrpos1
001db2 2fef      	mov  r30,r31
                 __strrpos1:
001db3 95f3      	inc  r31
001db4 2377      	tst  r23
001db5 f7c9      	brne __strrpos0
001db6 9508      	ret
                 
                 _toupper:
001db7 91e9      	ld   r30,y+
001db8 36e1      	cpi  r30,'a'
001db9 f018      	brlo __toupper0
001dba 37eb      	cpi  r30,'z'+1
001dbb f408      	brcc __toupper0
001dbc 52e0      	subi r30,32
                 __toupper0:
001dbd 9508      	ret
                 
                 _delay_ms:
001dbe 91e9      	ld   r30,y+
001dbf 91f9      	ld   r31,y+
001dc0 9630      	adiw r30,0
001dc1 f039      	breq __delay_ms1
                 __delay_ms0:
001dc2 ed80
001dc3 e097
001dc4 9701
001dc5 f7f1      	__DELAY_USW 0x7D0
001dc6 95a8      	wdr
001dc7 9731      	sbiw r30,1
001dc8 f7c9      	brne __delay_ms0
                 __delay_ms1:
001dc9 9508      	ret
                 
                 __ADDD12:
001dca 0fea      	ADD  R30,R26
001dcb 1ffb      	ADC  R31,R27
001dcc 1f68      	ADC  R22,R24
001dcd 1f79      	ADC  R23,R25
001dce 9508      	RET
                 
                 __ADDD21:
001dcf 0fae      	ADD  R26,R30
001dd0 1fbf      	ADC  R27,R31
001dd1 1f86      	ADC  R24,R22
001dd2 1f97      	ADC  R25,R23
001dd3 9508      	RET
                 
                 __SUBD12:
001dd4 1bea      	SUB  R30,R26
001dd5 0bfb      	SBC  R31,R27
001dd6 0b68      	SBC  R22,R24
001dd7 0b79      	SBC  R23,R25
001dd8 9508      	RET
                 
                 __SUBD21:
001dd9 1bae      	SUB  R26,R30
001dda 0bbf      	SBC  R27,R31
001ddb 0b86      	SBC  R24,R22
001ddc 0b97      	SBC  R25,R23
001ddd 9508      	RET
                 
                 __ORD12:
001dde 2bea      	OR   R30,R26
001ddf 2bfb      	OR   R31,R27
001de0 2b68      	OR   R22,R24
001de1 2b79      	OR   R23,R25
001de2 9508      	RET
                 
                 __ANEGW1:
001de3 95e0      	COM  R30
001de4 95f0      	COM  R31
001de5 9631      	ADIW R30,1
001de6 9508      	RET
                 
                 __ANEGD1:
001de7 95e0      	COM  R30
001de8 95f0      	COM  R31
001de9 9560      	COM  R22
001dea 9570      	COM  R23
001deb 5fef      	SUBI R30,-1
001dec 4fff      	SBCI R31,-1
001ded 4f6f      	SBCI R22,-1
001dee 4f7f      	SBCI R23,-1
001def 9508      	RET
                 
                 __LSLD12:
001df0 23ee      	TST  R30
001df1 2e0e      	MOV  R0,R30
001df2 01fd      	MOVW R30,R26
001df3 01bc      	MOVW R22,R24
001df4 f031      	BREQ __LSLD12R
                 __LSLD12L:
001df5 0fee      	LSL  R30
001df6 1fff      	ROL  R31
001df7 1f66      	ROL  R22
001df8 1f77      	ROL  R23
001df9 940a      	DEC  R0
001dfa f7d1      	BRNE __LSLD12L
                 __LSLD12R:
001dfb 9508      	RET
                 
                 __LSRD12:
001dfc 23ee      	TST  R30
001dfd 2e0e      	MOV  R0,R30
001dfe 01fd      	MOVW R30,R26
001dff 01bc      	MOVW R22,R24
001e00 f031      	BREQ __LSRD12R
                 __LSRD12L:
001e01 9576      	LSR  R23
001e02 9567      	ROR  R22
001e03 95f7      	ROR  R31
001e04 95e7      	ROR  R30
001e05 940a      	DEC  R0
001e06 f7d1      	BRNE __LSRD12L
                 __LSRD12R:
001e07 9508      	RET
                 
                 __LSLW4:
001e08 0fee      	LSL  R30
001e09 1fff      	ROL  R31
                 __LSLW3:
001e0a 0fee      	LSL  R30
001e0b 1fff      	ROL  R31
                 __LSLW2:
001e0c 0fee      	LSL  R30
001e0d 1fff      	ROL  R31
001e0e 0fee      	LSL  R30
001e0f 1fff      	ROL  R31
001e10 9508      	RET
                 
                 __LSRD16:
001e11 2fe6      	MOV  R30,R22
001e12 2ff7      	MOV  R31,R23
001e13 e060      	LDI  R22,0
001e14 e070      	LDI  R23,0
001e15 9508      	RET
                 
                 __LSLD16:
001e16 2f6e      	MOV  R22,R30
001e17 2f7f      	MOV  R23,R31
001e18 e0e0      	LDI  R30,0
001e19 e0f0      	LDI  R31,0
001e1a 9508      	RET
                 
                 __CWD1:
001e1b 2f6f      	MOV  R22,R31
001e1c 0f66      	ADD  R22,R22
001e1d 0b66      	SBC  R22,R22
001e1e 2f76      	MOV  R23,R22
001e1f 9508      	RET
                 
                 __MULW12U:
001e20 9ffa      	MUL  R31,R26
001e21 2df0      	MOV  R31,R0
001e22 9feb      	MUL  R30,R27
001e23 0df0      	ADD  R31,R0
001e24 9fea      	MUL  R30,R26
001e25 2de0      	MOV  R30,R0
001e26 0df1      	ADD  R31,R1
001e27 9508      	RET
                 
                 __MULD12U:
001e28 9f7a      	MUL  R23,R26
001e29 2d70      	MOV  R23,R0
001e2a 9f6b      	MUL  R22,R27
001e2b 0d70      	ADD  R23,R0
001e2c 9ff8      	MUL  R31,R24
001e2d 0d70      	ADD  R23,R0
001e2e 9fe9      	MUL  R30,R25
001e2f 0d70      	ADD  R23,R0
001e30 9f6a      	MUL  R22,R26
001e31 2d60      	MOV  R22,R0
001e32 0d71      	ADD  R23,R1
001e33 9ffb      	MUL  R31,R27
001e34 0d60      	ADD  R22,R0
001e35 1d71      	ADC  R23,R1
001e36 9fe8      	MUL  R30,R24
001e37 0d60      	ADD  R22,R0
001e38 1d71      	ADC  R23,R1
001e39 2788      	CLR  R24
001e3a 9ffa      	MUL  R31,R26
001e3b 2df0      	MOV  R31,R0
001e3c 0d61      	ADD  R22,R1
001e3d 1f78      	ADC  R23,R24
001e3e 9feb      	MUL  R30,R27
001e3f 0df0      	ADD  R31,R0
001e40 1d61      	ADC  R22,R1
001e41 1f78      	ADC  R23,R24
001e42 9fea      	MUL  R30,R26
001e43 2de0      	MOV  R30,R0
001e44 0df1      	ADD  R31,R1
001e45 1f68      	ADC  R22,R24
001e46 1f78      	ADC  R23,R24
001e47 9508      	RET
                 
                 __MULW12:
001e48 d04e      	RCALL __CHKSIGNW
001e49 dfd6      	RCALL __MULW12U
001e4a f40e      	BRTC __MULW121
001e4b df97      	RCALL __ANEGW1
                 __MULW121:
001e4c 9508      	RET
                 
                 __MULD12:
001e4d d057      	RCALL __CHKSIGND
001e4e dfd9      	RCALL __MULD12U
001e4f f40e      	BRTC __MULD121
001e50 df96      	RCALL __ANEGD1
                 __MULD121:
001e51 9508      	RET
                 
                 __DIVW21U:
001e52 2400      	CLR  R0
001e53 2411      	CLR  R1
001e54 e190      	LDI  R25,16
                 __DIVW21U1:
001e55 0faa      	LSL  R26
001e56 1fbb      	ROL  R27
001e57 1c00      	ROL  R0
001e58 1c11      	ROL  R1
001e59 1a0e      	SUB  R0,R30
001e5a 0a1f      	SBC  R1,R31
001e5b f418      	BRCC __DIVW21U2
001e5c 0e0e      	ADD  R0,R30
001e5d 1e1f      	ADC  R1,R31
001e5e c001      	RJMP __DIVW21U3
                 __DIVW21U2:
001e5f 60a1      	SBR  R26,1
                 __DIVW21U3:
001e60 959a      	DEC  R25
001e61 f799      	BRNE __DIVW21U1
001e62 01fd      	MOVW R30,R26
001e63 01d0      	MOVW R26,R0
001e64 9508      	RET
                 
                 __DIVD21U:
001e65 933f      	PUSH R19
001e66 934f      	PUSH R20
001e67 935f      	PUSH R21
001e68 2400      	CLR  R0
001e69 2411      	CLR  R1
001e6a 2733      	CLR  R19
001e6b 2744      	CLR  R20
001e6c e250      	LDI  R21,32
                 __DIVD21U1:
001e6d 0faa      	LSL  R26
001e6e 1fbb      	ROL  R27
001e6f 1f88      	ROL  R24
001e70 1f99      	ROL  R25
001e71 1c00      	ROL  R0
001e72 1c11      	ROL  R1
001e73 1f33      	ROL  R19
001e74 1f44      	ROL  R20
001e75 1a0e      	SUB  R0,R30
001e76 0a1f      	SBC  R1,R31
001e77 0b36      	SBC  R19,R22
001e78 0b47      	SBC  R20,R23
001e79 f428      	BRCC __DIVD21U2
001e7a 0e0e      	ADD  R0,R30
001e7b 1e1f      	ADC  R1,R31
001e7c 1f36      	ADC  R19,R22
001e7d 1f47      	ADC  R20,R23
001e7e c001      	RJMP __DIVD21U3
                 __DIVD21U2:
001e7f 60a1      	SBR  R26,1
                 __DIVD21U3:
001e80 955a      	DEC  R21
001e81 f759      	BRNE __DIVD21U1
001e82 01fd      	MOVW R30,R26
001e83 01bc      	MOVW R22,R24
001e84 01d0      	MOVW R26,R0
001e85 2f83      	MOV  R24,R19
001e86 2f94      	MOV  R25,R20
001e87 915f      	POP  R21
001e88 914f      	POP  R20
001e89 913f      	POP  R19
001e8a 9508      	RET
                 
                 __DIVD21:
001e8b d019      	RCALL __CHKSIGND
001e8c dfd8      	RCALL __DIVD21U
001e8d f40e      	BRTC __DIVD211
001e8e df58      	RCALL __ANEGD1
                 __DIVD211:
001e8f 9508      	RET
                 
                 __MODW21U:
001e90 dfc1      	RCALL __DIVW21U
001e91 01fd      	MOVW R30,R26
001e92 9508      	RET
                 
                 __MODD21U:
001e93 dfd1      	RCALL __DIVD21U
001e94 01fd      	MOVW R30,R26
001e95 01bc      	MOVW R22,R24
001e96 9508      	RET
                 
                 __CHKSIGNW:
001e97 94e8      	CLT
001e98 fff7      	SBRS R31,7
001e99 c002      	RJMP __CHKSW1
001e9a df48      	RCALL __ANEGW1
001e9b 9468      	SET
                 __CHKSW1:
001e9c ffb7      	SBRS R27,7
001e9d c006      	RJMP __CHKSW2
001e9e 95a0      	COM  R26
001e9f 95b0      	COM  R27
001ea0 9611      	ADIW R26,1
001ea1 f800      	BLD  R0,0
001ea2 9403      	INC  R0
001ea3 fa00      	BST  R0,0
                 __CHKSW2:
001ea4 9508      	RET
                 
                 __CHKSIGND:
001ea5 94e8      	CLT
001ea6 ff77      	SBRS R23,7
001ea7 c002      	RJMP __CHKSD1
001ea8 df3e      	RCALL __ANEGD1
001ea9 9468      	SET
                 __CHKSD1:
001eaa ff97      	SBRS R25,7
001eab c00b      	RJMP __CHKSD2
001eac 2400      	CLR  R0
001ead 95a0      	COM  R26
001eae 95b0      	COM  R27
001eaf 9580      	COM  R24
001eb0 9590      	COM  R25
001eb1 9611      	ADIW R26,1
001eb2 1d80      	ADC  R24,R0
001eb3 1d90      	ADC  R25,R0
001eb4 f800      	BLD  R0,0
001eb5 9403      	INC  R0
001eb6 fa00      	BST  R0,0
                 __CHKSD2:
001eb7 9508      	RET
                 
                 __GETW1P:
001eb8 91ed      	LD   R30,X+
001eb9 91fc      	LD   R31,X
001eba 9711      	SBIW R26,1
001ebb 9508      	RET
                 
                 __GETD1P:
001ebc 91ed      	LD   R30,X+
001ebd 91fd      	LD   R31,X+
001ebe 916d      	LD   R22,X+
001ebf 917c      	LD   R23,X
001ec0 9713      	SBIW R26,3
001ec1 9508      	RET
                 
                 __PUTDP1:
001ec2 93ed      	ST   X+,R30
001ec3 93fd      	ST   X+,R31
001ec4 936d      	ST   X+,R22
001ec5 937c      	ST   X,R23
001ec6 9508      	RET
                 
                 __GETW1PF:
001ec7 9005      	LPM  R0,Z+
001ec8 91f4      	LPM  R31,Z
001ec9 2de0      	MOV  R30,R0
001eca 9508      	RET
                 
                 __PUTPARD1:
001ecb 937a      	ST   -Y,R23
001ecc 936a      	ST   -Y,R22
001ecd 93fa      	ST   -Y,R31
001ece 93ea      	ST   -Y,R30
001ecf 9508      	RET
                 
                 __PUTPARD2:
001ed0 939a      	ST   -Y,R25
001ed1 938a      	ST   -Y,R24
001ed2 93ba      	ST   -Y,R27
001ed3 93aa      	ST   -Y,R26
001ed4 9508      	RET
                 
                 __EEPROMRDD:
001ed5 9612      	ADIW R26,2
001ed6 d003      	RCALL __EEPROMRDW
001ed7 2f7f      	MOV  R23,R31
001ed8 2f6e      	MOV  R22,R30
001ed9 9712      	SBIW R26,2
                 
                 __EEPROMRDW:
001eda 9611      	ADIW R26,1
001edb d002      	RCALL __EEPROMRDB
001edc 2ffe      	MOV  R31,R30
001edd 9711      	SBIW R26,1
                 
                 __EEPROMRDB:
001ede 99e1      	SBIC EECR,EEWE
001edf cffe      	RJMP __EEPROMRDB
001ee0 93ff      	PUSH R31
001ee1 b7ff      	IN   R31,SREG
001ee2 94f8      	CLI
001ee3 bbae      	OUT  EEARL,R26
001ee4 bbbf      	OUT  EEARH,R27
001ee5 9ae0      	SBI  EECR,EERE
001ee6 b3ed      	IN   R30,EEDR
001ee7 bfff      	OUT  SREG,R31
001ee8 91ff      	POP  R31
001ee9 9508      	RET
                 
                 __EEPROMWRD:
001eea d00a      	RCALL __EEPROMWRW
001eeb 9612      	ADIW R26,2
001eec 2e0e      	MOV  R0,R30
001eed 2e1f      	MOV  R1,R31
001eee 2fe6      	MOV  R30,R22
001eef 2ff7      	MOV  R31,R23
001ef0 d004      	RCALL __EEPROMWRW
001ef1 2de0      	MOV  R30,R0
001ef2 2df1      	MOV  R31,R1
001ef3 9712      	SBIW R26,2
001ef4 9508      	RET
                 
                 __EEPROMWRW:
001ef5 d007      	RCALL __EEPROMWRB
001ef6 9611      	ADIW R26,1
001ef7 93ef      	PUSH R30
001ef8 2fef      	MOV  R30,R31
001ef9 d003      	RCALL __EEPROMWRB
001efa 91ef      	POP  R30
001efb 9711      	SBIW R26,1
001efc 9508      	RET
                 
                 __EEPROMWRB:
001efd 99e1      	SBIC EECR,EEWE
001efe cffe      	RJMP __EEPROMWRB
001eff b79f      	IN   R25,SREG
001f00 94f8      	CLI
001f01 bbae      	OUT  EEARL,R26
001f02 bbbf      	OUT  EEARH,R27
001f03 9ae0      	SBI  EECR,EERE
001f04 b38d      	IN   R24,EEDR
001f05 17e8      	CP   R30,R24
001f06 f019      	BREQ __EEPROMWRB0
001f07 bbed      	OUT  EEDR,R30
001f08 9ae2      	SBI  EECR,EEMWE
001f09 9ae1      	SBI  EECR,EEWE
                 __EEPROMWRB0:
001f0a bf9f      	OUT  SREG,R25
001f0b 9508      	RET
                 
                 __CPD10:
001f0c 9730      	SBIW R30,0
001f0d 4060      	SBCI R22,0
001f0e 4070      	SBCI R23,0
001f0f 9508      	RET
                 
                 __CPW02:
001f10 2400      	CLR  R0
001f11 160a      	CP   R0,R26
001f12 060b      	CPC  R0,R27
001f13 9508      	RET
                 
                 __CPD02:
001f14 2400      	CLR  R0
001f15 160a      	CP   R0,R26
001f16 060b      	CPC  R0,R27
001f17 0608      	CPC  R0,R24
001f18 0609      	CPC  R0,R25
001f19 9508      	RET
                 
                 __CPD12:
001f1a 17ea      	CP   R30,R26
001f1b 07fb      	CPC  R31,R27
001f1c 0768      	CPC  R22,R24
001f1d 0779      	CPC  R23,R25
001f1e 9508      	RET
                 
                 __CPD21:
001f1f 17ae      	CP   R26,R30
001f20 07bf      	CPC  R27,R31
001f21 0786      	CPC  R24,R22
001f22 0797      	CPC  R25,R23
001f23 9508      	RET
                 
                 __SAVELOCR6:
001f24 935a      	ST   -Y,R21
                 __SAVELOCR5:
001f25 934a      	ST   -Y,R20
                 __SAVELOCR4:
001f26 933a      	ST   -Y,R19
                 __SAVELOCR3:
001f27 932a      	ST   -Y,R18
                 __SAVELOCR2:
001f28 931a      	ST   -Y,R17
001f29 930a      	ST   -Y,R16
001f2a 9508      	RET
                 
                 __LOADLOCR6:
001f2b 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
001f2c 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
001f2d 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
001f2e 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
001f2f 8119      	LDD  R17,Y+1
001f30 8108      	LD   R16,Y
001f31 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega128 register use summary:
r0 :  92 r1 :  18 r2 :   0 r3 :   0 r4 :   1 r5 :   0 r6 :   0 r7 :   0 
r8 :   6 r9 :   5 r10:   3 r11:  11 r12:   3 r13:   7 r14:   3 r15:   0 
r16: 227 r17: 131 r18:  83 r19:  45 r20:  56 r21:  15 r22: 375 r23: 332 
r24: 172 r25: 125 r26: 700 r27: 395 r28:  66 r29:   1 r30:2069 r31: 823 
x  : 164 y  :1579 z  :  60 
Registers used: 29 out of 35 (82.9%)

ATmega128 instruction use summary:
adc   :  53 add   :  55 adiw  : 134 and   :   0 andi  :  42 asr   :   0 
bclr  :   0 bld   :   2 brbc  :   0 brbs  :   0 brcc  :   4 brcs  :   0 
break :   0 breq  :  93 brge  :   1 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :  27 brlt  :   1 brmi  :   0 brne  : 174 brpl  :   0 
brsh  :  52 brtc  :   3 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   2 call  : 459 cbi   :  11 cbr   :   0 clc   :   0 clh   :   0 
cli   :   3 cln   :   0 clr   : 209 cls   :   0 clt   :   2 clv   :   0 
clz   :   0 com   :  12 cp    :  37 cpc   :  71 cpi   : 209 cpse  :   0 
dec   :   6 elpm  :   0 eor   :   3 fmul  :   0 fmuls :   0 fmulsu:   0 
icall :   0 ijmp  :   0 in    :  21 inc   :   3 jmp   :  59 ld    : 132 
ldd   : 897 ldi   : 783 lds   : 392 lpm   :  12 lsl   :  22 lsr   :   5 
mov   : 120 movw  : 195 mul   :  13 muls  :   0 mulsu :   0 neg   :   0 
nop   :   0 or    :  33 ori   :   7 out   :  53 pop   :  65 push  :  65 
rcall :  91 ret   : 110 reti  :   4 rjmp  : 271 rol   :  29 ror   :   7 
sbc   :  12 sbci  : 144 sbi   :  41 sbic  :   2 sbis  :   4 sbiw  :  88 
sbr   :   2 sbrc  :   0 sbrs  :   4 sec   :   0 seh   :   0 sei   :   1 
sen   :   0 ser   :   0 ses   :   0 set   :   2 sev   :   0 sez   :   0 
sleep :   0 spm   :   0 st    : 414 std   : 348 sts   : 293 sub   :   6 
subi  : 158 swap  :   0 tst   :   8 wdr   :   1 
Instructions used: 66 out of 112 (58.9%)

ATmega128 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003e64  15570    402  15972  131072  12.2%
[.dseg] 0x000100 0x000c5d      0   1885   1885    4096  46.0%
[.eseg] 0x000000 0x000005      0      5      5    4096   0.1%

Assembly complete, 0 errors, 16 warnings
