#include "Coding.h"

unsigned char flagTWI				=	0;
unsigned char int_Devices		=	0;			// количество подчиненных устройств



// Инициализация выводов
void portInit (void)
		{
			DDRB.7 = 1;		// testpin
			CS_DDR_SET();	// для CF Card
		}



// -------------------- Функции работы с таймером 0 -------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////
// Timer/Counter 0 initialization ; Clock source: System Clock
// Clock value: 31,250 kHz ;  Mode: Normal top=FFh
///////////////////////////////////////////////////////////////////////////////////////////////
void timer_0_Init  (void)
	{
		ASSR=0x00;
		TCCR0=0x0;        //0x06 -start
		TCNT0=0x01;
		OCR0=0x00;

		TIMSK=0x01;			// Timer(s)/Counter(s) Interrupt(s) initialization
		ETIMSK=0x00;

	}

// запускаем таймер для таймаута
void timeOut (void)
	{
//		flagTWI  = (flagTWI  ^ (1 << time_is_Out));		// сброс признака
		TCNT0=0x0	;														// обнуляем счетчик
		TCCR0 = 0x06;													// пускаем таймер (около 10 мс)
	}

// остановка таймера для таймаута
void timeOutStop (void)
	{
		TCCR0 = 0x0; 						// осттанов таймера (около 10 мс)
	}


// Timer 0 overflow interrupt service routine
interrupt [TIM0_OVF] void timer0_ovf_isr(void)
{
		TCCR0 = 0x0;						//останавливаем таймер
		flagTWI  = flagTWI  | (1 << time_is_Out);	 //взводим признак    

}
                                                                                             
// Проверяем количество подчиненных устройств
void verIntDev (void)
	{
		unsigned char a;
		for (a=1; a<10;a++)				// сканируем количество подчиненных устройств 
			{											//  адреса начинаются с 1
				if (!(txTWIbyte ( a, 0xaa))) break;   
			}
        int_Devices = a-1;
		lAddrDevice[0] = lAddrDevice;	// запоминаем кол-во портов 232
	}     
	
// считаем КС принятого пакета
unsigned char rxCRC (void)
	{                    
		unsigned char KS = 0, a;		
			for (a=0; a< rxBuffer [0] ;a++)
				{
					KS =KS+rxBuffer [a];
				}                                     
			if (KS == rxBuffer [a]) return 255; 	//Ok
			else return 0;                                         // Error
		
	}	        

// вычитываем логические адреса устройств
void ReadLogAddr (void)
		{          
		unsigned char b;
		
					txBuffer[0] = 'q';								// заголовок
					txBuffer[1] = 3;		                 		// длина
					txBuffer[2] = 0;                   		// адрес
					txBuffer[3] = GetLogAddr;       		// тип
					txBuffer[4] = 'q'+3+0+GetLogAddr; 		//KC

					txTWIbuff (0);		//передаем всем
//					delay_ms (20);          
					delay_ms (5);          

for (b=1; b<= int_Devices; b++)
	{
//					txTWIbuff (b);		//передаем 
//					delay_ms (10);          
					rxTWIbuff (b);
					lAddrDevice [b] = rxBuffer[1];		// запоминаем лог. адреса портов       
putchar (b);
putchar (rxBuffer[0]);
putchar (rxBuffer[1]);
putchar (rxBuffer[2]);

     }
				
}  

// ретранслируем пакет
void		recompPack (unsigned char device)
	{
		unsigned char a, b=0;
					txBuffer[0] = PACKHDR;				// заголовок
					txBuffer[1] = rx0len+3;            		// длина (+3 - тк. вычлось при приеме)
					txBuffer[2] = rx0addr;                 	// адрес
					txBuffer[3] = rx0type;					// тип

					for (a=4; a<=(rx0len+4); a++)
						{
							txBuffer[a] = rx0buf 	[b++];				
						}                   

					txTWIbuff (device);								//передаем 
					delay_ms (10);


	}
	
// пингуем подчиненное для проверки информации
void pingPack (unsigned char device)
	{
	unsigned char a;
			
/*					txBuffer[0] = 'q';									// заголовок
					txBuffer[1] = 3;                 					// длина
					txBuffer[2] = 0;                   				// адрес
					txBuffer[3] = pingPacket;       				// тип
					txBuffer[4] = 'q'+3+0+pingPacket; 		// KC

					txTWIbuff (device);								// передаем 

//					delay_ms (20);          */
//					delay_ms (10);          

					rxTWIbuff (device);                  			// принимаем

					if (rxBuffer[0] )
						{
						UCSR0B.3 = 1;								// Разрешаю передатчик
                            	for (a=0;a<=rxBuffer[0];a++)
									{
										putchar0 (rxBuffer [a]);
									}     
						rx0state = RX_HDR;					// Разрешаю прием след. запроса
						
						}          
	
	
	}
	

	
	