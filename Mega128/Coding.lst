
AVRASM ver. 2.1.2  Coding.asm Thu Dec 02 14:54:22 2010

Coding.asm(939): Including file 'Coding.vec'
Coding.asm(940): Including file 'Coding.inc'
Coding.inc(17): warning: Register r4 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(22): warning: Register r6 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(23): warning: Register r7 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(24): warning: Register r8 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(25): warning: Register r9 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(28): warning: Register r11 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
Coding.inc(31): warning: Register r13 already defined by the .DEF directive
Coding.asm(940): 'Coding.inc' included form here
                 
                 
                 ;(C) Copyright 1998-2005 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Chip type              : ATmega128
                 ;Program type           : Application
                 ;Clock frequency        : 8,000000 MHz
                 ;Memory model           : Small
                 ;Optimize for           : Size
                 ;(s)printf features     : int
                 ;(s)scanf features      : int, width
                 ;External SRAM size     : 0
                 ;Data Stack size        : 640 byte(s)
                 ;Heap size              : 1200 byte(s)
                 ;Promote char to int    : No
                 ;char is unsigned       : Yes
                 ;8 bit enums            : Yes
                 ;Word align FLASH struct: No
                 ;Enhanced core instructions    : On
                 ;Automatic register allocation : On
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega128
                 	#pragma AVRPART MEMORY PROG_FLASH 131072
                 	#pragma AVRPART MEMORY EEPROM 4096
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU USR=0xB
                 	.EQU UDR=0xC
                 	.EQU SPSR=0xE
                 	.EQU SPDR=0xF
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU EECR=0x1C
                 	.EQU EEDR=0x1D
                 	.EQU EEARL=0x1E
                 	.EQU EEARH=0x1F
                 	.EQU WDTCR=0x21
                 	.EQU MCUCR=0x35
                 	.EQU RAMPZ=0x3B
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 	.EQU XMCRA=0x6D
                 	.EQU XMCRB=0x6C
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __se_bit=0x20
                 	.EQU __sm_mask=0x1C
                 	.EQU __sm_adc_noise_red=0x08
                 	.EQU __sm_powerdown=0x10
                 	.EQU __sm_powersave=0x18
                 	.EQU __sm_standby=0x14
                 	.EQU __sm_ext_standby=0x1C
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	LDI  R30,0
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+@1)
                 	LDI  R31,HIGH(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+@1)
                 	LDI  R31,HIGH(2*@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+@1)
                 	LDI  R31,HIGH(2*@0+@1)
                 	LDI  R22,BYTE3(2*@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+@1)
                 	LDI  R27,HIGH(@0+@1)
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+@2)
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+@3)
                 	LDI  R@1,HIGH(@2+@3)
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+@3)
                 	LDI  R@1,HIGH(@2*2+@3)
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+@1
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+@1
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+@1
                 	LDS  R31,@0+@1+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+@1
                 	LDS  R31,@0+@1+1
                 	LDS  R22,@0+@1+2
                 	LDS  R23,@0+@1+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+@2
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+@3
                 	LDS  R@1,@2+@3+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+@1
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+@1
                 	LDS  R27,@0+@1+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+@1
                 	LDS  R27,@0+@1+1
                 	LDS  R24,@0+@1+2
                 	LDS  R25,@0+@1+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+@1,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+@1,R30
                 	STS  @0+@1+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+@1,R30
                 	STS  @0+@1+1,R31
                 	STS  @0+@1+2,R22
                 	STS  @0+@1+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+@1,R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+@1,R@2
                 	STS  @0+@1+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+@1
                 	LDS  R31,@0+@1+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+@1)
                 	LDI  R31,HIGH(2*@0+@1)
                 	CALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	LDI  R26,LOW(@0+@1)
                 	LDI  R27,HIGH(@0+@1)
                 	CALL __EEPROMRDW
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R26,SPL
                 	IN   R27,SPH
                 	ADIW R26,@0+1
                 	LD   R30,X+
                 	LD   R31,X
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	CALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	CALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	CLR  R0
                 	ST   Z+,R0
                 	ST   Z,R0
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	CLR  R0
                 	ST   Z+,R0
                 	ST   Z+,R0
                 	ST   Z+,R0
                 	ST   Z,R0
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.CSEG
                 	.ORG 0
                 
                 	.INCLUDE "Coding.vec"
                 
                 ;INTERRUPT VECTORS
000000 940c 0144 	JMP  __RESET
000002 940c 0000 	JMP  0x00
000004 940c 0000 	JMP  0x00
000006 940c 0000 	JMP  0x00
000008 940c 0000 	JMP  0x00
00000a 940c 0000 	JMP  0x00
00000c 940c 0000 	JMP  0x00
00000e 940c 0000 	JMP  0x00
000010 940c 0000 	JMP  0x00
000012 940c 0000 	JMP  0x00
000014 940c 0456 	JMP  _timer2_ovf_isr
000016 940c 0000 	JMP  0x00
000018 940c 03c4 	JMP  _timer1_comp_a_isr
00001a 940c 0000 	JMP  0x00
00001c 940c 0000 	JMP  0x00
00001e 940c 0000 	JMP  0x00
000020 940c 044a 	JMP  _timer0_ovf_isr
000022 940c 0000 	JMP  0x00
000024 940c 0354 	JMP  _uart_rx_isr
000026 940c 0000 	JMP  0x00
000028 940c 0000 	JMP  0x00
00002a 940c 0000 	JMP  0x00
00002c 940c 0000 	JMP  0x00
00002e 940c 0000 	JMP  0x00
000030 940c 0000 	JMP  0x00
000032 940c 0000 	JMP  0x00
000034 940c 0000 	JMP  0x00
000036 940c 0000 	JMP  0x00
000038 940c 0000 	JMP  0x00
00003a 940c 045b 	JMP  _timer3_ovf_isr
00003c 940c 0000 	JMP  0x00
00003e 940c 0000 	JMP  0x00
000040 940c 0000 	JMP  0x00
000042 940c 2007 	JMP  _TWI_ISR
000044 940c 0000 	JMP  0x00
                 
                 	.INCLUDE "Coding.inc"
                 
                 _update_program_ser_num:
000046 0009
000047 0000      	.DB  0x9,0x0,0x0,0x0
                 _device_name:
000048 6353
000049 6172
00004a 626d
00004b 696c      	.DB  0x53,0x63,0x72,0x61,0x6D,0x62,0x6C,0x69
00004c 676e
00004d 4420
00004e 7665
00004f 6369      	.DB  0x6E,0x67,0x20,0x44,0x65,0x76,0x69,0x63
000050 0065      	.DB  0x65,0x0
000051 0000      	.DW  0x0
000052 0000      	.DW  0x0
000053 0000      	.DW  0x0
000054 0000      	.DW  0x0
000055 0000      	.DW  0x0
000056 0000      	.DW  0x0
000057 0000      	.DW  0x0
                 _my_version:
000058 0209      	.DB  0x9,0x2
                 	.DEF _eefprog=R4
                 _3:
000059 0000      	.DW  0x00
                 _int_Devices:
Coding.inc(21): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005a 0008      	.DB  0x8
                 	.DEF _counter_ciklov=R6
                 	.DEF _Combine_Responce_GEN_CALL=R7
                 	.DEF _reflection_active_PORTS=R8
                 	.DEF _str=R9
                 _4:
00005b 0628      	.DW  _rx0buf
                 	.DEF _str1=R11
                 _5:
00005c 0628      	.DW  _rx0buf
                 	.DEF _fprog=R13
                 _78:
Coding.inc(33): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
00005d 0001      	.DB  0x1
                 _121:
00005e 0000      	.DW  0x00
                 _0x8C:
00005f 0000      	.DB  0x0,0x0
000060 0000      	.DB  0x0,0x0
                 _0xA6:
000061 0001      	.DB  0x1,0x0
000062 0000      	.DB  0x0,0x0
000063 0000      	.DB  0x0,0x0
000064 0000      	.DB  0x0,0x0
                 _sd_cmd:
000065 0000      	.DB  0x0,0x0
000066 0040      	.DB  0x40,0x0
000067 0000      	.DB  0x0,0x0
000068 0000      	.DB  0x0,0x0
000069 0001      	.DB  0x1,0x0
00006a 0041      	.DB  0x41,0x0
00006b 0000      	.DB  0x0,0x0
00006c 0000      	.DB  0x0,0x0
00006d 0002      	.DB  0x2,0x0
00006e 0049      	.DB  0x49,0x0
00006f 0000      	.DB  0x0,0x0
000070 0000      	.DB  0x0,0x0
000071 0003      	.DB  0x3,0x0
000072 004a      	.DB  0x4A,0x0
000073 0000      	.DB  0x0,0x0
000074 0000      	.DB  0x0,0x0
000075 0004      	.DB  0x4,0x0
000076 004c      	.DB  0x4C,0x0
000077 0000      	.DB  0x0,0x0
000078 0000      	.DB  0x0,0x0
000079 0005      	.DB  0x5,0x0
00007a 004d      	.DB  0x4D,0x0
00007b 0000      	.DB  0x0,0x0
00007c 0002      	.DB  0x2,0x0
00007d 0006      	.DB  0x6,0x0
00007e 0050      	.DB  0x50,0x0
00007f 0001      	.DB  0x1,0x0
000080 0000      	.DB  0x0,0x0
000081 0007      	.DB  0x7,0x0
000082 0051      	.DB  0x51,0x0
000083 0002      	.DB  0x2,0x0
000084 0000      	.DB  0x0,0x0
000085 0008      	.DB  0x8,0x0
000086 0052      	.DB  0x52,0x0
000087 0002      	.DB  0x2,0x0
000088 0000      	.DB  0x0,0x0
000089 0009      	.DB  0x9,0x0
00008a 0058      	.DB  0x58,0x0
00008b 0002      	.DB  0x2,0x0
00008c 0000      	.DB  0x0,0x0
00008d 000a      	.DB  0xA,0x0
00008e 0059      	.DB  0x59,0x0
00008f 0002      	.DB  0x2,0x0
000090 0000      	.DB  0x0,0x0
000091 000b      	.DB  0xB,0x0
000092 005b      	.DB  0x5B,0x0
000093 0000      	.DB  0x0,0x0
000094 0000      	.DB  0x0,0x0
000095 000c      	.DB  0xC,0x0
000096 005c      	.DB  0x5C,0x0
000097 0002      	.DB  0x2,0x0
000098 0001      	.DB  0x1,0x0
000099 000d      	.DB  0xD,0x0
00009a 005d      	.DB  0x5D,0x0
00009b 0002      	.DB  0x2,0x0
00009c 0001      	.DB  0x1,0x0
00009d 000e      	.DB  0xE,0x0
00009e 005e      	.DB  0x5E,0x0
00009f 0002      	.DB  0x2,0x0
0000a0 0000      	.DB  0x0,0x0
0000a1 000f      	.DB  0xF,0x0
0000a2 0060      	.DB  0x60,0x0
0000a3 0002      	.DB  0x2,0x0
0000a4 0000      	.DB  0x0,0x0
0000a5 0010      	.DB  0x10,0x0
0000a6 0061      	.DB  0x61,0x0
0000a7 0002      	.DB  0x2,0x0
0000a8 0000      	.DB  0x0,0x0
0000a9 0011      	.DB  0x11,0x0
0000aa 0062      	.DB  0x62,0x0
0000ab 0002      	.DB  0x2,0x0
0000ac 0000      	.DB  0x0,0x0
0000ad 0012      	.DB  0x12,0x0
0000ae 0063      	.DB  0x63,0x0
0000af 0002      	.DB  0x2,0x0
0000b0 0000      	.DB  0x0,0x0
0000b1 0013      	.DB  0x13,0x0
0000b2 0064      	.DB  0x64,0x0
0000b3 0002      	.DB  0x2,0x0
0000b4 0000      	.DB  0x0,0x0
0000b5 0014      	.DB  0x14,0x0
0000b6 0065      	.DB  0x65,0x0
0000b7 0002      	.DB  0x2,0x0
0000b8 0000      	.DB  0x0,0x0
0000b9 0015      	.DB  0x15,0x0
0000ba 0066      	.DB  0x66,0x0
0000bb 0003      	.DB  0x3,0x0
0000bc 0001      	.DB  0x1,0x0
0000bd 0016      	.DB  0x16,0x0
0000be 006a      	.DB  0x6A,0x0
0000bf 0003      	.DB  0x3,0x0
0000c0 0001      	.DB  0x1,0x0
0000c1 0017      	.DB  0x17,0x0
0000c2 007a      	.DB  0x7A,0x0
0000c3 0000      	.DB  0x0,0x0
0000c4 0003      	.DB  0x3,0x0
0000c5 0018      	.DB  0x18,0x0
0000c6 007b      	.DB  0x7B,0x0
0000c7 0003      	.DB  0x3,0x0
0000c8 0000      	.DB  0x0,0x0
0000c9 0019      	.DB  0x19,0x0
0000ca 0069      	.DB  0x69,0x0
0000cb 0000      	.DB  0x0,0x0
0000cc 0000      	.DB  0x0,0x0
                 _907:
0000cd 4502
0000ce 8901
0000cf 4206
0000d0 f605      	.DB  0x2,0x45,0x1,0x89,0x6,0x42,0x5,0xF6
                 _908:
0000d1 00cd      	.DB  0xCD,0x0
                 _909:
0000d2 00ae      	.DB  0xAE,0x0
                 _910:
0000d3 00ba      	.DB  0xBA,0x0
                 _911:
0000d4 0035      	.DB  0x35,0x0
                 _912:
0000d5 0043      	.DB  0x43,0x0
                 _913:
0000d6 0166      	.DB  0x66,0x1
                 _914:
0000d7 00b2      	.DB  0xB2,0x0
                 _915:
0000d8 00a6      	.DB  0xA6,0x0
                 _916:
0000d9 0007      	.DB  0x7,0x0
                 _917:
0000da 007d      	.DB  0x7D,0x0
                 _918:
Coding.inc(172): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
0000db 0006      	.DB  0x6
                 _919:
Coding.inc(174): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
0000dc 007a      	.DB  0x7A
                 _920:
Coding.inc(176): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
0000dd 0001      	.DB  0x1
                 _0x399:
0000de 0000      	.DB  0x0,0x0
0000df 0000      	.DB  0x0,0x0
                 _0x3EF:
0000e0 0000      	.DB  0x0,0x0
0000e1 0000      	.DB  0x0,0x0
                 _1021:
Coding.inc(184): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
0000e2 00f8      	.DB  0xF8
                 _tbl10_GC:
0000e3 2710
0000e4 03e8
0000e5 0064
0000e6 000a      	.DB  0x10,0x27,0xE8,0x3,0x64,0x0,0xA,0x0
0000e7 0001      	.DB  0x1,0x0
                 _tbl16_GC:
0000e8 1000
0000e9 0100
0000ea 0010
0000eb 0001      	.DB  0x0,0x10,0x0,0x1,0x10,0x0,0x1,0x0
                 _0:
0000ec 6f50
0000ed 7472
0000ee 2020
0000ef 5352      	.DB  0x50,0x6F,0x72,0x74,0x20,0x20,0x52,0x53
0000f0 322d
0000f1 3233
0000f2 b920
0000f3 7500      	.DB  0x2D,0x32,0x33,0x32,0x20,0xB9,0x0,0x75
0000f4 6573
0000f5 2e72
0000f6 6962
0000f7 006e      	.DB  0x73,0x65,0x72,0x2E,0x62,0x69,0x6E,0x0
0000f8 0d0a
0000f9 2500
0000fa 2058
0000fb 2500      	.DB  0xA,0xD,0x0,0x25,0x58,0x20,0x0,0x25
0000fc 3230
0000fd 2058
Coding.inc(195): warning: .cseg .db misalignment - padding zero byte
Coding.asm(940): 'Coding.inc' included form here
0000fe 0000      	.DB  0x30,0x32,0x58,0x20,0x0
                 
                 ;HEAP START MARKER INITIALIZATION
                 __HEAP_START_MARKER:
0000ff 0000
000100 0000      	.DW  0,0
                 
                 __GLOBAL_INI_TBL:
000101 0004      	.DW  0x04
000102 0c50      	.DW  0xC50
000103 01fe      	.DW  __HEAP_START_MARKER*2
                 
000104 0002      	.DW  0x02
000105 0004      	.DW  0x04
000106 00b2      	.DW  _3*2
                 
000107 0002      	.DW  0x02
000108 0009      	.DW  0x09
000109 00b6      	.DW  _4*2
                 
00010a 0002      	.DW  0x02
00010b 000b      	.DW  0x0B
00010c 00b8      	.DW  _5*2
                 
00010d 000f      	.DW  0x0F
00010e 060f      	.DW  _0cp
00010f 01d8      	.DW  _0*2
                 
000110 0001      	.DW  0x01
000111 0623      	.DW  _rx0state
000112 00ba      	.DW  _78*2
                 
000113 0002      	.DW  0x02
000114 0729      	.DW  _fu_user
000115 00bc      	.DW  _121*2
                 
000116 0008      	.DW  0x08
000117 09fc      	.DW  _kluchi_koderu
000118 019a      	.DW  _907*2
                 
000119 0002      	.DW  0x02
00011a 0a14      	.DW  _gshch1
00011b 01a2      	.DW  _908*2
                 
00011c 0002      	.DW  0x02
00011d 0a16      	.DW  _gshch2
00011e 01a4      	.DW  _909*2
                 
00011f 0002      	.DW  0x02
000120 0a18      	.DW  _gshch3
000121 01a6      	.DW  _910*2
                 
000122 0002      	.DW  0x02
000123 0a1a      	.DW  _gshch4
000124 01a8      	.DW  _911*2
                 
000125 0002      	.DW  0x02
000126 0a1c      	.DW  _gshch5
000127 01aa      	.DW  _912*2
                 
000128 0002      	.DW  0x02
000129 0a20      	.DW  _gshch7
00012a 01ac      	.DW  _913*2
                 
00012b 0002      	.DW  0x02
00012c 0a22      	.DW  _confkluch1
00012d 01ae      	.DW  _914*2
                 
00012e 0002      	.DW  0x02
00012f 0a24      	.DW  _confkluch2
000130 01b0      	.DW  _915*2
                 
000131 0002      	.DW  0x02
000132 0a26      	.DW  _krutnut
000133 01b2      	.DW  _916*2
                 
000134 0002      	.DW  0x02
000135 0a28      	.DW  _ver_kl
000136 01b4      	.DW  _917*2
                 
000137 0001      	.DW  0x01
000138 0a2f      	.DW  _scrambCond
000139 01b6      	.DW  _918*2
                 
00013a 0001      	.DW  0x01
00013b 0a30      	.DW  _N_sektora
00013c 01b8      	.DW  _919*2
                 
00013d 0001      	.DW  0x01
00013e 0a32      	.DW  _flag_est_obnovlenie_flash
00013f 01ba      	.DW  _920*2
                 
000140 0001      	.DW  0x01
000141 0b3c      	.DW  _TWI_state_GA
000142 01c4      	.DW  _1021*2
                 
000143 0000      	.DW  0
                 _0x4F5:
                 
                 __RESET:
000144 94f8      	CLI
000145 27ee      	CLR  R30
000146 bbec      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF FLASH
000147 e0f1      	LDI  R31,1
000148 bff5      	OUT  MCUCR,R31
000149 bfe5      	OUT  MCUCR,R30
00014a 93e0 006c 	STS  XMCRB,R30
00014c bfeb      	OUT  RAMPZ,R30
                 
                 ;DISABLE WATCHDOG
00014d e1f8      	LDI  R31,0x18
00014e bdf1      	OUT  WDTCR,R31
00014f bde1      	OUT  WDTCR,R30
                 
                 ;CLEAR R2-R14
000150 e08d      	LDI  R24,13
000151 e0a2      	LDI  R26,2
000152 27bb      	CLR  R27
                 __CLEAR_REG:
000153 93ed      	ST   X+,R30
000154 958a      	DEC  R24
000155 f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
000156 e580      	LDI  R24,LOW(0xB50)
000157 e09b      	LDI  R25,HIGH(0xB50)
000158 e0a0      	LDI  R26,LOW(0x100)
000159 e0b1      	LDI  R27,HIGH(0x100)
                 __CLEAR_SRAM:
00015a 93ed      	ST   X+,R30
00015b 9701      	SBIW R24,1
00015c f7e9      	BRNE __CLEAR_SRAM
                 
                 ;GLOBAL VARIABLES INITIALIZATION
00015d e0e2      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
00015e e0f2      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
                 __GLOBAL_INI_NEXT:
00015f 9185      	LPM  R24,Z+
000160 9195      	LPM  R25,Z+
000161 9700      	SBIW R24,0
000162 f061      	BREQ __GLOBAL_INI_END
000163 91a5      	LPM  R26,Z+
000164 91b5      	LPM  R27,Z+
000165 9005      	LPM  R0,Z+
000166 9015      	LPM  R1,Z+
000167 01bf      	MOVW R22,R30
000168 01f0      	MOVW R30,R0
                 __GLOBAL_INI_LOOP:
000169 9005      	LPM  R0,Z+
00016a 920d      	ST   X+,R0
00016b 9701      	SBIW R24,1
00016c f7e1      	BRNE __GLOBAL_INI_LOOP
00016d 01fb      	MOVW R30,R22
00016e cff0      	RJMP __GLOBAL_INI_NEXT
                 __GLOBAL_INI_END:
                 
                 ;STACK POINTER INITIALIZATION
00016f e4ef      	LDI  R30,LOW(0xC4F)
000170 bfed      	OUT  SPL,R30
000171 e0ec      	LDI  R30,HIGH(0xC4F)
000172 bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
000173 e8c0      	LDI  R28,LOW(0x380)
000174 e0d3      	LDI  R29,HIGH(0x380)
                 
000175 940c 0242 	JMP  _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x380
                 ;       1 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                 ;       2 // Управляющая программа 
                 ;       3 //  Подчиненные устройства сами сообщают о своем состоянии.
                 ;       4 
                 ;       5 #include "Coding.h"
                 ;       6 
                 ;       7 #ifdef print
                 ;       8 const flash unsigned long update_program_ser_num = 0;			// номер устройства, в кот. работает закрытие
                 ;       9 #else 
                 ;      10 const flash unsigned long update_program_ser_num = 9;			// номер устройства, в кот. работает закрытие
                 
                 	.CSEG
                 ;      11 #endif
                 ;      12 
                 ;      13 flash u8 device_name[32] =	"Scrambling Device";       	// Имя устройства                                                  
                 ;      14 const flash unsigned short my_version = 0x0209;			// Версия софта 
                 ;      15 eeprom unsigned char my_addr = TO_MON;					// Мой адрес - изначально TO_MON
                 
                 	.ESEG
                 _my_addr:
000000 fe        	.DB  0xFE
                 ;      16 eeprom unsigned long my_ser_num = 0;				// Серийный номер устройства
                 _my_ser_num:
000001 00 00     	.DW  0x0
000003 00 00     	.DW  0x0
                 ;      17 
                 ;      18 
                 ;      19 eeprom u8 f_buff_prog[len_prog_bin] = {0x01,0xff,0x7f};		// храним копию файла prog (+1 т.к. храню еще 1-й байт)
                 _f_buff_prog:
000005 01        	.DB  0x1
000006 ff        	.DB  0xFF
000007 7f        	.DB  0x7F
000008 00        	.DB  0x0
000009 00        	.DB  0x0
00000a 00        	.DB  0x0
00000b 00        	.DB  0x0
00000c 00        	.DB  0x0
00000d 00        	.DB  0x0
00000e 00        	.DB  0x0
00000f 00        	.DB  0x0
000010 00        	.DB  0x0
000011 00        	.DB  0x0
000012 00        	.DB  0x0
000013 00        	.DB  0x0
000014 00        	.DB  0x0
000015 00        	.DB  0x0
000016 00        	.DB  0x0
000017 00        	.DB  0x0
000018 00        	.DB  0x0
000019 00        	.DB  0x0
00001a 00        	.DB  0x0
00001b 00        	.DB  0x0
00001c 00        	.DB  0x0
00001d 00        	.DB  0x0
00001e 00        	.DB  0x0
00001f 00        	.DB  0x0
000020 00        	.DB  0x0
000021 00        	.DB  0x0
000022 00        	.DB  0x0
000023 00        	.DB  0x0
000024 00        	.DB  0x0
000025 00        	.DB  0x0
000026 00        	.DB  0x0
000027 00        	.DB  0x0
000028 00        	.DB  0x0
000029 00        	.DB  0x0
00002a 00        	.DB  0x0
00002b 00        	.DB  0x0
00002c 00        	.DB  0x0
00002d 00        	.DB  0x0
00002e 00        	.DB  0x0
00002f 00        	.DB  0x0
000030 00        	.DB  0x0
000031 00        	.DB  0x0
000032 00        	.DB  0x0
000033 00        	.DB  0x0
000034 00        	.DB  0x0
000035 00        	.DB  0x0
000036 00        	.DB  0x0
000037 00        	.DB  0x0
000038 00        	.DB  0x0
000039 00        	.DB  0x0
00003a 00        	.DB  0x0
00003b 00        	.DB  0x0
00003c 00        	.DB  0x0
00003d 00        	.DB  0x0
00003e 00        	.DB  0x0
00003f 00        	.DB  0x0
000040 00        	.DB  0x0
000041 00        	.DB  0x0
000042 00        	.DB  0x0
000043 00        	.DB  0x0
000044 00        	.DB  0x0
000045 00        	.DB  0x0
000046 00        	.DB  0x0
000047 00        	.DB  0x0
000048 00        	.DB  0x0
000049 00        	.DB  0x0
00004a 00        	.DB  0x0
00004b 00        	.DB  0x0
00004c 00        	.DB  0x0
00004d 00        	.DB  0x0
00004e 00        	.DB  0x0
00004f 00        	.DB  0x0
000050 00        	.DB  0x0
000051 00        	.DB  0x0
000052 00        	.DB  0x0
000053 00        	.DB  0x0
000054 00        	.DB  0x0
000055 00        	.DB  0x0
000056 00        	.DB  0x0
000057 00        	.DB  0x0
000058 00        	.DB  0x0
000059 00        	.DB  0x0
00005a 00        	.DB  0x0
00005b 00        	.DB  0x0
00005c 00        	.DB  0x0
00005d 00        	.DB  0x0
00005e 00        	.DB  0x0
00005f 00        	.DB  0x0
000060 00        	.DB  0x0
000061 00        	.DB  0x0
000062 00        	.DB  0x0
000063 00        	.DB  0x0
000064 00        	.DB  0x0
000065 00        	.DB  0x0
000066 00        	.DB  0x0
000067 00        	.DB  0x0
000068 00        	.DB  0x0
000069 00        	.DB  0x0
00006a 00        	.DB  0x0
00006b 00        	.DB  0x0
00006c 00        	.DB  0x0
00006d 00        	.DB  0x0
00006e 00        	.DB  0x0
00006f 00        	.DB  0x0
000070 00        	.DB  0x0
000071 00        	.DB  0x0
000072 00        	.DB  0x0
000073 00        	.DB  0x0
000074 00        	.DB  0x0
000075 00        	.DB  0x0
000076 00        	.DB  0x0
000077 00        	.DB  0x0
000078 00        	.DB  0x0
000079 00        	.DB  0x0
00007a 00        	.DB  0x0
00007b 00        	.DB  0x0
00007c 00        	.DB  0x0
00007d 00        	.DB  0x0
00007e 00        	.DB  0x0
00007f 00        	.DB  0x0
000080 00        	.DB  0x0
                 ;      20 u8	eeprom *eefprog = 0;
                 ;      21 
                 ;      22 u8 txBuffer 			[TWI_BUFFER_SIZE];			//буфер передатчика TWI
                 
                 	.DSEG
                 _txBuffer:
000380           	.BYTE 0xFF
                 ;      23 u8 buff_wyh_paket	[TWI_BUFFER_SIZE];			//буфер для генерации выходного пакета
                 _buff_wyh_paket:
00047f           	.BYTE 0xFF
                 ;      24 u8 rxBuffer 			[TWI_BUFFER_SIZE / 2];		//буфер приемника TWI
                 _rxBuffer:
00057e           	.BYTE 0x7F
                 ;      25 
                 ;      26 
                 ;      27 flash u8 int_Devices		=	8;	//8			// количество подчиненных устройств
                 
                 	.CSEG
                 ;      28 u8 lAddrDevice	[16];				// храним лог. адреса подключенных устройств
                 
                 	.DSEG
                 _lAddrDevice:
0005fd           	.BYTE 0x10
                 ;      29 											// 0 ячейка - кол-во портов 232 .1 ячейка содержит лог. адрес порта 1, 2-лог.
                 ;      30 											// адрес порта 2 и т. д.  
                 ;      31 
                 ;      32 u8 counter_ciklov = 0;
                 ;      33 u8 Combine_Responce_GEN_CALL = 0;	// собираем ответы при GEN CALL
                 ;      34 u8 reflection_active_PORTS	=	0;			// зеркало портов (1-активен, 0 - не активен)
                 ;      35 
                 ;      36 bit EndTimePack = 0;				// таймаут передачи пакетов закрытия
                 ;      37 bit intScremblerON	=	0;			// работает внутренний скремблер
                 ;      38 bit CF_card_INI_OK	=	0;			// признак удачно проинициализированной CF карты
                 ;      39 bit prog_bin_mode		=	0;			// режим открытого prog.bin файла 0-rd_file; 1-wr_file
                 ;      40 
                 ;      41 
                 ;      42 strInPack * str = (strInPack *)(rx0buf);
                 ;      43 strDataPack * str1 = (strDataPack *)(rx0buf);
                 ;      44 
                 ;      45 // Указатели для CRYPT
                 ;      46 //FILE * fu;				//обьявляется переменная для указателя входного файла s userami
                 ;      47 FILE * fprog;			//обьявляется переменная для указателя входного файла s programmami
                 ;      48 FILE * fprogflas;
                 _fprogflas:
00060d           	.BYTE 0x2
                 ;      49 
                 ;      50 
                 ;      51 #ifdef print_from_pin
                 ;      52 #define _ALTERNATE_PUTCHAR_
                 ;      53 void putchar(char c)
                 ;      54 {
                 ;      55 	putchar2 (c);
                 ;      56 }               
                 ;      57 #endif
                 ;      58 
                 ;      59 
                 ;      60 
                 ;      61 
                 ;      62 
                 ;      63 
                 ;      64 typedef struct _chip_port
                 ;      65 {
                 ;      66 	flash char name[16];
                 ;      67 	flash unsigned char addr;
                 ;      68 } CHIPPORT;
                 ;      69 
                 ;      70 CHIPPORT cp[] = {"Port  RS-232 №", 0};
                 _cp:
                 _0cp:
00060f           	.BYTE 0x10
                 _1cp:
00061f           	.BYTE 0x1
                 ;      71 
                 ;      72 // Все для работы с TWI
                 ;      73 TWISR TWI_statusReg;   
                 _TWI_statusReg:
000620           	.BYTE 0x1
                 ;      74 unsigned char  TWI_operation=0;
                 _TWI_operation:
000621           	.BYTE 0x1
                 ;      75 
                 ;      76 //unsigned char TWI_targetSlaveAddress;
                 ;      77 
                 ;      78 //-----------------------------------------------------------------------------------------------------------------
                 ;      79 // Возвращаю состояние устройства
                 ;      80 static void GetState(void)
                 ;      81 {
                 
                 	.CSEG
                 _GetState_G1:
                 ;      82 	register unsigned char i, n, b;
                 ;      83 	
                 ;      84 	#define strq  ((RQ_GETSTATE *)rx0buf)
                 ;      85 
                 ;      86 	switch(strq->page)
000177 940e 2abf 	CALL __SAVELOCR3
                 ;	i -> R16
                 ;	n -> R17
                 ;	b -> R18
000179 91e0 0628 	LDS  R30,_rx0buf
                 ;      87 	{
                 ;      88 	case 0:
00017b 30e0      	CPI  R30,0
00017c f549      	BRNE _0x9
                 ;      89 		StartReply(2 + 16 + 1);
00017d e1e3      	LDI  R30,LOW(19)
00017e 93ea      	ST   -Y,R30
00017f d1ba      	RCALL _StartReply
                 ;      90 
                 ;      91 		putchar0(2);               						 // число доступных страниц, включая эту
000180 e0e2      	LDI  R30,LOW(2)
000181 940e 230f 	CALL SUBOPT_0x0
                 ;      92 		putchar0(0);										// зарезервирован
                 ;      93 		
                 ;      94 
                 ;      95 			for (i = 0; i < 15; i ++)
000183 e000      	LDI  R16,LOW(0)
                 _0xB:
000184 300f      	CPI  R16,15
000185 f458      	BRSH _0xC
                 ;      96 			{
                 ;      97 				b = cp[0].name[i];
000186 2fe0      	MOV  R30,R16
000187 e0f0      	LDI  R31,0
000188 5fe1      	SUBI R30,LOW(-_cp)
000189 4ff9      	SBCI R31,HIGH(-_cp)
00018a 8120      	LD   R18,Z
                 ;      98 				if (!b)	break;
00018b 3020      	CPI  R18,0
00018c f021      	BREQ _0xC
                 ;      99 				putchar0(b);
00018d 932a      	ST   -Y,R18
00018e d1a1      	RCALL _putchar0
                 ;     100 			}
00018f 5f0f      	SUBI R16,-1
000190 cff3      	RJMP _0xB
                 _0xC:
                 ;     101 				
                 ;     102 
                 ;     103 			while(i < 15)
                 _0xE:
000191 300f      	CPI  R16,15
000192 f428      	BRSH _0x10
                 ;     104 			{
                 ;     105 				putchar0(' ');
000193 e2e0      	LDI  R30,LOW(32)
000194 93ea      	ST   -Y,R30
000195 d19a      	RCALL _putchar0
                 ;     106 				i++;
000196 5f0f      	SUBI R16,-1
                 ;     107 			}
000197 cff9      	RJMP _0xE
                 _0x10:
                 ;     108 			
                 ;     109 			putchar0(cp[n].addr);
000198 2fa1      	MOV  R26,R17
000199 27bb      	CLR  R27
00019a e1e1      	LDI  R30,LOW(17)
00019b e0f0      	LDI  R31,HIGH(17)
00019c 940e 29c5 	CALL __MULW12U
00019e e1af
00019f e0b6      	__POINTW2MN _cp,16
0001a0 940e 2316 	CALL SUBOPT_0x1
0001a2 d18d      	RCALL _putchar0
                 ;     110 		
                 ;     111 		putchar0(255);
0001a3 940e 231b 	CALL SUBOPT_0x2
                 ;     112 
                 ;     113 		EndReply();
                 ;     114 		return;
0001a5 c021      	RJMP _0x4E3
                 ;     115 
                 ;     116 	case 1:
                 _0x9:
0001a6 30e1      	CPI  R30,LOW(0x1)
0001a7 f4f9      	BRNE _0x8
                 ;     117 	
                 ;     118 		StartReply(3 * int_Devices + 1);
0001a8 ebe4      	LDI  R30,LOW(_int_Devices*2)
0001a9 e0f0      	LDI  R31,HIGH(_int_Devices*2)
0001aa 91e4      	LPM  R30,Z
0001ab e0a3      	LDI  R26,LOW(3)
0001ac 9fea      	MUL  R30,R26
0001ad 2de0      	MOV  R30,R0
0001ae 5fef      	SUBI R30,-LOW(1)
0001af 93ea      	ST   -Y,R30
0001b0 d189      	RCALL _StartReply
                 ;     119 		
                 ;     120 		for (n = 0; n < int_Devices; n++)
0001b1 e010      	LDI  R17,LOW(0)
                 _0x13:
0001b2 ebe4      	LDI  R30,LOW(_int_Devices*2)
0001b3 e0f0      	LDI  R31,HIGH(_int_Devices*2)
0001b4 91e4      	LPM  R30,Z
0001b5 171e      	CP   R17,R30
0001b6 f470      	BRSH _0x14
                 ;     121 		{
                 ;     122 			putchar0(0);
0001b7 940e 2321 	CALL SUBOPT_0x3
                 ;     123 			putchar0( n+1 );
0001b9 2fe1      	MOV  R30,R17
0001ba 940e 2325 	CALL SUBOPT_0x4
                 ;     124 #pragma warn-
                 ;     125 			putchar0((u8)lAddrDevice [n+1]);
0001bc 2fe1      	MOV  R30,R17
0001bd e0f0      	LDI  R31,0
0001be 50e2
0001bf 4ffa      	__ADDW1MN _lAddrDevice,1
0001c0 81e0      	LD   R30,Z
0001c1 93ea      	ST   -Y,R30
0001c2 d16d      	RCALL _putchar0
                 ;     126 #pragma warn+
                 ;     127 		}
0001c3 5f1f      	SUBI R17,-1
0001c4 cfed      	RJMP _0x13
                 _0x14:
                 ;     128 
                 ;     129 		putchar0(255);
0001c5 940e 231b 	CALL SUBOPT_0x2
                 ;     130 
                 ;     131 		EndReply();
                 ;     132 		return;
                 ;     133 	}
                 _0x8:
                 ;     134 }
                 _0x4E3:
0001c7 940e 2ac6 	CALL __LOADLOCR3
0001c9 9623      	ADIW R28,3
0001ca 9508      	RET
                 ;     135 
                 ;     136 //-----------------------------------------------------------------------------------------------------------------
                 ;     137 // Информация об устройстве
                 ;     138 static void GetInfo(void)
                 ;     139 {
                 _GetInfo_G1:
                 ;     140 	register unsigned char i;
                 ;     141 	
                 ;     142 	// 	Начинаю передачу ответа
                 ;     143 	StartReply(40);
0001cb 930a      	ST   -Y,R16
                 ;	i -> R16
0001cc e2e8      	LDI  R30,LOW(40)
0001cd 93ea      	ST   -Y,R30
0001ce d16b      	RCALL _StartReply
                 ;     144 	
                 ;     145 	for (i = 0; i < 32; i ++)	// Имя устройства
0001cf e000      	LDI  R16,LOW(0)
                 _0x16:
0001d0 3200      	CPI  R16,32
0001d1 f448      	BRSH _0x17
                 ;     146 	{
                 ;     147 		putchar0(device_name[i]);
0001d2 2fe0      	MOV  R30,R16
0001d3 e0f0      	LDI  R31,0
0001d4 57e0      	SUBI R30,LOW(-_device_name*2)
0001d5 4fff      	SBCI R31,HIGH(-_device_name*2)
0001d6 91e4      	LPM  R30,Z
0001d7 93ea      	ST   -Y,R30
0001d8 d157      	RCALL _putchar0
                 ;     148 	}
0001d9 5f0f      	SUBI R16,-1
0001da cff5      	RJMP _0x16
                 _0x17:
                 ;     149 
                 ;     150 	putword0(my_ser_num);		// Серийный номер
0001db e0a1      	LDI  R26,LOW(_my_ser_num)
0001dc e0b0      	LDI  R27,HIGH(_my_ser_num)
0001dd 940e 2a6d 	CALL __EEPROMRDD
0001df 93fa      	ST   -Y,R31
0001e0 93ea      	ST   -Y,R30
0001e1 d20b      	RCALL _putword0
                 ;     151 	putword0(my_ser_num >> 16);	
0001e2 e0a1      	LDI  R26,LOW(_my_ser_num)
0001e3 e0b0      	LDI  R27,HIGH(_my_ser_num)
0001e4 940e 2a6d 	CALL __EEPROMRDD
0001e6 940e 29b1 	CALL __LSRD16
0001e8 93fa      	ST   -Y,R31
0001e9 93ea      	ST   -Y,R30
0001ea d202      	RCALL _putword0
                 ;     152 	
                 ;     153 	putchar0(my_addr);			// Адрес устройстав
0001eb e0a0      	LDI  R26,LOW(_my_addr)
0001ec e0b0      	LDI  R27,HIGH(_my_addr)
0001ed 940e 2a76 	CALL __EEPROMRDB
0001ef 940e 230f 	CALL SUBOPT_0x0
                 ;     154 
                 ;     155 	putchar0(0);				// Зарезервированный байт
                 ;     156 	
                 ;     157 	putword0(my_version);		// Версия
0001f1 ebe0      	LDI  R30,LOW(_my_version*2)
0001f2 e0f0      	LDI  R31,HIGH(_my_version*2)
0001f3 940e 2a59 	CALL __GETW1PF
0001f5 93fa      	ST   -Y,R31
0001f6 93ea      	ST   -Y,R30
0001f7 d1f5      	RCALL _putword0
                 ;     158 	
                 ;     159 	EndReply();					// Завершаю ответ
0001f8 d14b      	RCALL _EndReply
                 ;     160 }
0001f9 9109      	LD   R16,Y+
0001fa 9508      	RET
                 ;     161 
                 ;     162 //-----------------------------------------------------------------------------------------------------------------
                 ;     163 // Смена адреса устройства
                 ;     164 static void SetAddr(void)
                 ;     165 {
                 _SetAddr_G1:
                 ;     166 	#define sap ((RQ_SETADDR *)rx0buf)
                 ;     167 	
                 ;     168 	my_addr = sap->addr;
0001fb 91e0 0628 	LDS  R30,_rx0buf
0001fd e0a0      	LDI  R26,LOW(_my_addr)
0001fe e0b0      	LDI  R27,HIGH(_my_addr)
0001ff 940e 2a95 	CALL __EEPROMWRB
                 ;     169 	
                 ;     170 	StartReply(1);
000201 940e 2329 	CALL SUBOPT_0x5
                 ;     171 	putchar0(RES_OK);
000203 940e 232d 	CALL SUBOPT_0x6
                 ;     172 	EndReply();
                 ;     173 }
000205 9508      	RET
                 ;     174 
                 ;     175 //-----------------------------------------------------------------------------------------------------------------
                 ;     176 // Назначение серийного номера устройства
                 ;     177 static void SetSerial(void)
                 ;     178 {
                 _SetSerial_G1:
                 ;     179 	#define ssp ((RQ_SETSERIAL *)rx0buf)
                 ;     180 	
                 ;     181 	if (my_ser_num)
000206 e0a1      	LDI  R26,LOW(_my_ser_num)
000207 e0b0      	LDI  R27,HIGH(_my_ser_num)
000208 940e 2a6d 	CALL __EEPROMRDD
00020a 940e 2aa4 	CALL __CPD10
00020c f031      	BREQ _0x18
                 ;     182 	{
                 ;     183 		StartReply(1);
00020d 940e 2329 	CALL SUBOPT_0x5
                 ;     184 		putchar0(RES_ERR);
00020f 940e 2321 	CALL SUBOPT_0x3
                 ;     185 		EndReply();
000211 d132      	RCALL _EndReply
                 ;     186 		return;
000212 9508      	RET
                 ;     187 	}
                 ;     188 	
                 ;     189 	my_ser_num = ssp->num;
                 _0x18:
000213 91e0 0628 	LDS  R30,_rx0buf
000215 91f0 0629 	LDS  R31,_rx0buf+1
000217 9160 062a 	LDS  R22,_rx0buf+2
000219 9170 062b 	LDS  R23,_rx0buf+3
00021b e0a1      	LDI  R26,LOW(_my_ser_num)
00021c e0b0      	LDI  R27,HIGH(_my_ser_num)
00021d 940e 2a82 	CALL __EEPROMWRD
                 ;     190 	
                 ;     191 	StartReply(1);
00021f 940e 2329 	CALL SUBOPT_0x5
                 ;     192 	putchar0(RES_OK);
000221 940e 232d 	CALL SUBOPT_0x6
                 ;     193 	EndReply();
                 ;     194 }
000223 9508      	RET
                 ;     195 
                 ;     196 //-----------------------------------------------------------------------------------------------------------------
                 ;     197 // Перезагрузка в режим программирования
                 ;     198 static void ToProg(void)
                 ;     199 {
                 _ToProg_G1:
                 ;     200 	// Отправляю ответ
                 ;     201 	StartReply(0);
000224 e0e0      	LDI  R30,LOW(0)
000225 93ea      	ST   -Y,R30
000226 d113      	RCALL _StartReply
                 ;     202 	EndReply();
000227 d11c      	RCALL _EndReply
                 ;     203 
                 ;     204 	// На перезагрузку в монитор
                 ;     205 	MCUCR = 1 << IVCE;
000228 e0e1      	LDI  R30,LOW(1)
000229 bfe5      	OUT  0x35,R30
                 ;     206 	MCUCR = 1 << IVSEL;
00022a e0e2      	LDI  R30,LOW(2)
00022b bfe5      	OUT  0x35,R30
                 ;     207 
                 ;     208 	#asm("jmp 0xFC00");
00022c 940c fc00 	jmp 0xFC00
                 ;     209 }
00022e 9508      	RET
                 ;     210 
                 ;     211 //-----------------------------------------------------------------------------------------------------------------
                 ;     212 // Железо процессора в исходное состояние
                 ;     213 static void HardwareInit(void)
                 ;     214 {         
                 _HardwareInit_G1:
                 ;     215         TWI_Master_Initialise();
00022f 940e 1fb1 	CALL _TWI_Master_Initialise
                 ;     216 		CommInit();				// Инициализация  COM-порта
000231 d1ac      	RCALL _CommInit
                 ;     217 		timer_0_Init ();			// Инициализируем таймер 0 (таймаут TWI)
000232 d1da      	RCALL _timer_0_Init
                 ;     218 		timer_2_Init ();			// Инициализируем таймер 2 (таймаут пакетов закрытия)
000233 d1e5      	RCALL _timer_2_Init
                 ;     219 		timer_3_Init  ();			// Инициализируем таймер 3 (таймаут пакетов закрытия)
000234 d1f1      	RCALL _timer_3_Init
                 ;     220 		portInit();					// Выводы - в исходное состояние
000235 d1d4      	RCALL _portInit
                 ;     221 		
                 ;     222 		// Вотчдог
                 ;     223 		#ifdef WD_active
                 ;     224 		WDTCR=0x1F;
                 ;     225 		WDTCR=0x0F;   
                 ;     226 		#endif           
                 ;     227 
                 ;     228         
                 ;     229 }
000236 9508      	RET
                 ;     230 
                 ;     231 //-----------------------------------------------------------------------------------------------------------------
                 ;     232 // Сброс периферии
                 ;     233 void ResetPeripherial(void)
                 ;     234 {
                 _ResetPeripherial:
                 ;     235 		DDRA.2 = 1;		// RESET подчиненных процессоров
000237 9ad2      	SBI  0x1A,2
                 ;     236         CRST = 0;
000238 98da      	CBI  0x1B,2
                 ;     237         delay_ms(10);
000239 e0ea      	LDI  R30,LOW(10)
00023a e0f0      	LDI  R31,HIGH(10)
00023b 93fa      	ST   -Y,R31
00023c 93ea      	ST   -Y,R30
00023d 940e 2950 	CALL _delay_ms
                 ;     238         CRST = 1;
00023f 9ada      	SBI  0x1B,2
                 ;     239 		DDRA.2 = 0;
000240 98d2      	CBI  0x1A,2
                 ;     240 }
000241 9508      	RET
                 ;     241 
                 ;     242 //-----------------------------------------------------------------------------------------------------------------
                 ;     243 // Точка входа в программу
                 ;     244 void main(void)
                 ;     245 {
                 _main:
                 ;     246 
                 ;     247 u8 TWI_targetSlaveAddress, a,counter_Responce = 0;
                 ;     248 
                 ;     249   TWI_targetSlaveAddress   = 0x10;
                 ;	TWI_targetSlaveAddress -> R16
                 ;	a -> R17
                 ;	counter_Responce -> R18
000242 e020      	LDI  R18,0
000243 e100      	LDI  R16,LOW(16)
                 ;     250 
                 ;     251 
                 ;     252 //	Пока происходят внутренние работы светодиод - красный. По окончании - зеленый.
                 ;     253 
                 ;     254     LedRed();               
000244 9ad0      	SBI  0x1A,0
000245 9ad1      	SBI  0x1A,1
000246 98d8      	CBI  0x1B,0
000247 9ad9      	SBI  0x1B,1
                 ;     255 	HardwareInit();				// Железо процессора
000248 940e 022f 	CALL _HardwareInit_G1
                 ;     256 
                 ;     257 	#asm("sei")
00024a 9478      	sei
                 ;     258 
                 ;     259 	ResetPeripherial();		// Сбрасываю периферию 
00024b 940e 0237 	CALL _ResetPeripherial
                 ;     260 	delay_ms (3000);					// даем время отработать сброс
00024d ebe8      	LDI  R30,LOW(3000)
00024e e0fb      	LDI  R31,HIGH(3000)
00024f 93fa      	ST   -Y,R31
000250 93ea      	ST   -Y,R30
000251 940e 2950 	CALL _delay_ms
                 ;     261 
                 ;     262 	// активируем TWI	
                 ;     263     txBuffer[0] = (TWI_GEN_CALL<< TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT);
000253 e0e0      	LDI  R30,LOW(0)
000254 93e0 0380 	STS  _txBuffer,R30
                 ;     264 	txBuffer[1] = TWI_CMD_MASTER_READ;             // The first byte is used for commands.
000256 e2e0      	LDI  R30,LOW(32)
000257 93e0 0381 	__PUTB1MN _txBuffer,1
                 ;     265 	TWI_Start_Transceiver_With_Data( txBuffer, 2 );
000259 e8e0      	LDI  R30,LOW(_txBuffer)
00025a e0f3      	LDI  R31,HIGH(_txBuffer)
00025b 940e 2333 	CALL SUBOPT_0x7
00025d 940e 1fc6 	CALL _TWI_Start_Transceiver_With_Data
                 ;     266 
                 ;     267 	UCSR0B.3 = 1;		 				// Разрешаю передатчик UART
00025f 9a53      	SBI  0xA,3
                 ;     268 
                 ;     269 	#ifdef print
                 ;     270 	printf ("Start program \r\n");
                 ;     271 	#endif
                 ;     272 
                 ;     273 	if (my_ser_num == update_program_ser_num)
000260 e0a1      	LDI  R26,LOW(_my_ser_num)
000261 e0b0      	LDI  R27,HIGH(_my_ser_num)
000262 940e 2a6d 	CALL __EEPROMRDD
000264 937f      	PUSH R23
000265 936f      	PUSH R22
000266 93ff      	PUSH R31
000267 93ef      	PUSH R30
000268 e8ec      	LDI  R30,LOW(_update_program_ser_num*2)
000269 e0f0      	LDI  R31,HIGH(_update_program_ser_num*2)
00026a 940e 2a5d 	CALL __GETD1PF
00026c 91af      	POP  R26
00026d 91bf      	POP  R27
00026e 918f      	POP  R24
00026f 919f      	POP  R25
000270 940e 2ab2 	CALL __CPD12
000272 f439      	BRNE _0x19
                 ;     274 	{
                 ;     275 		// работаем с карточкой...
                 ;     276 		#ifdef print
                 ;     277 		printf ("Scrambling ON! \r\n");
                 ;     278 		#endif
                 ;     279 		if (initialize_media())							// инициализация CF Card   
000273 d58a      	RCALL _initialize_media
000274 30e0      	CPI  R30,0
000275 f021      	BREQ _0x1A
                 ;     280 		{
                 ;     281 
                 ;     282 //format_CF();
                 ;     283 				CF_card_INI_OK = 1;
000276 9468      	SET
000277 f822      	BLD  R2,2
                 ;     284 				#ifdef print
                 ;     285 				printf ("Ini CF - OK! \r\n");
                 ;     286 				#endif
                 ;     287 
                 ;     288 				open_user_bin (rd_file);  // открываем БД юзеров (prog.bin)
000278 940e 2338 	CALL SUBOPT_0x8
                 ;     289 				 
                 ;     290 		}
                 ;     291 		else
                 _0x1A:
                 ;     292 		{
                 ;     293 		 		#ifdef print
                 ;     294 				printf ("Ini CF - Error! \r\n");
                 ;     295 				#endif
                 ;     296 		}
                 ;     297 	}
                 ;     298 
                 ;     299 	for (a=1; a<= int_Devices; a++)	     		   		// разблокируем порты
                 _0x19:
00027a e011      	LDI  R17,LOW(1)
                 _0x1D:
00027b ebe4      	LDI  R30,LOW(_int_Devices*2)
00027c e0f0      	LDI  R31,HIGH(_int_Devices*2)
00027d 91e4      	LPM  R30,Z
00027e 17e1      	CP   R30,R17
00027f f028      	BRLO _0x1E
                 ;     300 	{
                 ;     301 		unlock_Pack(a);
000280 931a      	ST   -Y,R17
000281 940e 20e7 	CALL _unlock_Pack
                 ;     302 	}
000283 5f1f      	SUBI R17,-1
000284 cff6      	RJMP _0x1D
                 _0x1E:
                 ;     303 // ---------------------------------------------------------------------------------------------------------------------
                 ;     304 while (1)
                 _0x1F:
                 ;     305 {
                 ;     306 	#asm("wdr");					// 	сброс WD
000285 95a8      	wdr
                 ;     307 
                 ;     308 	LedGreen(); 
000286 9ad0      	SBI  0x1A,0
000287 9ad1      	SBI  0x1A,1
000288 9ad8      	SBI  0x1B,0
000289 98d9      	CBI  0x1B,1
                 ;     309 
                 ;     310 		//					-------------------		TWI	---------------------
                 ;     311 //	for (a=1+offset; a<= int_Devices+offset; a++)	     		   			// вычитываем у кого что есть
                 ;     312 	for (a=1; a<= int_Devices; a++)	     		   			// вычитываем у кого что есть
00028a e011      	LDI  R17,LOW(1)
                 _0x23:
00028b ebe4      	LDI  R30,LOW(_int_Devices*2)
00028c e0f0      	LDI  R31,HIGH(_int_Devices*2)
00028d 91e4      	LPM  R30,Z
00028e 17e1      	CP   R30,R17
00028f f1d0      	BRLO _0x24
                 ;     313 	{
                 ;     314 		// подчиненные устройства - c адреса 0х01
                 ;     315 		 if ( pingPack (a) )
000290 931a      	ST   -Y,R17
000291 940e 2127 	CALL _pingPack
000293 30e0      	CPI  R30,0
000294 f199      	BREQ _0x25
                 ;     316 		 { 
                 ;     317  			if ( Incoming_Pack_TWI == Internal_Packet )
000295 91e0 0580 	__GETB1MN _rxBuffer,2
000297 30e0      	CPI  R30,0
000298 f551      	BRNE _0x26
                 ;     318 		 	{
                 ;     319 				switch (Incoming_Inernal_Information_TWI)
000299 91e0 0582 	__GETB1MN _rxBuffer,4
                 ;     320 				{
                 ;     321 					case GetLogAddr:            						// пришел лог. адрес
00029b 30e1      	CPI  R30,LOW(0x1)
00029c f419      	BRNE _0x2A
                 ;     322 						check_incoming_LOG_ADDR (a);
00029d 931a      	ST   -Y,R17
00029e d215      	RCALL _check_incoming_LOG_ADDR
                 ;     323 						break;
00029f c022      	RJMP _0x29
                 ;     324 
                 ;     325 					case Responce_GEN_CALL:				// пришло подтверждение GEN CALL
                 _0x2A:
0002a0 30e3      	CPI  R30,LOW(0x3)
0002a1 f491      	BRNE _0x2B
                 ;     326 						Combine_Responce_GEN_CALL |=  ( rxBuffer[5] & 1 ) <<  ( a - 1);    
0002a2 91e0 0583 	__GETB1MN _rxBuffer,5
0002a4 940e 233c 	CALL SUBOPT_0x9
0002a6 2a7e      	OR   R7,R30
                 ;     327 						counter_Responce &= (1 <<  ( a - 1)) ^-1;
0002a7 940e 2343 	CALL SUBOPT_0xA
0002a9 232e      	AND  R18,R30
                 ;     328 
                 ;     329 						if (counter_Responce == 0 )
0002aa 3020      	CPI  R18,0
0002ab f439      	BRNE _0x2C
                 ;     330 						{
                 ;     331 								if ( Combine_Responce_GEN_CALL != reflection_active_PORTS )
0002ac 1487      	CP   R8,R7
0002ad f011      	BREQ _0x2D
                 ;     332 										Reply (FALSE);		// ошибка передачи
0002ae e0e0      	LDI  R30,LOW(0)
0002af c001      	RJMP _0x4E4
                 ;     333 								else 	Reply (TRUE);															// передача удалась
                 _0x2D:
0002b0 e0e1      	LDI  R30,LOW(1)
                 _0x4E4:
0002b1 93ea      	ST   -Y,R30
0002b2 d09a      	RCALL _Reply
                 ;     334 								
                 ;     335 //								EndTimePack = TRUE;		// разрешаем скремблер
                 ;     336 						}                                  
                 ;     337 						break;
                 _0x2C:
0002b3 c00e      	RJMP _0x29
                 ;     338 
                 ;     339 					case Responce_GEN_CALL_internal:			// ответы для внутр. скремблера
                 _0x2B:
0002b4 30e4      	CPI  R30,LOW(0x4)
0002b5 f461      	BRNE _0x31
                 ;     340 						#ifdef print
                 ;     341 						printf ("Resp Int Scremb \r\n");
                 ;     342 						#endif
                 ;     343 
                 ;     344 						Combine_Responce_GEN_CALL |=  ( rxBuffer[5] & 1 ) <<  ( a - 1);    
0002b6 91e0 0583 	__GETB1MN _rxBuffer,5
0002b8 940e 233c 	CALL SUBOPT_0x9
0002ba 2a7e      	OR   R7,R30
                 ;     345 						counter_Responce &= (1 <<  ( a - 1)) ^-1;
0002bb 940e 2343 	CALL SUBOPT_0xA
0002bd 232e      	AND  R18,R30
                 ;     346 
                 ;     347 						if (counter_Responce == 0 )
0002be 3020      	CPI  R18,0
0002bf f411      	BRNE _0x30
                 ;     348 						{
                 ;     349 						#ifdef print
                 ;     350 						printf ("Resp OK! Scremb ON! \r\n");
                 ;     351 						#endif
                 ;     352 							EndTimePack = TRUE;		// разрешаем скремблер
0002c0 9468      	SET
0002c1 f820      	BLD  R2,0
                 ;     353 						}
                 ;     354 
                 ;     355 						break;
                 _0x30:
                 ;     356 
                 ;     357 						
                 ;     358 					default:	
                 _0x31:
                 ;     359 						break;
                 ;     360 				}		
                 _0x29:
                 ;     361 		 	}
                 ;     362 		 	else 	// пакет для ретрансляции
0002c2 c005      	RJMP _0x32
                 _0x26:
                 ;     363 			{
                 ;     364 				#ifdef print
                 ;     365 				printf ("Relay TWI_UART \r\n");
                 ;     366 				#endif
                 ;     367 
                 ;     368 				Transmitt_from_TWI_to_UART ( &rxBuffer[3] );
0002c3 e8e1
0002c4 e0f5      	__POINTW1MN _rxBuffer,3
0002c5 93fa      	ST   -Y,R31
0002c6 93ea      	ST   -Y,R30
0002c7 d12e      	RCALL _Transmitt_from_TWI_to_UART
                 ;     369 			}
                 _0x32:
                 ;     370 		 }
                 ;     371 		 else // нет полезной информации во внутр. канале
                 _0x25:
                 ;     372 		 {           
                 ;     373 		 
                 ;     374 		 }
                 ;     375 	 }
0002c8 5f1f      	SUBI R17,-1
0002c9 cfc1      	RJMP _0x23
                 _0x24:
                 ;     376 
                 ;     377 			 
                 ;     378 
                 ;     379 		// Проверяю пакет ---------------		UART		-----------------------
                 ;     380 		if (HaveIncomingPack())
0002ca d103      	RCALL _HaveIncomingPack
0002cb 30e0      	CPI  R30,0
0002cc f411      	BRNE PC+3
0002cd 940c 031e 	JMP _0x34
                 ;     381 		{
                 ;     382 			scrambOff();							// при получении пакета выключаем скремблер на 8сек
0002cf 940e 1aaa 	CALL _scrambOff
                 ;     383 
                 ;     384 			if ((rx0addr == my_addr) || (rx0addr == TO_ALL))				// адрес мой 
0002d1 e0a0      	LDI  R26,LOW(_my_addr)
0002d2 e0b0      	LDI  R27,HIGH(_my_addr)
0002d3 940e 2a76 	CALL __EEPROMRDB
0002d5 91a0 0626 	LDS  R26,_rx0addr
0002d7 17ea      	CP   R30,R26
0002d8 f011      	BREQ _0x36
0002d9 3faf      	CPI  R26,LOW(0xFF)
0002da f5e1      	BRNE _0x35
                 _0x36:
                 ;     385 			{
                 ;     386 				#ifdef print
                 ;     387 				printf ("Have Incoming Pack \r\n");
                 ;     388 				#endif
                 ;     389 
                 ;     390 				switch(IncomingPackType())
0002db d0fb      	RCALL _IncomingPackType
                 ;     391 				{
                 ;     392 					case PT_GETSTATE:
0002dc 30e1      	CPI  R30,LOW(0x1)
0002dd f419      	BRNE _0x3B
                 ;     393 							GetState();
0002de 940e 0177 	CALL _GetState_G1
                 ;     394 							break;
0002e0 c035      	RJMP _0x3A
                 ;     395 				
                 ;     396 					case PT_GETINFO:
                 _0x3B:
0002e1 30e3      	CPI  R30,LOW(0x3)
0002e2 f419      	BRNE _0x3C
                 ;     397 							GetInfo();
0002e3 940e 01cb 	CALL _GetInfo_G1
                 ;     398 							break;
0002e5 c030      	RJMP _0x3A
                 ;     399 				
                 ;     400 					case PT_SETADDR:
                 _0x3C:
0002e6 30e4      	CPI  R30,LOW(0x4)
0002e7 f419      	BRNE _0x3D
                 ;     401 							SetAddr();
0002e8 940e 01fb 	CALL _SetAddr_G1
                 ;     402 							break;
0002ea c02b      	RJMP _0x3A
                 ;     403 				
                 ;     404 					case PT_SETSERIAL:
                 _0x3D:
0002eb 30e5      	CPI  R30,LOW(0x5)
0002ec f419      	BRNE _0x3E
                 ;     405 							SetSerial();
0002ed 940e 0206 	CALL _SetSerial_G1
                 ;     406 							break;
0002ef c026      	RJMP _0x3A
                 ;     407 		
                 ;     408 					case PT_TOPROG:
                 _0x3E:
0002f0 30e7      	CPI  R30,LOW(0x7)
0002f1 f419      	BRNE _0x3F
                 ;     409 							ToProg();
0002f2 940e 0224 	CALL _ToProg_G1
                 ;     410 							break;      
0002f4 c021      	RJMP _0x3A
                 ;     411 
                 ;     412 					// ретрансляция пакета в TWI при MY_ADDR или 255. Приемник -  подчиненные
                 ;     413 					// процессоры (только один).
                 ;     414 					case PT_RELAY:           			
                 _0x3F:
0002f5 30e6      	CPI  R30,LOW(0x6)
0002f6 f461      	BRNE _0x40
                 ;     415 
                 ;     416 //						    if ( ! ( Relay_pack_from_UART_to_TWI_Internal (rx0buf [0]+offset) ) )	Reply (FALSE);					//ошибка
                 ;     417 						    if ( ! ( Relay_pack_from_UART_to_TWI_Internal (rx0buf [0]) ) )	Reply (FALSE);					//ошибка
0002f7 91e0 0628 	LDS  R30,_rx0buf
0002f9 93ea      	ST   -Y,R30
0002fa 940e 21b4 	CALL _Relay_pack_from_UART_to_TWI_Internal
0002fc 30e0      	CPI  R30,0
0002fd f411      	BRNE _0x41
0002fe 940e 234b 	CALL SUBOPT_0xB
                 ;     418 							#ifdef print
                 ;     419 							printf ("Relay to Internal PT_RELAY \r\n");
                 ;     420 							#endif
                 ;     421 							Combine_Responce_GEN_CALL = 0;	// сброс счетчиков приема подтверждений
                 _0x41:
000300 2477      	CLR  R7
                 ;     422 							counter_Responce = reflection_active_PORTS;
000301 2d28      	MOV  R18,R8
                 ;     423 
                 ;     424 							DiscardIncomingPack();        // разрешаем принимать след. пакет
000302 c012      	RJMP _0x4E5
                 ;     425         	   				break;
                 ;     426 
                 ;     427 					case PT_CF_CARD:						// пакеты для работы с CF Flash
                 _0x40:
000303 3aed      	CPI  R30,LOW(0xAD)
000304 f411      	BRNE _0x42
                 ;     428 							flash_Work();
000305 d3b8      	RCALL _flash_Work
                 ;     429 
                 ;     430 							DiscardIncomingPack();
000306 c00e      	RJMP _0x4E5
                 ;     431            					break;
                 ;     432 
                 ;     433 					case PT_SCRCTL:
                 _0x42:
000307 3ae0      	CPI  R30,LOW(0xA0)
000308 f011      	BREQ _0x44
                 ;     434 					case PT_SCRDATA:    
000309 3ae1      	CPI  R30,LOW(0xA1)
00030a f421      	BRNE _0x45
                 _0x44:
                 ;     435 				#ifdef print
                 ;     436 				printf ("Relay to Internal PT_SCRCTR or PT_SCRDATA\r\n");
                 ;     437 				#endif
                 ;     438 							Relay_pack_from_UART_to_TWI(Internal_Packet);
00030b 940e 234f 	CALL SUBOPT_0xC
                 ;     439 							Combine_Responce_GEN_CALL = 0;	// сброс счетчиков приема подтверждений
                 ;     440 							counter_Responce = reflection_active_PORTS;
00030d 2d28      	MOV  R18,R8
                 ;     441 
                 ;     442 							DiscardIncomingPack();
00030e c006      	RJMP _0x4E5
                 ;     443            					break;
                 ;     444 
                 ;     445            					
                 ;     446 					case PT_DESCRUPD:    
                 _0x45:
00030f 3ae2      	CPI  R30,LOW(0xA2)
000310 f421      	BRNE _0x47
                 ;     447 				#ifdef print
                 ;     448 				printf ("Relay to Internal PT_DESCRUPD\r\n");
                 ;     449 				#endif
                 ;     450                         ModifyKey ();									// подменяем текущий ключ
000311 d16a      	RCALL _ModifyKey
                 ;     451 						Relay_pack_from_UART_to_TWI(Internal_Packet);
000312 940e 234f 	CALL SUBOPT_0xC
                 ;     452 
                 ;     453 							Combine_Responce_GEN_CALL = 0;	// сброс счетчиков приема подтверждений
                 ;     454 							counter_Responce = reflection_active_PORTS;
000314 2d28      	MOV  R18,R8
                 ;     455 
                 ;     456 							DiscardIncomingPack();
                 ;     457            					break;    
                 ;     458                 			
                 ;     459 					default:
                 _0x47:
                 ;     460 							DiscardIncomingPack();
                 _0x4E5:
000315 d0c4      	RCALL _DiscardIncomingPack
                 ;     461 							break;
                 ;     462 				}
                 _0x3A:
                 ;     463 		    }
                 ;     464 		   	else																// ретранслируем
000316 c007      	RJMP _0x48
                 _0x35:
                 ;     465 			{                                                                     
                 ;     466 				#ifdef print
                 ;     467 				printf ("Relay Pack \r\n");
                 ;     468 				#endif
                 ;     469 
                 ;     470 
                 ;     471 		        if ( ! Searching_Port_for_Relay () ) 
000317 940e 2219 	CALL _Searching_Port_for_Relay
000319 30e0      	CPI  R30,0
00031a f411      	BRNE _0x49
                 ;     472 		        {
                 ;     473 					#ifdef print
                 ;     474 					printf ("port for Relay Pack not FOUND!\r\n");
                 ;     475 					printf ("Incoming PORT-%x!\r\n",rx0addr);
                 ;     476 					#endif
                 ;     477 		        	Reply (FALSE);		// передаем ошибку
00031b 940e 234b 	CALL SUBOPT_0xB
                 ;     478 	    	    }
                 ;     479 				DiscardIncomingPack();        // разрешаем принимать след. пакет
                 _0x49:
00031d d0bc      	RCALL _DiscardIncomingPack
                 ;     480 			}
                 _0x48:
                 ;     481 		}
                 ;     482 		
                 ;     483 
                 ;     484 		//					-------------------		Scrambler	---------------------
                 ;     485 		// если карта проинициализировалась - запускаем скремблирование
                 ;     486 		
                 ;     487 		if (CF_card_INI_OK)				
                 _0x34:
00031e fe22      	SBRS R2,2
00031f c00d      	RJMP _0x4A
                 ;     488 		{
                 ;     489 			if (EndTimePack == TRUE) 		// таймер разрешения
000320 fe20      	SBRS R2,0
000321 c00b      	RJMP _0x4B
                 ;     490 			{
                 ;     491 				if (reflection_active_PORTS != 0)	// если нет подкл. устойств - не скремблируем
000322 2088      	TST  R8
000323 f049      	BREQ _0x4C
                 ;     492 				{
                 ;     493 					#ifdef print
                 ;     494 					printf ("Scrambling... \r\n");
                 ;     495 					#endif
                 ;     496 
                 ;     497 					scrambling();   		// создаем свои пакеты для передачи в линию
000324 940e 1aee 	CALL _scrambling
                 ;     498 					timeOutPackStart();
000326 d14a      	RCALL _timeOutPackStart
                 ;     499 					LedRed(); 
000327 9ad0      	SBI  0x1A,0
000328 9ad1      	SBI  0x1A,1
000329 98d8      	CBI  0x1B,0
00032a 9ad9      	SBI  0x1B,1
                 ;     500 
                 ;     501 					Combine_Responce_GEN_CALL = 0;	// сброс счетчиков приема подтверждений
00032b 2477      	CLR  R7
                 ;     502 					counter_Responce = reflection_active_PORTS;
00032c 2d28      	MOV  R18,R8
                 ;     503 				}
                 ;     504 
                 ;     505 			}
                 _0x4C:
                 ;     506 		}	
                 _0x4B:
                 ;     507 }
                 _0x4A:
00032d 940c 0285 	JMP  _0x1F
                 ;     508 }    	
                 _0x4D:
00032f cfff      	RJMP _0x4D
                 ;     509 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                 ;     510 // Управляющая программа КОДЕРА
                 ;     511 // Связь с внешним миром
                 ;     512 
                 ;     513 #include "Coding.h"
                 ;     514 
                 ;     515 #define BAUD 38400
                 ;     516 #define DTXDDR 	DDRC.0		// вывод программного UART   (35pin, на стороне - 16)
                 ;     517 #define DTXPIN	PORTC.0		// вывод программного UART
                 ;     518 
                 ;     519 
                 ;     520 ////////////////////////////////////////////////////////////////////////////////
                 ;     521 // Фазы работы приемопередатчиков
                 ;     522 #define RX_HDR	 1		// Принятый байт - заголовок
                 ;     523 #define RX_LEN   2		// Принятый байт - длина
                 ;     524 #define RX_ADDR  3		// Принятый байт - адрес
                 ;     525 #define RX_TYPE  4		// Принятый байт - тип пакета
                 ;     526 #define RX_DATA  5		// Принятый байт - байт данных
                 ;     527 #define RX_CRC   6		// Принятый байт - CRC
                 ;     528 #define RX_OK    7		// Пакет успешно принят и адресован мне
                 ;     529 #define RX_TIME  8		// Во время приема произошел тайм-аут
                 ;     530 #define RX_ERR   9		// Ошибка CRC приема
                 ;     531 #define RX_BUSY 10		// Запрос прочитан, а ответ еще не сформирован
                 ;     532 
                 ;     533 #define UDRE 5
                 ;     534 #define DATA_REGISTER_EMPTY (1<<UDRE)
                 ;     535 
                 ;     536 #define RXTIMEOUT 4000	// Тайм-аут приема наружного канала
                 ;     537 
                 ;     538 ////////////////////////////////////////////////////////////////////////////////
                 ;     539 // Работа с наружным каналом
                 ;     540 
                 ;     541 unsigned char tx0crc;
                 
                 	.DSEG
                 _tx0crc:
000622           	.BYTE 0x1
                 ;     542 unsigned char rx0state = RX_HDR;
                 _rx0state:
000623           	.BYTE 0x1
                 ;     543 unsigned char rx0crc;
                 _rx0crc:
000624           	.BYTE 0x1
                 ;     544 unsigned char rx0len;
                 _rx0len:
000625           	.BYTE 0x1
                 ;     545 unsigned char rx0addr;
                 _rx0addr:
000626           	.BYTE 0x1
                 ;     546 unsigned char rx0type;
                 _rx0type:
000627           	.BYTE 0x1
                 ;     547 
                 ;     548 #define COMBUFSIZ 255
                 ;     549 
                 ;     550 unsigned char rx0buf[COMBUFSIZ];
                 _rx0buf:
000628           	.BYTE 0xFF
                 ;     551 unsigned char rx0ptr;
                 _rx0ptr:
000727           	.BYTE 0x1
                 ;     552 
                 ;     553 // Передача байта во "внешний" канал
                 ;     554 void putchar0(char byt)
                 ;     555 {
                 
                 	.CSEG
                 _putchar0:
                 ;     556 	while ((UCSR0A & DATA_REGISTER_EMPTY)==0);
                 _0x4F:
000330 9b5d      	SBIS 0xB,5
000331 cffe      	RJMP _0x4F
                 ;     557 	UDR0 = byt;
000332 81e8      	LD   R30,Y
000333 b9ec      	OUT  0xC,R30
                 ;     558 	tx0crc += byt;
000334 91a0 0622 	LDS  R26,_tx0crc
000336 0fea      	ADD  R30,R26
000337 93e0 0622 	STS  _tx0crc,R30
                 ;     559 }
000339 c19c      	RJMP _0x4E1
                 ;     560 
                 ;     561 // Начало ответа на запрос по внешнему каналу
                 ;     562 void StartReply(unsigned char dlen) 
                 ;     563 {
                 _StartReply:
                 ;     564 	rx0state = RX_BUSY;					// Запрос обработан
00033a e0ea      	LDI  R30,LOW(10)
00033b 93e0 0623 	STS  _rx0state,R30
                 ;     565 	tx0crc = 0;										// Готовлю CRC
00033d e0e0      	LDI  R30,LOW(0)
00033e 93e0 0622 	STS  _tx0crc,R30
                 ;     566 	
                 ;     567 //	UCSR0B.3 = 1;								// Разрешаю передатчик
                 ;     568 	
                 ;     569 	putchar0(dlen+1);							// Передаю длину
000340 81e8      	LD   R30,Y
000341 940e 2325 	CALL SUBOPT_0x4
                 ;     570 }
000343 c192      	RJMP _0x4E1
                 ;     571 
                 ;     572 void EndReply(void)
                 ;     573 {
                 _EndReply:
                 ;     574 	putchar0(tx0crc);							// Контрольная сумма
000344 91e0 0622 	LDS  R30,_tx0crc
000346 93ea      	ST   -Y,R30
000347 940e 0330 	CALL _putchar0
                 ;     575 //	UCSR0B.3 = 0;								// Запрещаю передатчик
                 ;     576 	rx0state = RX_HDR;						// Разрешаю прием след. запроса
000349 e0e1      	LDI  R30,LOW(1)
00034a 93e0 0623 	STS  _rx0state,R30
                 ;     577 }        
00034c 9508      	RET
                 ;     578 
                 ;     579 // 
                 ;     580 void Reply(u8 status)
                 ;     581 {
                 _Reply:
                 ;     582 
                 ;     583 		#ifdef print
                 ;     584 		printf("Reply-%x\n\r",status);
                 ;     585 		#endif
                 ;     586 	
                 ;     587 		StartReply (1);
00034d 940e 2329 	CALL SUBOPT_0x5
                 ;     588 		putchar0(status);        // текущий статус
00034f 940e 2355 	CALL SUBOPT_0xD
                 ;     589 		EndReply();  
000351 940e 0344 	CALL _EndReply
                 ;     590 
                 ;     591 }
000353 c182      	RJMP _0x4E1
                 ;     592 
                 ;     593 // Прерывание по приему байта из "наружного" канала
                 ;     594 interrupt [USART0_RXC] void uart_rx_isr(void)
                 ;     595 {
                 _uart_rx_isr:
000354 93aa      	ST   -Y,R26
000355 93ea      	ST   -Y,R30
000356 93fa      	ST   -Y,R31
000357 b7ef      	IN   R30,SREG
000358 93ea      	ST   -Y,R30
                 ;     596 	register unsigned char byt;
                 ;     597 
                 ;     598 	byt = UDR0;									// Принятый байт
000359 930a      	ST   -Y,R16
                 ;	byt -> R16
00035a b10c      	IN   R16,12
                 ;     599 
                 ;     600 	
                 ;     601 	switch (rx0state)
00035b 91e0 0623 	LDS  R30,_rx0state
                 ;     602 	{
                 ;     603 	case RX_HDR:								// Должен быть заголовок
00035d 30e1      	CPI  R30,LOW(0x1)
00035e f4a9      	BRNE _0x55
                 ;     604 		if (byt != PACKHDR)					// Отбрасываю не заголовок
00035f 3701      	CPI  R16,113
000360 f009      	BREQ _0x56
                 ;     605 		{
                 ;     606 			break;
000361 c055      	RJMP _0x54
                 ;     607 		}
                 ;     608 
                 ;     609 
                 ;     610 		rx0state = RX_LEN;					// Перехожу к ожиданию длины
                 _0x56:
000362 e0e2      	LDI  R30,LOW(2)
000363 93e0 0623 	STS  _rx0state,R30
                 ;     611 		rx0crc = 0;								// Готовлю подсчет CRC
000365 e0e0      	LDI  R30,LOW(0)
000366 93e0 0624 	STS  _rx0crc,R30
                 ;     612 		
                 ;     613 		OCR1A = TCNT1+RXTIMEOUT;	// Взвожу тайм-аут
000368 b5ec      	IN   R30,0x2C
000369 b5fd      	IN   R31,0x2C+1
00036a 56e0      	SUBI R30,LOW(-4000)
00036b 4ff0      	SBCI R31,HIGH(-4000)
00036c bdfb      	OUT  0x2A+1,R31
00036d bdea      	OUT  0x2A,R30
                 ;     614 		TIFR = 0x10;								// Предотвращаю ложное срабатывание
00036e e1e0      	LDI  R30,LOW(16)
00036f bfe6      	OUT  0x36,R30
                 ;     615 		TIMSK |= 0x10;							// Разрешение прерывания по тайм-ауту
000370 b7e7      	IN   R30,0x37
000371 61e0      	ORI  R30,0x10
000372 bfe7      	OUT  0x37,R30
                 ;     616 		break;
000373 c043      	RJMP _0x54
                 ;     617 		
                 ;     618 	case RX_LEN:
                 _0x55:
000374 30e2      	CPI  R30,LOW(0x2)
000375 f431      	BRNE _0x57
                 ;     619 		rx0len = byt - 3;							// Длина содержимого
000376 2fe0      	MOV  R30,R16
000377 50e3      	SUBI R30,LOW(3)
000378 93e0 0625 	STS  _rx0len,R30
                 ;     620 		rx0state = RX_ADDR;					// К приему адреса
00037a e0e3      	LDI  R30,LOW(3)
00037b c039      	RJMP _0x4E6
                 ;     621 		break;
                 ;     622 
                 ;     623 	case RX_ADDR:
                 _0x57:
00037c 30e3      	CPI  R30,LOW(0x3)
00037d f421      	BRNE _0x58
                 ;     624 		rx0addr = byt;							// Адрес
00037e 9300 0626 	STS  _rx0addr,R16
                 ;     625 		rx0state = RX_TYPE;					// К приему типа
000380 e0e4      	LDI  R30,LOW(4)
000381 c033      	RJMP _0x4E6
                 ;     626 		break;
                 ;     627 
                 ;     628 	case RX_TYPE:
                 _0x58:
000382 30e4      	CPI  R30,LOW(0x4)
000383 f479      	BRNE _0x59
                 ;     629 		rx0type = byt;							// Тип
000384 9300 0627 	STS  _rx0type,R16
                 ;     630 		rx0ptr = 0;									// Указатель на начало данных
000386 e0e0      	LDI  R30,LOW(0)
000387 93e0 0727 	STS  _rx0ptr,R30
                 ;     631 		if (rx0len)
000389 91e0 0625 	LDS  R30,_rx0len
00038b 30e0      	CPI  R30,0
00038c f011      	BREQ _0x5A
                 ;     632 		{
                 ;     633 			rx0state = RX_DATA;				// К приему данных
00038d e0e5      	LDI  R30,LOW(5)
00038e c001      	RJMP _0x4E7
                 ;     634 		}
                 ;     635 		else
                 _0x5A:
                 ;     636 		{
                 ;     637 			rx0state = RX_CRC; 				// К приему контрольной суммы
00038f e0e6      	LDI  R30,LOW(6)
                 _0x4E7:
000390 93e0 0623 	STS  _rx0state,R30
                 ;     638 		}
                 ;     639 		break;
000392 c024      	RJMP _0x54
                 ;     640 
                 ;     641 	case RX_DATA:
                 _0x59:
000393 30e5      	CPI  R30,LOW(0x5)
000394 f479      	BRNE _0x5C
                 ;     642 		if (rx0ptr > (COMBUFSIZ-1))
000395 91a0 0727 	LDS  R26,_rx0ptr
000397 3faf      	CPI  R26,LOW(0xFF)
000398 f008      	BRLO _0x5D
                 ;     643 		{
                 ;     644 			rx0state = RX_HDR;				// Если пакет слишком длинный - отвергаю и иду в начало
000399 c01a      	RJMP _0x4E8
                 ;     645 			break;
                 ;     646 		}
                 ;     647 		rx0buf[rx0ptr++] = byt;				// Данные
                 _0x5D:
00039a 940e 2359 	CALL SUBOPT_0xE
                 ;     648 		if (rx0ptr < rx0len)						// Еще не все ?
00039c 91e0 0625 	LDS  R30,_rx0len
00039e 91a0 0727 	LDS  R26,_rx0ptr
0003a0 17ae      	CP   R26,R30
0003a1 f0a8      	BRLO _0x54
                 ;     649 		{
                 ;     650 			break;
                 ;     651 		}
                 ;     652 		rx0state = RX_CRC;					// К приему контрольной суммы
0003a2 e0e6      	LDI  R30,LOW(6)
0003a3 c011      	RJMP _0x4E6
                 ;     653 		break;
                 ;     654 
                 ;     655 	case RX_CRC:
                 _0x5C:
0003a4 30e6      	CPI  R30,LOW(0x6)
0003a5 f471      	BRNE _0x62
                 ;     656 		if (byt != rx0crc)
0003a6 91e0 0624 	LDS  R30,_rx0crc
0003a8 17e0      	CP   R30,R16
0003a9 f011      	BREQ _0x60
                 ;     657 		{
                 ;     658 			rx0state = RX_HDR;				// Не сошлась CRC - игнорирую пакет и жду следующий
0003aa e0e1      	LDI  R30,LOW(1)
0003ab c003      	RJMP _0x4E9
                 ;     659 		}
                 ;     660 // убрал фильтр адреса
                 ;     661 else
                 _0x60:
                 ;     662 {
                 ;     663 rx0buf[rx0ptr++] = byt;						// Данные
0003ac 940e 2359 	CALL SUBOPT_0xE
                 ;     664 rx0state = RX_OK;								// Принят пакет, на который нужно ответить
0003ae e0e7      	LDI  R30,LOW(7)
                 _0x4E9:
0003af 93e0 0623 	STS  _rx0state,R30
                 ;     665 }
                 ;     666 
                 ;     667 		TIMSK &= 0x10 ^ 0xFF;				// Запретить прерывание по тайм-ауту
0003b1 940e 2364 	CALL SUBOPT_0xF
                 ;     668 		break;
0003b3 c003      	RJMP _0x54
                 ;     669 		
                 ;     670 		break;
                 ;     671 		
                 ;     672 	default:											// Ошибочное состояние
                 _0x62:
                 ;     673 		rx0state = RX_HDR;					// Перехожу на начало
                 _0x4E8:
0003b4 e0e1      	LDI  R30,LOW(1)
                 _0x4E6:
0003b5 93e0 0623 	STS  _rx0state,R30
                 ;     674 		break;
                 ;     675 	}
                 _0x54:
                 ;     676 
                 ;     677 	rx0crc += byt;								// Подсчитываю контрольную сумму
0003b7 2fe0      	MOV  R30,R16
0003b8 91a0 0624 	LDS  R26,_rx0crc
0003ba 0fea      	ADD  R30,R26
0003bb 93e0 0624 	STS  _rx0crc,R30
                 ;     678 }
0003bd 9109      	LD   R16,Y+
0003be 91e9      	LD   R30,Y+
0003bf bfef      	OUT  SREG,R30
0003c0 91f9      	LD   R31,Y+
0003c1 91e9      	LD   R30,Y+
0003c2 91a9      	LD   R26,Y+
0003c3 9518      	RETI
                 ;     679 
                 ;     680 // Прерывание по сравнению A таймера 1 для подсчета тайм-аута приема "внешнего" канала
                 ;     681 interrupt [TIM1_COMPA] void timer1_comp_a_isr(void)
                 ;     682 {
                 _timer1_comp_a_isr:
0003c4 940e 2368 	CALL SUBOPT_0x10
                 ;     683 	rx0state = RX_HDR;						// По тайм-ауту перехожу к началу приема нового пакета
0003c6 e0e1      	LDI  R30,LOW(1)
0003c7 93e0 0623 	STS  _rx0state,R30
                 ;     684 	TIMSK &= 0x10 ^ 0xFF;					// Больше не генерировать прерываний
0003c9 940e 2364 	CALL SUBOPT_0xF
                 ;     685 }
0003cb 940e 236c 	CALL SUBOPT_0x11
0003cd 9518      	RETI
                 ;     686 
                 ;     687 unsigned char HaveIncomingPack(void)
                 ;     688 {
                 _HaveIncomingPack:
                 ;     689 	if (rx0state == RX_OK)	return 255;
0003ce 91a0 0623 	LDS  R26,_rx0state
0003d0 30a7      	CPI  R26,LOW(0x7)
0003d1 f411      	BRNE _0x63
0003d2 efef      	LDI  R30,LOW(255)
0003d3 9508      	RET
                 ;     690 	else					return 0;
                 _0x63:
0003d4 e0e0      	LDI  R30,LOW(0)
0003d5 9508      	RET
                 ;     691 }
0003d6 9508      	RET
                 ;     692 
                 ;     693 unsigned char IncomingPackType(void)
                 ;     694 {
                 _IncomingPackType:
                 ;     695 	return rx0type;
0003d7 91e0 0627 	LDS  R30,_rx0type
0003d9 9508      	RET
                 ;     696 }
                 ;     697 
                 ;     698 void DiscardIncomingPack(void)
                 ;     699 {
                 _DiscardIncomingPack:
                 ;     700 	rx0state = RX_HDR;						// Разрешаю прием следующего пакета
0003da e0e1      	LDI  R30,LOW(1)
0003db 93e0 0623 	STS  _rx0state,R30
                 ;     701 }
0003dd 9508      	RET
                 ;     702 
                 ;     703 // Настройка приемопередатчика
                 ;     704 void CommInit(void)
                 ;     705 {
                 _CommInit:
                 ;     706 	// Настраиваю UART
                 ;     707 	UCSR0A = 0b00000000;
0003de e0e0      	LDI  R30,LOW(0)
0003df b9eb      	OUT  0xB,R30
                 ;     708 	UCSR0B = 0b10010000;	//0b10011000;
0003e0 e9e0      	LDI  R30,LOW(144)
0003e1 b9ea      	OUT  0xA,R30
                 ;     709 	UCSR0C = 0x86;
0003e2 e8e6      	LDI  R30,LOW(134)
0003e3 93e0 0095 	STS  149,R30
                 ;     710 	UBRR0L = ((_MCU_CLOCK_FREQUENCY_ / (16 * BAUD)) - 1) & 0xFF;
0003e5 e0ec      	LDI  R30,LOW(12)
0003e6 b9e9      	OUT  0x9,R30
                 ;     711 	UBRR0H = (((_MCU_CLOCK_FREQUENCY_ / (16 * BAUD)) - 1) >> 8) & 0xFF;
0003e7 e0e0      	LDI  R30,LOW(0)
0003e8 93e0 0090 	STS  144,R30
                 ;     712 	
                 ;     713 	// Таймер 1 для подсчета тайм-аутов приема
                 ;     714 	TCCR1B  = 0b00000101;
0003ea e0e5      	LDI  R30,LOW(5)
0003eb bdee      	OUT  0x2E,R30
                 ;     715 }
0003ec 9508      	RET
                 ;     716 
                 ;     717 void putword0(unsigned short wd)
                 ;     718 {
                 _putword0:
                 ;     719 	putchar0(wd);
0003ed 940e 2355 	CALL SUBOPT_0xD
                 ;     720 	putchar0(wd >> 8);
0003ef 81e9      	LDD  R30,Y+1
0003f0 70f0      	ANDI R31,HIGH(0x0)
0003f1 93ea      	ST   -Y,R30
0003f2 940e 0330 	CALL _putchar0
                 ;     721 }                                  
0003f4 9622      	ADIW R28,2
0003f5 9508      	RET
                 ;     722 
                 ;     723 //--------------------------------------------------------------------------------------------
                 ;     724 // "программный" UART
                 ;     725 void dtxdl(void)
                 ;     726 {
                 ;     727 	int i;
                 ;     728 	for (i = 0; i < 15; i ++)
                 ;	i -> R16,R17
                 ;     729 	{
                 ;     730 		#asm("nop")
                 ;     731 	}
                 ;     732 }
                 ;     733 
                 ;     734 void putchar2(char c)
                 ;     735 {
                 ;     736 	register unsigned char b;
                 ;     737 	
                 ;     738 	#asm("cli")
                 ;	c -> Y+1
                 ;	b -> R16
                 ;     739 	
                 ;     740 	DTXDDR = 1;
                 ;     741 //	DRXDDR = 0;
                 ;     742 	DTXPIN = 0;
                 ;     743 	dtxdl();
                 ;     744 	
                 ;     745 	for (b = 0; b < 8; b ++)
                 ;     746 	{
                 ;     747 		if (c & 1)
                 ;     748 		{
                 ;     749 			DTXPIN = 1;
                 ;     750 		}
                 ;     751 		else
                 ;     752 		{
                 ;     753 			DTXPIN = 0;
                 ;     754 		}
                 ;     755              
                 ;     756 		c >>= 1;
                 ;     757 		dtxdl();
                 ;     758 	}
                 ;     759 
                 ;     760 	DTXPIN = 1;
                 ;     761 	dtxdl();
                 ;     762 	dtxdl();
                 ;     763 	
                 ;     764 	#asm("sei")
                 ;     765 }
                 ;     766 
                 ;     767 // передача с внутреннего канада во внешний. Указываем количество передаваемых байт.
                 ;     768 void	Transmitt_from_TWI_to_UART (u8 *Transmitting_Bytes)
                 ;     769 {
                 _Transmitt_from_TWI_to_UART:
                 ;     770 	u8 temp;
                 ;     771 	
                 ;     772 	temp = *Transmitting_Bytes + 1;
0003f6 930a      	ST   -Y,R16
                 ;	*Transmitting_Bytes -> Y+1
                 ;	temp -> R16
0003f7 81a9      	LDD  R26,Y+1
0003f8 81ba      	LDD  R27,Y+1+1
0003f9 91ec      	LD   R30,X
0003fa 5fef      	SUBI R30,-LOW(1)
0003fb 2f0e      	MOV  R16,R30
                 ;     773 	
                 ;     774 		while ( temp -- )
                 _0x6D:
0003fc 2fe0      	MOV  R30,R16
0003fd 5001      	SUBI R16,1
0003fe 30e0      	CPI  R30,0
0003ff f049      	BREQ _0x6F
                 ;     775 	   				putchar0 (*Transmitting_Bytes++);
000400 81a9      	LDD  R26,Y+1
000401 81ba      	LDD  R27,Y+1+1
000402 91ed      	LD   R30,X+
000403 83a9      	STD  Y+1,R26
000404 83ba      	STD  Y+1+1,R27
000405 93ea      	ST   -Y,R30
000406 940e 0330 	CALL _putchar0
                 ;     776 }			
000408 cff3      	RJMP _0x6D
                 _0x6F:
000409 c0a7      	RJMP _0x4E2
                 ;     777 #include "Coding.h"
                 ;     778 
                 ;     779 unsigned char flagTWI				=	0;
                 
                 	.DSEG
                 _flagTWI:
000728           	.BYTE 0x1
                 ;     780 
                 ;     781 
                 ;     782 
                 ;     783 // Инициализация выводов
                 ;     784 void portInit (void)
                 ;     785 		{
                 
                 	.CSEG
                 _portInit:
                 ;     786 			DDRB.7 = 1;		// testpin
00040a 9abf      	SBI  0x17,7
                 ;     787 			CS_DDR_SET();	// для CF Card
00040b 9abc      	SBI  0x17,4
                 ;     788 		}
00040c 9508      	RET
                 ;     789 
                 ;     790 
                 ;     791 
                 ;     792 // -------------------- Функции работы с таймером 0 -------------------------------
                 ;     793 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;     794 // Timer/Counter 0 initialization ; Clock source: System Clock
                 ;     795 // Clock value: 31,250 kHz ;  Mode: Normal top=FFh   
                 ;     796 // Используем для контроля за шиной TWI
                 ;     797 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;     798 void timer_0_Init  (void)
                 ;     799 	{
                 _timer_0_Init:
                 ;     800 		ASSR=0x00;
00040d e0e0      	LDI  R30,LOW(0)
00040e bfe0      	OUT  0x30,R30
                 ;     801 		TCCR0=0x0;        //0x06 -start
00040f bfe3      	OUT  0x33,R30
                 ;     802 		TCNT0=0x01;
000410 e0e1      	LDI  R30,LOW(1)
000411 bfe2      	OUT  0x32,R30
                 ;     803 		OCR0=0x00;
000412 e0e0      	LDI  R30,LOW(0)
000413 bfe1      	OUT  0x31,R30
                 ;     804 		TIMSK^=0x01;			// Timer(s)/Counter(s) Interrupt(s) initialization
000414 b7e7      	IN   R30,0x37
000415 e0a1      	LDI  R26,LOW(1)
000416 27ea      	EOR  R30,R26
000417 bfe7      	OUT  0x37,R30
                 ;     805 	}
000418 9508      	RET
                 ;     806 
                 ;     807 // -------------------- Функции работы с таймером 2 -------------------------------
                 ;     808 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;     809 // Timer/Counter 2 initialization;  Clock source: System Clock
                 ;     810 // Clock value: 7,813 kHz ; Mode: Normal top=FFh
                 ;     811 // Используем для таймаута передачи пакетов закрытия
                 ;     812 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;     813 void timer_2_Init  (void)
                 ;     814 	{
                 _timer_2_Init:
                 ;     815 		TCCR2=0x00;
000419 e0e0      	LDI  R30,LOW(0)
00041a bde5      	OUT  0x25,R30
                 ;     816 		TCNT2=0x00;
00041b bde4      	OUT  0x24,R30
                 ;     817 		OCR2=0x00;
00041c bde3      	OUT  0x23,R30
                 ;     818 		TIMSK^=0x40;			// Timer(s)/Counter(s) Interrupt(s) initialization
00041d b7e7      	IN   R30,0x37
00041e e4a0      	LDI  R26,LOW(64)
00041f 940e 2370 	CALL SUBOPT_0x12
                 ;     819 		ETIMSK^=0x00;
000421 e0a0      	LDI  R26,LOW(0)
000422 27ea      	EOR  R30,R26
000423 93e0 007d 	STS  125,R30
                 ;     820 	}                      
000425 9508      	RET
                 ;     821 	
                 ;     822 // -------------------- Функции работы с таймером 3 -------------------------------
                 ;     823 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;     824 // Clock source: System Clock; Clock value: 7,813 kHz
                 ;     825 // Mode: Normal top=FFFFh ;Timer 3 Overflow Interrupt: On
                 ;     826 // Используем для таймаута передачи пакетов закрытия
                 ;     827 ///////////////////////////////////////////////////////////////////////////////////////////////
                 ;     828 void timer_3_Init  (void)
                 ;     829 	{
                 _timer_3_Init:
                 ;     830 		TCCR3A=0x00;
000426 940e 2375 	CALL SUBOPT_0x13
                 ;     831 		TCCR3B=0x05;
                 ;     832 		TCNT3H=0x00;
000428 e0e0      	LDI  R30,LOW(0)
000429 93e0 0089 	STS  137,R30
                 ;     833 		TCNT3L=0xAA;
00042b eaea      	LDI  R30,LOW(170)
00042c 93e0 0088 	STS  136,R30
                 ;     834 		ICR3H=0x00;
00042e e0e0      	LDI  R30,LOW(0)
00042f 93e0 0081 	STS  129,R30
                 ;     835 		ICR3L=0xFF;
000431 efef      	LDI  R30,LOW(255)
000432 93e0 0080 	STS  128,R30
                 ;     836 		OCR3AH=0x00;
000434 e0e0      	LDI  R30,LOW(0)
000435 93e0 0087 	STS  135,R30
                 ;     837 		OCR3AL=0x00;
000437 93e0 0086 	STS  134,R30
                 ;     838 		OCR3BH=0x00;
000439 93e0 0085 	STS  133,R30
                 ;     839 		OCR3BL=0x00;
00043b 93e0 0084 	STS  132,R30
                 ;     840 		OCR3CH=0x00;
00043d 93e0 0083 	STS  131,R30
                 ;     841 		OCR3CL=0x00;
00043f 93e0 0082 	STS  130,R30
                 ;     842 										
                 ;     843 		TIMSK^=0x00;                    // Timer(s)/Counter(s) Interrupt(s) initialization
000441 b7e7      	IN   R30,0x37
000442 e0a0      	LDI  R26,LOW(0)
000443 940e 2370 	CALL SUBOPT_0x12
                 ;     844 		ETIMSK^=0x04;   
000445 e0a4      	LDI  R26,LOW(4)
000446 27ea      	EOR  R30,R26
000447 93e0 007d 	STS  125,R30
                 ;     845 	}
000449 9508      	RET
                 ;     846 
                 ;     847 
                 ;     848 
                 ;     849 // Timer 0 overflow interrupt service routine
                 ;     850 interrupt [TIM0_OVF] void timer0_ovf_isr(void)
                 ;     851 {
                 _timer0_ovf_isr:
00044a 940e 2368 	CALL SUBOPT_0x10
                 ;     852 		TCCR0 = 0x0;						//останавливаем таймер
00044c e0e0      	LDI  R30,LOW(0)
00044d bfe3      	OUT  0x33,R30
                 ;     853 		flagTWI  = flagTWI  | (1 << time_is_Out);	 //взводим признак    
00044e 91e0 0728 	LDS  R30,_flagTWI
000450 60e1      	ORI  R30,1
000451 93e0 0728 	STS  _flagTWI,R30
                 ;     854 
                 ;     855 }
000453 940e 236c 	CALL SUBOPT_0x11
000455 9518      	RETI
                 ;     856                                                                                              
                 ;     857 // Timer 2 overflow interrupt service routine
                 ;     858 interrupt [TIM2_OVF] void timer2_ovf_isr(void)
                 ;     859 {
                 _timer2_ovf_isr:
000456 93ea      	ST   -Y,R30
                 ;     860 		TCCR2 = 0x0; 						// останов таймера 
000457 e0e0      	LDI  R30,LOW(0)
000458 bde5      	OUT  0x25,R30
                 ;     861 }
000459 91e9      	LD   R30,Y+
00045a 9518      	RETI
                 ;     862 
                 ;     863 
                 ;     864 
                 ;     865 // запускаем таймер для таймаута
                 ;     866 void timeOut (void)
                 ;     867 	{
                 ;     868 //		flagTWI  = (flagTWI  ^ (1 << time_is_Out));		// сброс признака
                 ;     869 		TCNT0=0x0	;														// обнуляем счетчик
                 ;     870 		TCCR0 = 0x06;													// пускаем таймер (около 10 мс)
                 ;     871 	}
                 ;     872 
                 ;     873 // остановка таймера для таймаута
                 ;     874 void timeOutStop (void)
                 ;     875 	{
                 ;     876 		TCCR0 = 0x0; 						// осттанов таймера (около 10 мс)
                 ;     877 	}          
                 ;     878 	
                 ;     879 // Timer 3 overflow interrupt service routine
                 ;     880 interrupt [TIM3_OVF] void timer3_ovf_isr(void)
                 ;     881 {
                 _timer3_ovf_isr:
00045b 93aa      	ST   -Y,R26
00045c 93ea      	ST   -Y,R30
00045d b7ef      	IN   R30,SREG
00045e 93ea      	ST   -Y,R30
                 ;     882 		EndTimePack = 1;			// время вышло
00045f 9468      	SET
000460 f820      	BLD  R2,0
                 ;     883 
                 ;     884 						#ifdef print
                 ;     885 						printf ("Timeout Scremb! \r\n");
                 ;     886 						#endif
                 ;     887 		
                 ;     888 
                 ;     889 		TCCR3A=0x00;			// останов таймера 
000461 e0e0      	LDI  R30,LOW(0)
000462 93e0 008b 	STS  139,R30
                 ;     890 		TCCR3B=0x00;
000464 93e0 008a 	STS  138,R30
                 ;     891 		
                 ;     892 		testpin = ~testpin;
000466 94e8      	CLT
000467 9bc7      	SBIS 0x18,7
000468 9468      	SET
000469 b3a8      	IN   R26,0x18
00046a f9a7      	BLD  R26,7
00046b bba8      	OUT  0x18,R26
                 ;     893 		
                 ;     894 }
00046c 91e9      	LD   R30,Y+
00046d bfef      	OUT  SREG,R30
00046e 91e9      	LD   R30,Y+
00046f 91a9      	LD   R26,Y+
000470 9518      	RETI
                 ;     895 
                 ;     896 // запускаем таймер для таймаута пакетов (150mc)
                 ;     897 void timeOutPackStart (void)
                 ;     898 	{
                 _timeOutPackStart:
                 ;     899 		EndTimePack = 0;		// сброс признака
000471 94e8      	CLT
000472 f820      	BLD  R2,0
                 ;     900 		
                 ;     901 //		TCNT3H=0xFF;			// иниц. величины 32мс
                 ;     902 //		TCNT3L=0x00;			// иниц. величины 32мс
                 ;     903 
                 ;     904 //		TCNT3H=0xFC;			// иниц. величины 100мс
                 ;     905 //		TCNT3L=0xF2;        // иниц. величины 100мс
                 ;     906 
                 ;     907 //		TCNT3H=0xFB;			// иниц. величины 150мс
                 ;     908 //		TCNT3L=0x6C;			// иниц. величины 150мс
                 ;     909 
                 ;     910 		TCNT3H=0xF0;			// test
000473 efe0      	LDI  R30,LOW(240)
000474 93e0 0089 	STS  137,R30
                 ;     911 		TCNT3L=0x00;        // test
000476 e0e0      	LDI  R30,LOW(0)
000477 93e0 0088 	STS  136,R30
                 ;     912 
                 ;     913 		TCCR3A=0x00;			// делитель до 7.813кГц
000479 940e 2375 	CALL SUBOPT_0x13
                 ;     914 		TCCR3B=0x05;
                 ;     915 
                 ;     916 
                 ;     917 	}
00047b 9508      	RET
                 ;     918 
                 ;     919 // подменяем ключ в пакете
                 ;     920 void ModifyKey (void)
                 ;     921 {
                 _ModifyKey:
                 ;     922 		u8 a,b;
                 ;     923 		#ifdef print
                 ;     924 		printf ("Modify Key\n\r");
                 ;     925 		#endif
                 ;     926 			
                 ;     927 		#ifdef print
                 ;     928 			for (a=0;a<rx0len;a++) printf ("%x ", rx0buf[a]);
                 ;     929 		#endif
                 ;     930 
                 ;     931 		b=rx0buf [55];
00047c 931a      	ST   -Y,R17
00047d 930a      	ST   -Y,R16
                 ;	a -> R16
                 ;	b -> R17
00047e 9110 065f 	__GETBRMN 17,_rx0buf,55
                 ;     932 		rx0buf[55] = ver_kl;
000480 e5af
000481 e0b6      	__POINTW2MN _rx0buf,55
000482 91e0 0a28 	LDS  R30,_ver_kl
000484 91f0 0a29 	LDS  R31,_ver_kl+1
000486 93ec      	ST   X,R30
                 ;     933 		
                 ;     934 		rx0buf[rx0len] = ((rx0buf[rx0len]-b) +ver_kl);
000487 91e0 0625 	LDS  R30,_rx0len
000489 e0f0      	LDI  R31,0
00048a 5de8      	SUBI R30,LOW(-_rx0buf)
00048b 4ff9      	SBCI R31,HIGH(-_rx0buf)
00048c 010f      	MOVW R0,R30
00048d 81e0      	LD   R30,Z
00048e 1be1      	SUB  R30,R17
00048f 2fae      	MOV  R26,R30
000490 91e0 0a28 	LDS  R30,_ver_kl
000492 91f0 0a29 	LDS  R31,_ver_kl+1
000494 e0b0      	LDI  R27,0
000495 0fea      	ADD  R30,R26
000496 1ffb      	ADC  R31,R27
000497 01d0      	MOVW R26,R0
000498 93ec      	ST   X,R30
                 ;     935 
                 ;     936 		#ifdef print
                 ;     937 			printf("\n\r");
                 ;     938 			for (a=0;a<rx0len;a++) printf ("%x ", rx0buf[a]);
                 ;     939 		#endif
                 ;     940 }
000499 9109      	LD   R16,Y+
00049a 9119      	LD   R17,Y+
00049b 9508      	RET
                 ;     941 
                 ;     942 
                 ;     943 //  проверяем совпадение логических адресов
                 ;     944  unsigned char Logic_Address_Identical (unsigned char Logik_Address, unsigned char device)
                 ;     945  {
                 _Logic_Address_Identical:
                 ;     946 		unsigned char a;
                 ;     947 		
                 ;     948 		for (a=1; a<= int_Devices; a++)				// ищем порт по адресу
00049c 930a      	ST   -Y,R16
                 ;	Logik_Address -> Y+2
                 ;	device -> Y+1
                 ;	a -> R16
00049d e001      	LDI  R16,LOW(1)
                 _0x71:
00049e ebe4      	LDI  R30,LOW(_int_Devices*2)
00049f e0f0      	LDI  R31,HIGH(_int_Devices*2)
0004a0 91e4      	LPM  R30,Z
0004a1 17e0      	CP   R30,R16
0004a2 f068      	BRLO _0x72
                 ;     949 		{
                 ;     950 		 	if (lAddrDevice [a]	== Logik_Address)
0004a3 940e 237c 	CALL SUBOPT_0x14
0004a5 2fae      	MOV  R26,R30
0004a6 81ea      	LDD  R30,Y+2
0004a7 17ea      	CP   R30,R26
0004a8 f429      	BRNE _0x73
                 ;     951 		 	{
                 ;     952 		 		if (a != device) return TRUE;		// есть совпадение
0004a9 81e9      	LDD  R30,Y+1
0004aa 17e0      	CP   R30,R16
0004ab f011      	BREQ _0x74
0004ac e0e1      	LDI  R30,LOW(1)
0004ad c003      	RJMP _0x4E2
                 ;     953 		 	}
                 _0x74:
                 ;     954 		 }	
                 _0x73:
0004ae 5f0f      	SUBI R16,-1
0004af cfee      	RJMP _0x71
                 _0x72:
                 ;     955 
                 ;     956  		return FALSE;
0004b0 e0e0      	LDI  R30,LOW(0)
                 _0x4E2:
0004b1 8108      	LDD  R16,Y+0
0004b2 9623      	ADIW R28,3
0004b3 9508      	RET
                 ;     957  }
                 ;     958 	
                 ;     959  // проверяем и заполняем внутр. таблицу адресов
                 ;     960 void check_incoming_LOG_ADDR (u8 checking_Device)
                 ;     961 {
                 _check_incoming_LOG_ADDR:
                 ;     962 		
                 ;     963 		if ( !( Logic_Address_Identical ( rxBuffer[5], checking_Device ) ) )  //есть ли схожий адрес?
0004b4 91e0 0583 	__GETB1MN _rxBuffer,5
0004b6 93ea      	ST   -Y,R30
0004b7 81e9      	LDD  R30,Y+1
0004b8 93ea      	ST   -Y,R30
0004b9 940e 049c 	CALL _Logic_Address_Identical
0004bb 30e0      	CPI  R30,0
0004bc f429      	BRNE _0x75
                 ;     964 		{
                 ;     965 					#ifdef print
                 ;     966 					printf ("Logic ADDR-%d\r\n",rxBuffer[5]);
                 ;     967 					#endif
                 ;     968 					 lAddrDevice [checking_Device] = rxBuffer[5];
0004bd 940e 2382 	CALL SUBOPT_0x15
0004bf 91e0 0583 	__GETB1MN _rxBuffer,5
0004c1 c003      	RJMP _0x4EA
                 ;     969 		}
                 ;     970 		else		 lAddrDevice [checking_Device] = 0;                                                                                
                 _0x75:
0004c2 940e 2382 	CALL SUBOPT_0x15
0004c4 e0e0      	LDI  R30,LOW(0)
                 _0x4EA:
0004c5 93ec      	ST   X,R30
                 ;     971 
                 ;     972 // обновляем зеркало портов
                 ;     973 		 if (! lAddrDevice [checking_Device])	reflection_active_PORTS &= ((1 << (checking_Device - 1)) ^ -1);
0004c6 81e8      	LD   R30,Y
0004c7 e0f0      	LDI  R31,0
0004c8 50e3      	SUBI R30,LOW(-_lAddrDevice)
0004c9 4ffa      	SBCI R31,HIGH(-_lAddrDevice)
0004ca 81e0      	LD   R30,Z
0004cb 30e0      	CPI  R30,0
0004cc f431      	BRNE _0x77
0004cd 940e 2387 	CALL SUBOPT_0x16
0004cf efaf      	LDI  R26,LOW(255)
0004d0 27ea      	EOR  R30,R26
0004d1 228e      	AND  R8,R30
                 ;     974 		 else													reflection_active_PORTS |= (1 << (checking_Device - 1));		
0004d2 c003      	RJMP _0x78
                 _0x77:
0004d3 940e 2387 	CALL SUBOPT_0x16
0004d5 2a8e      	OR   R8,R30
                 ;     975 }
                 _0x78:
                 _0x4E1:
0004d6 9621      	ADIW R28,1
0004d7 9508      	RET
                 ;     976 ///////////////////////////////////////////////////////
                 ;     977 // Секция работы с CF CARD
                 ;     978 
                 ;     979 #include "Coding.h"    
                 ;     980 
                 ;     981 #define FLASH_command 	rx0buf[0]
                 ;     982 #define appendAbon			1						// добавить абонента 
                 ;     983 #define deleteAbon			2						// удалить абонента
                 ;     984 #define pack_for_scremb	3						// пакет кодеру
                 ;     985 #define pack_readAbons	4						// прочитать разрешения абонента
                 ;     986 
                 ;     987 FILE * fu_user = NULL;	//обьявляется переменная для указателя входного файла s userami
                 
                 	.DSEG
                 _fu_user:
000729           	.BYTE 0x2
                 ;     988 
                 ;     989 
                 ;     990 // Копируем принятый пакет prog.bin в ЕЕПРОМ 
                 ;     991 void check_fprog (void)
                 ;     992 {
                 
                 	.CSEG
                 _check_fprog:
                 ;     993 	u8 temp = 0;
                 ;     994 	eefprog = f_buff_prog; 
0004d8 930a      	ST   -Y,R16
                 ;	temp -> R16
0004d9 e000      	LDI  R16,0
0004da e0e5      	LDI  R30,LOW(_f_buff_prog)
0004db e0f0      	LDI  R31,HIGH(_f_buff_prog)
0004dc 012f      	MOVW R4,R30
                 ;     995 		
                 ;     996 	while (temp ++ < len_prog_bin)
                 _0x7A:
0004dd 2fa0      	MOV  R26,R16
0004de 5f0f      	SUBI R16,-1
0004df 37ac      	CPI  R26,LOW(0x7C)
0004e0 f440      	BRSH _0x7C
                 ;     997 	{
                 ;     998 		*eefprog ++ = rx0buf [temp];
0004e1 940e 238d 	CALL SUBOPT_0x17
0004e3 2fe0      	MOV  R30,R16
0004e4 940e 2393 	CALL SUBOPT_0x18
0004e6 940e 2a95 	CALL __EEPROMWRB
                 ;     999 /*		#ifdef print
                 ;    1000 		printf("dann=%02x ",rx0buf [temp]);
                 ;    1001  		#endif       */
                 ;    1002 	}
0004e8 cff4      	RJMP _0x7A
                 _0x7C:
                 ;    1003 }
0004e9 c032      	RJMP _0x4E0
                 ;    1004 
                 ;    1005 
                 ;    1006 typedef union
                 ;    1007 {
                 ;    1008 	u32 w;
                 ;    1009 	u8 b[4];
                 ;    1010 } B2DW;
                 ;    1011 
                 ;    1012 // преобразовываем 4байта в 1 слово (32бит)
                 ;    1013 u32 convTOw32 (u8 *pConv)
                 ;    1014 {
                 _convTOw32:
                 ;    1015 	B2DW out_W;  
                 ;    1016 	
                 ;    1017 	out_W.b[0] = *pConv++;			// 
0004ea 9724      	SBIW R28,4
                 ;	*pConv -> Y+4
                 ;	out_W -> Y+0
0004eb 940e 2398 	CALL SUBOPT_0x19
0004ed 83e8      	ST   Y,R30
                 ;    1018 	out_W.b[1] = *pConv++;
0004ee 940e 2398 	CALL SUBOPT_0x19
0004f0 83e9      	STD  Y+1,R30
                 ;    1019 	out_W.b[2] = *pConv++;
0004f1 940e 2398 	CALL SUBOPT_0x19
0004f3 83ea      	STD  Y+2,R30
                 ;    1020 	out_W.b[3] = *pConv;        
0004f4 81ac      	LDD  R26,Y+4
0004f5 81bd      	LDD  R27,Y+4+1
0004f6 91ec      	LD   R30,X
0004f7 83eb      	STD  Y+3,R30
                 ;    1021 
                 ;    1022 	return out_W.w;
0004f8 81e8
0004f9 81f9
0004fa 816a
0004fb 817b      	__GETD1S 0
0004fc c08f      	RJMP _0x4DF
                 ;    1023 }
                 ;    1024 
                 ;    1025 
                 ;    1026 
                 ;    1027 // форматируем карточку
                 ;    1028 u8 format_CF (void)
                 ;    1029 {  
                 ;    1030 		#ifdef print
                 ;    1031 		printf ("Format CF... ");
                 ;    1032 		#endif
                 ;    1033 	if (fquickformat() == EOF)
                 ;    1034 	{
                 ;    1035 		#ifdef print
                 ;    1036 		printf ("ERROR \r\n");
                 ;    1037 		#endif
                 ;    1038 		 return FALSE; 
                 ;    1039 	 }
                 ;    1040 	else
                 ;    1041 	{
                 ;    1042 		#ifdef print
                 ;    1043 		printf ("OK \r\n");
                 ;    1044 		#endif
                 ;    1045 
                 ;    1046 		 return TRUE;           
                 ;    1047 	 }
                 ;    1048 }                       
                 ;    1049 
                 ;    1050 
                 ;    1051 
                 ;    1052 // добавить / изменить запись
                 ;    1053 u8 append_abons (void)
                 ;    1054 {
                 _append_abons:
                 ;    1055 	u8 temp;
                 ;    1056 	
                 ;    1057 	for (temp = 0; temp < dann_1_abon; temp++)
0004fd 930a      	ST   -Y,R16
                 ;	temp -> R16
0004fe e000      	LDI  R16,LOW(0)
                 _0x80:
0004ff 3804      	CPI  R16,132
000500 f460      	BRSH _0x81
                 ;    1058 	{
                 ;    1059 		if ((fputc (rx0buf[temp+9], fu_user)) == EOF) return FALSE;
000501 2fe0      	MOV  R30,R16
000502 e0f0      	LDI  R31,0
000503 5cef
000504 4ff9      	__ADDW1MN _rx0buf,9
000505 81e0      	LD   R30,Z
000506 940e 239e 	CALL SUBOPT_0x1A
000508 f411      	BRNE _0x82
000509 e0e0      	LDI  R30,LOW(0)
00050a c011      	RJMP _0x4E0
                 ;    1060 	}
                 _0x82:
00050b 5f0f      	SUBI R16,-1
00050c cff2      	RJMP _0x80
                 _0x81:
                 ;    1061 	
                 ;    1062 		#ifdef print
                 ;    1063 		printf ("Append abons \r\n");
                 ;    1064 		#endif
                 ;    1065 
                 ;    1066 	return TRUE;
00050d e0e1      	LDI  R30,LOW(1)
00050e c00d      	RJMP _0x4E0
                 ;    1067 }                                                  
                 ;    1068 
                 ;    1069 // удалить запись                           
                 ;    1070 u8 delete_abons (void)
                 ;    1071 {                    
                 _delete_abons:
                 ;    1072 	u8 temp;
                 ;    1073 	
                 ;    1074 
                 ;    1075 	for (temp = 0; temp < 4; temp++)
00050f 930a      	ST   -Y,R16
                 ;	temp -> R16
000510 e000      	LDI  R16,LOW(0)
                 _0x84:
000511 3004      	CPI  R16,4
000512 f440      	BRSH _0x85
                 ;    1076 	{
                 ;    1077 		if ((fputc (0xFF, fu_user)) == EOF) return FALSE;
000513 efef      	LDI  R30,LOW(255)
000514 940e 239e 	CALL SUBOPT_0x1A
000516 f411      	BRNE _0x86
000517 e0e0      	LDI  R30,LOW(0)
000518 c003      	RJMP _0x4E0
                 ;    1078 	}                               
                 _0x86:
000519 5f0f      	SUBI R16,-1
00051a cff6      	RJMP _0x84
                 _0x85:
                 ;    1079 	
                 ;    1080 		#ifdef print
                 ;    1081 		printf ("Del abons \r\n");
                 ;    1082 		#endif
                 ;    1083 
                 ;    1084 	
                 ;    1085 	return TRUE;
00051b e0e1      	LDI  R30,LOW(1)
                 _0x4E0:
00051c 9109      	LD   R16,Y+
00051d 9508      	RET
                 ;    1086 }
                 ;    1087 
                 ;    1088 // внести запись о количестве абонентов
                 ;    1089 u8 define_abons (void)
                 ;    1090 {
                 _define_abons:
                 ;    1091 
                 ;    1092 	if (fseek (fu_user,0,SEEK_SET) != EOF) 
00051e 940e 23ab 	CALL SUBOPT_0x1B
000520 f0b1      	BREQ _0x87
                 ;    1093 	{
                 ;    1094 		if ((fputc (rx0buf[1], fu_user)) != EOF) 
000521 91e0 0629 	__GETB1MN _rx0buf,1
000523 940e 239e 	CALL SUBOPT_0x1A
000525 f089      	BREQ _0x88
                 ;    1095 			if ((fputc (rx0buf[2], fu_user)) != EOF) 
000526 91e0 062a 	__GETB1MN _rx0buf,2
000528 940e 239e 	CALL SUBOPT_0x1A
00052a f061      	BREQ _0x89
                 ;    1096 				if ((fputc (rx0buf[3], fu_user)) != EOF) 
00052b 91e0 062b 	__GETB1MN _rx0buf,3
00052d 940e 239e 	CALL SUBOPT_0x1A
00052f f039      	BREQ _0x8A
                 ;    1097 					if ((fputc (rx0buf[4], fu_user)) != EOF)
000530 91e0 062c 	__GETB1MN _rx0buf,4
000532 940e 239e 	CALL SUBOPT_0x1A
000534 f011      	BREQ _0x8B
                 ;    1098 					{
                 ;    1099 						#ifdef print
                 ;    1100 						printf ("WR count abons \r\n");
                 ;    1101 						#endif
                 ;    1102 
                 ;    1103 						return TRUE;
000535 e0e1      	LDI  R30,LOW(1)
000536 9508      	RET
                 ;    1104 					}
                 ;    1105 	}
                 _0x8B:
                 _0x8A:
                 _0x89:
                 _0x88:
                 ;    1106 
                 ;    1107 	return FALSE;
                 _0x87:
000537 e0e0      	LDI  R30,LOW(0)
000538 9508      	RET
                 ;    1108 
                 ;    1109 }
                 ;    1110 
                 ;    1111 
                 ;    1112 // поиск позиции в файле. 
                 ;    1113 u8 found_location_in_file (u8 *pLoc)
                 ;    1114 {
                 _found_location_in_file:
                 ;    1115   	u32 position = 0;
                 ;    1116 
                 ;    1117 /*	position = ( 													// позиция в файле
                 ;    1118 					((position | rx0buf[8]) <<24) |
                 ;    1119      				((position | rx0buf[7]) <<16) |
                 ;    1120 					((position | rx0buf[6]) << 8) |
                 ;    1121 					  (position | rx0buf[5]) );  
                 ;    1122   */
                 ;    1123 	position = convTOw32 (pLoc);				// получаем 32 разр указатель на позицию
000539 9724      	SBIW R28,4
00053a e084      	LDI  R24,4
00053b e0a0      	LDI  R26,LOW(0)
00053c e0b0      	LDI  R27,HIGH(0)
00053d ebee      	LDI  R30,LOW(_0x8C*2)
00053e e0f0      	LDI  R31,HIGH(_0x8C*2)
00053f 940e 2aca 	CALL __INITLOCB
                 ;	*pLoc -> Y+4
                 ;	position -> Y+0
000541 81ec      	LDD  R30,Y+4
000542 81fd      	LDD  R31,Y+4+1
000543 93fa      	ST   -Y,R31
000544 93ea      	ST   -Y,R30
000545 940e 04ea 	CALL _convTOw32
000547 83e8
000548 83f9
000549 836a
00054a 837b      	__PUTD1S 0
                 ;    1124 
                 ;    1125 	position = ((position - 1) * dann_1_abon) + 4;		//пропускаем начальные 4 байта
00054b 940e 23bf 	CALL SUBOPT_0x1C
00054d 83e8
00054e 83f9
00054f 836a
000550 837b      	__PUTD1S 0
                 ;    1126 
                 ;    1127 	//если надо то добиваем до нужной позиции 0XFF
                 ;    1128 	while  ( ftell (fu_user) < position)
                 _0x8D:
000551 940e 23ce 	CALL SUBOPT_0x1D
000553 01df      	MOVW R26,R30
000554 01cb      	MOVW R24,R22
000555 81e8
000556 81f9
000557 816a
000558 817b      	__GETD1S 0
000559 940e 2ab7 	CALL __CPD21
00055b f420      	BRSH _0x8F
                 ;    1129 	{
                 ;    1130 		fputc (0xFF,fu_user);							
00055c efef      	LDI  R30,LOW(255)
00055d 940e 23d6 	CALL SUBOPT_0x1E
                 ;    1131 	}
00055f cff1      	RJMP _0x8D
                 _0x8F:
                 ;    1132 	
                 ;    1133 
                 ;    1134 	if ( ! define_abons()) return FALSE;				// вносим запись о количестве абонентов
000560 940e 051e 	CALL _define_abons
000562 30e0      	CPI  R30,0
000563 f411      	BRNE _0x90
000564 e0e0      	LDI  R30,LOW(0)
000565 c026      	RJMP _0x4DF
                 ;    1135 
                 ;    1136 	if (fseek (fu_user,position,SEEK_SET) == EOF) return FALSE; //смещение
                 _0x90:
000566 91e0 0729 	LDS  R30,_fu_user
000568 91f0 072a 	LDS  R31,_fu_user+1
00056a 93fa      	ST   -Y,R31
00056b 93ea      	ST   -Y,R30
00056c 81ea
00056d 81fb
00056e 816c
00056f 817d      	__GETD1S 2
000570 940e 23df 	CALL SUBOPT_0x1F
000572 f411      	BRNE _0x91
000573 e0e0      	LDI  R30,LOW(0)
000574 c017      	RJMP _0x4DF
                 ;    1137 
                 ;    1138 		#ifdef print
                 ;    1139 		printf ("Position found-%x \r\n",position);
                 ;    1140 		#endif
                 ;    1141 
                 ;    1142 	switch (FLASH_command)
                 _0x91:
000575 91e0 0628 	LDS  R30,_rx0buf
                 ;    1143 	{
                 ;    1144 		case appendAbon:
000577 30e1      	CPI  R30,LOW(0x1)
000578 f439      	BRNE _0x95
                 ;    1145 				if ( ! append_abons ()) return FALSE;		// добавить/изменить запись
000579 940e 04fd 	CALL _append_abons
00057b 30e0      	CPI  R30,0
00057c f411      	BRNE _0x96
00057d e0e0      	LDI  R30,LOW(0)
00057e c00d      	RJMP _0x4DF
                 ;    1146 				break;
                 _0x96:
00057f c00b      	RJMP _0x94
                 ;    1147 
                 ;    1148 		case deleteAbon:
                 _0x95:
000580 30e2      	CPI  R30,LOW(0x2)
000581 f439      	BRNE _0x99
                 ;    1149 				if ( ! delete_abons ()) return FALSE;		// удалить запись
000582 940e 050f 	CALL _delete_abons
000584 30e0      	CPI  R30,0
000585 f411      	BRNE _0x98
000586 e0e0      	LDI  R30,LOW(0)
000587 c004      	RJMP _0x4DF
                 ;    1150 				break;
                 _0x98:
000588 c002      	RJMP _0x94
                 ;    1151 
                 ;    1152 		default:
                 _0x99:
                 ;    1153 				return FALSE;
000589 e0e0      	LDI  R30,LOW(0)
00058a c001      	RJMP _0x4DF
                 ;    1154 	}
                 _0x94:
                 ;    1155 
                 ;    1156 	return TRUE;
00058b e0e1      	LDI  R30,LOW(1)
                 _0x4DF:
00058c 9626      	ADIW R28,6
00058d 9508      	RET
                 ;    1157 }
                 ;    1158 
                 ;    1159 // закрываем файл
                 ;    1160 u8 close_prog_bin (void)
                 ;    1161 {
                 _close_prog_bin:
                 ;    1162 
                 ;    1163 	if (fclose (fu_user) == EOF) return FALSE;											// закрываем файл
00058e 91e0 0729 	LDS  R30,_fu_user
000590 91f0 072a 	LDS  R31,_fu_user+1
000592 93fa      	ST   -Y,R31
000593 93ea      	ST   -Y,R30
000594 940e 163c 	CALL _fclose
000596 3fef      	CPI  R30,LOW(0xFFFF)
000597 efaf      	LDI  R26,HIGH(0xFFFF)
000598 07fa      	CPC  R31,R26
000599 f411      	BRNE _0x9A
00059a e0e0      	LDI  R30,LOW(0)
00059b 9508      	RET
                 ;    1164 
                 ;    1165 	#ifdef print
                 ;    1166 	printf ("File CLOSE \r\n");
                 ;    1167 	#endif
                 ;    1168 
                 ;    1169 	return TRUE;
                 _0x9A:
00059c e0e1      	LDI  R30,LOW(1)
00059d 9508      	RET
                 ;    1170 	
                 ;    1171 }
                 ;    1172 
                 ;    1173 
                 ;    1174 // Открываем файл для чтения / записи
                 ;    1175 u8 open_user_bin (u8 mode)
                 ;    1176 {
                 _open_user_bin:
                 ;    1177 	u8 temp = 4;
                 ;    1178 
                 ;    1179 	if (prog_bin_mode != (mode & 0x1)) close_prog_bin ();	// закрываем файл при изменении режима
00059e 930a      	ST   -Y,R16
                 ;	mode -> Y+1
                 ;	temp -> R16
00059f e004      	LDI  R16,4
0005a0 e0e0      	LDI  R30,0
0005a1 fc23      	SBRC R2,3
0005a2 e0e1      	LDI  R30,1
0005a3 2fae      	MOV  R26,R30
0005a4 81e9      	LDD  R30,Y+1
0005a5 70e1      	ANDI R30,LOW(0x1)
0005a6 17ea      	CP   R30,R26
0005a7 f019      	BREQ _0x9B
0005a8 940e 058e 	CALL _close_prog_bin
                 ;    1180 	else 
0005aa c00c      	RJMP _0x9C
                 _0x9B:
                 ;    1181 	{
                 ;    1182 		if ( ftell(fu_user) != EOF )	return TRUE;					// иначе проверяем есть ли файл и выходим если есть
0005ab 940e 23ce 	CALL SUBOPT_0x1D
0005ad 3fef
0005ae efaf
0005af 07fa
0005b0 efaf
0005b1 076a
0005b2 efaf
0005b3 077a      	__CPD1N 0xFFFFFFFF
0005b4 f011      	BREQ _0x9D
0005b5 e0e1      	LDI  R30,LOW(1)
0005b6 c030      	RJMP _0x4DE
                 ;    1183 	}
                 _0x9D:
                 _0x9C:
                 ;    1184 
                 ;    1185 	if ( mode == rd_file)
0005b7 81e9      	LDD  R30,Y+1
0005b8 30e0      	CPI  R30,0
0005b9 f451      	BRNE _0x9E
                 ;    1186 	{
                 ;    1187 		fu_user = fopenc("user.bin", READ);			
0005ba eee7
0005bb e0f1      	__POINTW1FN _0,15
0005bc 940e 23e9 	CALL SUBOPT_0x20
0005be 940e 23ee 	CALL SUBOPT_0x21
                 ;    1188 
                 ;    1189 		if (fu_user == NULL)												
0005c0 f411      	BRNE _0x9F
                 ;    1190 		{
                 ;    1191 			#ifdef print
                 ;    1192 			printf ("Open ERROR! \r\n");
                 ;    1193 			#endif
                 ;    1194 			return FALSE;
0005c1 e0e0      	LDI  R30,LOW(0)
0005c2 c024      	RJMP _0x4DE
                 ;    1195 		}
                 ;    1196 
                 ;    1197 		#ifdef print
                 ;    1198 		printf ("File OPEN read \r\n");
                 ;    1199 		#endif
                 ;    1200 
                 ;    1201 	}
                 _0x9F:
                 ;    1202 	else
0005c3 c01f      	RJMP _0xA0
                 _0x9E:
                 ;    1203 	{
                 ;    1204 		fu_user = fopenc("user.bin", APPEND);			
0005c4 eee7
0005c5 e0f1      	__POINTW1FN _0,15
0005c6 93fa      	ST   -Y,R31
0005c7 93ea      	ST   -Y,R30
0005c8 e0e3      	LDI  R30,LOW(3)
0005c9 93ea      	ST   -Y,R30
0005ca 940e 23ee 	CALL SUBOPT_0x21
                 ;    1205 
                 ;    1206 		if (fu_user == NULL)												
0005cc f4b1      	BRNE _0xA1
                 ;    1207 		{
                 ;    1208 			#ifdef print
                 ;    1209 			printf ("Create NEW file \r\n");
                 ;    1210 			#endif
                 ;    1211 
                 ;    1212 //			if (fquickformat() == EOF) return FALSE;		//перед созданием файла форматируем карту
                 ;    1213 			fu_user = fcreatec ("user.bin",0);
0005cd eee7
0005ce e0f1      	__POINTW1FN _0,15
0005cf 940e 23f6 	CALL SUBOPT_0x22
0005d1 940e 14f3 	CALL _fcreatec
0005d3 93e0 0729 	STS  _fu_user,R30
0005d5 93f0 072a 	STS  _fu_user+1,R31
                 ;    1214 
                 ;    1215 			if (fu_user == NULL )                                 // ошибка
0005d7 9730      	SBIW R30,0
0005d8 f411      	BRNE _0xA2
                 ;    1216 				return FALSE;
0005d9 e0e0      	LDI  R30,LOW(0)
0005da c00c      	RJMP _0x4DE
                 ;    1217 
                 ;    1218 			while ( temp--)  	fputc (0x00,fu_user);							// место для количества абонентов
                 _0xA2:
                 _0xA3:
0005db 2fe0      	MOV  R30,R16
0005dc 5001      	SUBI R16,1
0005dd 30e0      	CPI  R30,0
0005de f021      	BREQ _0xA5
0005df e0e0      	LDI  R30,LOW(0)
0005e0 940e 23d6 	CALL SUBOPT_0x1E
                 ;    1219 		}                                             
0005e2 cff8      	RJMP _0xA3
                 _0xA5:
                 ;    1220         
                 ;    1221 		#ifdef print
                 ;    1222 		printf ("File OPEN write \r\n");
                 ;    1223 		#endif
                 ;    1224 
                 ;    1225 	}
                 _0xA1:
                 _0xA0:
                 ;    1226 	
                 ;    1227 	prog_bin_mode = mode & 0x1;
0005e3 81e9      	LDD  R30,Y+1
0005e4 fbe0      	BST  R30,0
0005e5 f823      	BLD  R2,3
                 ;    1228 
                 ;    1229 	return TRUE;
0005e6 e0e1      	LDI  R30,LOW(1)
                 _0x4DE:
0005e7 8108      	LDD  R16,Y+0
0005e8 9622      	ADIW R28,2
0005e9 9508      	RET
                 ;    1230 }
                 ;    1231 
                 ;    1232 
                 ;    1233 //Читаем состояние абонента
                 ;    1234 // Входной параметр - MAC абонета, выходной - указатель на 
                 ;    1235 // сторку с разрешениями
                 ;    1236 u8 read_abons (u32 MACabons)
                 ;    1237 {
                 _read_abons:
                 ;    1238   	u32 position = 0;			// позиция в файле
                 ;    1239   	u32 pos = 0+1;	
                 ;    1240   	u32 a;			      
                 ;    1241 	u32 	countAbons;
                 ;    1242 
                 ;    1243 
                 ;    1244   	MACabons = (MACabons - 1)*2;
0005ea 9760      	SBIW R28,16
0005eb e088      	LDI  R24,8
0005ec e0a8      	LDI  R26,LOW(8)
0005ed e0b0      	LDI  R27,HIGH(8)
0005ee ece2      	LDI  R30,LOW(_0xA6*2)
0005ef e0f0      	LDI  R31,HIGH(_0xA6*2)
0005f0 940e 2aca 	CALL __INITLOCB
                 ;	MACabons -> Y+16
                 ;	position -> Y+12
                 ;	pos -> Y+8
                 ;	a -> Y+4
                 ;	countAbons -> Y+0
0005f2 89e8
0005f3 89f9
0005f4 896a
0005f5 897b      	__GETD1S 16
0005f6 50e1
0005f7 40f0
0005f8 4060
0005f9 4070      	__SUBD1N 1
0005fa 940e 29ac 	CALL __LSLD1
0005fc 8be8
0005fd 8bf9
0005fe 8b6a
0005ff 8b7b      	__PUTD1S 16
                 ;    1245 
                 ;    1246 	if ( open_user_bin (rd_file) )	 		// проверяем файл
000600 940e 2338 	CALL SUBOPT_0x8
000602 30e0      	CPI  R30,0
000603 f411      	BRNE PC+3
000604 940c 06bb 	JMP _0xA7
                 ;    1247 	{
                 ;    1248 		countAbons = getAbons ();			// количество введенных абонентов	
000606 940e 1ab5 	CALL _getAbons
000608 83e8
000609 83f9
00060a 836a
00060b 837b      	__PUTD1S 0
                 ;    1249 
                 ;    1250 		while ( countAbons --)
                 _0xA8:
00060c 81e8
00060d 81f9
00060e 816a
00060f 817b      	__GETD1S 0
000610 9731      	SBIW R30,1
000611 4060      	SBCI R22,0
000612 4070      	SBCI R23,0
000613 83e8
000614 83f9
000615 836a
000616 837b      	__PUTD1S 0
000617 5fef
000618 4fff
000619 4f6f
00061a 4f7f      	__SUBD1N -1
00061b f411      	BRNE PC+3
00061c 940c 06bb 	JMP _0xAA
                 ;    1251 		{
                 ;    1252 			position = pos++;				// получаем 32 разр указатель на позицию
00061e 85e8
00061f 85f9
000620 856a
000621 857b      	__GETD1S 8
000622 5fef
000623 4fff
000624 4f6f
000625 4f7f      	__SUBD1N -1
000626 87e8
000627 87f9
000628 876a
000629 877b      	__PUTD1S 8
00062a 9731      	SBIW R30,1
00062b 4060      	SBCI R22,0
00062c 4070      	SBCI R23,0
00062d 87ec
00062e 87fd
00062f 876e
000630 877f      	__PUTD1S 12
                 ;    1253 			position = ((position - 1) * dann_1_abon) + 4;		//пропускаем начальные 4 байта
000631 940e 23bf 	CALL SUBOPT_0x1C
000633 87ec
000634 87fd
000635 876e
000636 877f      	__PUTD1S 12
                 ;    1254 
                 ;    1255 			if ( fseek (fu_user,position,SEEK_SET) != EOF)  //смещение
000637 91e0 0729 	LDS  R30,_fu_user
000639 91f0 072a 	LDS  R31,_fu_user+1
00063b 93fa      	ST   -Y,R31
00063c 93ea      	ST   -Y,R30
00063d 85ee
00063e 85ff
00063f 8968
000640 8979      	__GETD1S 14
000641 940e 23df 	CALL SUBOPT_0x1F
000643 f411      	BRNE PC+3
000644 940c 06ba 	JMP _0xAB
                 ;    1256 			{
                 ;    1257 					a = fgetc(fu_user);
000646 940e 23fb 	CALL SUBOPT_0x23
000648 940e 29bb 	CALL __CWD1
00064a 83ec
00064b 83fd
00064c 836e
00064d 837f      	__PUTD1S 4
                 ;    1258 					a |= fgetc(fu_user)*256;
00064e 940e 23fb 	CALL SUBOPT_0x23
000650 940e 2403 	CALL SUBOPT_0x24
                 ;    1259 					a |= fgetc(fu_user)*256*256;
000652 940e 23fb 	CALL SUBOPT_0x23
000654 2ffe      	MOV  R31,R30
000655 e0e0      	LDI  R30,0
000656 2ffe      	MOV  R31,R30
000657 e0e0      	LDI  R30,0
000658 81ac
000659 81bd
00065a 818e
00065b 819f      	__GETD2S 4
00065c 940e 29bb 	CALL __CWD1
00065e 940e 2970 	CALL __ORD12
000660 83ec
000661 83fd
000662 836e
000663 837f      	__PUTD1S 4
                 ;    1260 					a |= fgetc(fu_user)*256*256*256;         
000664 940e 23fb 	CALL SUBOPT_0x23
000666 2ffe      	MOV  R31,R30
000667 e0e0      	LDI  R30,0
000668 2ffe      	MOV  R31,R30
000669 e0e0      	LDI  R30,0
00066a 940e 2403 	CALL SUBOPT_0x24
                 ;    1261 
                 ;    1262 					if (a == MACabons)
00066c 89e8
00066d 89f9
00066e 896a
00066f 897b      	__GETD1S 16
000670 81ac
000671 81bd
000672 818e
000673 819f      	__GETD2S 4
000674 940e 2ab2 	CALL __CPD12
000676 f011      	BREQ PC+3
000677 940c 06ba 	JMP _0xAC
                 ;    1263 					{
                 ;    1264 						StartReply(dann_1_abon);         		// передаем
000679 e8e4      	LDI  R30,LOW(132)
00067a 93ea      	ST   -Y,R30
00067b 940e 033a 	CALL _StartReply
                 ;    1265 
                 ;    1266 						putchar0(a);						// MAC адрес
00067d 81ec      	LDD  R30,Y+4
00067e 940e 2412 	CALL SUBOPT_0x25
                 ;    1267 						putchar0(a>>8);
000680 e0e8      	LDI  R30,LOW(8)
000681 940e 241a 	CALL SUBOPT_0x26
                 ;    1268 						putchar0(a>>16);
000683 81ec
000684 81fd
000685 816e
000686 817f      	__GETD1S 4
000687 940e 29b1 	CALL __LSRD16
000689 940e 2412 	CALL SUBOPT_0x25
                 ;    1269 						putchar0(a>>24);
00068b e1e8      	LDI  R30,LOW(24)
00068c 940e 241a 	CALL SUBOPT_0x26
                 ;    1270 
                 ;    1271 	 					for (a = 0; a<(dann_1_abon - 4); a ++)		// данные
00068e e0e0
00068f 83ec
000690 83ed
000691 83ee
000692 83ef      	__CLRD1S 4
                 _0xAE:
000693 81ac
000694 81bd
000695 818e
000696 819f      	__GETD2S 4
000697 38a0
000698 e0e0
000699 07be
00069a e0e0
00069b 078e
00069c e0e0
00069d 079e      	__CPD2N 0x80
00069e f4b8      	BRSH _0xAF
                 ;    1272 						{
                 ;    1273 							if (feof(fu_user)) 
00069f 940e 241f 	CALL SUBOPT_0x27
0006a1 f011      	BREQ _0xB0
                 ;    1274 							{
                 ;    1275 								putchar0 (0);
0006a2 e0e0      	LDI  R30,LOW(0)
0006a3 c002      	RJMP _0x4EB
                 ;    1276 								#ifdef print
                 ;    1277 								printf ("Error READ! \r\n");
                 ;    1278 								#endif    
                 ;    1279 							}
                 ;    1280 							else
                 _0xB0:
                 ;    1281 							{
                 ;    1282 //								#ifdef print
                 ;    1283 //								printf ("%x ",fgetc(fu_user));
                 ;    1284 //								#endif    
                 ;    1285 
                 ;    1286 								putchar0(fgetc(fu_user));
0006a4 940e 23fb 	CALL SUBOPT_0x23
                 _0x4EB:
0006a6 93ea      	ST   -Y,R30
0006a7 940e 0330 	CALL _putchar0
                 ;    1287 							}
                 ;    1288 						}
0006a9 81ec
0006aa 81fd
0006ab 816e
0006ac 817f      	__GETD1S 4
0006ad 5fef
0006ae 4fff
0006af 4f6f
0006b0 4f7f      	__SUBD1N -1
0006b1 83ec
0006b2 83fd
0006b3 836e
0006b4 837f      	__PUTD1S 4
0006b5 cfdd      	RJMP _0xAE
                 _0xAF:
                 ;    1289 						EndReply();
0006b6 940e 0344 	CALL _EndReply
                 ;    1290 						return TRUE;
0006b8 e0e1      	LDI  R30,LOW(1)
0006b9 c002      	RJMP _0x4DD
                 ;    1291 					}
                 ;    1292 			}
                 _0xAC:
                 ;    1293 		}
                 _0xAB:
0006ba cf51      	RJMP _0xA8
                 _0xAA:
                 ;    1294 	
                 ;    1295 		#ifdef print
                 ;    1296 		printf ("readAbons NOT Found! \r\n");
                 ;    1297 		#endif    
                 ;    1298 
                 ;    1299     }
                 ;    1300 	return FALSE;
                 _0xA7:
0006bb e0e0      	LDI  R30,LOW(0)
                 _0x4DD:
0006bc 9664      	ADIW R28,20
0006bd 9508      	RET
                 ;    1301 }
                 ;    1302 
                 ;    1303 
                 ;    1304 
                 ;    1305 
                 ;    1306 ///////////////////////////////////////////////////////////////////
                 ;    1307 // Формат входного пакета: 
                 ;    1308 //		1 - номер задания (	1 - добавить абонента, 
                 ;    1309 //										2 - удалить абонента, 
                 ;    1310 //										3 - передается список каналов(кодирован/некодирован)
                 ;    1311 //										4 - прочитать разрешения абонента (передан  4b MAC);
                 ;    1312 //										5 - процесс заливки файла в АРМ процессоре на карточку
                 ;    1313 //										)
                 ;    1314 //		2...5 - максимальное значение номера места;
                 ;    1315 //		6...9 - номер места куда произвести запись;
                 ;    1316 //		10...13 - МАС адрес абонента;
                 ;    1317 //		14...137 - содержимое для передачи в канал;
                 ;    1318 //  Как хранится на карте - 	1...4 - максимальное значение номера места;
                 ;    1319 //												5...8 -  МАС адрес абонента;
                 ;    1320 //												9...132 - содержимое для передачи в канал;
                 ;    1321 
                 ;    1322 void flash_Work (void)
                 ;    1323 {  
                 _flash_Work:
                 ;    1324 //	u8 status = TRUE;  	
                 ;    1325   
                 ;    1326 	if ( ! CF_card_INI_OK ) Reply(FALSE);	// CF карта не готова 
0006be fc22      	SBRC R2,2
0006bf c003      	RJMP _0xB2
0006c0 940e 234b 	CALL SUBOPT_0xB
                 ;    1327 	else
0006c2 c03b      	RJMP _0xB3
                 _0xB2:
                 ;    1328 	{
                 ;    1329 		switch (FLASH_command)
0006c3 91e0 0628 	LDS  R30,_rx0buf
                 ;    1330 		{
                 ;    1331 			case appendAbon:							// работаем с пакетами юзеров
0006c5 30e1      	CPI  R30,LOW(0x1)
0006c6 f011      	BREQ _0xB8
                 ;    1332 			case deleteAbon:							// открываем базу. Если файла нет - создаем.
0006c7 30e2      	CPI  R30,LOW(0x2)
0006c8 f4e1      	BRNE _0xB9
                 _0xB8:
                 ;    1333 				#ifdef print
                 ;    1334 				printf ("Rx pack user.bin \r\n");
                 ;    1335 				#endif    
                 ;    1336 				if ( open_user_bin (wr_file) ) 
0006c9 e0e1      	LDI  R30,LOW(1)
0006ca 93ea      	ST   -Y,R30
0006cb 940e 059e 	CALL _open_user_bin
0006cd 30e0      	CPI  R30,0
0006ce f099      	BREQ _0xBA
                 ;    1337 				{
                 ;    1338 					if (found_location_in_file(&rx0buf[5]) )
0006cf e2ed
0006d0 e0f6      	__POINTW1MN _rx0buf,5
0006d1 93fa      	ST   -Y,R31
0006d2 93ea      	ST   -Y,R30
0006d3 940e 0539 	CALL _found_location_in_file
0006d5 30e0      	CPI  R30,0
0006d6 f021      	BREQ _0xBB
                 ;    1339 					{
                 ;    1340 						open_user_bin (rd_file);							// открываем БД юзеров (prog.bin)
0006d7 940e 2338 	CALL SUBOPT_0x8
                 ;    1341 					 	Reply (TRUE);                                      // сначала откр. файл а потом передаем. Иначе не успевает
0006d9 e0e1      	LDI  R30,LOW(1)
0006da c003      	RJMP _0x4EC
                 ;    1342 					 }
                 ;    1343 					else 
                 _0xBB:
                 ;    1344 					{
                 ;    1345 						open_user_bin (rd_file);							// открываем БД юзеров (prog.bin)
0006db 940e 2338 	CALL SUBOPT_0x8
                 ;    1346 						Reply (FALSE); 
0006dd e0e0      	LDI  R30,LOW(0)
                 _0x4EC:
0006de 93ea      	ST   -Y,R30
0006df 940e 034d 	CALL _Reply
                 ;    1347 					}
                 ;    1348 				}
                 ;    1349 				else Reply (FALSE);
0006e1 c002      	RJMP _0xBD
                 _0xBA:
0006e2 940e 234b 	CALL SUBOPT_0xB
                 ;    1350 
                 ;    1351 				break;
                 _0xBD:
0006e4 c019      	RJMP _0xB6
                 ;    1352 
                 ;    1353 			case pack_for_scremb:  				// работаем с пакетом для кодера
                 _0xB9:
0006e5 30e3      	CPI  R30,LOW(0x3)
0006e6 f439      	BRNE _0xBE
                 ;    1354 				#ifdef print
                 ;    1355 				printf ("Rx pack for coder \r\n");
                 ;    1356 				#endif    
                 ;    1357 
                 ;    1358 				check_fprog();
0006e7 940e 04d8 	CALL _check_fprog
                 ;    1359 				Reply(TRUE);
0006e9 e0e1      	LDI  R30,LOW(1)
0006ea 93ea      	ST   -Y,R30
0006eb 940e 034d 	CALL _Reply
                 ;    1360 				break;
0006ed c010      	RJMP _0xB6
                 ;    1361 
                 ;    1362 			case pack_readAbons:
                 _0xBE:
0006ee 30e4      	CPI  R30,LOW(0x4)
0006ef f471      	BRNE _0xC1
                 ;    1363 				#ifdef print
                 ;    1364 				printf ("Rx pack readAbons \r\n");
                 ;    1365 				#endif    
                 ;    1366 		
                 ;    1367 				if (! read_abons (convTOw32 (&rx0buf[5]))) Reply (FALSE);                             
0006f0 e2ed
0006f1 e0f6      	__POINTW1MN _rx0buf,5
0006f2 93fa      	ST   -Y,R31
0006f3 93ea      	ST   -Y,R30
0006f4 940e 04ea 	CALL _convTOw32
0006f6 940e 2a63 	CALL __PUTPARD1
0006f8 940e 05ea 	CALL _read_abons
0006fa 30e0      	CPI  R30,0
0006fb f411      	BRNE _0xC0
0006fc 940e 234b 	CALL SUBOPT_0xB
                 ;    1368 
                 ;    1369 				break;
                 _0xC0:
                 ;    1370 
                 ;    1371 			default:
                 _0xC1:
                 ;    1372 				break;
                 ;    1373 		}
                 _0xB6:
                 ;    1374 	}
                 _0xB3:
                 ;    1375 
                 ;    1376 
                 ;    1377 /*
                 ;    1378 	// работаем с пакетом для кодера
                 ;    1379 	if (FLASH_command == pack_for_scremb)
                 ;    1380 	{
                 ;    1381 		#ifdef print
                 ;    1382 		printf ("Rx pack for coder \r\n");
                 ;    1383 		#endif    
                 ;    1384 
                 ;    1385 		check_fprog();
                 ;    1386 
                 ;    1387 		return TRUE;		
                 ;    1388 	}
                 ;    1389 
                 ;    1390 	if ( ! CF_card_INI_OK ) return FALSE;		// CF карта не готова 
                 ;    1391 	
                 ;    1392 	if (FLASH_command == pack_readAbons)
                 ;    1393 	{                                                           
                 ;    1394 		#ifdef print
                 ;    1395 		printf ("Rx pack readAbons \r\n");
                 ;    1396 		#endif    
                 ;    1397 		
                 ;    1398 		if (! read_abons ()) return FALSE;                             
                 ;    1399 		else return TRUE;
                 ;    1400 		
                 ;    1401 	}
                 ;    1402 
                 ;    1403 
                 ;    1404 	// работаем с пакетами юзеров
                 ;    1405 	// открываем базу. Если файла нет - создаем.
                 ;    1406 	#ifdef print
                 ;    1407 	printf ("Rx pack user.bin \r\n");
                 ;    1408 	#endif    
                 ;    1409 
                 ;    1410 	if ( !open_prog_bin (wr_file) ) return FALSE;
                 ;    1411 
                 ;    1412 	if (! found_location_in_file(&rx0buf[5]) ) status = FALSE;
                 ;    1413 	else status = TRUE; 
                 ;    1414 
                 ;    1415 	open_prog_bin (rd_file);							// открываем БД юзеров (prog.bin)
                 ;    1416 
                 ;    1417 	return status;	*/
                 ;    1418 }
0006fe 9508      	RET
                 ;    1419 
                 ;    1420 
                 ;    1421 
                 ;    1422 	
                 ;    1423 /*
                 ;    1424 	Progressive Resources LLC
                 ;    1425                                     
                 ;    1426 			FlashFile
                 ;    1427 	
                 ;    1428 	Version : 	1.32
                 ;    1429 	Date: 		12/31/2003
                 ;    1430 	Author: 	Erick M. Higa
                 ;    1431                                            
                 ;    1432 	Software License
                 ;    1433 	The use of Progressive Resources LLC FlashFile Source Package indicates 
                 ;    1434 	your understanding and acceptance of the following terms and conditions. 
                 ;    1435 	This license shall supersede any verbal or prior verbal or written, statement 
                 ;    1436 	or agreement to the contrary. If you do not understand or accept these terms, 
                 ;    1437 	or your local regulations prohibit "after sale" license agreements or limited 
                 ;    1438 	disclaimers, you must cease and desist using this product immediately.
                 ;    1439 	This product is © Copyright 2003 by Progressive Resources LLC, all rights 
                 ;    1440 	reserved. International copyright laws, international treaties and all other 
                 ;    1441 	applicable national or international laws protect this product. This software 
                 ;    1442 	product and documentation may not, in whole or in part, be copied, photocopied, 
                 ;    1443 	translated, or reduced to any electronic medium or machine readable form, without 
                 ;    1444 	prior consent in writing, from Progressive Resources LLC and according to all 
                 ;    1445 	applicable laws. The sole owner of this product is Progressive Resources LLC.
                 ;    1446 
                 ;    1447 	Operating License
                 ;    1448 	You have the non-exclusive right to use any enclosed product but have no right 
                 ;    1449 	to distribute it as a source code product without the express written permission 
                 ;    1450 	of Progressive Resources LLC. Use over a "local area network" (within the same 
                 ;    1451 	locale) is permitted provided that only a single person, on a single computer 
                 ;    1452 	uses the product at a time. Use over a "wide area network" (outside the same 
                 ;    1453 	locale) is strictly prohibited under any and all circumstances.
                 ;    1454                                            
                 ;    1455 	Liability Disclaimer
                 ;    1456 	This product and/or license is provided as is, without any representation or 
                 ;    1457 	warranty of any kind, either express or implied, including without limitation 
                 ;    1458 	any representations or endorsements regarding the use of, the results of, or 
                 ;    1459 	performance of the product, Its appropriateness, accuracy, reliability, or 
                 ;    1460 	correctness. The user and/or licensee assume the entire risk as to the use of 
                 ;    1461 	this product. Progressive Resources LLC does not assume liability for the use 
                 ;    1462 	of this product beyond the original purchase price of the software. In no event 
                 ;    1463 	will Progressive Resources LLC be liable for additional direct or indirect 
                 ;    1464 	damages including any lost profits, lost savings, or other incidental or 
                 ;    1465 	consequential damages arising from any defects, or the use or inability to 
                 ;    1466 	use these products, even if Progressive Resources LLC have been advised of 
                 ;    1467 	the possibility of such damages.
                 ;    1468 */                                 
                 ;    1469 
                 ;    1470 /*
                 ;    1471 #include _AVR_LIB_
                 ;    1472 #include <stdio.h>
                 ;    1473 
                 ;    1474 #ifndef _file_sys_h_
                 ;    1475 	#include "..\flash\file_sys.h"
                 ;    1476 #endif
                 ;    1477 */
                 ;    1478 	#include <coding.h>
                 ;    1479 
                 ;    1480 unsigned long OCR_REG;
                 
                 	.DSEG
                 _OCR_REG:
00072b           	.BYTE 0x4
                 ;    1481 unsigned char _FF_buff[512];
                 __FF_buff:
00072f           	.BYTE 0x200
                 ;    1482 unsigned int PT_SecStart;
                 _PT_SecStart:
00092f           	.BYTE 0x2
                 ;    1483 unsigned long BS_jmpBoot;
                 _BS_jmpBoot:
000931           	.BYTE 0x4
                 ;    1484 unsigned int BPB_BytsPerSec;
                 _BPB_BytsPerSec:
000935           	.BYTE 0x2
                 ;    1485 unsigned char BPB_SecPerClus;
                 _BPB_SecPerClus:
000937           	.BYTE 0x1
                 ;    1486 unsigned int BPB_RsvdSecCnt;
                 _BPB_RsvdSecCnt:
000938           	.BYTE 0x2
                 ;    1487 unsigned char BPB_NumFATs;
                 _BPB_NumFATs:
00093a           	.BYTE 0x1
                 ;    1488 unsigned int BPB_RootEntCnt;
                 _BPB_RootEntCnt:
00093b           	.BYTE 0x2
                 ;    1489 unsigned int BPB_FATSz16;
                 _BPB_FATSz16:
00093d           	.BYTE 0x2
                 ;    1490 unsigned char BPB_FATType;
                 _BPB_FATType:
00093f           	.BYTE 0x1
                 ;    1491 unsigned long BPB_TotSec;
                 _BPB_TotSec:
000940           	.BYTE 0x4
                 ;    1492 unsigned long BS_VolSerial;
                 _BS_VolSerial:
000944           	.BYTE 0x4
                 ;    1493 unsigned char BS_VolLab[12];
                 _BS_VolLab:
000948           	.BYTE 0xC
                 ;    1494 unsigned long _FF_PART_ADDR, _FF_ROOT_ADDR, _FF_DIR_ADDR;
                 __FF_PART_ADDR:
000954           	.BYTE 0x4
                 __FF_ROOT_ADDR:
000958           	.BYTE 0x4
                 __FF_DIR_ADDR:
00095c           	.BYTE 0x4
                 ;    1495 unsigned long _FF_FAT1_ADDR, _FF_FAT2_ADDR;
                 __FF_FAT1_ADDR:
000960           	.BYTE 0x4
                 __FF_FAT2_ADDR:
000964           	.BYTE 0x4
                 ;    1496 unsigned long _FF_RootDirSectors;
                 __FF_RootDirSectors:
000968           	.BYTE 0x4
                 ;    1497 unsigned int FirstDataSector;
                 _FirstDataSector:
00096c           	.BYTE 0x2
                 ;    1498 unsigned long FirstSectorofCluster;
                 _FirstSectorofCluster:
00096e           	.BYTE 0x4
                 ;    1499 unsigned char _FF_error;
                 __FF_error:
000972           	.BYTE 0x1
                 ;    1500 unsigned long _FF_buff_addr;
                 __FF_buff_addr:
000973           	.BYTE 0x4
                 ;    1501 extern unsigned long clus_0_addr, _FF_n_temp;
                 ;    1502 extern unsigned int c_counter;
                 ;    1503 //extern unsigned char _FF_FULL_PATH[_FF_PATH_LENGTH];
                 ;    1504 
                 ;    1505 unsigned long DataClusTot;
                 _DataClusTot:
000977           	.BYTE 0x4
                 ;    1506 
                 ;    1507 flash struct CMD
                 ;    1508 {
                 ;    1509 	unsigned int index;
                 ;    1510 	unsigned int tx_data;
                 ;    1511 	unsigned int arg;
                 ;    1512 	unsigned int resp;
                 ;    1513 };
                 ;    1514 
                 ;    1515 flash struct CMD sd_cmd[CMD_TOT] =
                 
                 	.CSEG
                 ;    1516 {
                 ;    1517 	{CMD0,	0x40,	NO_ARG,		RESP_1},		// GO_IDLE_STATE
                 ;    1518 	{CMD1,	0x41,	NO_ARG,		RESP_1},		// SEND_OP_COND (ACMD41 = 0x69)
                 ;    1519 	{CMD9,	0x49,	NO_ARG,		RESP_1},		// SEND_CSD
                 ;    1520 	{CMD10,	0x4A,	NO_ARG,		RESP_1},		// SEND_CID
                 ;    1521 	{CMD12,	0x4C,	NO_ARG,		RESP_1},		// STOP_TRANSMISSION
                 ;    1522 	{CMD13,	0x4D,	NO_ARG,		RESP_2},		// SEND_STATUS
                 ;    1523 	{CMD16,	0x50,	BLOCK_LEN,	RESP_1},		// SET_BLOCKLEN
                 ;    1524 	{CMD17, 0x51,	DATA_ADDR,	RESP_1},		// READ_SINGLE_BLOCK
                 ;    1525 	{CMD18, 0x52,	DATA_ADDR,	RESP_1},		// READ_MULTIPLE_BLOCK
                 ;    1526 	{CMD24, 0x58,	DATA_ADDR,	RESP_1},		// WRITE_BLOCK
                 ;    1527 	{CMD25, 0x59,	DATA_ADDR,	RESP_1},		// WRITE_MULTIPLE_BLOCK
                 ;    1528 	{CMD27,	0x5B,	NO_ARG,		RESP_1},		// PROGRAM_CSD
                 ;    1529 	{CMD28, 0x5C,	DATA_ADDR,	RESP_1b},		// SET_WRITE_PROT
                 ;    1530 	{CMD29, 0x5D,	DATA_ADDR,	RESP_1b},		// CLR_WRITE_PROT
                 ;    1531 	{CMD30, 0x5E,	DATA_ADDR,	RESP_1},		// SEND_WRITE_PROT
                 ;    1532 	{CMD32,	0x60,	DATA_ADDR,	RESP_1},		// TAG_SECTOR_START
                 ;    1533 	{CMD33,	0x61,	DATA_ADDR,	RESP_1},		// TAG_SECTOR_END
                 ;    1534 	{CMD34,	0x62,	DATA_ADDR,	RESP_1},		// UNTAG_SECTOR
                 ;    1535 	{CMD35,	0x63,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP_START
                 ;    1536 	{CMD36,	0x64,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP_END
                 ;    1537 	{CMD37,	0x65,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP
                 ;    1538 	{CMD38,	0x66,	STUFF_BITS,	RESP_1b},		// ERASE
                 ;    1539 	{CMD42,	0x6A,	STUFF_BITS,	RESP_1b},		// LOCK_UNLOCK
                 ;    1540 	{CMD58,	0x7A,	NO_ARG,		RESP_3},		// READ_OCR
                 ;    1541 	{CMD59,	0x7B,	STUFF_BITS,	RESP_1},		// CRC_ON_OFF
                 ;    1542 	{ACMD41, 0x69,	NO_ARG,		RESP_1}
                 ;    1543 };
                 ;    1544 
                 ;    1545 unsigned char _FF_spi(unsigned char mydata)
                 ;    1546 {
                 __FF_spi:
                 ;    1547     SPDR = mydata;          //byte 1
0006ff 81e8      	LD   R30,Y
000700 b9ef      	OUT  0xF,R30
                 ;    1548     while ((SPSR&0x80) == 0); 
                 _0xC2:
000701 9b77      	SBIS 0xE,7
000702 cffe      	RJMP _0xC2
                 ;    1549     return SPDR;
000703 b1ef      	IN   R30,0xF
000704 c537      	RJMP _0x4D7
                 ;    1550 }
                 ;    1551 	
                 ;    1552 unsigned int send_cmd(unsigned char command, unsigned long argument)
                 ;    1553 {
                 _send_cmd:
                 ;    1554 	unsigned char spi_data_out;
                 ;    1555 	unsigned char response_1;
                 ;    1556 	unsigned long response_2;
                 ;    1557 	unsigned int c, i;
                 ;    1558 	
                 ;    1559 	SD_CS_ON();			// select chip
000705 9724      	SBIW R28,4
000706 940e 2abc 	CALL __SAVELOCR6
                 ;	command -> Y+14
                 ;	argument -> Y+10
                 ;	spi_data_out -> R16
                 ;	response_1 -> R17
                 ;	response_2 -> Y+6
                 ;	c -> R18,R19
                 ;	i -> R20,R21
000708 98c4      	CBI  0x18,4
                 ;    1560 	
                 ;    1561 	spi_data_out = sd_cmd[command].tx_data;
000709 85ae      	LDD  R26,Y+14
00070a 27bb      	CLR  R27
00070b ec6c
00070c e070      	__POINTWRFN 22,23,_sd_cmd,2
00070d 940e 2429 	CALL SUBOPT_0x28
00070f 9104      	LPM  R16,Z
                 ;    1562 	_FF_spi(spi_data_out);
000710 930a      	ST   -Y,R16
000711 940e 2430 	CALL SUBOPT_0x29
                 ;    1563 	
                 ;    1564 	c = sd_cmd[command].arg;
000713 ec6e
000714 e070      	__POINTWRFN 22,23,_sd_cmd,4
000715 940e 2429 	CALL SUBOPT_0x28
000717 940e 2a59 	CALL __GETW1PF
000719 019f      	MOVW R18,R30
                 ;    1565 	if (c == NO_ARG)
00071a 2e02      	MOV  R0,R18
00071b 2a03      	OR   R0,R19
00071c f471      	BRNE _0xC5
                 ;    1566 		for (i=0; i<4; i++)
00071d e040
00071e e050      	__GETWRN 20,21,0
                 _0xC7:
00071f 3044
000720 e0e0
000721 075e      	__CPWRN 20,21,4
000722 f438      	BRSH _0xC8
                 ;    1567 			_FF_spi(0);
000723 e0e0      	LDI  R30,LOW(0)
000724 93ea      	ST   -Y,R30
000725 940e 06ff 	CALL __FF_spi
                 ;    1568 	else
000727 5f4f
000728 4f5f      	__ADDWRN 20,21,1
000729 cff5      	RJMP _0xC7
                 _0xC8:
00072a c028      	RJMP _0xC9
                 _0xC5:
                 ;    1569 	{
                 ;    1570 		spi_data_out = (argument & 0xFF000000) >> 24;
00072b 85ea
00072c 85fb
00072d 856c
00072e 857d      	__GETD1S 10
00072f 70e0
000730 70f0
000731 7060
000732 7f7f      	__ANDD1N 0xFF000000
000733 01df      	MOVW R26,R30
000734 01cb      	MOVW R24,R22
000735 e1e8      	LDI  R30,LOW(24)
000736 940e 2435 	CALL SUBOPT_0x2A
                 ;    1571 		_FF_spi(spi_data_out);
                 ;    1572 		spi_data_out = (argument & 0x00FF0000) >> 16;
000738 70e0
000739 70f0
00073a 7f6f
00073b 7070      	__ANDD1N 0xFF0000
00073c 940e 29b1 	CALL __LSRD16
00073e 940e 2440 	CALL SUBOPT_0x2B
                 ;    1573 		_FF_spi(spi_data_out);
                 ;    1574 		spi_data_out = (argument & 0x0000FF00) >> 8;
000740 85ea
000741 85fb
000742 856c
000743 857d      	__GETD1S 10
000744 70e0
000745 7fff
000746 7060
000747 7070      	__ANDD1N 0xFF00
000748 01df      	MOVW R26,R30
000749 01cb      	MOVW R24,R22
00074a e0e8      	LDI  R30,LOW(8)
00074b 940e 2435 	CALL SUBOPT_0x2A
                 ;    1575 		_FF_spi(spi_data_out);
                 ;    1576 		spi_data_out = (argument & 0x000000FF);
00074d 7fef
00074e 70f0
00074f 7060
000750 7070      	__ANDD1N 0xFF
000751 940e 2440 	CALL SUBOPT_0x2B
                 ;    1577 		_FF_spi(spi_data_out);
                 ;    1578 	}
                 _0xC9:
                 ;    1579 	if (command == CMD0)
000753 85ee      	LDD  R30,Y+14
000754 30e0      	CPI  R30,0
000755 f411      	BRNE _0xCA
                 ;    1580 		spi_data_out = 0x95;		// CRC byte, don't care except for first signal=0x95
000756 e905      	LDI  R16,LOW(149)
                 ;    1581 	else
000757 c001      	RJMP _0xCB
                 _0xCA:
                 ;    1582 		spi_data_out = 0xFF;
000758 ef0f      	LDI  R16,LOW(255)
                 ;    1583 	_FF_spi(spi_data_out);
                 _0xCB:
000759 930a      	ST   -Y,R16
00075a 940e 2444 	CALL SUBOPT_0x2C
                 ;    1584 	_FF_spi(0xff);	
00075c 940e 2430 	CALL SUBOPT_0x29
                 ;    1585 	c = sd_cmd[command].resp;
00075e ed60
00075f e070      	__POINTWRFN 22,23,_sd_cmd,6
000760 940e 2429 	CALL SUBOPT_0x28
000762 940e 2a59 	CALL __GETW1PF
000764 019f      	MOVW R18,R30
                 ;    1586 	switch(c)
000765 01f9      	MOVW R30,R18
                 ;    1587 	{
                 ;    1588 		case RESP_1:
000766 9730      	SBIW R30,0
000767 f421      	BRNE _0xCF
                 ;    1589 			return (_FF_spi(0xFF));
000768 940e 2449 	CALL SUBOPT_0x2D
00076a e0f0      	LDI  R31,0
00076b c088      	RJMP _0x4DC
                 ;    1590 			break;
                 ;    1591 		case RESP_1b:
                 _0xCF:
00076c 30e1      	CPI  R30,LOW(0x1)
00076d e0a0      	LDI  R26,HIGH(0x1)
00076e 07fa      	CPC  R31,R26
00076f f4e1      	BRNE _0xD0
                 ;    1592 			response_1 = _FF_spi(0xFF);
000770 940e 2449 	CALL SUBOPT_0x2D
000772 2f1e      	MOV  R17,R30
                 ;    1593 			response_2 = 0;
000773 e0e0
000774 83ee
000775 83ef
000776 87e8
000777 87e9      	__CLRD1S 6
                 ;    1594 			while (response_2 == 0)
                 _0xD1:
000778 81ee
000779 81ff
00077a 8568
00077b 8579      	__GETD1S 6
00077c 940e 2aa4 	CALL __CPD10
00077e f451      	BRNE _0xD3
                 ;    1595 				response_2 = _FF_spi(0xFF);
00077f 940e 2449 	CALL SUBOPT_0x2D
000781 27ff      	CLR  R31
000782 2766      	CLR  R22
000783 2777      	CLR  R23
000784 83ee
000785 83ff
000786 8768
000787 8779      	__PUTD1S 6
                 ;    1596 			return (response_1);
000788 cfef      	RJMP _0xD1
                 _0xD3:
000789 2fe1      	MOV  R30,R17
00078a e0f0      	LDI  R31,0
00078b c068      	RJMP _0x4DC
                 ;    1597 			break;
                 ;    1598 		case RESP_2:
                 _0xD0:
00078c 30e2      	CPI  R30,LOW(0x2)
00078d e0a0      	LDI  R26,HIGH(0x2)
00078e 07fa      	CPC  R31,R26
00078f f4d9      	BRNE _0xD4
                 ;    1599 			response_2 = _FF_spi(0xFF);
000790 940e 2449 	CALL SUBOPT_0x2D
000792 940e 244d 	CALL SUBOPT_0x2E
                 ;    1600 			response_2 = (response_2 << 8) | _FF_spi(0xFF);
000794 e0e8      	LDI  R30,LOW(8)
000795 940e 2986 	CALL __LSLD12
000797 937f      	PUSH R23
000798 936f      	PUSH R22
000799 93ff      	PUSH R31
00079a 93ef      	PUSH R30
00079b 940e 2449 	CALL SUBOPT_0x2D
00079d 91af      	POP  R26
00079e 91bf      	POP  R27
00079f 918f      	POP  R24
0007a0 919f      	POP  R25
0007a1 27ff      	CLR  R31
0007a2 2766      	CLR  R22
0007a3 2777      	CLR  R23
0007a4 940e 2970 	CALL __ORD12
0007a6 83ee
0007a7 83ff
0007a8 8768
0007a9 8779      	__PUTD1S 6
                 ;    1601 			return (response_2);
0007aa c049      	RJMP _0x4DC
                 ;    1602 			break;
                 ;    1603 		case RESP_3:
                 _0xD4:
0007ab 30e3      	CPI  R30,LOW(0x3)
0007ac e0a0      	LDI  R26,HIGH(0x3)
0007ad 07fa      	CPC  R31,R26
0007ae f011      	BREQ PC+3
0007af 940c 07f2 	JMP _0xCE
                 ;    1604 			response_1 = _FF_spi(0xFF);
0007b1 940e 2449 	CALL SUBOPT_0x2D
0007b3 2f1e      	MOV  R17,R30
                 ;    1605 			OCR_REG = 0;
0007b4 e0e0      	LDI  R30,0
0007b5 93e0 072b 	STS  _OCR_REG,R30
0007b7 93e0 072c 	STS  _OCR_REG+1,R30
0007b9 93e0 072d 	STS  _OCR_REG+2,R30
0007bb 93e0 072e 	STS  _OCR_REG+3,R30
                 ;    1606 			response_2 = _FF_spi(0xFF);
0007bd 940e 2449 	CALL SUBOPT_0x2D
0007bf 940e 244d 	CALL SUBOPT_0x2E
                 ;    1607 			OCR_REG = response_2 << 24;
0007c1 e1e8      	LDI  R30,LOW(24)
0007c2 940e 2986 	CALL __LSLD12
0007c4 93e0 072b 	STS  _OCR_REG,R30
0007c6 93f0 072c 	STS  _OCR_REG+1,R31
0007c8 9360 072d 	STS  _OCR_REG+2,R22
0007ca 9370 072e 	STS  _OCR_REG+3,R23
                 ;    1608 			response_2 = _FF_spi(0xFF);
0007cc 940e 2449 	CALL SUBOPT_0x2D
0007ce 940e 2459 	CALL SUBOPT_0x2F
                 ;    1609 			OCR_REG |= (response_2 << 16);
0007d0 940e 29b6 	CALL __LSLD16
0007d2 940e 2461 	CALL SUBOPT_0x30
                 ;    1610 			response_2 = _FF_spi(0xFF);
0007d4 940e 244d 	CALL SUBOPT_0x2E
                 ;    1611 			OCR_REG |= (response_2 << 8);
0007d6 e0e8      	LDI  R30,LOW(8)
0007d7 940e 2986 	CALL __LSLD12
0007d9 940e 2461 	CALL SUBOPT_0x30
                 ;    1612 			response_2 = _FF_spi(0xFF);
0007db 940e 2459 	CALL SUBOPT_0x2F
                 ;    1613 			OCR_REG |= (response_2);
0007dd 91a0 072b 	LDS  R26,_OCR_REG
0007df 91b0 072c 	LDS  R27,_OCR_REG+1
0007e1 9180 072d 	LDS  R24,_OCR_REG+2
0007e3 9190 072e 	LDS  R25,_OCR_REG+3
0007e5 940e 2970 	CALL __ORD12
0007e7 93e0 072b 	STS  _OCR_REG,R30
0007e9 93f0 072c 	STS  _OCR_REG+1,R31
0007eb 9360 072d 	STS  _OCR_REG+2,R22
0007ed 9370 072e 	STS  _OCR_REG+3,R23
                 ;    1614 			return (response_1);
0007ef 2fe1      	MOV  R30,R17
0007f0 e0f0      	LDI  R31,0
0007f1 c002      	RJMP _0x4DC
                 ;    1615 			break;
                 ;    1616 	}
                 _0xCE:
                 ;    1617 	return (0);
0007f2 e0e0      	LDI  R30,LOW(0)
0007f3 e0f0      	LDI  R31,HIGH(0)
                 _0x4DC:
0007f4 940e 2ac3 	CALL __LOADLOCR6
0007f6 962f      	ADIW R28,15
0007f7 9508      	RET
                 ;    1618 }
                 ;    1619 
                 ;    1620 void clear_sd_buff(void)
                 ;    1621 {
                 _clear_sd_buff:
                 ;    1622 	SD_CS_OFF();
0007f8 9ac4      	SBI  0x18,4
                 ;    1623 	_FF_spi(0xFF);
0007f9 940e 2474 	CALL SUBOPT_0x31
                 ;    1624 	_FF_spi(0xFF);
0007fb 940e 06ff 	CALL __FF_spi
                 ;    1625 }	
0007fd 9508      	RET
                 ;    1626 
                 ;    1627 unsigned char initialize_media(void)
                 ;    1628 {
                 _initialize_media:
                 ;    1629 	unsigned char data_temp;
                 ;    1630 	unsigned long n;
                 ;    1631 	
                 ;    1632 	// SPI BUS SETUP
                 ;    1633 	// SPI initialization
                 ;    1634 	// SPI Type: Master
                 ;    1635 	// SPI Clock Rate: 921.600 kHz
                 ;    1636 	// SPI Clock Phase: Cycle Half
                 ;    1637 	// SPI Clock Polarity: Low
                 ;    1638 	// SPI Data Order: MSB First
                 ;    1639 	DDRB |= 0x07;		// Set SS, SCK, and MOSI to Output (If not output, processor will be a slave)
0007fe 9724      	SBIW R28,4
0007ff 930a      	ST   -Y,R16
                 ;	data_temp -> R16
                 ;	n -> Y+1
000800 b3e7      	IN   R30,0x17
000801 60e7      	ORI  R30,LOW(0x7)
000802 bbe7      	OUT  0x17,R30
                 ;    1640 	DDRB &= 0xF7;		// Set MISO to Input
000803 98bb      	CBI  0x17,3
                 ;    1641 	CS_DDR_SET();		// Set CS to Output
000804 9abc      	SBI  0x17,4
                 ;    1642 	SPCR=0x50;
000805 940e 2477 	CALL SUBOPT_0x32
                 ;    1643 	SPSR=0x00;
000807 b9ee      	OUT  0xE,R30
                 ;    1644 		
                 ;    1645 	BPB_BytsPerSec = 512;	// Initialize sector size to 512 (all SD cards have a 512 sector size)
000808 e0e0      	LDI  R30,LOW(512)
000809 e0f2      	LDI  R31,HIGH(512)
00080a 93e0 0935 	STS  _BPB_BytsPerSec,R30
00080c 93f0 0936 	STS  _BPB_BytsPerSec+1,R31
                 ;    1646     _FF_n_temp = 0;
00080e e0e0      	LDI  R30,0
00080f 93e0 0986 	STS  __FF_n_temp,R30
000811 93e0 0987 	STS  __FF_n_temp+1,R30
000813 93e0 0988 	STS  __FF_n_temp+2,R30
000815 93e0 0989 	STS  __FF_n_temp+3,R30
                 ;    1647 	if (reset_sd()==0)
000817 d2d7      	RCALL _reset_sd
000818 30e0      	CPI  R30,0
000819 f411      	BRNE _0xD6
                 ;    1648 		return (0);
00081a e0e0      	LDI  R30,LOW(0)
00081b c2b9      	RJMP _0x4DB
                 ;    1649 	// delay_ms(50);
                 ;    1650 	for (n=0; ((n<100)||(data_temp==0)) ; n++)
                 _0xD6:
00081c e0e0
00081d 83e9
00081e 83ea
00081f 83eb
000820 83ec      	__CLRD1S 1
                 _0xD8:
000821 81a9
000822 81ba
000823 818b
000824 819c      	__GETD2S 1
000825 36a4
000826 e0e0
000827 07be
000828 e0e0
000829 078e
00082a e0e0
00082b 079e      	__CPD2N 0x64
00082c f010      	BRLO _0xDA
00082d 3000      	CPI  R16,0
00082e f441      	BRNE _0xD9
                 _0xDA:
                 ;    1651 	{
                 ;    1652 		SD_CS_ON();
00082f 98c4      	CBI  0x18,4
                 ;    1653 		data_temp = _FF_spi(0xFF);
000830 940e 2449 	CALL SUBOPT_0x2D
000832 2f0e      	MOV  R16,R30
                 ;    1654 		SD_CS_OFF();
000833 9ac4      	SBI  0x18,4
                 ;    1655 	}
000834 940e 247b 	CALL SUBOPT_0x33
000836 cfea      	RJMP _0xD8
                 _0xD9:
                 ;    1656 	// delay_ms(50);
                 ;    1657 	for (n=0; n<100; n++)
000837 e0e0
000838 83e9
000839 83ea
00083a 83eb
00083b 83ec      	__CLRD1S 1
                 _0xDD:
00083c 81a9
00083d 81ba
00083e 818b
00083f 819c      	__GETD2S 1
000840 36a4
000841 e0e0
000842 07be
000843 e0e0
000844 078e
000845 e0e0
000846 079e      	__CPD2N 0x64
000847 f4a0      	BRSH _0xDE
                 ;    1658 	{
                 ;    1659 		if (init_sd())		// Initialization Succeeded
000848 d2cf      	RCALL _init_sd
000849 30e0      	CPI  R30,0
00084a f489      	BRNE _0xDE
                 ;    1660 			break;
                 ;    1661 		if (n==99)
00084b 81a9
00084c 81ba
00084d 818b
00084e 819c      	__GETD2S 1
00084f 36a3
000850 e0e0
000851 07be
000852 e0e0
000853 078e
000854 e0e0
000855 079e      	__CPD2N 0x63
000856 f411      	BRNE _0xE0
                 ;    1662 			return (0);
000857 e0e0      	LDI  R30,LOW(0)
000858 c27c      	RJMP _0x4DB
                 ;    1663 	}
                 _0xE0:
000859 940e 247b 	CALL SUBOPT_0x33
00085b cfe0      	RJMP _0xDD
                 _0xDE:
                 ;    1664 
                 ;    1665 	if (_FF_read(0x0)==0)
00085c e0e0
00085d e0f0
00085e e060
00085f e070      	__GETD1N 0x0
000860 940e 2488 	CALL SUBOPT_0x34
000862 f419      	BRNE _0xE1
                 ;    1666 	{
                 ;    1667 		#ifdef _DEBUG_ON_
                 ;    1668 			printf("\n\rREAD_ERR"); 		
                 ;    1669 		#endif
                 ;    1670 		_FF_error = INIT_ERR;
000863 940e 248e 	CALL SUBOPT_0x35
                 ;    1671 		return (0);
000865 c26f      	RJMP _0x4DB
                 ;    1672 	}
                 ;    1673 	PT_SecStart = ((int) _FF_buff[0x1c7] << 8) | (int) _FF_buff[0x1c6];
                 _0xE1:
000866 91b0 08f6 	__GETBRMN 27,__FF_buff,455
000868 e0a0      	LDI  R26,LOW(0)
000869 91e0 08f5 	__GETB1MN __FF_buff,454
00086b e0f0      	LDI  R31,0
00086c 2bea      	OR   R30,R26
00086d 2bfb      	OR   R31,R27
00086e 93e0 092f 	STS  _PT_SecStart,R30
000870 93f0 0930 	STS  _PT_SecStart+1,R31
                 ;    1674 	
                 ;    1675 	if ((((_FF_buff[0]==0xEB)&&(_FF_buff[2]==0x90))||(_FF_buff[0]==0xE9)) && ((_FF_buff[510]==0x55)&&(_FF_buff[511]==0xAA)))
000872 91a0 072f 	LDS  R26,__FF_buff
000874 3eab      	CPI  R26,LOW(0xEB)
000875 f421      	BRNE _0xE3
000876 91e0 0731 	__GETB1MN __FF_buff,2
000878 39e0      	CPI  R30,LOW(0x90)
000879 f021      	BREQ _0xE5
                 _0xE3:
00087a 91a0 072f 	LDS  R26,__FF_buff
00087c 3ea9      	CPI  R26,LOW(0xE9)
00087d f451      	BRNE _0xE7
                 _0xE5:
00087e 91e0 092d 	__GETB1MN __FF_buff,510
000880 35e5      	CPI  R30,LOW(0x55)
000881 f421      	BRNE _0xE8
000882 91e0 092e 	__GETB1MN __FF_buff,511
000884 3aea      	CPI  R30,LOW(0xAA)
000885 f009      	BREQ _0xE9
                 _0xE8:
000886 c001      	RJMP _0xE7
                 _0xE9:
000887 c001      	RJMP _0xEA
                 _0xE7:
000888 c005      	RJMP _0xE2
                 _0xEA:
                 ;    1676     	PT_SecStart = 0;
000889 e0e0      	LDI  R30,0
00088a 93e0 092f 	STS  _PT_SecStart,R30
00088c 93e0 0930 	STS  _PT_SecStart+1,R30
                 ;    1677  
                 ;    1678 	_FF_PART_ADDR = (long) PT_SecStart * (long) BPB_BytsPerSec;
                 _0xE2:
00088e 91e0 092f 	LDS  R30,_PT_SecStart
000890 91f0 0930 	LDS  R31,_PT_SecStart+1
000892 940e 2493 	CALL SUBOPT_0x36
000894 93e0 0954 	STS  __FF_PART_ADDR,R30
000896 93f0 0955 	STS  __FF_PART_ADDR+1,R31
000898 9360 0956 	STS  __FF_PART_ADDR+2,R22
00089a 9370 0957 	STS  __FF_PART_ADDR+3,R23
                 ;    1679 
                 ;    1680 	if (PT_SecStart)
00089c 91e0 092f 	LDS  R30,_PT_SecStart
00089e 91f0 0930 	LDS  R31,_PT_SecStart+1
0008a0 9730      	SBIW R30,0
0008a1 f071      	BREQ _0xEB
                 ;    1681 	{
                 ;    1682 		if (_FF_read(_FF_PART_ADDR)==0)
0008a2 91e0 0954 	LDS  R30,__FF_PART_ADDR
0008a4 91f0 0955 	LDS  R31,__FF_PART_ADDR+1
0008a6 9160 0956 	LDS  R22,__FF_PART_ADDR+2
0008a8 9170 0957 	LDS  R23,__FF_PART_ADDR+3
0008aa 940e 2488 	CALL SUBOPT_0x34
0008ac f419      	BRNE _0xEC
                 ;    1683 		{
                 ;    1684 		   	#ifdef _DEBUG_ON_
                 ;    1685 				printf("\n\rREAD_ERR");
                 ;    1686 			#endif
                 ;    1687 			_FF_error = INIT_ERR;
0008ad 940e 248e 	CALL SUBOPT_0x35
                 ;    1688 			return (0);
0008af c225      	RJMP _0x4DB
                 ;    1689 		}
                 ;    1690 	}
                 _0xEC:
                 ;    1691 
                 ;    1692  	#ifdef _DEBUG_ON_
                 ;    1693 		printf("\n\rBoot_Sec: [0x%X %X %X] [0x%X] [0x%X]", _FF_buff[0],_FF_buff[1],_FF_buff[2],_FF_buff[510],_FF_buff[511]); 		
                 ;    1694 	#endif
                 ;    1695    	
                 ;    1696     BS_jmpBoot = (((long) _FF_buff[0] << 16) | ((int) _FF_buff[1] << 8) | (int) _FF_buff[2]);    		
                 _0xEB:
0008b0 91e0 072f 	LDS  R30,__FF_buff
0008b2 27ff      	CLR  R31
0008b3 2766      	CLR  R22
0008b4 2777      	CLR  R23
0008b5 940e 29b6 	CALL __LSLD16
0008b7 01df      	MOVW R26,R30
0008b8 01cb      	MOVW R24,R22
0008b9 91f0 0730 	__GETBRMN 31,__FF_buff,1
0008bb e0e0      	LDI  R30,LOW(0)
0008bc 940e 29bb 	CALL __CWD1
0008be 940e 2970 	CALL __ORD12
0008c0 01df      	MOVW R26,R30
0008c1 01cb      	MOVW R24,R22
0008c2 91e0 0731 	__GETB1MN __FF_buff,2
0008c4 e0f0      	LDI  R31,0
0008c5 940e 29bb 	CALL __CWD1
0008c7 940e 2970 	CALL __ORD12
0008c9 93e0 0931 	STS  _BS_jmpBoot,R30
0008cb 93f0 0932 	STS  _BS_jmpBoot+1,R31
0008cd 9360 0933 	STS  _BS_jmpBoot+2,R22
0008cf 9370 0934 	STS  _BS_jmpBoot+3,R23
                 ;    1697 	BPB_BytsPerSec = ((int) _FF_buff[0xC] << 8) | (int) _FF_buff[0xB];
0008d1 91b0 073b 	__GETBRMN 27,__FF_buff,12
0008d3 e0a0      	LDI  R26,LOW(0)
0008d4 91e0 073a 	__GETB1MN __FF_buff,11
0008d6 e0f0      	LDI  R31,0
0008d7 2bea      	OR   R30,R26
0008d8 2bfb      	OR   R31,R27
0008d9 93e0 0935 	STS  _BPB_BytsPerSec,R30
0008db 93f0 0936 	STS  _BPB_BytsPerSec+1,R31
                 ;    1698     BPB_SecPerClus = _FF_buff[0xD];
0008dd 91e0 073c 	__GETB1MN __FF_buff,13
0008df 93e0 0937 	STS  _BPB_SecPerClus,R30
                 ;    1699 	BPB_RsvdSecCnt = ((int) _FF_buff[0xF] << 8) | (int) _FF_buff[0xE];	
0008e1 91b0 073e 	__GETBRMN 27,__FF_buff,15
0008e3 e0a0      	LDI  R26,LOW(0)
0008e4 91e0 073d 	__GETB1MN __FF_buff,14
0008e6 e0f0      	LDI  R31,0
0008e7 2bea      	OR   R30,R26
0008e8 2bfb      	OR   R31,R27
0008e9 93e0 0938 	STS  _BPB_RsvdSecCnt,R30
0008eb 93f0 0939 	STS  _BPB_RsvdSecCnt+1,R31
                 ;    1700 	BPB_NumFATs = _FF_buff[0x10];
0008ed 91e0 073f 	__GETB1MN __FF_buff,16
0008ef 93e0 093a 	STS  _BPB_NumFATs,R30
                 ;    1701 	BPB_RootEntCnt = ((int) _FF_buff[0x12] << 8) | (int) _FF_buff[0x11];	
0008f1 91b0 0741 	__GETBRMN 27,__FF_buff,18
0008f3 e0a0      	LDI  R26,LOW(0)
0008f4 91e0 0740 	__GETB1MN __FF_buff,17
0008f6 e0f0      	LDI  R31,0
0008f7 2bea      	OR   R30,R26
0008f8 2bfb      	OR   R31,R27
0008f9 93e0 093b 	STS  _BPB_RootEntCnt,R30
0008fb 93f0 093c 	STS  _BPB_RootEntCnt+1,R31
                 ;    1702 	BPB_FATSz16 = ((int) _FF_buff[0x17] << 8) | (int) _FF_buff[0x16];
0008fd 91b0 0746 	__GETBRMN 27,__FF_buff,23
0008ff e0a0      	LDI  R26,LOW(0)
000900 91e0 0745 	__GETB1MN __FF_buff,22
000902 e0f0      	LDI  R31,0
000903 2bea      	OR   R30,R26
000904 2bfb      	OR   R31,R27
000905 93e0 093d 	STS  _BPB_FATSz16,R30
000907 93f0 093e 	STS  _BPB_FATSz16+1,R31
                 ;    1703 	BPB_TotSec = ((unsigned int) _FF_buff[0x14] << 8) | (unsigned int) _FF_buff[0x13];
000909 91b0 0743 	__GETBRMN 27,__FF_buff,20
00090b e0a0      	LDI  R26,LOW(0)
00090c 91e0 0742 	__GETB1MN __FF_buff,19
00090e 940e 24a0 	CALL SUBOPT_0x37
000910 93e0 0940 	STS  _BPB_TotSec,R30
000912 93f0 0941 	STS  _BPB_TotSec+1,R31
000914 9360 0942 	STS  _BPB_TotSec+2,R22
000916 9370 0943 	STS  _BPB_TotSec+3,R23
                 ;    1704 	if (BPB_TotSec==0)
000918 940e 2aa4 	CALL __CPD10
00091a f539      	BRNE _0xED
                 ;    1705 		BPB_TotSec = ((unsigned long) _FF_buff[0x23] << 24) | ((unsigned long) _FF_buff[0x22] << 16)
                 ;    1706 					| ((unsigned long) _FF_buff[0x21] << 8) | ((unsigned long) _FF_buff[0x20]);
00091b 91e0 0752 	__GETB1MN __FF_buff,35
00091d 940e 24a6 	CALL SUBOPT_0x38
00091f 91e0 0751 	__GETB1MN __FF_buff,34
000921 940e 24b1 	CALL SUBOPT_0x39
000923 937f      	PUSH R23
000924 936f      	PUSH R22
000925 93ff      	PUSH R31
000926 93ef      	PUSH R30
000927 91e0 0750 	__GETB1MN __FF_buff,33
000929 940e 24b9 	CALL SUBOPT_0x3A
00092b 91af      	POP  R26
00092c 91bf      	POP  R27
00092d 918f      	POP  R24
00092e 919f      	POP  R25
00092f 940e 2970 	CALL __ORD12
000931 01df      	MOVW R26,R30
000932 01cb      	MOVW R24,R22
000933 91e0 074f 	__GETB1MN __FF_buff,32
000935 27ff      	CLR  R31
000936 2766      	CLR  R22
000937 2777      	CLR  R23
000938 940e 2970 	CALL __ORD12
00093a 93e0 0940 	STS  _BPB_TotSec,R30
00093c 93f0 0941 	STS  _BPB_TotSec+1,R31
00093e 9360 0942 	STS  _BPB_TotSec+2,R22
000940 9370 0943 	STS  _BPB_TotSec+3,R23
                 ;    1707 	BS_VolSerial = ((unsigned long) _FF_buff[0x2A] << 24) | ((unsigned long) _FF_buff[0x29] << 16)
                 _0xED:
                 ;    1708 				| ((unsigned long) _FF_buff[0x28] << 8) | ((unsigned long) _FF_buff[0x27]);
000942 91e0 0759 	__GETB1MN __FF_buff,42
000944 940e 24a6 	CALL SUBOPT_0x38
000946 91e0 0758 	__GETB1MN __FF_buff,41
000948 940e 24b1 	CALL SUBOPT_0x39
00094a 937f      	PUSH R23
00094b 936f      	PUSH R22
00094c 93ff      	PUSH R31
00094d 93ef      	PUSH R30
00094e 91e0 0757 	__GETB1MN __FF_buff,40
000950 940e 24b9 	CALL SUBOPT_0x3A
000952 91af      	POP  R26
000953 91bf      	POP  R27
000954 918f      	POP  R24
000955 919f      	POP  R25
000956 940e 2970 	CALL __ORD12
000958 01df      	MOVW R26,R30
000959 01cb      	MOVW R24,R22
00095a 91e0 0756 	__GETB1MN __FF_buff,39
00095c 27ff      	CLR  R31
00095d 2766      	CLR  R22
00095e 2777      	CLR  R23
00095f 940e 2970 	CALL __ORD12
000961 93e0 0944 	STS  _BS_VolSerial,R30
000963 93f0 0945 	STS  _BS_VolSerial+1,R31
000965 9360 0946 	STS  _BS_VolSerial+2,R22
000967 9370 0947 	STS  _BS_VolSerial+3,R23
                 ;    1709 	for (n=0; n<11; n++)
000969 e0e0
00096a 83e9
00096b 83ea
00096c 83eb
00096d 83ec      	__CLRD1S 1
                 _0xEF:
00096e 81a9
00096f 81ba
000970 818b
000971 819c      	__GETD2S 1
000972 30ab
000973 e0e0
000974 07be
000975 e0e0
000976 078e
000977 e0e0
000978 079e      	__CPD2N 0xB
000979 f4b0      	BRSH _0xF0
                 ;    1710 		BS_VolLab[n] = _FF_buff[0x2B+n];
00097a 81e9
00097b 81fa
00097c 816b
00097d 817c      	__GETD1S 1
00097e 5be8      	SUBI R30,LOW(-_BS_VolLab)
00097f 4ff6      	SBCI R31,HIGH(-_BS_VolLab)
000980 01df      	MOVW R26,R30
000981 81e9
000982 81fa
000983 816b
000984 817c      	__GETD1S 1
000985 5de5
000986 4fff
000987 4f6f
000988 4f7f      	__ADDD1N 43
000989 5de1      	SUBI R30,LOW(-__FF_buff)
00098a 4ff8      	SBCI R31,HIGH(-__FF_buff)
00098b 81e0      	LD   R30,Z
00098c 93ec      	ST   X,R30
                 ;    1711 	BS_VolLab[11] = 0;		// Terminate the string
00098d 940e 247b 	CALL SUBOPT_0x33
00098f cfde      	RJMP _0xEF
                 _0xF0:
000990 e0e0      	LDI  R30,LOW(0)
000991 93e0 0953 	__PUTB1MN _BS_VolLab,11
                 ;    1712 	_FF_FAT1_ADDR = _FF_PART_ADDR + ((long) BPB_RsvdSecCnt * (long) BPB_BytsPerSec); 
000993 91e0 0938 	LDS  R30,_BPB_RsvdSecCnt
000995 91f0 0939 	LDS  R31,_BPB_RsvdSecCnt+1
000997 940e 2493 	CALL SUBOPT_0x36
000999 91a0 0954 	LDS  R26,__FF_PART_ADDR
00099b 91b0 0955 	LDS  R27,__FF_PART_ADDR+1
00099d 9180 0956 	LDS  R24,__FF_PART_ADDR+2
00099f 9190 0957 	LDS  R25,__FF_PART_ADDR+3
0009a1 940e 295c 	CALL __ADDD12
0009a3 93e0 0960 	STS  __FF_FAT1_ADDR,R30
0009a5 93f0 0961 	STS  __FF_FAT1_ADDR+1,R31
0009a7 9360 0962 	STS  __FF_FAT1_ADDR+2,R22
0009a9 9370 0963 	STS  __FF_FAT1_ADDR+3,R23
                 ;    1713 	_FF_FAT2_ADDR = _FF_FAT1_ADDR + ((long) BPB_FATSz16 * (long) BPB_BytsPerSec);
0009ab 91e0 093d 	LDS  R30,_BPB_FATSz16
0009ad 91f0 093e 	LDS  R31,_BPB_FATSz16+1
0009af 940e 2493 	CALL SUBOPT_0x36
0009b1 91a0 0960 	LDS  R26,__FF_FAT1_ADDR
0009b3 91b0 0961 	LDS  R27,__FF_FAT1_ADDR+1
0009b5 9180 0962 	LDS  R24,__FF_FAT1_ADDR+2
0009b7 9190 0963 	LDS  R25,__FF_FAT1_ADDR+3
0009b9 940e 295c 	CALL __ADDD12
0009bb 93e0 0964 	STS  __FF_FAT2_ADDR,R30
0009bd 93f0 0965 	STS  __FF_FAT2_ADDR+1,R31
0009bf 9360 0966 	STS  __FF_FAT2_ADDR+2,R22
0009c1 9370 0967 	STS  __FF_FAT2_ADDR+3,R23
                 ;    1714 	_FF_ROOT_ADDR = ((long) BPB_NumFATs * (long) BPB_FATSz16) + (long) BPB_RsvdSecCnt;
0009c3 91e0 093a 	LDS  R30,_BPB_NumFATs
0009c5 27ff      	CLR  R31
0009c6 2766      	CLR  R22
0009c7 2777      	CLR  R23
0009c8 01df      	MOVW R26,R30
0009c9 01cb      	MOVW R24,R22
0009ca 91e0 093d 	LDS  R30,_BPB_FATSz16
0009cc 91f0 093e 	LDS  R31,_BPB_FATSz16+1
0009ce 2766      	CLR  R22
0009cf 2777      	CLR  R23
0009d0 940e 29ed 	CALL __MULD12
0009d2 01df      	MOVW R26,R30
0009d3 01cb      	MOVW R24,R22
0009d4 91e0 0938 	LDS  R30,_BPB_RsvdSecCnt
0009d6 91f0 0939 	LDS  R31,_BPB_RsvdSecCnt+1
0009d8 2766      	CLR  R22
0009d9 2777      	CLR  R23
0009da 940e 295c 	CALL __ADDD12
0009dc 93e0 0958 	STS  __FF_ROOT_ADDR,R30
0009de 93f0 0959 	STS  __FF_ROOT_ADDR+1,R31
0009e0 9360 095a 	STS  __FF_ROOT_ADDR+2,R22
0009e2 9370 095b 	STS  __FF_ROOT_ADDR+3,R23
                 ;    1715 	_FF_ROOT_ADDR *= BPB_BytsPerSec;
0009e4 91e0 0935 	LDS  R30,_BPB_BytsPerSec
0009e6 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
0009e8 91a0 0958 	LDS  R26,__FF_ROOT_ADDR
0009ea 91b0 0959 	LDS  R27,__FF_ROOT_ADDR+1
0009ec 9180 095a 	LDS  R24,__FF_ROOT_ADDR+2
0009ee 9190 095b 	LDS  R25,__FF_ROOT_ADDR+3
0009f0 2766      	CLR  R22
0009f1 2777      	CLR  R23
0009f2 940e 29cd 	CALL __MULD12U
0009f4 93e0 0958 	STS  __FF_ROOT_ADDR,R30
0009f6 93f0 0959 	STS  __FF_ROOT_ADDR+1,R31
0009f8 9360 095a 	STS  __FF_ROOT_ADDR+2,R22
0009fa 9370 095b 	STS  __FF_ROOT_ADDR+3,R23
                 ;    1716 	_FF_ROOT_ADDR += _FF_PART_ADDR;
0009fc 91e0 0954 	LDS  R30,__FF_PART_ADDR
0009fe 91f0 0955 	LDS  R31,__FF_PART_ADDR+1
000a00 9160 0956 	LDS  R22,__FF_PART_ADDR+2
000a02 9170 0957 	LDS  R23,__FF_PART_ADDR+3
000a04 91a0 0958 	LDS  R26,__FF_ROOT_ADDR
000a06 91b0 0959 	LDS  R27,__FF_ROOT_ADDR+1
000a08 9180 095a 	LDS  R24,__FF_ROOT_ADDR+2
000a0a 9190 095b 	LDS  R25,__FF_ROOT_ADDR+3
000a0c 940e 295c 	CALL __ADDD12
000a0e 93e0 0958 	STS  __FF_ROOT_ADDR,R30
000a10 93f0 0959 	STS  __FF_ROOT_ADDR+1,R31
000a12 9360 095a 	STS  __FF_ROOT_ADDR+2,R22
000a14 9370 095b 	STS  __FF_ROOT_ADDR+3,R23
                 ;    1717 	
                 ;    1718 	_FF_RootDirSectors = ((BPB_RootEntCnt * 32) + BPB_BytsPerSec - 1) / BPB_BytsPerSec;
000a16 91e0 093b 	LDS  R30,_BPB_RootEntCnt
000a18 91f0 093c 	LDS  R31,_BPB_RootEntCnt+1
000a1a 0fee      	LSL  R30
000a1b 1fff      	ROL  R31
000a1c 940e 299e 	CALL __LSLW4
000a1e 91a0 0935 	LDS  R26,_BPB_BytsPerSec
000a20 91b0 0936 	LDS  R27,_BPB_BytsPerSec+1
000a22 0fae      	ADD  R26,R30
000a23 1fbf      	ADC  R27,R31
000a24 9711      	SBIW R26,1
000a25 91e0 0935 	LDS  R30,_BPB_BytsPerSec
000a27 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
000a29 940e 29f2 	CALL __DIVW21U
000a2b 2766      	CLR  R22
000a2c 2777      	CLR  R23
000a2d 93e0 0968 	STS  __FF_RootDirSectors,R30
000a2f 93f0 0969 	STS  __FF_RootDirSectors+1,R31
000a31 9360 096a 	STS  __FF_RootDirSectors+2,R22
000a33 9370 096b 	STS  __FF_RootDirSectors+3,R23
                 ;    1719 	FirstDataSector = (BPB_NumFATs * BPB_FATSz16) + BPB_RsvdSecCnt + _FF_RootDirSectors; 
000a35 91e0 093d 	LDS  R30,_BPB_FATSz16
000a37 91f0 093e 	LDS  R31,_BPB_FATSz16+1
000a39 91a0 093a 	LDS  R26,_BPB_NumFATs
000a3b e0b0      	LDI  R27,0
000a3c 940e 29c5 	CALL __MULW12U
000a3e 91a0 0938 	LDS  R26,_BPB_RsvdSecCnt
000a40 91b0 0939 	LDS  R27,_BPB_RsvdSecCnt+1
000a42 0fae      	ADD  R26,R30
000a43 1fbf      	ADC  R27,R31
000a44 91e0 0968 	LDS  R30,__FF_RootDirSectors
000a46 91f0 0969 	LDS  R31,__FF_RootDirSectors+1
000a48 9160 096a 	LDS  R22,__FF_RootDirSectors+2
000a4a 9170 096b 	LDS  R23,__FF_RootDirSectors+3
000a4c 2788      	CLR  R24
000a4d 2799      	CLR  R25
000a4e 940e 295c 	CALL __ADDD12
000a50 93e0 096c 	STS  _FirstDataSector,R30
000a52 93f0 096d 	STS  _FirstDataSector+1,R31
                 ;    1720 	
                 ;    1721 	DataClusTot = BPB_TotSec - FirstDataSector;
000a54 91a0 0940 	LDS  R26,_BPB_TotSec
000a56 91b0 0941 	LDS  R27,_BPB_TotSec+1
000a58 9180 0942 	LDS  R24,_BPB_TotSec+2
000a5a 9190 0943 	LDS  R25,_BPB_TotSec+3
000a5c 2766      	CLR  R22
000a5d 2777      	CLR  R23
000a5e 940e 296b 	CALL __SUBD21
000a60 93a0 0977 	STS  _DataClusTot,R26
000a62 93b0 0978 	STS  _DataClusTot+1,R27
000a64 9380 0979 	STS  _DataClusTot+2,R24
000a66 9390 097a 	STS  _DataClusTot+3,R25
                 ;    1722 	DataClusTot /= BPB_SecPerClus;
000a68 91e0 0937 	LDS  R30,_BPB_SecPerClus
000a6a 91a0 0977 	LDS  R26,_DataClusTot
000a6c 91b0 0978 	LDS  R27,_DataClusTot+1
000a6e 9180 0979 	LDS  R24,_DataClusTot+2
000a70 9190 097a 	LDS  R25,_DataClusTot+3
000a72 27ff      	CLR  R31
000a73 2766      	CLR  R22
000a74 2777      	CLR  R23
000a75 940e 2a05 	CALL __DIVD21U
000a77 93e0 0977 	STS  _DataClusTot,R30
000a79 93f0 0978 	STS  _DataClusTot+1,R31
000a7b 9360 0979 	STS  _DataClusTot+2,R22
000a7d 9370 097a 	STS  _DataClusTot+3,R23
                 ;    1723 	clus_0_addr = 0;		// Reset Empty Cluster table location
000a7f e0e0      	LDI  R30,0
000a80 93e0 0982 	STS  _clus_0_addr,R30
000a82 93e0 0983 	STS  _clus_0_addr+1,R30
000a84 93e0 0984 	STS  _clus_0_addr+2,R30
000a86 93e0 0985 	STS  _clus_0_addr+3,R30
                 ;    1724 	c_counter = 1;
000a88 e0e1      	LDI  R30,LOW(1)
000a89 e0f0      	LDI  R31,HIGH(1)
000a8a 93e0 098a 	STS  _c_counter,R30
000a8c 93f0 098b 	STS  _c_counter+1,R31
                 ;    1725 	
                 ;    1726 	if (DataClusTot < 4085)				// FAT12
000a8e 91a0 0977 	LDS  R26,_DataClusTot
000a90 91b0 0978 	LDS  R27,_DataClusTot+1
000a92 9180 0979 	LDS  R24,_DataClusTot+2
000a94 9190 097a 	LDS  R25,_DataClusTot+3
000a96 3fa5
000a97 e0ef
000a98 07be
000a99 e0e0
000a9a 078e
000a9b e0e0
000a9c 079e      	__CPD2N 0xFF5
000a9d f420      	BRSH _0xF1
                 ;    1727 		BPB_FATType = 0x32;
000a9e e3e2      	LDI  R30,LOW(50)
000a9f 93e0 093f 	STS  _BPB_FATType,R30
                 ;    1728 	else if (DataClusTot < 65525)		// FAT16
000aa1 c01c      	RJMP _0xF2
                 _0xF1:
000aa2 91a0 0977 	LDS  R26,_DataClusTot
000aa4 91b0 0978 	LDS  R27,_DataClusTot+1
000aa6 9180 0979 	LDS  R24,_DataClusTot+2
000aa8 9190 097a 	LDS  R25,_DataClusTot+3
000aaa 3fa5
000aab efef
000aac 07be
000aad e0e0
000aae 078e
000aaf e0e0
000ab0 079e      	__CPD2N 0xFFF5
000ab1 f420      	BRSH _0xF3
                 ;    1729 		BPB_FATType = 0x36;
000ab2 e3e6      	LDI  R30,LOW(54)
000ab3 93e0 093f 	STS  _BPB_FATType,R30
                 ;    1730 	else
000ab5 c008      	RJMP _0xF4
                 _0xF3:
                 ;    1731 	{
                 ;    1732 		BPB_FATType = 0;
000ab6 e0e0      	LDI  R30,LOW(0)
000ab7 93e0 093f 	STS  _BPB_FATType,R30
                 ;    1733 		_FF_error = FAT_ERR;
000ab9 e0ec      	LDI  R30,LOW(12)
000aba 93e0 0972 	STS  __FF_error,R30
                 ;    1734 		return (0);
000abc e0e0      	LDI  R30,LOW(0)
000abd c017      	RJMP _0x4DB
                 ;    1735 	}
                 _0xF4:
                 _0xF2:
                 ;    1736     
                 ;    1737 	_FF_DIR_ADDR = _FF_ROOT_ADDR;		// Set current directory to root address
000abe 91e0 0958 	LDS  R30,__FF_ROOT_ADDR
000ac0 91f0 0959 	LDS  R31,__FF_ROOT_ADDR+1
000ac2 9160 095a 	LDS  R22,__FF_ROOT_ADDR+2
000ac4 9170 095b 	LDS  R23,__FF_ROOT_ADDR+3
000ac6 93e0 095c 	STS  __FF_DIR_ADDR,R30
000ac8 93f0 095d 	STS  __FF_DIR_ADDR+1,R31
000aca 9360 095e 	STS  __FF_DIR_ADDR+2,R22
000acc 9370 095f 	STS  __FF_DIR_ADDR+3,R23
                 ;    1738 
                 ;    1739 	_FF_FULL_PATH[0] = 0x5C;	// a '\'
000ace e5ec      	LDI  R30,LOW(92)
000acf 93e0 098c 	STS  __FF_FULL_PATH,R30
                 ;    1740 	_FF_FULL_PATH[1] = 0;
000ad1 e0e0      	LDI  R30,LOW(0)
000ad2 93e0 098d 	__PUTB1MN __FF_FULL_PATH,1
                 ;    1741 	
                 ;    1742 	#ifdef _DEBUG_ON_
                 ;    1743 		printf("\n\rPart Address:  %lX", _FF_PART_ADDR);
                 ;    1744 		printf("\n\rBS_jmpBoot:  %lX", BS_jmpBoot);
                 ;    1745 		printf("\n\rBPB_BytsPerSec:  %X", BPB_BytsPerSec);
                 ;    1746 		printf("\n\rBPB_SecPerClus:  %X", BPB_SecPerClus);
                 ;    1747 		printf("\n\rBPB_RsvdSecCnt:  %X", BPB_RsvdSecCnt);
                 ;    1748 		printf("\n\rBPB_NumFATs:  %X", BPB_NumFATs);
                 ;    1749 		printf("\n\rBPB_RootEntCnt:  %X", BPB_RootEntCnt);
                 ;    1750 		printf("\n\rBPB_FATSz16:  %X", BPB_FATSz16);
                 ;    1751 		printf("\n\rBPB_TotSec16:  %lX", BPB_TotSec);
                 ;    1752 		if (BPB_FATType == 0x32)
                 ;    1753 			printf("\n\rBPB_FATType:  FAT12");
                 ;    1754 		else if (BPB_FATType == 0x36)
                 ;    1755 			printf("\n\rBPB_FATType:  FAT16");
                 ;    1756 		else
                 ;    1757 			printf("\n\rBPB_FATType:  FAT ERROR!!");
                 ;    1758 		printf("\n\rClusterCnt:  %lX", DataClusTot);
                 ;    1759 		printf("\n\rROOT_ADDR:  %lX", _FF_ROOT_ADDR);
                 ;    1760 		printf("\n\rFAT2_ADDR:  %lX", _FF_FAT2_ADDR);
                 ;    1761 		printf("\n\rRootDirSectors:  %X", _FF_RootDirSectors);
                 ;    1762 		printf("\n\rFirstDataSector:  %X", FirstDataSector);
                 ;    1763 	#endif
                 ;    1764 	
                 ;    1765 	return (1);	
000ad4 e0e1      	LDI  R30,LOW(1)
                 _0x4DB:
000ad5 8108      	LDD  R16,Y+0
000ad6 9625      	ADIW R28,5
000ad7 9508      	RET
                 ;    1766 }
                 ;    1767 
                 ;    1768 unsigned char spi_speedset(void)
                 ;    1769 {
                 _spi_speedset:
                 ;    1770 	if (SPCR == 0x50)
000ad8 b1ed      	IN   R30,0xD
000ad9 35e0      	CPI  R30,LOW(0x50)
000ada f419      	BRNE _0xF5
                 ;    1771 		SPCR = 0x51;
000adb e5e1      	LDI  R30,LOW(81)
000adc b9ed      	OUT  0xD,R30
                 ;    1772 	else if (SPCR == 0x51)
000add c00f      	RJMP _0xF6
                 _0xF5:
000ade b1ed      	IN   R30,0xD
000adf 35e1      	CPI  R30,LOW(0x51)
000ae0 f419      	BRNE _0xF7
                 ;    1773 		SPCR = 0x52;
000ae1 e5e2      	LDI  R30,LOW(82)
000ae2 b9ed      	OUT  0xD,R30
                 ;    1774 	else if (SPCR == 0x52)
000ae3 c009      	RJMP _0xF8
                 _0xF7:
000ae4 b1ed      	IN   R30,0xD
000ae5 35e2      	CPI  R30,LOW(0x52)
000ae6 f419      	BRNE _0xF9
                 ;    1775 		SPCR = 0x53;
000ae7 e5e3      	LDI  R30,LOW(83)
000ae8 b9ed      	OUT  0xD,R30
                 ;    1776 	else
000ae9 c003      	RJMP _0xFA
                 _0xF9:
                 ;    1777 	{
                 ;    1778 		SPCR = 0x50;
000aea 940e 2477 	CALL SUBOPT_0x32
                 ;    1779 		return (0);
000aec 9508      	RET
                 ;    1780 	}
                 _0xFA:
                 _0xF8:
                 _0xF6:
                 ;    1781 	return (1);
000aed e0e1      	LDI  R30,LOW(1)
000aee 9508      	RET
                 ;    1782 }
                 ;    1783 
                 ;    1784 unsigned char reset_sd(void)
                 ;    1785 {
                 _reset_sd:
                 ;    1786 	unsigned char resp, n, c;
                 ;    1787 
                 ;    1788 	#ifdef _DEBUG_ON_
                 ;    1789 		printf("\n\rReset CMD:  ");	
                 ;    1790 	#endif
                 ;    1791 
                 ;    1792 	for (c=0; c<4; c++)		// try reset command 3 times if needed
000aef 940e 2abf 	CALL __SAVELOCR3
                 ;	resp -> R16
                 ;	n -> R17
                 ;	c -> R18
000af1 e020      	LDI  R18,LOW(0)
                 _0xFC:
000af2 3024      	CPI  R18,4
000af3 f510      	BRSH _0xFD
                 ;    1793 	{
                 ;    1794 		SD_CS_OFF();
000af4 9ac4      	SBI  0x18,4
                 ;    1795 		for (n=0; n<10; n++)	// initialize clk signal to sync card
000af5 e010      	LDI  R17,LOW(0)
                 _0xFF:
000af6 301a      	CPI  R17,10
000af7 f420      	BRSH _0x100
                 ;    1796 			_FF_spi(0xFF);
000af8 940e 2449 	CALL SUBOPT_0x2D
                 ;    1797 		resp = send_cmd(CMD0,0);
000afa 5f1f      	SUBI R17,-1
000afb cffa      	RJMP _0xFF
                 _0x100:
000afc e0e0      	LDI  R30,LOW(0)
000afd 940e 24c2 	CALL SUBOPT_0x3B
                 ;    1798 		for (n=0; n<200; n++)
000aff e010      	LDI  R17,LOW(0)
                 _0x102:
000b00 3c18      	CPI  R17,200
000b01 f458      	BRSH _0x103
                 ;    1799 		{
                 ;    1800 			if (resp == 0x1)
000b02 3001      	CPI  R16,1
000b03 f421      	BRNE _0x104
                 ;    1801 			{
                 ;    1802 				SD_CS_OFF();
000b04 9ac4      	SBI  0x18,4
                 ;    1803     			#ifdef _DEBUG_ON_
                 ;    1804 					printf("OK!!!");
                 ;    1805 				#endif
                 ;    1806 				SPCR = 0x50;
000b05 940e 24cd 	CALL SUBOPT_0x3C
                 ;    1807 				return(1);
000b07 c031      	RJMP _0x4DA
                 ;    1808 			}
                 ;    1809 	      	resp = _FF_spi(0xFF);
                 _0x104:
000b08 940e 2449 	CALL SUBOPT_0x2D
000b0a 2f0e      	MOV  R16,R30
                 ;    1810 		}
000b0b 5f1f      	SUBI R17,-1
000b0c cff3      	RJMP _0x102
                 _0x103:
                 ;    1811 		#ifdef _DEBUG_ON_
                 ;    1812 			printf("ERROR!!!");
                 ;    1813 		#endif
                 ;    1814  		if (spi_speedset()==0)
000b0d 940e 0ad8 	CALL _spi_speedset
000b0f 30e0      	CPI  R30,0
000b10 f419      	BRNE _0x105
                 ;    1815  		{
                 ;    1816 		    SD_CS_OFF();
000b11 9ac4      	SBI  0x18,4
                 ;    1817  			return (0);
000b12 e0e0      	LDI  R30,LOW(0)
000b13 c025      	RJMP _0x4DA
                 ;    1818  		}
                 ;    1819 	}
                 _0x105:
000b14 5f2f      	SUBI R18,-1
000b15 cfdc      	RJMP _0xFC
                 _0xFD:
                 ;    1820 	return (0);
000b16 e0e0      	LDI  R30,LOW(0)
000b17 c021      	RJMP _0x4DA
                 ;    1821 }
                 ;    1822 
                 ;    1823 unsigned char init_sd(void)
                 ;    1824 {
                 _init_sd:
                 ;    1825 	unsigned char resp;
                 ;    1826 	unsigned int c;
                 ;    1827 	
                 ;    1828 	clear_sd_buff();
000b18 940e 2abf 	CALL __SAVELOCR3
                 ;	resp -> R16
                 ;	c -> R17,R18
000b1a 940e 07f8 	CALL _clear_sd_buff
                 ;    1829 
                 ;    1830     #ifdef _DEBUG_ON_
                 ;    1831 		printf("\r\nInitialization:  ");
                 ;    1832 	#endif
                 ;    1833     for (c=0; c<1000; c++)
000b1c e010
000b1d e020      	__GETWRN 17,18,0
                 _0x107:
000b1e 3e18
000b1f e0e3
000b20 072e      	__CPWRN 17,18,1000
000b21 f490      	BRSH _0x108
                 ;    1834     {
                 ;    1835     	resp = send_cmd(CMD1, 0);
000b22 e0e1      	LDI  R30,LOW(1)
000b23 940e 24c2 	CALL SUBOPT_0x3B
                 ;    1836     	if (resp == 0)
000b25 3000      	CPI  R16,0
000b26 f069      	BREQ _0x108
                 ;    1837     		break;
                 ;    1838    		resp = _FF_spi(0xFF);
000b27 940e 2449 	CALL SUBOPT_0x2D
000b29 2f0e      	MOV  R16,R30
                 ;    1839    		if (resp == 0)
000b2a 3000      	CPI  R16,0
000b2b f041      	BREQ _0x108
                 ;    1840    			break;
                 ;    1841    		resp = _FF_spi(0xFF);
000b2c 940e 2449 	CALL SUBOPT_0x2D
000b2e 2f0e      	MOV  R16,R30
                 ;    1842    		if (resp == 0)
000b2f 3000      	CPI  R16,0
000b30 f019      	BREQ _0x108
                 ;    1843    			break;
                 ;    1844 	}
000b31 5f1f
000b32 4f2f      	__ADDWRN 17,18,1
000b33 cfea      	RJMP _0x107
                 _0x108:
                 ;    1845    	if (resp == 0)
000b34 3000      	CPI  R16,0
000b35 f411      	BRNE _0x10C
                 ;    1846 	{
                 ;    1847 		#ifdef _DEBUG_ON_
                 ;    1848    			printf("OK!");
                 ;    1849 	   	#endif
                 ;    1850 		return (1);
000b36 e0e1      	LDI  R30,LOW(1)
000b37 c001      	RJMP _0x4DA
                 ;    1851 	}
                 ;    1852 	else
                 _0x10C:
                 ;    1853 	{
                 ;    1854 		#ifdef _DEBUG_ON_
                 ;    1855    			printf("ERROR-%x  ", resp);
                 ;    1856 	   	#endif
                 ;    1857 		return (0);
000b38 e0e0      	LDI  R30,LOW(0)
                 ;    1858  	}        		
                 ;    1859 }
                 _0x4DA:
000b39 940e 2ac6 	CALL __LOADLOCR3
000b3b 9623      	ADIW R28,3
000b3c 9508      	RET
                 ;    1860 
                 ;    1861 unsigned char _FF_read_disp(unsigned long sd_addr)
                 ;    1862 {
                 ;    1863 	unsigned char resp;
                 ;    1864 	unsigned long n, remainder;
                 ;    1865 	
                 ;    1866 	if (sd_addr % 0x200)
                 ;	sd_addr -> Y+9
                 ;	resp -> R16
                 ;	n -> Y+5
                 ;	remainder -> Y+1
                 ;    1867 	{	// Not a valid read address, return 0
                 ;    1868 		_FF_error = READ_ERR;
                 ;    1869 		return (0);
                 ;    1870 	}
                 ;    1871 
                 ;    1872 	clear_sd_buff();
                 ;    1873 	resp = send_cmd(CMD17, sd_addr);		// Send read request
                 ;    1874 	
                 ;    1875 	while(resp!=0xFE)
                 ;    1876 		resp = _FF_spi(0xFF);
                 ;    1877 	for (n=0; n<512; n++)
                 ;    1878 	{
                 ;    1879 		remainder = n % 0x10;
                 ;    1880 		if (remainder == 0)
                 ;    1881 			printf("\n\r");
                 ;    1882 		_FF_buff[n] = _FF_spi(0xFF);
                 ;    1883 		if (_FF_buff[n]<0x10)
                 ;    1884 			putchar(0x30);
                 ;    1885 		printf("%X ", _FF_buff[n]);
                 ;    1886 	}
                 ;    1887 	_FF_spi(0xFF);
                 ;    1888 	_FF_spi(0xFF);
                 ;    1889 	_FF_spi(0xFF);
                 ;    1890 	SD_CS_OFF();
                 ;    1891 	return (1);
                 ;    1892 }
                 ;    1893 
                 ;    1894 // Read data from a SD card @ address
                 ;    1895 unsigned char _FF_read(unsigned long sd_addr)
                 ;    1896 {
                 __FF_read:
                 ;    1897 	unsigned char resp;
                 ;    1898 	unsigned long n;
                 ;    1899 //printf("\r\nReadin ADDR [0x%lX]", sd_addr);
                 ;    1900 	
                 ;    1901 	if (sd_addr % BPB_BytsPerSec)
000b3d 9724      	SBIW R28,4
000b3e 930a      	ST   -Y,R16
                 ;	sd_addr -> Y+5
                 ;	resp -> R16
                 ;	n -> Y+1
000b3f 940e 24d1 	CALL SUBOPT_0x3D
000b41 f019      	BREQ _0x117
                 ;    1902 	{	// Not a valid read address, return 0
                 ;    1903 		_FF_error = READ_ERR;
000b42 940e 24e0 	CALL SUBOPT_0x3E
                 ;    1904 		return (0);
000b44 c063      	RJMP _0x4D9
                 ;    1905 	}
                 ;    1906 		
                 ;    1907 	for (;;)
                 _0x117:
                 _0x119:
                 ;    1908 	{
                 ;    1909 		clear_sd_buff();
000b45 940e 07f8 	CALL _clear_sd_buff
                 ;    1910 		resp = send_cmd(CMD17, sd_addr);	// read block command
000b47 e0e7      	LDI  R30,LOW(7)
000b48 940e 24e5 	CALL SUBOPT_0x3F
                 ;    1911 		for (n=0; n<1000; n++)
000b4a e0e0
000b4b 83e9
000b4c 83ea
000b4d 83eb
000b4e 83ec      	__CLRD1S 1
                 _0x11C:
000b4f 81a9
000b50 81ba
000b51 818b
000b52 819c      	__GETD2S 1
000b53 3ea8
000b54 e0e3
000b55 07be
000b56 e0e0
000b57 078e
000b58 e0e0
000b59 079e      	__CPD2N 0x3E8
000b5a f440      	BRSH _0x11D
                 ;    1912 		{
                 ;    1913 			if (resp==0xFE)
000b5b 3f0e      	CPI  R16,254
000b5c f031      	BREQ _0x11D
                 ;    1914 			{	// waiting for start byte
                 ;    1915 				break;
                 ;    1916 			}
                 ;    1917 			resp = _FF_spi(0xFF);
000b5d 940e 2449 	CALL SUBOPT_0x2D
000b5f 2f0e      	MOV  R16,R30
                 ;    1918 		}
000b60 940e 247b 	CALL SUBOPT_0x33
000b62 cfec      	RJMP _0x11C
                 _0x11D:
                 ;    1919 		if (resp==0xFE)
000b63 3f0e      	CPI  R16,254
000b64 f5d9      	BRNE _0x11F
                 ;    1920 		{	// if it is a valid start byte => start reading SD Card
                 ;    1921 			for (n=0; n<BPB_BytsPerSec; n++)
000b65 e0e0
000b66 83e9
000b67 83ea
000b68 83eb
000b69 83ec      	__CLRD1S 1
                 _0x121:
000b6a 91e0 0935 	LDS  R30,_BPB_BytsPerSec
000b6c 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
000b6e 81a9
000b6f 81ba
000b70 818b
000b71 819c      	__GETD2S 1
000b72 2766      	CLR  R22
000b73 2777      	CLR  R23
000b74 940e 2ab7 	CALL __CPD21
000b76 f480      	BRSH _0x122
                 ;    1922 				_FF_buff[n] = _FF_spi(0xFF);
000b77 81e9
000b78 81fa
000b79 816b
000b7a 817c      	__GETD1S 1
000b7b 5de1      	SUBI R30,LOW(-__FF_buff)
000b7c 4ff8      	SBCI R31,HIGH(-__FF_buff)
000b7d 93ff      	PUSH R31
000b7e 93ef      	PUSH R30
000b7f 940e 2449 	CALL SUBOPT_0x2D
000b81 91af      	POP  R26
000b82 91bf      	POP  R27
000b83 93ec      	ST   X,R30
                 ;    1923 			_FF_spi(0xFF);
000b84 940e 247b 	CALL SUBOPT_0x33
000b86 cfe3      	RJMP _0x121
                 _0x122:
000b87 940e 2474 	CALL SUBOPT_0x31
                 ;    1924 			_FF_spi(0xFF);
000b89 940e 2444 	CALL SUBOPT_0x2C
                 ;    1925 			_FF_spi(0xFF);
000b8b 940e 06ff 	CALL __FF_spi
                 ;    1926 			SD_CS_OFF();
000b8d 9ac4      	SBI  0x18,4
                 ;    1927 			_FF_error = NO_ERR;
000b8e e0e0      	LDI  R30,LOW(0)
000b8f 93e0 0972 	STS  __FF_error,R30
                 ;    1928 			_FF_buff_addr = sd_addr;
000b91 81ed
000b92 81fe
000b93 816f
000b94 8578      	__GETD1S 5
000b95 93e0 0973 	STS  __FF_buff_addr,R30
000b97 93f0 0974 	STS  __FF_buff_addr+1,R31
000b99 9360 0975 	STS  __FF_buff_addr+2,R22
000b9b 9370 0976 	STS  __FF_buff_addr+3,R23
                 ;    1929 			SPCR = 0x50;
000b9d 940e 24cd 	CALL SUBOPT_0x3C
                 ;    1930 			return (1);
000b9f c008      	RJMP _0x4D9
                 ;    1931 		}
                 ;    1932 
                 ;    1933 		SD_CS_OFF();
                 _0x11F:
000ba0 9ac4      	SBI  0x18,4
                 ;    1934 
                 ;    1935 		if (spi_speedset()==0)
000ba1 940e 0ad8 	CALL _spi_speedset
000ba3 30e0      	CPI  R30,0
000ba4 f009      	BREQ _0x11A
                 ;    1936 			break;
                 ;    1937 	}	
000ba5 cf9f      	RJMP _0x119
                 _0x11A:
                 ;    1938 	_FF_error = READ_ERR;    
000ba6 940e 24e0 	CALL SUBOPT_0x3E
                 ;    1939 	return(0);
                 _0x4D9:
000ba8 8108      	LDD  R16,Y+0
000ba9 9629      	ADIW R28,9
000baa 9508      	RET
                 ;    1940 }
                 ;    1941 
                 ;    1942 
                 ;    1943 #ifndef _READ_ONLY_
                 ;    1944 unsigned char _FF_write(unsigned long sd_addr)
                 ;    1945 {
                 __FF_write:
                 ;    1946 	unsigned char resp, calc, valid_flag;
                 ;    1947 	unsigned int n;
                 ;    1948 	
                 ;    1949 	if ((sd_addr%BPB_BytsPerSec) || (sd_addr <= _FF_PART_ADDR))
000bab 940e 2abd 	CALL __SAVELOCR5
                 ;	sd_addr -> Y+5
                 ;	resp -> R16
                 ;	calc -> R17
                 ;	valid_flag -> R18
                 ;	n -> R19,R20
000bad 940e 24d1 	CALL SUBOPT_0x3D
000baf f479      	BRNE _0x125
000bb0 91e0 0954 	LDS  R30,__FF_PART_ADDR
000bb2 91f0 0955 	LDS  R31,__FF_PART_ADDR+1
000bb4 9160 0956 	LDS  R22,__FF_PART_ADDR+2
000bb6 9170 0957 	LDS  R23,__FF_PART_ADDR+3
000bb8 81ad
000bb9 81be
000bba 818f
000bbb 8598      	__GETD2S 5
000bbc 940e 2ab2 	CALL __CPD12
000bbe f018      	BRLO _0x124
                 _0x125:
                 ;    1950 	{	// Not a valid write address, return 0
                 ;    1951 		_FF_error = WRITE_ERR;
000bbf 940e 24f0 	CALL SUBOPT_0x40
                 ;    1952 		return (0);
000bc1 c050      	RJMP _0x4D8
                 ;    1953 	}
                 ;    1954 
                 ;    1955 //printf("\r\nWriting to address:  %lX", sd_addr);
                 ;    1956 	for (;;)
                 _0x124:
                 _0x128:
                 ;    1957 	{
                 ;    1958 		clear_sd_buff();
000bc2 940e 07f8 	CALL _clear_sd_buff
                 ;    1959 		resp = send_cmd(CMD24, sd_addr);
000bc4 e0e9      	LDI  R30,LOW(9)
000bc5 940e 24e5 	CALL SUBOPT_0x3F
                 ;    1960 		valid_flag = 0;
000bc7 e020      	LDI  R18,LOW(0)
                 ;    1961 		for (n=0; n<1000; n++)
000bc8 e030
000bc9 e040      	__GETWRN 19,20,0
                 _0x12B:
000bca 3e38
000bcb e0e3
000bcc 074e      	__CPWRN 19,20,1000
000bcd f450      	BRSH _0x12C
                 ;    1962 		{
                 ;    1963 			if (resp == 0x00)
000bce 3000      	CPI  R16,0
000bcf f411      	BRNE _0x12D
                 ;    1964 			{
                 ;    1965 				valid_flag = 1;
000bd0 e021      	LDI  R18,LOW(1)
                 ;    1966 				break;
000bd1 c006      	RJMP _0x12C
                 ;    1967 			}
                 ;    1968 			resp = _FF_spi(0xFF);
                 _0x12D:
000bd2 940e 2449 	CALL SUBOPT_0x2D
000bd4 2f0e      	MOV  R16,R30
                 ;    1969 		}
000bd5 5f3f
000bd6 4f4f      	__ADDWRN 19,20,1
000bd7 cff2      	RJMP _0x12B
                 _0x12C:
                 ;    1970 	
                 ;    1971 		if (valid_flag)
000bd8 3020      	CPI  R18,0
000bd9 f181      	BREQ _0x12E
                 ;    1972 		{
                 ;    1973 			_FF_spi(0xFF);
000bda 940e 2449 	CALL SUBOPT_0x2D
                 ;    1974 			_FF_spi(0xFE);					// Start Block Token
000bdc efee      	LDI  R30,LOW(254)
000bdd 93ea      	ST   -Y,R30
000bde 940e 06ff 	CALL __FF_spi
                 ;    1975 			for (n=0; n<BPB_BytsPerSec; n++)		// Write Data in buffer to card
000be0 e030
000be1 e040      	__GETWRN 19,20,0
                 _0x130:
000be2 91e0 0935 	LDS  R30,_BPB_BytsPerSec
000be4 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
000be6 173e      	CP   R19,R30
000be7 074f      	CPC  R20,R31
000be8 f458      	BRSH _0x131
                 ;    1976 				_FF_spi(_FF_buff[n]);
000be9 e2af      	LDI  R26,LOW(__FF_buff)
000bea e0b7      	LDI  R27,HIGH(__FF_buff)
000beb 0fa3      	ADD  R26,R19
000bec 1fb4      	ADC  R27,R20
000bed 91ec      	LD   R30,X
000bee 93ea      	ST   -Y,R30
000bef 940e 06ff 	CALL __FF_spi
                 ;    1977 			_FF_spi(0xFF);					// Send 2 blank CRC bytes
000bf1 5f3f
000bf2 4f4f      	__ADDWRN 19,20,1
000bf3 cfee      	RJMP _0x130
                 _0x131:
000bf4 940e 2474 	CALL SUBOPT_0x31
                 ;    1978 			_FF_spi(0xFF);
000bf6 940e 2444 	CALL SUBOPT_0x2C
                 ;    1979 			resp = _FF_spi(0xFF);			// Response should be 0bXXX00101
000bf8 940e 06ff 	CALL __FF_spi
000bfa 2f0e      	MOV  R16,R30
                 ;    1980 			calc = resp | 0xE0;
000bfb 2fe0      	MOV  R30,R16
000bfc 6ee0      	ORI  R30,LOW(0xE0)
000bfd 2f1e      	MOV  R17,R30
                 ;    1981 			if (calc==0xE5)
000bfe 3e15      	CPI  R17,229
000bff f451      	BRNE _0x132
                 ;    1982 			{
                 ;    1983 				while(_FF_spi(0xFF)==0)
                 _0x133:
000c00 940e 2449 	CALL SUBOPT_0x2D
000c02 30e0      	CPI  R30,0
000c03 f3e1      	BREQ _0x133
                 ;    1984 					;	// Clear Buffer before returning 'OK'
                 ;    1985 				SD_CS_OFF();
000c04 9ac4      	SBI  0x18,4
                 ;    1986 //				SPCR = 0x50;			// Reset SPI bus Speed
                 ;    1987 				_FF_error = NO_ERR;
000c05 e0e0      	LDI  R30,LOW(0)
000c06 93e0 0972 	STS  __FF_error,R30
                 ;    1988 				return(1);
000c08 e0e1      	LDI  R30,LOW(1)
000c09 c008      	RJMP _0x4D8
                 ;    1989 			}
                 ;    1990 		}
                 _0x132:
                 ;    1991 		SD_CS_OFF(); 
                 _0x12E:
000c0a 9ac4      	SBI  0x18,4
                 ;    1992 
                 ;    1993 		if (spi_speedset()==0)
000c0b 940e 0ad8 	CALL _spi_speedset
000c0d 30e0      	CPI  R30,0
000c0e f009      	BREQ _0x129
                 ;    1994 			break;
                 ;    1995 		// delay_ms(100);		
                 ;    1996 	}
000c0f cfb2      	RJMP _0x128
                 _0x129:
                 ;    1997 	_FF_error = WRITE_ERR;
000c10 940e 24f0 	CALL SUBOPT_0x40
                 ;    1998 	return(0x0);
                 _0x4D8:
000c12 940e 2ac4 	CALL __LOADLOCR5
000c14 9629      	ADIW R28,9
000c15 9508      	RET
                 ;    1999 }
                 ;    2000 #endif
                 ;    2001 /*
                 ;    2002 	Progressive Resources LLC
                 ;    2003                                     
                 ;    2004 			FlashFile
                 ;    2005 	
                 ;    2006 	Version : 	1.32
                 ;    2007 	Date: 		12/31/2003
                 ;    2008 	Author: 	Erick M. Higa
                 ;    2009 	
                 ;    2010 	Revision History:
                 ;    2011 	12/31/2003 - EMH - v1.00 
                 ;    2012 			   	 	 - Initial Release
                 ;    2013 	01/19/2004 - EMH - v1.10
                 ;    2014 			   	 	 - fixed FAT access errors by allowing both FAT tables to be updated
                 ;    2015 					 - fixed erase_cluster chain to stop if chain goes to '0'
                 ;    2016 					 - fixed #include's so other non m128 processors could be used
                 ;    2017 					 - fixed fcreate to match 'C' standard for function "creat"
                 ;    2018 					 - fixed fseek so it would not error when in "READ" mode
                 ;    2019 					 - modified SPI interface to use _FF_spi() so it is more universal
                 ;    2020 					   (see the "sd_cmd.c" file for the function used)
                 ;    2021 					 - redifined global variables and #defines for more unique names
                 ;    2022 					 - added string functions fputs, fputsc, & fgets
                 ;    2023 					 - added functions fquickformat, fgetfileinfo, & GetVolID()
                 ;    2024 					 - added directory support
                 ;    2025 					 - modified delays in "sd_cmd.c" to increase transfer speed to max
                 ;    2026 					 - updated "options.h" to include additions, and to make #defines 
                 ;    2027 					   more universal to multiple platforms
                 ;    2028 	01/21/2004 - EMH - v1.20
                 ;    2029 			   	 	 - Added ICC Support to the FlashFileSD
                 ;    2030 					 - fixed card initialization error for MMC/SD's that have only a boot 
                 ;    2031 			   	 	   sector and no partition table
                 ;    2032 					 - Fixed intermittant error on fcreate when creating existing file
                 ;    2033 					 - changed "options.h" to #include all required files
                 ;    2034 	02/19/2004 - EMH - v1.21
                 ;    2035 					 - Replaced all "const" refrances to "flash" to support CodeVision 1.24.1b
                 ;    2036 	03/02/2004 - EMH - v1.22 (unofficial release)
                 ;    2037 					 - Changed Directory Functions to allow for multi-cluster directory entries
                 ;    2038 					 - Added function addr_to_clust() to support long directories
                 ;    2039 					 - Fixed FAT table address calculation to support multiple reserved sectors
                 ;    2040 					   (previously) assumed one reserved sector, if XP formats card sometimes 
                 ;    2041 					   multiple reserved sectors - thanks YW
                 ;    2042 	03/10/2004 - EMH - v1.30
                 ;    2043 					 - Added support for a Compact Flash package
                 ;    2044 					 - Renamed read and write to flash function names for multiple media support	
                 ;    2045 	03/26/2004 - EMH - v1.31
                 ;    2046 					 - Added define for easy MEGA128Dev board setup
                 ;    2047 					 - Changed demo projects so "option.h" is in the project directory	
                 ;    2048 	04/01/2004 - EMH - v1.32
                 ;    2049 					 - Fixed bug in "prev_cluster()" that didn't use updated FAT table address
                 ;    2050 					   calculations.  (effects XP formatted cards see v1.22 notes)
                 ;    2051                                            
                 ;    2052 	Software License
                 ;    2053 	The use of Progressive Resources LLC FlashFile Source Package indicates 
                 ;    2054 	your understanding and acceptance of the following terms and conditions. 
                 ;    2055 	This license shall supersede any verbal or prior verbal or written, statement 
                 ;    2056 	or agreement to the contrary. If you do not understand or accept these terms, 
                 ;    2057 	or your local regulations prohibit "after sale" license agreements or limited 
                 ;    2058 	disclaimers, you must cease and desist using this product immediately.
                 ;    2059 	This product is © Copyright 2003 by Progressive Resources LLC, all rights 
                 ;    2060 	reserved. International copyright laws, international treaties and all other 
                 ;    2061 	applicable national or international laws protect this product. This software 
                 ;    2062 	product and documentation may not, in whole or in part, be copied, photocopied, 
                 ;    2063 	translated, or reduced to any electronic medium or machine readable form, without 
                 ;    2064 	prior consent in writing, from Progressive Resources LLC and according to all 
                 ;    2065 	applicable laws. The sole owner of this product is Progressive Resources LLC.
                 ;    2066 
                 ;    2067 	Operating License
                 ;    2068 	You have the non-exclusive right to use any enclosed product but have no right 
                 ;    2069 	to distribute it as a source code product without the express written permission 
                 ;    2070 	of Progressive Resources LLC. Use over a "local area network" (within the same 
                 ;    2071 	locale) is permitted provided that only a single person, on a single computer 
                 ;    2072 	uses the product at a time. Use over a "wide area network" (outside the same 
                 ;    2073 	locale) is strictly prohibited under any and all circumstances.
                 ;    2074                                            
                 ;    2075 	Liability Disclaimer
                 ;    2076 	This product and/or license is provided as is, without any representation or 
                 ;    2077 	warranty of any kind, either express or implied, including without limitation 
                 ;    2078 	any representations or endorsements regarding the use of, the results of, or 
                 ;    2079 	performance of the product, Its appropriateness, accuracy, reliability, or 
                 ;    2080 	correctness. The user and/or licensee assume the entire risk as to the use of 
                 ;    2081 	this product. Progressive Resources LLC does not assume liability for the use 
                 ;    2082 	of this product beyond the original purchase price of the software. In no event 
                 ;    2083 	will Progressive Resources LLC be liable for additional direct or indirect 
                 ;    2084 	damages including any lost profits, lost savings, or other incidental or 
                 ;    2085 	consequential damages arising from any defects, or the use or inability to 
                 ;    2086 	use these products, even if Progressive Resources LLC have been advised of 
                 ;    2087 	the possibility of such damages.
                 ;    2088 */                                 
                 ;    2089 
                 ;    2090 	#include <coding.h>
                 ;    2091 
                 ;    2092 extern unsigned long OCR_REG;
                 ;    2093 extern unsigned char _FF_buff[512];
                 ;    2094 extern unsigned int PT_SecStart;
                 ;    2095 extern unsigned long BS_jmpBoot;
                 ;    2096 extern unsigned int BPB_BytsPerSec;
                 ;    2097 extern unsigned char BPB_SecPerClus;
                 ;    2098 extern unsigned int BPB_RsvdSecCnt;
                 ;    2099 extern unsigned char BPB_NumFATs;
                 ;    2100 extern unsigned int BPB_RootEntCnt;
                 ;    2101 extern unsigned int BPB_FATSz16;
                 ;    2102 extern unsigned char BPB_FATType;
                 ;    2103 extern unsigned long BPB_TotSec;
                 ;    2104 extern unsigned long BS_VolSerial;
                 ;    2105 extern unsigned char BS_VolLab[12];
                 ;    2106 extern unsigned long _FF_PART_ADDR, _FF_ROOT_ADDR, _FF_DIR_ADDR;
                 ;    2107 extern unsigned long _FF_FAT1_ADDR, _FF_FAT2_ADDR;
                 ;    2108 extern unsigned int FirstDataSector;
                 ;    2109 extern unsigned long FirstSectorofCluster;
                 ;    2110 extern unsigned char _FF_error;
                 ;    2111 extern unsigned long _FF_buff_addr;
                 ;    2112 extern unsigned long DataClusTot;
                 ;    2113 unsigned char rtc_hour, rtc_min, rtc_sec;
                 
                 	.DSEG
                 _rtc_hour:
00097b           	.BYTE 0x1
                 _rtc_min:
00097c           	.BYTE 0x1
                 _rtc_sec:
00097d           	.BYTE 0x1
                 ;    2114 unsigned char rtc_date, rtc_month;
                 _rtc_date:
00097e           	.BYTE 0x1
                 _rtc_month:
00097f           	.BYTE 0x1
                 ;    2115 unsigned int rtc_year;
                 _rtc_year:
000980           	.BYTE 0x2
                 ;    2116 unsigned long clus_0_addr, _FF_n_temp;
                 _clus_0_addr:
000982           	.BYTE 0x4
                 __FF_n_temp:
000986           	.BYTE 0x4
                 ;    2117 unsigned int c_counter;
                 _c_counter:
00098a           	.BYTE 0x2
                 ;    2118 unsigned char _FF_FULL_PATH[_FF_PATH_LENGTH];
                 __FF_FULL_PATH:
00098c           	.BYTE 0x64
                 ;    2119 unsigned char FILENAME[12];
                 _FILENAME:
0009f0           	.BYTE 0xC
                 ;    2120 
                 ;    2121 // Conversion file to change an ASCII valued character into the calculated value
                 ;    2122 unsigned char ascii_to_char(unsigned char ascii_char)
                 ;    2123 {
                 
                 	.CSEG
                 ;    2124 	unsigned char temp_char;
                 ;    2125 	
                 ;    2126 	if (ascii_char < 0x30)		// invalid, return error
                 ;	ascii_char -> Y+1
                 ;	temp_char -> R16
                 ;    2127 		return (0xFF);
                 ;    2128 	else if (ascii_char < 0x3A)
                 ;    2129 	{	//number, subtract 0x30, retrun value
                 ;    2130 		temp_char = ascii_char - 0x30;
                 ;    2131 		return (temp_char);
                 ;    2132 	}
                 ;    2133 	else if (ascii_char < 0x41)	// invalid, return error
                 ;    2134 		return (0xFF);
                 ;    2135 	else if (ascii_char < 0x47)
                 ;    2136 	{	// lower case a-f, subtract 0x37, return value
                 ;    2137 		temp_char = ascii_char - 0x37;
                 ;    2138 		return (temp_char);
                 ;    2139 	}
                 ;    2140 	else if (ascii_char < 0x61)	// invalid, return error
                 ;    2141 		return (0xFF);
                 ;    2142 	else if (ascii_char < 0x67)
                 ;    2143 	{	// upper case A-F, subtract 0x57, return value
                 ;    2144 		temp_char = ascii_char - 0x57;
                 ;    2145 		return (temp_char);
                 ;    2146 	}
                 ;    2147 	else	// invalid, return error
                 ;    2148 		return (0xFF);
                 ;    2149 }
                 ;    2150 
                 ;    2151 // Function to see if the character is a valid FILENAME character
                 ;    2152 int valid_file_char(unsigned char file_char)
                 ;    2153 {
                 _valid_file_char:
                 ;    2154 	if (file_char < 0x20)
000c16 81a8      	LD   R26,Y
000c17 32a0      	CPI  R26,LOW(0x20)
000c18 f418      	BRSH _0x143
                 ;    2155 		return (EOF);
000c19 efef      	LDI  R30,LOW(65535)
000c1a efff      	LDI  R31,HIGH(65535)
000c1b c020      	RJMP _0x4D7
                 ;    2156 	else if ((file_char==0x22) || (file_char==0x2A) || (file_char==0x2B) || (file_char==0x2C) ||
                 _0x143:
                 ;    2157 			(file_char==0x2E) || (file_char==0x2F) || ((file_char>=0x3A)&&(file_char<=0x3F)) ||
                 ;    2158 			((file_char>=0x5B)&&(file_char<=0x5D)) || (file_char==0x7C) || (file_char==0xE5))
000c1c 81a8      	LD   R26,Y
000c1d 32a2      	CPI  R26,LOW(0x22)
000c1e f0c1      	BREQ _0x146
000c1f 32aa      	CPI  R26,LOW(0x2A)
000c20 f0b1      	BREQ _0x146
000c21 32ab      	CPI  R26,LOW(0x2B)
000c22 f0a1      	BREQ _0x146
000c23 32ac      	CPI  R26,LOW(0x2C)
000c24 f091      	BREQ _0x146
000c25 32ae      	CPI  R26,LOW(0x2E)
000c26 f081      	BREQ _0x146
000c27 32af      	CPI  R26,LOW(0x2F)
000c28 f071      	BREQ _0x146
000c29 33aa      	CPI  R26,LOW(0x3A)
000c2a f010      	BRLO _0x147
000c2b 34a0      	CPI  R26,LOW(0x40)
000c2c f050      	BRLO _0x146
                 _0x147:
000c2d 81a8      	LD   R26,Y
000c2e 35ab      	CPI  R26,LOW(0x5B)
000c2f f010      	BRLO _0x149
000c30 35ae      	CPI  R26,LOW(0x5E)
000c31 f028      	BRLO _0x146
                 _0x149:
000c32 81a8      	LD   R26,Y
000c33 37ac      	CPI  R26,LOW(0x7C)
000c34 f011      	BREQ _0x146
000c35 3ea5      	CPI  R26,LOW(0xE5)
000c36 f419      	BRNE _0x145
                 _0x146:
                 ;    2159 		return (EOF);
000c37 efef      	LDI  R30,LOW(65535)
000c38 efff      	LDI  R31,HIGH(65535)
000c39 c002      	RJMP _0x4D7
                 ;    2160 	else
                 _0x145:
                 ;    2161 		return (0);
000c3a e0e0      	LDI  R30,LOW(0)
000c3b e0f0      	LDI  R31,HIGH(0)
                 ;    2162 }
                 _0x4D7:
000c3c 9621      	ADIW R28,1
000c3d 9508      	RET
                 ;    2163 
                 ;    2164 // Function will scan the directory @VALID_ADDR and return a
                 ;    2165 // '0' if successful (w/ VALID_ADDR changing to location of entry avaliable),
                 ;    2166 // and a '-1' if file or folder exists (w/ VALID_ADDR changing to location of
                 ;    2167 // entry of exisiting file/folder) or if no more entry space (VALID_ADDR would
                 ;    2168 // change to 0).
                 ;    2169 int scan_directory(unsigned long *VALID_ADDR, unsigned char *NAME)
                 ;    2170 {
                 _scan_directory:
                 ;    2171 	unsigned int ent_cntr, ent_max, n, c, dir_clus;
                 ;    2172 	unsigned long temp_addr;
                 ;    2173 	unsigned char *sp, *qp, aval_flag, name_store[14];
                 ;    2174 	
                 ;    2175 	aval_flag = 0;
000c3e 976b      	SBIW R28,27
000c3f 940e 2abc 	CALL __SAVELOCR6
                 ;	*VALID_ADDR -> Y+35
                 ;	*NAME -> Y+33
                 ;	ent_cntr -> R16,R17
                 ;	ent_max -> R18,R19
                 ;	n -> R20,R21
                 ;	c -> Y+31
                 ;	dir_clus -> Y+29
                 ;	temp_addr -> Y+25
                 ;	*sp -> Y+23
                 ;	*qp -> Y+21
                 ;	aval_flag -> Y+20
                 ;	name_store -> Y+6
000c41 e0e0      	LDI  R30,LOW(0)
000c42 8bec      	STD  Y+20,R30
                 ;    2176 	ent_cntr = 0;	// set to 0
000c43 e000
000c44 e010      	__GETWRN 16,17,0
                 ;    2177 	
                 ;    2178 	qp = NAME;
000c45 a1e9      	LDD  R30,Y+33
000c46 a1fa      	LDD  R31,Y+33+1
000c47 8bed      	STD  Y+21,R30
000c48 8bfe      	STD  Y+21+1,R31
                 ;    2179 	for (c=0; c<11; c++)
000c49 e0e0      	LDI  R30,0
000c4a 8fef      	STD  Y+31,R30
000c4b a3e8      	STD  Y+31+1,R30
                 _0x14E:
000c4c 8daf      	LDD  R26,Y+31
000c4d a1b8      	LDD  R27,Y+31+1
000c4e 971b      	SBIW R26,11
000c4f f010      	BRLO PC+3
000c50 940c 0c98 	JMP _0x14F
                 ;    2180 	{
                 ;    2181 		if (valid_file_char(*qp)==0)
000c52 89ad      	LDD  R26,Y+21
000c53 89be      	LDD  R27,Y+21+1
000c54 940e 24f5 	CALL SUBOPT_0x41
000c56 f4a1      	BRNE _0x150
                 ;    2182 			name_store[c] = toupper(*qp++);
000c57 8def      	LDD  R30,Y+31
000c58 a1f8      	LDD  R31,Y+31+1
000c59 01de      	MOVW R26,R28
000c5a 9616      	ADIW R26,6
000c5b 0fea      	ADD  R30,R26
000c5c 1ffb      	ADC  R31,R27
000c5d 93ff      	PUSH R31
000c5e 93ef      	PUSH R30
000c5f 89ad      	LDD  R26,Y+21
000c60 89be      	LDD  R27,Y+21+1
000c61 91ed      	LD   R30,X+
000c62 8bad      	STD  Y+21,R26
000c63 8bbe      	STD  Y+21+1,R27
000c64 93ea      	ST   -Y,R30
000c65 940e 2949 	CALL _toupper
000c67 91af      	POP  R26
000c68 91bf      	POP  R27
000c69 93ec      	ST   X,R30
                 ;    2183 		else if (*qp == '.')
000c6a c02a      	RJMP _0x151
                 _0x150:
000c6b 89ad      	LDD  R26,Y+21
000c6c 89be      	LDD  R27,Y+21+1
000c6d 91ac      	LD   R26,X
000c6e 32ae      	CPI  R26,LOW(0x2E)
000c6f f4a9      	BRNE _0x152
                 ;    2184 		{
                 ;    2185 			while (c<8)
                 _0x153:
000c70 8daf      	LDD  R26,Y+31
000c71 a1b8      	LDD  R27,Y+31+1
000c72 9718      	SBIW R26,8
000c73 f418      	BRSH _0x155
                 ;    2186 				name_store[c++] = 0x20;
000c74 940e 24fb 	CALL SUBOPT_0x42
                 ;    2187 			c--;
000c76 cff9      	RJMP _0x153
                 _0x155:
000c77 8def      	LDD  R30,Y+31
000c78 a1f8      	LDD  R31,Y+31+1
000c79 9731      	SBIW R30,1
000c7a 8fef      	STD  Y+31,R30
000c7b a3f8      	STD  Y+31+1,R31
                 ;    2188 			
                 ;    2189 			qp++;
000c7c 89ed      	LDD  R30,Y+21
000c7d 89fe      	LDD  R31,Y+21+1
000c7e 9631      	ADIW R30,1
000c7f 8bed      	STD  Y+21,R30
000c80 8bfe      	STD  Y+21+1,R31
                 ;    2190 			aval_flag |= 1;
000c81 89ec      	LDD  R30,Y+20
000c82 60e1      	ORI  R30,1
000c83 8bec      	STD  Y+20,R30
                 ;    2191 		}
                 ;    2192 		else if (*qp == 0)
000c84 c010      	RJMP _0x156
                 _0x152:
000c85 89ad      	LDD  R26,Y+21
000c86 89be      	LDD  R27,Y+21+1
000c87 91ec      	LD   R30,X
000c88 30e0      	CPI  R30,0
000c89 f441      	BRNE _0x157
                 ;    2193 		{
                 ;    2194 			while (c<11)
                 _0x158:
000c8a 8daf      	LDD  R26,Y+31
000c8b a1b8      	LDD  R27,Y+31+1
000c8c 971b      	SBIW R26,11
000c8d f418      	BRSH _0x15A
                 ;    2195 				name_store[c++] = 0x20;
000c8e 940e 24fb 	CALL SUBOPT_0x42
                 ;    2196 		}
000c90 cff9      	RJMP _0x158
                 _0x15A:
                 ;    2197 		else
000c91 c003      	RJMP _0x15B
                 _0x157:
                 ;    2198 		{
                 ;    2199 			*VALID_ADDR = 0;
000c92 940e 2508 	CALL SUBOPT_0x43
                 ;    2200 			return (EOF);
000c94 c110      	RJMP _0x4D6
                 ;    2201 		}
                 _0x15B:
                 _0x156:
                 _0x151:
                 ;    2202 	}
000c95 940e 2513 	CALL SUBOPT_0x44
000c97 cfb4      	RJMP _0x14E
                 _0x14F:
                 ;    2203 	name_store[11] = 0;
000c98 e0e0      	LDI  R30,LOW(0)
000c99 8be9      	STD  Y+17,R30
                 ;    2204 	
                 ;    2205 	if (*VALID_ADDR == _FF_ROOT_ADDR)
000c9a a1ab      	LDD  R26,Y+35
000c9b a1bc      	LDD  R27,Y+35+1
000c9c 940e 2a4e 	CALL __GETD1P
000c9e 91a0 0958 	LDS  R26,__FF_ROOT_ADDR
000ca0 91b0 0959 	LDS  R27,__FF_ROOT_ADDR+1
000ca2 9180 095a 	LDS  R24,__FF_ROOT_ADDR+2
000ca4 9190 095b 	LDS  R25,__FF_ROOT_ADDR+3
000ca6 940e 2ab2 	CALL __CPD12
000ca8 f429      	BRNE _0x15C
                 ;    2206 		ent_max = BPB_RootEntCnt;
000ca9 9120 093b
000cab 9130 093c 	__GETWRMN 18,19,0,_BPB_RootEntCnt
                 ;    2207 	else
000cad c019      	RJMP _0x15D
                 _0x15C:
                 ;    2208 	{
                 ;    2209 		dir_clus = addr_to_clust(*VALID_ADDR);
000cae a1ab      	LDD  R26,Y+35
000caf a1bc      	LDD  R27,Y+35+1
000cb0 940e 2a4e 	CALL __GETD1P
000cb2 940e 2a63 	CALL __PUTPARD1
000cb4 d129      	RCALL _addr_to_clust
000cb5 8fed      	STD  Y+29,R30
000cb6 8ffe      	STD  Y+29+1,R31
                 ;    2210 		if (dir_clus != 0)
000cb7 9730      	SBIW R30,0
000cb8 f019      	BREQ _0x15E
                 ;    2211 			aval_flag |= 0x80;
000cb9 89ec      	LDD  R30,Y+20
000cba 68e0      	ORI  R30,0x80
000cbb 8bec      	STD  Y+20,R30
                 ;    2212 		ent_max = ((long) BPB_BytsPerSec * (long) BPB_SecPerClus) / 0x20;
                 _0x15E:
000cbc 940e 2519 	CALL SUBOPT_0x45
000cbe 01df      	MOVW R26,R30
000cbf 01cb      	MOVW R24,R22
000cc0 e2e0
000cc1 e0f0
000cc2 e060
000cc3 e070      	__GETD1N 0x20
000cc4 940e 2a2b 	CALL __DIVD21
000cc6 019f      	MOVW R18,R30
                 ;    2213     }
                 _0x15D:
                 ;    2214 	c = 0;
000cc7 e0e0      	LDI  R30,0
000cc8 8fef      	STD  Y+31,R30
000cc9 a3e8      	STD  Y+31+1,R30
                 ;    2215 	while (ent_cntr < ent_max)	
                 _0x15F:
000cca 1702
000ccb 0713      	__CPWRR 16,17,18,19
000ccc f010      	BRLO PC+3
000ccd 940c 0da3 	JMP _0x161
                 ;    2216 	{
                 ;    2217 		if (_FF_read(*VALID_ADDR+((long)c*BPB_BytsPerSec))==0)
000ccf a1ab      	LDD  R26,Y+35
000cd0 a1bc      	LDD  R27,Y+35+1
000cd1 940e 2a4e 	CALL __GETD1P
000cd3 937f      	PUSH R23
000cd4 936f      	PUSH R22
000cd5 93ff      	PUSH R31
000cd6 93ef      	PUSH R30
000cd7 940e 2529 	CALL SUBOPT_0x46
000cd9 91af      	POP  R26
000cda 91bf      	POP  R27
000cdb 918f      	POP  R24
000cdc 919f      	POP  R25
000cdd 940e 295c 	CALL __ADDD12
000cdf 940e 2488 	CALL SUBOPT_0x34
000ce1 f409      	BRNE _0x162
                 ;    2218 			break;
000ce2 c0c0      	RJMP _0x161
                 ;    2219 		for (n=0; n<16; n++)
                 _0x162:
000ce3 e040
000ce4 e050      	__GETWRN 20,21,0
                 _0x164:
000ce5 3140
000ce6 e0e0
000ce7 075e      	__CPWRN 20,21,16
000ce8 f010      	BRLO PC+3
000ce9 940c 0d7b 	JMP _0x165
                 ;    2220 		{
                 ;    2221 			sp = &_FF_buff[n*0x20];
000ceb 940e 2538 	CALL SUBOPT_0x47
000ced 5de1      	SUBI R30,LOW(-__FF_buff)
000cee 4ff8      	SBCI R31,HIGH(-__FF_buff)
000cef 8bef      	STD  Y+23,R30
000cf0 8ff8      	STD  Y+23+1,R31
                 ;    2222 			qp = name_store;
000cf1 01fe      	MOVW R30,R28
000cf2 9636      	ADIW R30,6
000cf3 8bed      	STD  Y+21,R30
000cf4 8bfe      	STD  Y+21+1,R31
                 ;    2223 			if (*sp==0)
000cf5 89af      	LDD  R26,Y+23
000cf6 8db8      	LDD  R27,Y+23+1
000cf7 91ec      	LD   R30,X
000cf8 30e0      	CPI  R30,0
000cf9 f4e1      	BRNE _0x166
                 ;    2224 			{
                 ;    2225 				if ((aval_flag&0x10)==0)
000cfa 89ec      	LDD  R30,Y+20
000cfb 71e0      	ANDI R30,LOW(0x10)
000cfc f4a1      	BRNE _0x167
                 ;    2226 					temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000cfd a1ab      	LDD  R26,Y+35
000cfe a1bc      	LDD  R27,Y+35+1
000cff 940e 2a4e 	CALL __GETD1P
000d01 937f      	PUSH R23
000d02 936f      	PUSH R22
000d03 93ff      	PUSH R31
000d04 93ef      	PUSH R30
000d05 940e 2529 	CALL SUBOPT_0x46
000d07 91af      	POP  R26
000d08 91bf      	POP  R27
000d09 918f      	POP  R24
000d0a 919f      	POP  R25
000d0b 940e 2961 	CALL __ADDD21
000d0d 940e 2538 	CALL SUBOPT_0x47
000d0f 940e 253e 	CALL SUBOPT_0x48
                 ;    2227 				*VALID_ADDR = temp_addr;
                 _0x167:
000d11 940e 2547 	CALL SUBOPT_0x49
                 ;    2228 				return (0);
000d13 e0e0      	LDI  R30,LOW(0)
000d14 e0f0      	LDI  R31,HIGH(0)
000d15 c08f      	RJMP _0x4D6
                 ;    2229 			}
                 ;    2230 			else if (*sp==0xE5)
                 _0x166:
000d16 89af      	LDD  R26,Y+23
000d17 8db8      	LDD  R27,Y+23+1
000d18 91ac      	LD   R26,X
000d19 3ea5      	CPI  R26,LOW(0xE5)
000d1a f4c1      	BRNE _0x169
                 ;    2231 			{
                 ;    2232 				temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000d1b a1ab      	LDD  R26,Y+35
000d1c a1bc      	LDD  R27,Y+35+1
000d1d 940e 2a4e 	CALL __GETD1P
000d1f 937f      	PUSH R23
000d20 936f      	PUSH R22
000d21 93ff      	PUSH R31
000d22 93ef      	PUSH R30
000d23 940e 2529 	CALL SUBOPT_0x46
000d25 91af      	POP  R26
000d26 91bf      	POP  R27
000d27 918f      	POP  R24
000d28 919f      	POP  R25
000d29 940e 2961 	CALL __ADDD21
000d2b 940e 2538 	CALL SUBOPT_0x47
000d2d 940e 253e 	CALL SUBOPT_0x48
                 ;    2233 				aval_flag |= 0x10;
000d2f 89ec      	LDD  R30,Y+20
000d30 61e0      	ORI  R30,0x10
000d31 8bec      	STD  Y+20,R30
                 ;    2234 			}
                 ;    2235 			else
000d32 c043      	RJMP _0x16A
                 _0x169:
                 ;    2236 			{
                 ;    2237 				if (aval_flag & 0x01)	// file
000d33 89ec      	LDD  R30,Y+20
000d34 70e1      	ANDI R30,LOW(0x1)
000d35 f0e9      	BREQ _0x16B
                 ;    2238 				{
                 ;    2239 					if (strncmp(qp, sp, 11)==0)
000d36 940e 2550 	CALL SUBOPT_0x4A
000d38 f4c9      	BRNE _0x16C
                 ;    2240 					{
                 ;    2241 						temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000d39 a1ab      	LDD  R26,Y+35
000d3a a1bc      	LDD  R27,Y+35+1
000d3b 940e 2a4e 	CALL __GETD1P
000d3d 937f      	PUSH R23
000d3e 936f      	PUSH R22
000d3f 93ff      	PUSH R31
000d40 93ef      	PUSH R30
000d41 940e 2529 	CALL SUBOPT_0x46
000d43 91af      	POP  R26
000d44 91bf      	POP  R27
000d45 918f      	POP  R24
000d46 919f      	POP  R25
000d47 940e 2961 	CALL __ADDD21
000d49 940e 2538 	CALL SUBOPT_0x47
000d4b 940e 253e 	CALL SUBOPT_0x48
                 ;    2242 						*VALID_ADDR = temp_addr;
000d4d 940e 2547 	CALL SUBOPT_0x49
                 ;    2243 						return (EOF);	// file exists @ temp_addr
000d4f efef      	LDI  R30,LOW(65535)
000d50 efff      	LDI  R31,HIGH(65535)
000d51 c053      	RJMP _0x4D6
                 ;    2244 					}
                 ;    2245 				}
                 _0x16C:
                 ;    2246 				else					// folder
000d52 c023      	RJMP _0x16D
                 _0x16B:
                 ;    2247 				{
                 ;    2248 					if ((strncmp(qp, sp, 11)==0)&&(*(sp+11)&0x10))
000d53 940e 2550 	CALL SUBOPT_0x4A
000d55 f431      	BRNE _0x16F
000d56 89af      	LDD  R26,Y+23
000d57 8db8      	LDD  R27,Y+23+1
000d58 961b      	ADIW R26,11
000d59 91ec      	LD   R30,X
000d5a 71e0      	ANDI R30,LOW(0x10)
000d5b f409      	BRNE _0x170
                 _0x16F:
000d5c c019      	RJMP _0x16E
                 _0x170:
                 ;    2249 					{
                 ;    2250 						temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000d5d a1ab      	LDD  R26,Y+35
000d5e a1bc      	LDD  R27,Y+35+1
000d5f 940e 2a4e 	CALL __GETD1P
000d61 937f      	PUSH R23
000d62 936f      	PUSH R22
000d63 93ff      	PUSH R31
000d64 93ef      	PUSH R30
000d65 940e 2529 	CALL SUBOPT_0x46
000d67 91af      	POP  R26
000d68 91bf      	POP  R27
000d69 918f      	POP  R24
000d6a 919f      	POP  R25
000d6b 940e 2961 	CALL __ADDD21
000d6d 940e 2538 	CALL SUBOPT_0x47
000d6f 940e 253e 	CALL SUBOPT_0x48
                 ;    2251 						*VALID_ADDR = temp_addr;
000d71 940e 2547 	CALL SUBOPT_0x49
                 ;    2252 						return (EOF);	// file exists @ temp_addr
000d73 efef      	LDI  R30,LOW(65535)
000d74 efff      	LDI  R31,HIGH(65535)
000d75 c02f      	RJMP _0x4D6
                 ;    2253 					}
                 ;    2254 				}
                 _0x16E:
                 _0x16D:
                 ;    2255 			}
                 _0x16A:
                 ;    2256 			ent_cntr++;
000d76 5f0f
000d77 4f1f      	__ADDWRN 16,17,1
                 ;    2257 		}
000d78 5f4f
000d79 4f5f      	__ADDWRN 20,21,1
000d7a cf6a      	RJMP _0x164
                 _0x165:
                 ;    2258 		c++;
000d7b 940e 2513 	CALL SUBOPT_0x44
                 ;    2259 		if (ent_cntr == ent_max)
000d7d 1720
000d7e 0731      	__CPWRR 18,19,16,17
000d7f f511      	BRNE _0x171
                 ;    2260 		{
                 ;    2261 			if (aval_flag & 0x80)		// a folder @ a valid cluster
000d80 89ec      	LDD  R30,Y+20
000d81 78e0      	ANDI R30,LOW(0x80)
000d82 f0f9      	BREQ _0x172
                 ;    2262 			{
                 ;    2263 				c = next_cluster(dir_clus, SINGLE);
000d83 8ded      	LDD  R30,Y+29
000d84 8dfe      	LDD  R31,Y+29+1
000d85 940e 23e9 	CALL SUBOPT_0x20
000d87 d0d4      	RCALL _next_cluster
000d88 8fef      	STD  Y+31,R30
000d89 a3f8      	STD  Y+31+1,R31
                 ;    2264 				if (c != EOF)
000d8a 8daf      	LDD  R26,Y+31
000d8b a1b8      	LDD  R27,Y+31+1
000d8c 3faf      	CPI  R26,LOW(0xFFFF)
000d8d efef      	LDI  R30,HIGH(0xFFFF)
000d8e 07be      	CPC  R27,R30
000d8f f091      	BREQ _0x173
                 ;    2265 				{	// another dir cluster exists
                 ;    2266 					*VALID_ADDR = clust_to_addr(c);
000d90 8def      	LDD  R30,Y+31
000d91 a1f8      	LDD  R31,Y+31+1
000d92 93fa      	ST   -Y,R31
000d93 93ea      	ST   -Y,R30
000d94 d014      	RCALL _clust_to_addr
000d95 a1ab      	LDD  R26,Y+35
000d96 a1bc      	LDD  R27,Y+35+1
000d97 940e 2a54 	CALL __PUTDP1
                 ;    2267 					dir_clus = c;
000d99 8def      	LDD  R30,Y+31
000d9a a1f8      	LDD  R31,Y+31+1
000d9b 8fed      	STD  Y+29,R30
000d9c 8ffe      	STD  Y+29+1,R31
                 ;    2268 					ent_cntr = 0;
000d9d e000
000d9e e010      	__GETWRN 16,17,0
                 ;    2269 					c = 0;
000d9f e0e0      	LDI  R30,0
000da0 8fef      	STD  Y+31,R30
000da1 a3e8      	STD  Y+31+1,R30
                 ;    2270 				}
                 ;    2271 			}
                 _0x173:
                 ;    2272 		}
                 _0x172:
                 ;    2273 	}
                 _0x171:
000da2 cf27      	RJMP _0x15F
                 _0x161:
                 ;    2274 	*VALID_ADDR = 0;
000da3 940e 2508 	CALL SUBOPT_0x43
                 ;    2275 	return (EOF);	
                 _0x4D6:
000da5 940e 2ac3 	CALL __LOADLOCR6
000da7 96a5      	ADIW R28,37
000da8 9508      	RET
                 ;    2276 }
                 ;    2277 
                 ;    2278 #ifdef _DEBUG_ON_
                 ;    2279 // Function to display all files and folders in the root directory, 
                 ;    2280 // with the size of the file in bytes within the [brakets]
                 ;    2281 void read_directory(void)
                 ;    2282 {
                 ;    2283 	unsigned char valid_flag, attribute_temp;
                 ;    2284 	unsigned int c, n, d, m, dir_clus;
                 ;    2285 	unsigned long calc, calc_clus, dir_addr;
                 ;    2286 	
                 ;    2287 	if (_FF_DIR_ADDR != _FF_ROOT_ADDR)
                 ;    2288 	{
                 ;    2289 		dir_clus = addr_to_clust(_FF_DIR_ADDR);
                 ;    2290 		if (dir_clus == 0)
                 ;    2291 			return;
                 ;    2292 	}
                 ;    2293 
                 ;    2294 	printf("\r\nFile Listing for:  ROOT\\");
                 ;    2295 	for (d=0; d<_FF_PATH_LENGTH; d++)
                 ;    2296 	{
                 ;    2297 		if (_FF_FULL_PATH[d])
                 ;    2298 			putchar(_FF_FULL_PATH[d]);
                 ;    2299 		else
                 ;    2300 			break;
                 ;    2301 	}
                 ;    2302 	
                 ;    2303     
                 ;    2304     dir_addr = _FF_DIR_ADDR;
                 ;    2305 	d = 0;
                 ;    2306 	m = 0;
                 ;    2307 	while (d<BPB_RootEntCnt)
                 ;    2308 	{
                 ;    2309     	if (_FF_read(dir_addr+(m*0x200))==0)
                 ;    2310     		break;
                 ;    2311 		for (n=0; n<16; n++)
                 ;    2312 		{
                 ;    2313 			for (c=0; c<11; c++)
                 ;    2314 			{
                 ;    2315 				if (_FF_buff[(n*0x20)]==0)
                 ;    2316 				{
                 ;    2317 					n=16;
                 ;    2318 					d=BPB_RootEntCnt;
                 ;    2319 					valid_flag = 0;
                 ;    2320 					break;
                 ;    2321 				}
                 ;    2322 				valid_flag = 1;
                 ;    2323 				if (valid_file_char(_FF_buff[(n*0x20)+c]))
                 ;    2324 				{
                 ;    2325 					valid_flag = 0;
                 ;    2326 					break;
                 ;    2327 				}
                 ;    2328 		    }   
                 ;    2329 		    if (valid_flag)
                 ;    2330 	  		{
                 ;    2331 		  		calc = (n * 0x20) + 0xB;
                 ;    2332 		  		attribute_temp = _FF_buff[calc];
                 ;    2333 		  		putchar('\n');
                 ;    2334 				putchar('\r');
                 ;    2335 				c = (n * 0x20);
                 ;    2336 			  	calc = ((long) _FF_buff[c+0x1F] << 24) | ((long) _FF_buff[c+0x1E] << 16) |
                 ;    2337 			  			((long) _FF_buff[c+0x1D] << 8) | ((long) _FF_buff[c+0x1C]);
                 ;    2338 			  	calc_clus = ((int) _FF_buff[c+0x1B] << 8) | (int) _FF_buff[c+0x1A];
                 ;    2339 				if (attribute_temp & 0x10)
                 ;    2340 					printf("  [");
                 ;    2341 				else
                 ;    2342 			  		printf("                [%ld] bytes      (%X)\r  ", calc, calc_clus);		  		
                 ;    2343 				for (c=0; c<8; c++)
                 ;    2344 				{
                 ;    2345 					calc = (n * 0x20) + c;
                 ;    2346 					if (_FF_buff[calc]==0x20)
                 ;    2347 						break;
                 ;    2348 					putchar(_FF_buff[calc]);
                 ;    2349 				}
                 ;    2350 				if (attribute_temp & 0x10)
                 ;    2351 				{
                 ;    2352 					printf("]      (%X)", calc_clus);
                 ;    2353 				}
                 ;    2354 				else
                 ;    2355 				{
                 ;    2356 					putchar('.');
                 ;    2357 					for (c=8; c<11; c++)
                 ;    2358 					{
                 ;    2359 						calc = (n * 0x20) + c;
                 ;    2360 						if (_FF_buff[calc]==0x20)
                 ;    2361 							break;
                 ;    2362 						putchar(_FF_buff[calc]);
                 ;    2363 					}
                 ;    2364 				}
                 ;    2365 		  	}
                 ;    2366 		  	d++;		  		
                 ;    2367 		}
                 ;    2368 		m++;
                 ;    2369 		if (_FF_ROOT_ADDR!=_FF_DIR_ADDR)
                 ;    2370 		{
                 ;    2371 		   	if (m==BPB_SecPerClus)
                 ;    2372 		   	{
                 ;    2373 
                 ;    2374 				m = next_cluster(dir_clus, SINGLE);
                 ;    2375 				if (m != EOF)
                 ;    2376 				{	// another dir cluster exists
                 ;    2377 					dir_addr = clust_to_addr(m);
                 ;    2378 					dir_clus = m;
                 ;    2379 					d = 0;
                 ;    2380 					m = 0;
                 ;    2381 				}
                 ;    2382 				else
                 ;    2383 					break;
                 ;    2384 		   		
                 ;    2385 		   	}
                 ;    2386 		}
                 ;    2387 	}
                 ;    2388 	putchar('\n');
                 ;    2389 	putchar('\r');	
                 ;    2390 } 
                 ;    2391 
                 ;    2392 void GetVolID(void)
                 ;    2393 {
                 ;    2394 	printf("\r\n  Volume Serial:  [0x%lX]", BS_VolSerial);
                 ;    2395 	printf("\r\n  Volume Label:  [%s]\r\n", BS_VolLab);
                 ;    2396 }
                 ;    2397 #endif
                 ;    2398 
                 ;    2399 // Convert a cluster number into a read address
                 ;    2400 unsigned long clust_to_addr(unsigned int clust_no)
                 ;    2401 {
                 _clust_to_addr:
                 ;    2402 	unsigned long clust_addr;
                 ;    2403 	
                 ;    2404 	FirstSectorofCluster = ((clust_no - 2) * (long) BPB_SecPerClus) + (long) FirstDataSector;
000da9 9724      	SBIW R28,4
                 ;	clust_no -> Y+4
                 ;	clust_addr -> Y+0
000daa 81ac      	LDD  R26,Y+4
000dab 81bd      	LDD  R27,Y+4+1
000dac 9712      	SBIW R26,2
000dad 91e0 0937 	LDS  R30,_BPB_SecPerClus
000daf 27ff      	CLR  R31
000db0 2766      	CLR  R22
000db1 2777      	CLR  R23
000db2 2788      	CLR  R24
000db3 2799      	CLR  R25
000db4 940e 29ed 	CALL __MULD12
000db6 01df      	MOVW R26,R30
000db7 01cb      	MOVW R24,R22
000db8 91e0 096c 	LDS  R30,_FirstDataSector
000dba 91f0 096d 	LDS  R31,_FirstDataSector+1
000dbc 2766      	CLR  R22
000dbd 2777      	CLR  R23
000dbe 940e 295c 	CALL __ADDD12
000dc0 93e0 096e 	STS  _FirstSectorofCluster,R30
000dc2 93f0 096f 	STS  _FirstSectorofCluster+1,R31
000dc4 9360 0970 	STS  _FirstSectorofCluster+2,R22
000dc6 9370 0971 	STS  _FirstSectorofCluster+3,R23
                 ;    2405 	clust_addr = (long) FirstSectorofCluster * (long) BPB_BytsPerSec + _FF_PART_ADDR;
000dc8 91e0 0935 	LDS  R30,_BPB_BytsPerSec
000dca 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
000dcc 2766      	CLR  R22
000dcd 2777      	CLR  R23
000dce 91a0 096e 	LDS  R26,_FirstSectorofCluster
000dd0 91b0 096f 	LDS  R27,_FirstSectorofCluster+1
000dd2 9180 0970 	LDS  R24,_FirstSectorofCluster+2
000dd4 9190 0971 	LDS  R25,_FirstSectorofCluster+3
000dd6 940e 255e 	CALL SUBOPT_0x4B
000dd8 83e8
000dd9 83f9
000dda 836a
000ddb 837b      	__PUTD1S 0
                 ;    2406 
                 ;    2407 	return (clust_addr);
000ddc 9626      	ADIW R28,6
000ddd 9508      	RET
                 ;    2408 }
                 ;    2409 
                 ;    2410 // Converts an address into a cluster number
                 ;    2411 unsigned int addr_to_clust(unsigned long clus_addr)
                 ;    2412 {
                 _addr_to_clust:
                 ;    2413 	if (clus_addr <= _FF_PART_ADDR)
000dde 91e0 0954 	LDS  R30,__FF_PART_ADDR
000de0 91f0 0955 	LDS  R31,__FF_PART_ADDR+1
000de2 9160 0956 	LDS  R22,__FF_PART_ADDR+2
000de4 9170 0957 	LDS  R23,__FF_PART_ADDR+3
000de6 81a8
000de7 81b9
000de8 818a
000de9 819b      	__GETD2S 0
000dea 940e 2ab2 	CALL __CPD12
000dec f018      	BRLO _0x174
                 ;    2414 		return (0);
000ded e0e0      	LDI  R30,LOW(0)
000dee e0f0      	LDI  R31,HIGH(0)
000def c06a      	RJMP _0x4D5
                 ;    2415 	clus_addr -= _FF_PART_ADDR;
                 _0x174:
000df0 91a0 0954 	LDS  R26,__FF_PART_ADDR
000df2 91b0 0955 	LDS  R27,__FF_PART_ADDR+1
000df4 9180 0956 	LDS  R24,__FF_PART_ADDR+2
000df6 9190 0957 	LDS  R25,__FF_PART_ADDR+3
000df8 81e8
000df9 81f9
000dfa 816a
000dfb 817b      	__GETD1S 0
000dfc 940e 2966 	CALL __SUBD12
000dfe 83e8
000dff 83f9
000e00 836a
000e01 837b      	__PUTD1S 0
                 ;    2416 	clus_addr /= BPB_BytsPerSec;
000e02 91e0 0935 	LDS  R30,_BPB_BytsPerSec
000e04 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
000e06 81a8
000e07 81b9
000e08 818a
000e09 819b      	__GETD2S 0
000e0a 2766      	CLR  R22
000e0b 2777      	CLR  R23
000e0c 940e 2a05 	CALL __DIVD21U
000e0e 83e8
000e0f 83f9
000e10 836a
000e11 837b      	__PUTD1S 0
                 ;    2417 	if (clus_addr <= (unsigned long) FirstDataSector)
000e12 91e0 096c 	LDS  R30,_FirstDataSector
000e14 91f0 096d 	LDS  R31,_FirstDataSector+1
000e16 2766      	CLR  R22
000e17 2777      	CLR  R23
000e18 81a8
000e19 81b9
000e1a 818a
000e1b 819b      	__GETD2S 0
000e1c 940e 2ab2 	CALL __CPD12
000e1e f018      	BRLO _0x175
                 ;    2418 		return (0);
000e1f e0e0      	LDI  R30,LOW(0)
000e20 e0f0      	LDI  R31,HIGH(0)
000e21 c038      	RJMP _0x4D5
                 ;    2419 	clus_addr -= FirstDataSector;
                 _0x175:
000e22 91e0 096c 	LDS  R30,_FirstDataSector
000e24 91f0 096d 	LDS  R31,_FirstDataSector+1
000e26 81a8
000e27 81b9
000e28 818a
000e29 819b      	__GETD2S 0
000e2a 2766      	CLR  R22
000e2b 2777      	CLR  R23
000e2c 940e 296b 	CALL __SUBD21
000e2e 83a8
000e2f 83b9
000e30 838a
000e31 839b      	__PUTD2S 0
                 ;    2420 	clus_addr /= BPB_SecPerClus;
000e32 91e0 0937 	LDS  R30,_BPB_SecPerClus
000e34 81a8
000e35 81b9
000e36 818a
000e37 819b      	__GETD2S 0
000e38 27ff      	CLR  R31
000e39 2766      	CLR  R22
000e3a 2777      	CLR  R23
000e3b 940e 2a05 	CALL __DIVD21U
000e3d 83e8
000e3e 83f9
000e3f 836a
000e40 837b      	__PUTD1S 0
                 ;    2421 	clus_addr += 2;
000e41 5fee
000e42 4fff
000e43 4f6f
000e44 4f7f      	__ADDD1N 2
000e45 83e8
000e46 83f9
000e47 836a
000e48 837b      	__PUTD1S 0
                 ;    2422 	if (clus_addr > 0xFFFF)
000e49 81a8
000e4a 81b9
000e4b 818a
000e4c 819b      	__GETD2S 0
000e4d 30a0
000e4e e0e0
000e4f 07be
000e50 e0e1
000e51 078e
000e52 e0e0
000e53 079e      	__CPD2N 0x10000
000e54 f018      	BRLO _0x176
                 ;    2423 		return (0);
000e55 e0e0      	LDI  R30,LOW(0)
000e56 e0f0      	LDI  R31,HIGH(0)
000e57 c002      	RJMP _0x4D5
                 ;    2424 	
                 ;    2425 	return ((int) clus_addr);	
                 _0x176:
000e58 81e8      	LD   R30,Y
000e59 81f9      	LDD  R31,Y+1
                 _0x4D5:
000e5a 9624      	ADIW R28,4
000e5b 9508      	RET
                 ;    2426 }
                 ;    2427 
                 ;    2428 // Find the cluster that the current cluster is pointing to
                 ;    2429 unsigned int next_cluster(unsigned int current_cluster, unsigned char mode)
                 ;    2430 {
                 _next_cluster:
                 ;    2431 	unsigned int calc_sec, calc_offset, calc_remainder, next_clust;
                 ;    2432 	unsigned long addr_temp;
                 ;    2433 	
                 ;    2434 	if (current_cluster<=1)		// If cluster is 0 or 1, its the wrong cluster
000e5c 9726      	SBIW R28,6
000e5d 940e 2abc 	CALL __SAVELOCR6
                 ;	current_cluster -> Y+13
                 ;	mode -> Y+12
                 ;	calc_sec -> R16,R17
                 ;	calc_offset -> R18,R19
                 ;	calc_remainder -> R20,R21
                 ;	next_clust -> Y+10
                 ;	addr_temp -> Y+6
000e5f 85ad      	LDD  R26,Y+13
000e60 85be      	LDD  R27,Y+13+1
000e61 9712      	SBIW R26,2
000e62 f418      	BRSH _0x177
                 ;    2435 		return (EOF);
000e63 efef      	LDI  R30,LOW(65535)
000e64 efff      	LDI  R31,HIGH(65535)
000e65 c073      	RJMP _0x4D4
                 ;    2436 		
                 ;    2437 	if (BPB_FATType == 0x36)		// if FAT16
                 _0x177:
000e66 91a0 093f 	LDS  R26,_BPB_FATType
000e68 33a6      	CPI  R26,LOW(0x36)
000e69 f011      	BREQ PC+3
000e6a 940c 0ed4 	JMP _0x178
                 ;    2438 	{
                 ;    2439 		// FAT16 table address calculations
                 ;    2440 		calc_sec = current_cluster / (BPB_BytsPerSec / 2) + BPB_RsvdSecCnt;
000e6c 940e 256b 	CALL SUBOPT_0x4C
000e6e 940e 2574 	CALL SUBOPT_0x4D
                 ;    2441 		calc_offset = 2 * (current_cluster % (BPB_BytsPerSec / 2));
000e70 940e 256b 	CALL SUBOPT_0x4C
000e72 940e 257e 	CALL SUBOPT_0x4E
                 ;    2442 	    
                 ;    2443 	 	addr_temp = _FF_PART_ADDR+(calc_sec*0x200);
000e74 0fee      	LSL  R30
000e75 1fff      	ROL  R31
000e76 2ffe      	MOV  R31,R30
000e77 e0e0      	LDI  R30,0
000e78 91a0 0954 	LDS  R26,__FF_PART_ADDR
000e7a 91b0 0955 	LDS  R27,__FF_PART_ADDR+1
000e7c 9180 0956 	LDS  R24,__FF_PART_ADDR+2
000e7e 9190 0957 	LDS  R25,__FF_PART_ADDR+3
000e80 2766      	CLR  R22
000e81 2777      	CLR  R23
000e82 940e 295c 	CALL __ADDD12
000e84 83ee
000e85 83ff
000e86 8768
000e87 8779      	__PUTD1S 6
                 ;    2444 		if (mode==SINGLE)
000e88 85ac      	LDD  R26,Y+12
000e89 30a1      	CPI  R26,LOW(0x1)
000e8a f439      	BRNE _0x179
                 ;    2445 		{	// This is a single cluster lookup
                 ;    2446 			if (_FF_read(addr_temp)==0)
000e8b 940e 2488 	CALL SUBOPT_0x34
000e8d f419      	BRNE _0x17A
                 ;    2447 				return(EOF);
000e8e efef      	LDI  R30,LOW(65535)
000e8f efff      	LDI  R31,HIGH(65535)
000e90 c048      	RJMP _0x4D4
                 ;    2448 		}
                 _0x17A:
                 ;    2449 		else if ((mode==CHAIN) || (mode==END_CHAIN))
000e91 c030      	RJMP _0x17B
                 _0x179:
000e92 85ac      	LDD  R26,Y+12
000e93 30a0      	CPI  R26,LOW(0x0)
000e94 f011      	BREQ _0x17D
000e95 30a2      	CPI  R26,LOW(0x2)
000e96 f559      	BRNE _0x17C
                 _0x17D:
                 ;    2450 		{	// Mupltiple clusters to lookup
                 ;    2451 			if (addr_temp!=_FF_buff_addr)
000e97 91e0 0973 	LDS  R30,__FF_buff_addr
000e99 91f0 0974 	LDS  R31,__FF_buff_addr+1
000e9b 9160 0975 	LDS  R22,__FF_buff_addr+2
000e9d 9170 0976 	LDS  R23,__FF_buff_addr+3
000e9f 81ae
000ea0 81bf
000ea1 8588
000ea2 8599      	__GETD2S 6
000ea3 940e 2ab2 	CALL __CPD12
000ea5 f0e1      	BREQ _0x17F
                 ;    2452 			{	// Is the address of lookup is different then the current buffere address
                 ;    2453 				#ifndef _READ_ONLY_
                 ;    2454 				if (_FF_buff_addr)	// if the buffer address is 0, don't write
000ea6 940e 2aa4 	CALL __CPD10
000ea8 f079      	BREQ _0x180
                 ;    2455 				{
                 ;    2456 					#ifdef _SECOND_FAT_ON_
                 ;    2457 						if (_FF_buff_addr < _FF_FAT2_ADDR)
000ea9 940e 2585 	CALL SUBOPT_0x4F
000eab f430      	BRSH _0x181
                 ;    2458 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000eac 940e 2598 	CALL SUBOPT_0x50
000eae f419      	BRNE _0x182
                 ;    2459 								return(EOF);
000eaf efef      	LDI  R30,LOW(65535)
000eb0 efff      	LDI  R31,HIGH(65535)
000eb1 c027      	RJMP _0x4D4
                 ;    2460 					#endif
                 ;    2461 					if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
                 _0x182:
                 _0x181:
000eb2 940e 25ba 	CALL SUBOPT_0x51
000eb4 f419      	BRNE _0x183
                 ;    2462 						return(EOF);
000eb5 efef      	LDI  R30,LOW(65535)
000eb6 efff      	LDI  R31,HIGH(65535)
000eb7 c021      	RJMP _0x4D4
                 ;    2463 				}
                 _0x183:
                 ;    2464 				#endif
                 ;    2465 				if (_FF_read(addr_temp)==0)	// Read new table info
                 _0x180:
000eb8 81ee
000eb9 81ff
000eba 8568
000ebb 8579      	__GETD1S 6
000ebc 940e 2488 	CALL SUBOPT_0x34
000ebe f419      	BRNE _0x184
                 ;    2466 					return(EOF);
000ebf efef      	LDI  R30,LOW(65535)
000ec0 efff      	LDI  R31,HIGH(65535)
000ec1 c017      	RJMP _0x4D4
                 ;    2467 			}
                 _0x184:
                 ;    2468 		}
                 _0x17F:
                 ;    2469 		next_clust = ((int) _FF_buff[calc_offset+1] << 8) | _FF_buff[calc_offset];
                 _0x17C:
                 _0x17B:
000ec2 01f9      	MOVW R30,R18
000ec3 5de0
000ec4 4ff8      	__ADDW1MN __FF_buff,1
000ec5 81f0      	LD   R31,Z
000ec6 e0e0      	LDI  R30,LOW(0)
000ec7 010f      	MOVW R0,R30
000ec8 e2af      	LDI  R26,LOW(__FF_buff)
000ec9 e0b7      	LDI  R27,HIGH(__FF_buff)
000eca 0fa2      	ADD  R26,R18
000ecb 1fb3      	ADC  R27,R19
000ecc 91ec      	LD   R30,X
000ecd 01d0      	MOVW R26,R0
000ece e0f0      	LDI  R31,0
000ecf 2bea      	OR   R30,R26
000ed0 2bfb      	OR   R31,R27
000ed1 87ea      	STD  Y+10,R30
000ed2 87fb      	STD  Y+10+1,R31
                 ;    2470 	}
                 ;    2471 	#ifdef _FAT12_ON_
                 ;    2472 	else if (BPB_FATType == 0x32)	// if FAT12
                 ;    2473 	{
                 ;    2474 		// FAT12 table address calculations
                 ;    2475 		calc_offset = (current_cluster * 3) / 2;
                 ;    2476 		calc_remainder = (current_cluster * 3) % 2;
                 ;    2477 		calc_sec = (calc_offset / BPB_BytsPerSec) + BPB_RsvdSecCnt;
                 ;    2478 		calc_offset %= BPB_BytsPerSec;
                 ;    2479 
                 ;    2480 	 	addr_temp = _FF_PART_ADDR+(calc_sec*BPB_BytsPerSec);
                 ;    2481 		if (mode==SINGLE)
                 ;    2482 		{	// This is a single cluster lookup
                 ;    2483 			if (_FF_read(addr_temp)==0)
                 ;    2484 				return(EOF);
                 ;    2485 		}
                 ;    2486 		else if ((mode==CHAIN) || (mode==END_CHAIN))
                 ;    2487 		{	// Mupltiple clusters to lookup
                 ;    2488 			if (addr_temp!=_FF_buff_addr)
                 ;    2489 			{	// Is the address of lookup is different then the current buffere address
                 ;    2490 				#ifndef _READ_ONLY_
                 ;    2491 				if (_FF_buff_addr)	// if the buffer address is 0, don't write
                 ;    2492 				{
                 ;    2493 					#ifdef _SECOND_FAT_ON_
                 ;    2494 						if (_FF_buff_addr < _FF_FAT2_ADDR)
                 ;    2495 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2496 								return(EOF);
                 ;    2497 					#endif
                 ;    2498 					if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
                 ;    2499 						return(EOF);
                 ;    2500 				}
                 ;    2501 				#endif
                 ;    2502 				if (_FF_read(addr_temp)==0)	// Read new table info
                 ;    2503 					return(EOF);
                 ;    2504 			}
                 ;    2505 		}
                 ;    2506 		next_clust = _FF_buff[calc_offset];
                 ;    2507 		if (calc_offset == (BPB_BytsPerSec-1))
                 ;    2508 		{	// Is the FAT12 record accross more than one sector?
                 ;    2509 			addr_temp = _FF_PART_ADDR+((calc_sec+1)*0x200);
                 ;    2510 			if ((mode==CHAIN) || (mode==END_CHAIN))
                 ;    2511 			{	// multiple chain lookup
                 ;    2512 				#ifndef _READ_ONLY_
                 ;    2513 					#ifdef _SECOND_FAT_ON_
                 ;    2514 						if (_FF_buff_addr < _FF_FAT2_ADDR)
                 ;    2515 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2516 								return(EOF);
                 ;    2517 					#endif
                 ;    2518 				if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
                 ;    2519 					return(EOF);
                 ;    2520 				#endif
                 ;    2521 				_FF_buff_addr = addr_temp;		// Save new buffer address
                 ;    2522 			}
                 ;    2523 			if (_FF_read(addr_temp)==0)
                 ;    2524 				return(EOF);
                 ;    2525 			next_clust |= ((int) _FF_buff[0] << 8);
                 ;    2526 		}
                 ;    2527 		else
                 ;    2528 			next_clust |= ((int) _FF_buff[calc_offset+1] << 8);
                 ;    2529 
                 ;    2530 		if (calc_remainder)
                 ;    2531 			next_clust >>= 4;
                 ;    2532 		else
                 ;    2533 			next_clust &= 0x0FFF;
                 ;    2534 			
                 ;    2535 		if (next_clust >= 0xFF8)
                 ;    2536 			next_clust |= 0xF000;			
                 ;    2537 	}
                 ;    2538 	#endif
                 ;    2539 	else		// not FAT12 or FAT16, return 0
000ed3 c003      	RJMP _0x185
                 _0x178:
                 ;    2540 		return (EOF);
000ed4 efef      	LDI  R30,LOW(65535)
000ed5 efff      	LDI  R31,HIGH(65535)
000ed6 c002      	RJMP _0x4D4
                 ;    2541 	return (next_clust);
                 _0x185:
000ed7 85ea      	LDD  R30,Y+10
000ed8 85fb      	LDD  R31,Y+10+1
                 _0x4D4:
000ed9 940e 2ac3 	CALL __LOADLOCR6
000edb 962f      	ADIW R28,15
000edc 9508      	RET
                 ;    2542 }
                 ;    2543 
                 ;    2544 // Convert a constant string file name into the proper 8.3 FAT format
                 ;    2545 unsigned char *file_name_conversion(unsigned char *current_file)
                 ;    2546 {
                 _file_name_conversion:
                 ;    2547 	unsigned char n, c;
                 ;    2548 		
                 ;    2549 	c = 0;
000edd 931a      	ST   -Y,R17
000ede 930a      	ST   -Y,R16
                 ;	*current_file -> Y+2
                 ;	n -> R16
                 ;	c -> R17
000edf e010      	LDI  R17,LOW(0)
                 ;    2550 	
                 ;    2551 	for (n=0; n<14; n++)
000ee0 e000      	LDI  R16,LOW(0)
                 _0x187:
000ee1 300e      	CPI  R16,14
000ee2 f5c8      	BRSH _0x188
                 ;    2552 	{
                 ;    2553 		if (valid_file_char(current_file[n])==0)
000ee3 940e 25c8 	CALL SUBOPT_0x52
000ee5 940e 0c16 	CALL _valid_file_char
000ee7 9730      	SBIW R30,0
000ee8 f479      	BRNE _0x189
                 ;    2554 			// If the character is valid, save in uppercase to file name buffer
                 ;    2555 			FILENAME[c++] = toupper(current_file[n]);
000ee9 2fe1      	MOV  R30,R17
000eea 5f1f      	SUBI R17,-1
000eeb e0f0      	LDI  R31,0
000eec 51e0      	SUBI R30,LOW(-_FILENAME)
000eed 4ff6      	SBCI R31,HIGH(-_FILENAME)
000eee 93ff      	PUSH R31
000eef 93ef      	PUSH R30
000ef0 940e 25c8 	CALL SUBOPT_0x52
000ef2 940e 2949 	CALL _toupper
000ef4 91af      	POP  R26
000ef5 91bf      	POP  R27
000ef6 93ec      	ST   X,R30
                 ;    2556 		else if (current_file[n]=='.')
000ef7 c020      	RJMP _0x18A
                 _0x189:
000ef8 940e 25cd 	CALL SUBOPT_0x53
000efa 91ac      	LD   R26,X
000efb 32ae      	CPI  R26,LOW(0x2E)
000efc f441      	BRNE _0x18B
                 ;    2557 			// If it is a period, back fill buffer with [spaces], till 8 characters deep
                 ;    2558 			while (c<8)
                 _0x18C:
000efd 3018      	CPI  R17,8
000efe f428      	BRSH _0x18E
                 ;    2559 				FILENAME[c++] = 0x20;
000eff 2fe1      	MOV  R30,R17
000f00 5f1f      	SUBI R17,-1
000f01 940e 25d4 	CALL SUBOPT_0x54
                 ;    2560 		else if (current_file[n]==0)
000f03 cff9      	RJMP _0x18C
                 _0x18E:
000f04 c013      	RJMP _0x18F
                 _0x18B:
000f05 940e 25cd 	CALL SUBOPT_0x53
000f07 91ec      	LD   R30,X
000f08 30e0      	CPI  R30,0
000f09 f441      	BRNE _0x190
                 ;    2561 		{	// If it is NULL, back fill buffer with [spaces], till 11 characters deep
                 ;    2562 			while (c<11)
                 _0x191:
000f0a 301b      	CPI  R17,11
000f0b f428      	BRSH _0x193
                 ;    2563 				FILENAME[c++] = 0x20;
000f0c 2fe1      	MOV  R30,R17
000f0d 5f1f      	SUBI R17,-1
000f0e 940e 25d4 	CALL SUBOPT_0x54
                 ;    2564 			break;
000f10 cff9      	RJMP _0x191
                 _0x193:
000f11 c00a      	RJMP _0x188
                 ;    2565 		}
                 ;    2566 		else
                 _0x190:
                 ;    2567 		{
                 ;    2568 			_FF_error = NAME_ERR;
000f12 e0e5      	LDI  R30,LOW(5)
000f13 93e0 0972 	STS  __FF_error,R30
                 ;    2569 			return (0);
000f15 e0e0      	LDI  R30,LOW(0)
000f16 e0f0      	LDI  R31,HIGH(0)
000f17 c00c      	RJMP _0x4D3
                 ;    2570 		}
                 _0x18F:
                 _0x18A:
                 ;    2571 		if (c>=11)
000f18 301b      	CPI  R17,11
000f19 f410      	BRSH _0x188
                 ;    2572 			break;
                 ;    2573 	}
000f1a 5f0f      	SUBI R16,-1
000f1b cfc5      	RJMP _0x187
                 _0x188:
                 ;    2574 	FILENAME[c] = 0;
000f1c 2fa1      	MOV  R26,R17
000f1d e0b0      	LDI  R27,0
000f1e 51a0      	SUBI R26,LOW(-_FILENAME)
000f1f 4fb6      	SBCI R27,HIGH(-_FILENAME)
000f20 e0e0      	LDI  R30,LOW(0)
000f21 93ec      	ST   X,R30
                 ;    2575 	// Return the pointer of the filename
                 ;    2576 	return (FILENAME);		
000f22 efe0      	LDI  R30,LOW(_FILENAME)
000f23 e0f9      	LDI  R31,HIGH(_FILENAME)
                 _0x4D3:
000f24 8119      	LDD  R17,Y+1
000f25 8108      	LDD  R16,Y+0
000f26 9624      	ADIW R28,4
000f27 9508      	RET
                 ;    2577 }
                 ;    2578 
                 ;    2579 // Find the first cluster that is pointing to clus_no
                 ;    2580 unsigned int prev_cluster(unsigned int clus_no)
                 ;    2581 {
                 _prev_cluster:
                 ;    2582 	unsigned char read_flag;
                 ;    2583 	unsigned int calc_temp, n, c, n_temp;
                 ;    2584 	unsigned long calc_clus, addr_temp;
                 ;    2585 	
                 ;    2586 	addr_temp = _FF_FAT1_ADDR;
000f28 972c      	SBIW R28,12
000f29 940e 2abd 	CALL __SAVELOCR5
                 ;	clus_no -> Y+17
                 ;	read_flag -> R16
                 ;	calc_temp -> R17,R18
                 ;	n -> R19,R20
                 ;	c -> Y+15
                 ;	n_temp -> Y+13
                 ;	calc_clus -> Y+9
                 ;	addr_temp -> Y+5
000f2b 91e0 0960 	LDS  R30,__FF_FAT1_ADDR
000f2d 91f0 0961 	LDS  R31,__FF_FAT1_ADDR+1
000f2f 9160 0962 	LDS  R22,__FF_FAT1_ADDR+2
000f31 9170 0963 	LDS  R23,__FF_FAT1_ADDR+3
000f33 83ed
000f34 83fe
000f35 836f
000f36 8778      	__PUTD1S 5
                 ;    2587 	c = 1;
000f37 e0e1      	LDI  R30,LOW(1)
000f38 e0f0      	LDI  R31,HIGH(1)
000f39 87ef      	STD  Y+15,R30
000f3a 8bf8      	STD  Y+15+1,R31
                 ;    2588 	if ((clus_no==0) && (BPB_FATType==0x36))
000f3b 89a9      	LDD  R26,Y+17
000f3c 89ba      	LDD  R27,Y+17+1
000f3d 940e 2aa8 	CALL __CPW02
000f3f f421      	BRNE _0x197
000f40 91a0 093f 	LDS  R26,_BPB_FATType
000f42 33a6      	CPI  R26,LOW(0x36)
000f43 f009      	BREQ _0x198
                 _0x197:
000f44 c021      	RJMP _0x196
                 _0x198:
                 ;    2589 	{
                 ;    2590 		if (clus_0_addr>addr_temp)
000f45 81ed
000f46 81fe
000f47 816f
000f48 8578      	__GETD1S 5
000f49 91a0 0982 	LDS  R26,_clus_0_addr
000f4b 91b0 0983 	LDS  R27,_clus_0_addr+1
000f4d 9180 0984 	LDS  R24,_clus_0_addr+2
000f4f 9190 0985 	LDS  R25,_clus_0_addr+3
000f51 940e 2ab2 	CALL __CPD12
000f53 f490      	BRSH _0x199
                 ;    2591 		{
                 ;    2592 			addr_temp = clus_0_addr;
000f54 91e0 0982 	LDS  R30,_clus_0_addr
000f56 91f0 0983 	LDS  R31,_clus_0_addr+1
000f58 9160 0984 	LDS  R22,_clus_0_addr+2
000f5a 9170 0985 	LDS  R23,_clus_0_addr+3
000f5c 83ed
000f5d 83fe
000f5e 836f
000f5f 8778      	__PUTD1S 5
                 ;    2593 			c = c_counter;
000f60 91e0 098a 	LDS  R30,_c_counter
000f62 91f0 098b 	LDS  R31,_c_counter+1
000f64 87ef      	STD  Y+15,R30
000f65 8bf8      	STD  Y+15+1,R31
                 ;    2594 		}
                 ;    2595 	}
                 _0x199:
                 ;    2596 
                 ;    2597 	read_flag = 1;
                 _0x196:
000f66 e001      	LDI  R16,LOW(1)
                 ;    2598 	
                 ;    2599 	while (addr_temp<_FF_FAT2_ADDR)
                 _0x19A:
000f67 91e0 0964 	LDS  R30,__FF_FAT2_ADDR
000f69 91f0 0965 	LDS  R31,__FF_FAT2_ADDR+1
000f6b 9160 0966 	LDS  R22,__FF_FAT2_ADDR+2
000f6d 9170 0967 	LDS  R23,__FF_FAT2_ADDR+3
000f6f 81ad
000f70 81be
000f71 818f
000f72 8598      	__GETD2S 5
000f73 940e 2ab7 	CALL __CPD21
000f75 f010      	BRLO PC+3
000f76 940c 104e 	JMP _0x19C
                 ;    2600 	{
                 ;    2601 		if (BPB_FATType == 0x36)		// if FAT16
000f78 91a0 093f 	LDS  R26,_BPB_FATType
000f7a 33a6      	CPI  R26,LOW(0x36)
000f7b f011      	BREQ PC+3
000f7c 940c 104a 	JMP _0x19D
                 ;    2602 		{
                 ;    2603 			if (clus_no==0)
000f7e 89e9      	LDD  R30,Y+17
000f7f 89fa      	LDD  R31,Y+17+1
000f80 9730      	SBIW R30,0
000f81 f491      	BRNE _0x19E
                 ;    2604 			{
                 ;    2605 				clus_0_addr = addr_temp;
000f82 81ed
000f83 81fe
000f84 816f
000f85 8578      	__GETD1S 5
000f86 93e0 0982 	STS  _clus_0_addr,R30
000f88 93f0 0983 	STS  _clus_0_addr+1,R31
000f8a 9360 0984 	STS  _clus_0_addr+2,R22
000f8c 9370 0985 	STS  _clus_0_addr+3,R23
                 ;    2606 				c_counter = c;
000f8e 85ef      	LDD  R30,Y+15
000f8f 89f8      	LDD  R31,Y+15+1
000f90 93e0 098a 	STS  _c_counter,R30
000f92 93f0 098b 	STS  _c_counter+1,R31
                 ;    2607 			}
                 ;    2608 			if (_FF_read(addr_temp)==0)		// Read error ==> break
                 _0x19E:
000f94 81ed
000f95 81fe
000f96 816f
000f97 8578      	__GETD1S 5
000f98 940e 2488 	CALL SUBOPT_0x34
000f9a f419      	BRNE _0x19F
                 ;    2609 				return(0);
000f9b e0e0      	LDI  R30,LOW(0)
000f9c e0f0      	LDI  R31,HIGH(0)
000f9d c0b2      	RJMP _0x4D2
                 ;    2610 			if (_FF_n_temp)
                 _0x19F:
000f9e 91e0 0986 	LDS  R30,__FF_n_temp
000fa0 91f0 0987 	LDS  R31,__FF_n_temp+1
000fa2 9160 0988 	LDS  R22,__FF_n_temp+2
000fa4 9170 0989 	LDS  R23,__FF_n_temp+3
000fa6 940e 2aa4 	CALL __CPD10
000fa8 f081      	BREQ _0x1A0
                 ;    2611 			{
                 ;    2612 				n_temp = _FF_n_temp;
000fa9 91e0 0986 	LDS  R30,__FF_n_temp
000fab 91f0 0987 	LDS  R31,__FF_n_temp+1
000fad 87ed      	STD  Y+13,R30
000fae 87fe      	STD  Y+13+1,R31
                 ;    2613 				_FF_n_temp = 0;
000faf e0e0      	LDI  R30,0
000fb0 93e0 0986 	STS  __FF_n_temp,R30
000fb2 93e0 0987 	STS  __FF_n_temp+1,R30
000fb4 93e0 0988 	STS  __FF_n_temp+2,R30
000fb6 93e0 0989 	STS  __FF_n_temp+3,R30
                 ;    2614 			}
                 ;    2615 			else
000fb8 c003      	RJMP _0x1A1
                 _0x1A0:
                 ;    2616 				n_temp = 0;
000fb9 e0e0      	LDI  R30,0
000fba 87ed      	STD  Y+13,R30
000fbb 87ee      	STD  Y+13+1,R30
                 ;    2617 			for (n=n_temp; n<(BPB_BytsPerSec/2); n++)
                 _0x1A1:
000fbc 853d
000fbd 854e      	__GETWRS 19,20,13
                 _0x1A3:
000fbe 91e0 0935 	LDS  R30,_BPB_BytsPerSec
000fc0 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
000fc2 95f6      	LSR  R31
000fc3 95e7      	ROR  R30
000fc4 173e      	CP   R19,R30
000fc5 074f      	CPC  R20,R31
000fc6 f010      	BRLO PC+3
000fc7 940c 1038 	JMP _0x1A4
                 ;    2618 			{
                 ;    2619 				calc_clus = ((unsigned int) _FF_buff[(n*2)+1] << 8) | ((unsigned int) _FF_buff[n*2]);
000fc9 2fe3
000fca 2ff4      	__GETW1R 19,20
000fcb 0fee      	LSL  R30
000fcc 1fff      	ROL  R31
000fcd 5de0
000fce 4ff8      	__ADDW1MN __FF_buff,1
000fcf 940e 25db 	CALL SUBOPT_0x55
000fd1 2fe3
000fd2 2ff4      	__GETW1R 19,20
000fd3 0fee      	LSL  R30
000fd4 1fff      	ROL  R31
000fd5 5de1      	SUBI R30,LOW(-__FF_buff)
000fd6 4ff8      	SBCI R31,HIGH(-__FF_buff)
000fd7 81e0      	LD   R30,Z
000fd8 940e 24a0 	CALL SUBOPT_0x37
000fda 87e9
000fdb 87fa
000fdc 876b
000fdd 877c      	__PUTD1S 9
                 ;    2620 				calc_temp = (unsigned long) n + (((unsigned long) BPB_BytsPerSec/2) * ((unsigned long) c - 1));
000fde 2fe3
000fdf 2ff4      	__GETW1R 19,20
000fe0 2766      	CLR  R22
000fe1 2777      	CLR  R23
000fe2 937f      	PUSH R23
000fe3 936f      	PUSH R22
000fe4 93ff      	PUSH R31
000fe5 93ef      	PUSH R30
000fe6 91e0 0935 	LDS  R30,_BPB_BytsPerSec
000fe8 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
000fea 2766      	CLR  R22
000feb 2777      	CLR  R23
000fec 940e 29a7 	CALL __LSRD1
000fee 01df      	MOVW R26,R30
000fef 01cb      	MOVW R24,R22
000ff0 85ef      	LDD  R30,Y+15
000ff1 89f8      	LDD  R31,Y+15+1
000ff2 2766      	CLR  R22
000ff3 2777      	CLR  R23
000ff4 50e1
000ff5 40f0
000ff6 4060
000ff7 4070      	__SUBD1N 1
000ff8 940e 29cd 	CALL __MULD12U
000ffa 91af      	POP  R26
000ffb 91bf      	POP  R27
000ffc 918f      	POP  R24
000ffd 919f      	POP  R25
000ffe 940e 295c 	CALL __ADDD12
001000 2f1e
001001 2f2f      	__PUTW1R 17,18
                 ;    2621 				if (calc_clus==clus_no)
001002 89e9      	LDD  R30,Y+17
001003 89fa      	LDD  R31,Y+17+1
001004 85a9
001005 85ba
001006 858b
001007 859c      	__GETD2S 9
001008 2766      	CLR  R22
001009 2777      	CLR  R23
00100a 940e 2ab2 	CALL __CPD12
00100c f4b1      	BRNE _0x1A5
                 ;    2622 				{
                 ;    2623 					if (calc_clus==0)
00100d 85e9
00100e 85fa
00100f 856b
001010 857c      	__GETD1S 9
001011 940e 2aa4 	CALL __CPD10
001013 f461      	BRNE _0x1A6
                 ;    2624 						_FF_n_temp = n;
001014 2fe3
001015 2ff4      	__GETW1R 19,20
001016 2766      	CLR  R22
001017 2777      	CLR  R23
001018 93e0 0986 	STS  __FF_n_temp,R30
00101a 93f0 0987 	STS  __FF_n_temp+1,R31
00101c 9360 0988 	STS  __FF_n_temp+2,R22
00101e 9370 0989 	STS  __FF_n_temp+3,R23
                 ;    2625 					return(calc_temp);
                 _0x1A6:
001020 2fe1
001021 2ff2      	__GETW1R 17,18
001022 c02d      	RJMP _0x4D2
                 ;    2626 				}
                 ;    2627 				else if (calc_temp > DataClusTot)
                 _0x1A5:
001023 91e0 0977 	LDS  R30,_DataClusTot
001025 91f0 0978 	LDS  R31,_DataClusTot+1
001027 9160 0979 	LDS  R22,_DataClusTot+2
001029 9170 097a 	LDS  R23,_DataClusTot+3
00102b 2fa1
00102c 2fb2      	__GETW2R 17,18
00102d 2788      	CLR  R24
00102e 2799      	CLR  R25
00102f 940e 2ab2 	CALL __CPD12
001031 f418      	BRSH _0x1A8
                 ;    2628 				{
                 ;    2629 					_FF_error = DISK_FULL;
001032 940e 25df 	CALL SUBOPT_0x56
                 ;    2630 					return (0);
001034 c01b      	RJMP _0x4D2
                 ;    2631 				}
                 ;    2632 			}
                 _0x1A8:
001035 5f3f
001036 4f4f      	__ADDWRN 19,20,1
001037 cf86      	RJMP _0x1A3
                 _0x1A4:
                 ;    2633 			addr_temp += 0x200;
001038 81ed
001039 81fe
00103a 816f
00103b 8578      	__GETD1S 5
00103c 50e0
00103d 4ffe
00103e 4f6f
00103f 4f7f      	__ADDD1N 512
001040 83ed
001041 83fe
001042 836f
001043 8778      	__PUTD1S 5
                 ;    2634 			c++;
001044 85ef      	LDD  R30,Y+15
001045 89f8      	LDD  R31,Y+15+1
001046 9631      	ADIW R30,1
001047 87ef      	STD  Y+15,R30
001048 8bf8      	STD  Y+15+1,R31
                 ;    2635 		}
                 ;    2636 		#ifdef _FAT12_ON_
                 ;    2637 		else if (BPB_FATType == 0x32)	// if FAT12
                 ;    2638 		{
                 ;    2639 			if (read_flag)
                 ;    2640 			{
                 ;    2641 				if (_FF_read(addr_temp)==0)
                 ;    2642 					return (0);	// if the read fails return 0
                 ;    2643 				read_flag = 0;
                 ;    2644 			}
                 ;    2645 			calc_temp = ((unsigned long) c * 3) / 2;
                 ;    2646 			calc_temp %= BPB_BytsPerSec;
                 ;    2647 			calc_clus = _FF_buff[calc_temp++];
                 ;    2648 			if (calc_temp == BPB_BytsPerSec)
                 ;    2649 			{	// Is the FAT12 record accross a sector?
                 ;    2650 				addr_temp += 0x200;
                 ;    2651 				if (_FF_read(addr_temp)==0)
                 ;    2652 					return (0);
                 ;    2653 				calc_clus |= ((unsigned int) _FF_buff[0] << 8);
                 ;    2654 				calc_temp = 0;
                 ;    2655 			}
                 ;    2656 			else
                 ;    2657 				calc_clus |= ((unsigned int) _FF_buff[calc_temp++] << 8);
                 ;    2658                           	
                 ;    2659 			if (c % 2)
                 ;    2660 				calc_clus >>= 4;
                 ;    2661 			else
                 ;    2662 				calc_clus &= 0x0FFF;
                 ;    2663 			
                 ;    2664 			if (calc_clus == clus_no)
                 ;    2665 				return (c);
                 ;    2666 			else if (c > DataClusTot)
                 ;    2667 			{
                 ;    2668 				_FF_error = DISK_FULL;
                 ;    2669 				return (0);
                 ;    2670 			}
                 ;    2671 			if ((calc_temp == BPB_BytsPerSec) && (c % 2))
                 ;    2672 			{
                 ;    2673 				addr_temp += 0x200;
                 ;    2674 				read_flag = 1;
                 ;    2675 			}                                                           
                 ;    2676 			
                 ;    2677 			c++;			
                 ;    2678 		}
                 ;    2679 		#endif
                 ;    2680 		else
001049 c003      	RJMP _0x1A9
                 _0x19D:
                 ;    2681 			return (0);
00104a e0e0      	LDI  R30,LOW(0)
00104b e0f0      	LDI  R31,HIGH(0)
00104c c003      	RJMP _0x4D2
                 ;    2682 	}
                 _0x1A9:
00104d cf19      	RJMP _0x19A
                 _0x19C:
                 ;    2683 	_FF_error = DISK_FULL;
00104e 940e 25df 	CALL SUBOPT_0x56
                 ;    2684 	return (0);
                 _0x4D2:
001050 940e 2ac4 	CALL __LOADLOCR5
001052 9663      	ADIW R28,19
001053 9508      	RET
                 ;    2685 }
                 ;    2686 
                 ;    2687 #ifndef _READ_ONLY_
                 ;    2688 // Update cluster table to point to new cluster
                 ;    2689 unsigned char write_clus_table(unsigned int current_cluster, unsigned int next_value, unsigned char mode)
                 ;    2690 {
                 _write_clus_table:
                 ;    2691 	unsigned long addr_temp;
                 ;    2692 	unsigned int calc_sec, calc_offset, calc_temp, calc_remainder;
                 ;    2693 	unsigned char nibble[3];
                 ;    2694 	
                 ;    2695 	if (current_cluster <=1)		// Should never be writing to cluster 0 or 1
001054 9729      	SBIW R28,9
001055 940e 2abc 	CALL __SAVELOCR6
                 ;	current_cluster -> Y+18
                 ;	next_value -> Y+16
                 ;	mode -> Y+15
                 ;	addr_temp -> Y+11
                 ;	calc_sec -> R16,R17
                 ;	calc_offset -> R18,R19
                 ;	calc_temp -> R20,R21
                 ;	calc_remainder -> Y+9
                 ;	nibble -> Y+6
001057 89aa      	LDD  R26,Y+18
001058 89bb      	LDD  R27,Y+18+1
001059 9712      	SBIW R26,2
00105a f410      	BRSH _0x1AA
                 ;    2696 	{
                 ;    2697 		return (0);
00105b e0e0      	LDI  R30,LOW(0)
00105c c08b      	RJMP _0x4D1
                 ;    2698 	}
                 ;    2699 	if (BPB_FATType == 0x36)		// if FAT16
                 _0x1AA:
00105d 91a0 093f 	LDS  R26,_BPB_FATType
00105f 33a6      	CPI  R26,LOW(0x36)
001060 f011      	BREQ PC+3
001061 940c 10e5 	JMP _0x1AB
                 ;    2700 	{
                 ;    2701 		calc_sec = current_cluster / (BPB_BytsPerSec / 2) + BPB_RsvdSecCnt;
001063 940e 25e5 	CALL SUBOPT_0x57
001065 940e 2574 	CALL SUBOPT_0x4D
                 ;    2702 		calc_offset = 2 * (current_cluster % (BPB_BytsPerSec / 2));
001067 940e 25e5 	CALL SUBOPT_0x57
001069 940e 257e 	CALL SUBOPT_0x4E
                 ;    2703 		addr_temp = _FF_PART_ADDR + ((long) calc_sec*0x200);
00106b 2766      	CLR  R22
00106c 2777      	CLR  R23
00106d e0a0
00106e e0b2
00106f e080
001070 e090      	__GETD2N 0x200
001071 940e 255e 	CALL SUBOPT_0x4B
001073 87eb
001074 87fc
001075 876d
001076 877e      	__PUTD1S 11
                 ;    2704 		if (mode==SINGLE)
001077 85af      	LDD  R26,Y+15
001078 30a1      	CPI  R26,LOW(0x1)
001079 f431      	BRNE _0x1AC
                 ;    2705 		{	// Updating a single cluster (like writing or saving a file)
                 ;    2706 			if (_FF_read(addr_temp)==0)
00107a 940e 2488 	CALL SUBOPT_0x34
00107c f411      	BRNE _0x1AD
                 ;    2707 				return(0);
00107d e0e0      	LDI  R30,LOW(0)
00107e c069      	RJMP _0x4D1
                 ;    2708 		}
                 _0x1AD:
                 ;    2709 		else if ((mode==CHAIN) || (mode==END_CHAIN))
00107f c02d      	RJMP _0x1AE
                 _0x1AC:
001080 85af      	LDD  R26,Y+15
001081 30a0      	CPI  R26,LOW(0x0)
001082 f011      	BREQ _0x1B0
001083 30a2      	CPI  R26,LOW(0x2)
001084 f541      	BRNE _0x1AF
                 _0x1B0:
                 ;    2710 		{	// Multiple table access operation
                 ;    2711 			if (addr_temp!=_FF_buff_addr)
001085 91e0 0973 	LDS  R30,__FF_buff_addr
001087 91f0 0974 	LDS  R31,__FF_buff_addr+1
001089 9160 0975 	LDS  R22,__FF_buff_addr+2
00108b 9170 0976 	LDS  R23,__FF_buff_addr+3
00108d 85ab
00108e 85bc
00108f 858d
001090 859e      	__GETD2S 11
001091 940e 2ab2 	CALL __CPD12
001093 f0c9      	BREQ _0x1B2
                 ;    2712 			{	// if the desired address is already in the buffer => skip loading buffer
                 ;    2713 				if (_FF_buff_addr)	// if new table address, write buffered, and load new
001094 940e 2aa4 	CALL __CPD10
001096 f069      	BREQ _0x1B3
                 ;    2714 				{
                 ;    2715 					#ifdef _SECOND_FAT_ON_
                 ;    2716 						if (_FF_buff_addr < _FF_FAT2_ADDR)
001097 940e 2585 	CALL SUBOPT_0x4F
001099 f428      	BRSH _0x1B4
                 ;    2717 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
00109a 940e 2598 	CALL SUBOPT_0x50
00109c f411      	BRNE _0x1B5
                 ;    2718 								return(0);
00109d e0e0      	LDI  R30,LOW(0)
00109e c049      	RJMP _0x4D1
                 ;    2719 					#endif
                 ;    2720 					if (_FF_write(_FF_buff_addr)==0)
                 _0x1B5:
                 _0x1B4:
00109f 940e 25ba 	CALL SUBOPT_0x51
0010a1 f411      	BRNE _0x1B6
                 ;    2721 						return(0);
0010a2 e0e0      	LDI  R30,LOW(0)
0010a3 c044      	RJMP _0x4D1
                 ;    2722 				}
                 _0x1B6:
                 ;    2723 				if (_FF_read(addr_temp)==0)
                 _0x1B3:
0010a4 85eb
0010a5 85fc
0010a6 856d
0010a7 857e      	__GETD1S 11
0010a8 940e 2488 	CALL SUBOPT_0x34
0010aa f411      	BRNE _0x1B7
                 ;    2724 					return(0);
0010ab e0e0      	LDI  R30,LOW(0)
0010ac c03b      	RJMP _0x4D1
                 ;    2725 			}
                 _0x1B7:
                 ;    2726 		}
                 _0x1B2:
                 ;    2727 				
                 ;    2728 		_FF_buff[calc_offset+1] = (next_value >> 8); 
                 _0x1AF:
                 _0x1AE:
0010ad 01f9      	MOVW R30,R18
0010ae 5de0
0010af 4ff8      	__ADDW1MN __FF_buff,1
0010b0 01df      	MOVW R26,R30
0010b1 89e9      	LDD  R30,Y+17
0010b2 70f0      	ANDI R31,HIGH(0x0)
0010b3 93ec      	ST   X,R30
                 ;    2729 		_FF_buff[calc_offset] = (next_value & 0xFF);
0010b4 01d9      	MOVW R26,R18
0010b5 5da1      	SUBI R26,LOW(-__FF_buff)
0010b6 4fb8      	SBCI R27,HIGH(-__FF_buff)
0010b7 89e8      	LDD  R30,Y+16
0010b8 89f9      	LDD  R31,Y+16+1
0010b9 70f0      	ANDI R31,HIGH(0xFF)
0010ba 93ec      	ST   X,R30
                 ;    2730 		if ((mode==SINGLE) || (mode==END_CHAIN))
0010bb 85af      	LDD  R26,Y+15
0010bc 30a1      	CPI  R26,LOW(0x1)
0010bd f011      	BREQ _0x1B9
0010be 30a2      	CPI  R26,LOW(0x2)
0010bf f521      	BRNE _0x1B8
                 _0x1B9:
                 ;    2731 		{
                 ;    2732 			#ifdef _SECOND_FAT_ON_
                 ;    2733 				if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
0010c0 91a0 0960 	LDS  R26,__FF_FAT1_ADDR
0010c2 91b0 0961 	LDS  R27,__FF_FAT1_ADDR+1
0010c4 9180 0962 	LDS  R24,__FF_FAT1_ADDR+2
0010c6 9190 0963 	LDS  R25,__FF_FAT1_ADDR+3
0010c8 91e0 0964 	LDS  R30,__FF_FAT2_ADDR
0010ca 91f0 0965 	LDS  R31,__FF_FAT2_ADDR+1
0010cc 9160 0966 	LDS  R22,__FF_FAT2_ADDR+2
0010ce 9170 0967 	LDS  R23,__FF_FAT2_ADDR+3
0010d0 940e 2966 	CALL __SUBD12
0010d2 85ab
0010d3 85bc
0010d4 858d
0010d5 859e      	__GETD2S 11
0010d6 940e 25ee 	CALL SUBOPT_0x58
0010d8 f411      	BRNE _0x1BB
                 ;    2734 					return(0);
0010d9 e0e0      	LDI  R30,LOW(0)
0010da c00d      	RJMP _0x4D1
                 ;    2735 			#endif
                 ;    2736 			if (_FF_write(addr_temp)==0)
                 _0x1BB:
0010db 85eb
0010dc 85fc
0010dd 856d
0010de 857e      	__GETD1S 11
0010df 940e 25f6 	CALL SUBOPT_0x59
0010e1 f411      	BRNE _0x1BC
                 ;    2737 			{
                 ;    2738 				return(0);
0010e2 e0e0      	LDI  R30,LOW(0)
0010e3 c004      	RJMP _0x4D1
                 ;    2739 			}
                 ;    2740 		}
                 _0x1BC:
                 ;    2741 	}
                 _0x1B8:
                 ;    2742 	#ifdef _FAT12_ON_
                 ;    2743 		else if (BPB_FATType == 0x32)		// if FAT12
                 ;    2744 		{
                 ;    2745 			calc_offset = (current_cluster * 3) / 2;
                 ;    2746 			calc_remainder = (current_cluster * 3) % 2;
                 ;    2747 			calc_sec = calc_offset / BPB_BytsPerSec + BPB_RsvdSecCnt;
                 ;    2748 			calc_offset %= BPB_BytsPerSec;
                 ;    2749 			addr_temp = _FF_PART_ADDR + ((long) calc_sec * (long) BPB_BytsPerSec);
                 ;    2750 
                 ;    2751 			if (mode==SINGLE)
                 ;    2752 			{
                 ;    2753 				if (_FF_read(addr_temp)==0)
                 ;    2754 					return(0);
                 ;    2755  			}
                 ;    2756  			else if ((mode==CHAIN) || (mode==END_CHAIN))
                 ;    2757   			{
                 ;    2758 				if (addr_temp!=_FF_buff_addr)
                 ;    2759 				{
                 ;    2760 					if (_FF_buff_addr)
                 ;    2761 					{
                 ;    2762 					#ifdef _SECOND_FAT_ON_
                 ;    2763 						if (_FF_buff_addr < _FF_FAT2_ADDR)
                 ;    2764 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2765 								return(0);
                 ;    2766 					#endif
                 ;    2767 						if (_FF_write(_FF_buff_addr)==0)
                 ;    2768 							return(0);
                 ;    2769 					}
                 ;    2770 					if (_FF_read(addr_temp)==0)
                 ;    2771 						return(0);
                 ;    2772 				}
                 ;    2773 			}
                 ;    2774 			nibble[0] = next_value & 0x00F;
                 ;    2775 			nibble[1] = (next_value >> 4) & 0x00F;
                 ;    2776 			nibble[2] = (next_value >> 8) & 0x00F;
                 ;    2777     	
                 ;    2778 			if (calc_offset == (BPB_BytsPerSec-1))
                 ;    2779 			{	// Is the FAT12 record accross a sector?
                 ;    2780 				if (calc_remainder)
                 ;    2781 				{	// Record table uses 1 nibble of last byte
                 ;    2782 					calc_temp = _FF_buff[calc_offset] & 0x0F;	// Mask to add new value
                 ;    2783 					_FF_buff[calc_offset] = calc_temp | (nibble[0] << 4);	// store nibble in correct location
                 ;    2784 					#ifdef _SECOND_FAT_ON_
                 ;    2785 						if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2786 							return(0);
                 ;    2787 					#endif
                 ;    2788 					if (_FF_write(addr_temp)==0)
                 ;    2789 						return(0);
                 ;    2790 					addr_temp += BPB_BytsPerSec;
                 ;    2791 					if (_FF_read(addr_temp)==0)
                 ;    2792 						return(0);	// if the read fails return 0
                 ;    2793 					_FF_buff[0] = (nibble[2] << 4) | nibble[1];
                 ;    2794 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2795 					{
                 ;    2796 						#ifdef _SECOND_FAT_ON_
                 ;    2797 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2798 								return(0);
                 ;    2799 						#endif
                 ;    2800 						if (_FF_write(addr_temp)==0)
                 ;    2801 							return(0);
                 ;    2802 					}
                 ;    2803 				}
                 ;    2804 				else
                 ;    2805 				{	// Record table uses whole last byte
                 ;    2806 					_FF_buff[calc_offset] = (nibble[1] << 4) | nibble[0];
                 ;    2807 					#ifdef _SECOND_FAT_ON_
                 ;    2808 						if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2809 							return(0);
                 ;    2810 					#endif
                 ;    2811 					if (_FF_write(addr_temp)==0)
                 ;    2812 						return(0);
                 ;    2813 					addr_temp += BPB_BytsPerSec;
                 ;    2814 					if (_FF_read(addr_temp)==0)
                 ;    2815 						return(0);	// if the read fails return 0
                 ;    2816 					calc_temp = _FF_buff[0] & 0xF0;		// Mask to add new value
                 ;    2817 					_FF_buff[0] = calc_temp | nibble[2];	// store nibble in correct location
                 ;    2818 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2819 					{
                 ;    2820 						#ifdef _SECOND_FAT_ON_
                 ;    2821 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2822 								return(0);
                 ;    2823 						#endif
                 ;    2824 						if (_FF_write(addr_temp)==0)
                 ;    2825 							return(0);
                 ;    2826 					}
                 ;    2827 				}
                 ;    2828 			}
                 ;    2829 			else
                 ;    2830 			{
                 ;    2831 				if (calc_remainder)
                 ;    2832 				{	// Record table uses 1 nibble of current byte
                 ;    2833 					calc_temp = _FF_buff[calc_offset] & 0x0F;	// Mask to add new value
                 ;    2834 					_FF_buff[calc_offset] = calc_temp | (nibble[0] << 4);	// store nibble in correct location
                 ;    2835 					_FF_buff[calc_offset+1] = (nibble[2] << 4) | nibble[1];
                 ;    2836 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2837 					{
                 ;    2838 						#ifdef _SECOND_FAT_ON_
                 ;    2839 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2840 								return(0);
                 ;    2841 						#endif
                 ;    2842 						if (_FF_write(addr_temp)==0)
                 ;    2843 							return(0);
                 ;    2844 					}
                 ;    2845 				}
                 ;    2846 				else
                 ;    2847 				{	// Record table uses whole current byte
                 ;    2848 					_FF_buff[calc_offset] = (nibble[1] << 4) | nibble[0];
                 ;    2849 					calc_temp = _FF_buff[calc_offset+1] & 0xF0;		// Mask to add new value
                 ;    2850 					_FF_buff[calc_offset+1] = calc_temp | nibble[2];	// store nibble in correct location
                 ;    2851 					if ((mode==SINGLE) || (mode==END_CHAIN))
                 ;    2852 					{
                 ;    2853 						#ifdef _SECOND_FAT_ON_
                 ;    2854 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
                 ;    2855 								return(0);
                 ;    2856 						#endif
                 ;    2857 						if (_FF_write(addr_temp)==0)
                 ;    2858 							return(0);
                 ;    2859 					}
                 ;    2860 				}
                 ;    2861 			}
                 ;    2862 		}
                 ;    2863 	#endif
                 ;    2864 	else		// not FAT12 or FAT16, return 0
0010e4 c002      	RJMP _0x1BD
                 _0x1AB:
                 ;    2865 		return (0);
0010e5 e0e0      	LDI  R30,LOW(0)
0010e6 c001      	RJMP _0x4D1
                 ;    2866 		
                 ;    2867 	return(1);	
                 _0x1BD:
0010e7 e0e1      	LDI  R30,LOW(1)
                 _0x4D1:
0010e8 940e 2ac3 	CALL __LOADLOCR6
0010ea 9664      	ADIW R28,20
0010eb 9508      	RET
                 ;    2868 }
                 ;    2869 #endif
                 ;    2870 
                 ;    2871 #ifndef _READ_ONLY_
                 ;    2872 // Save new entry data to FAT entry
                 ;    2873 unsigned char append_toc(FILE *rp)
                 ;    2874 {
                 _append_toc:
                 ;    2875 	unsigned long file_data;
                 ;    2876 	unsigned char n;
                 ;    2877 	unsigned char *fp;
                 ;    2878 	unsigned int calc_temp, calc_date;
                 ;    2879 	
                 ;    2880 	if (rp==NULL)
0010ec 9726      	SBIW R28,6
0010ed 940e 2abd 	CALL __SAVELOCR5
                 ;	*rp -> Y+11
                 ;	file_data -> Y+7
                 ;	n -> R16
                 ;	*fp -> R17,R18
                 ;	calc_temp -> R19,R20
                 ;	calc_date -> Y+5
0010ef 85eb      	LDD  R30,Y+11
0010f0 85fc      	LDD  R31,Y+11+1
0010f1 9730      	SBIW R30,0
0010f2 f411      	BRNE _0x1BE
                 ;    2881 		return (0);
0010f3 e0e0      	LDI  R30,LOW(0)
0010f4 c081      	RJMP _0x4D0
                 ;    2882 
                 ;    2883 	file_data = rp->length;
                 _0x1BE:
0010f5 85ab      	LDD  R26,Y+11
0010f6 85bc      	LDD  R27,Y+11+1
0010f7 5ea4      	SUBI R26,LOW(-540)
0010f8 4fbd      	SBCI R27,HIGH(-540)
0010f9 940e 2a4e 	CALL __GETD1P
0010fb 83ef
0010fc 87f8
0010fd 8769
0010fe 877a      	__PUTD1S 7
                 ;    2884 	if (_FF_read(rp->entry_sec_addr)==0)
0010ff 940e 25fc 	CALL SUBOPT_0x5A
001101 940e 0b3d 	CALL __FF_read
001103 30e0      	CPI  R30,0
001104 f411      	BRNE _0x1BF
                 ;    2885 		return (0);
001105 e0e0      	LDI  R30,LOW(0)
001106 c06f      	RJMP _0x4D0
                 ;    2886 	
                 ;    2887 	// Update Starting Cluster 
                 ;    2888 	fp = &_FF_buff[rp->entry_offset+0x1a];
                 _0x1BF:
001107 940e 2605 	CALL SUBOPT_0x5B
001109 5be7
00110a 4ff8      	__ADDW1MN __FF_buff,26
00110b 2f1e
00110c 2f2f      	__PUTW1R 17,18
                 ;    2889 	*fp++ = rp->clus_start & 0xFF;
00110d 932f      	PUSH R18
00110e 931f      	PUSH R17
00110f 5f1f
001110 4f2f      	__ADDWRN 17,18,1
001111 940e 260b 	CALL SUBOPT_0x5C
001113 70f0      	ANDI R31,HIGH(0xFF)
001114 91af      	POP  R26
001115 91bf      	POP  R27
001116 93ec      	ST   X,R30
                 ;    2890 	*fp++ = rp->clus_start >> 8;
001117 932f      	PUSH R18
001118 931f      	PUSH R17
001119 5f1f
00111a 4f2f      	__ADDWRN 17,18,1
00111b 940e 260b 	CALL SUBOPT_0x5C
00111d 2fef      	MOV  R30,R31
00111e e0f0      	LDI  R31,0
00111f 91af      	POP  R26
001120 91bf      	POP  R27
001121 93ec      	ST   X,R30
                 ;    2891 	
                 ;    2892 	// Update the File Size
                 ;    2893 	for (n=0; n<4; n++)
001122 e000      	LDI  R16,LOW(0)
                 _0x1C1:
001123 3004      	CPI  R16,4
001124 f430      	BRSH _0x1C2
                 ;    2894 	{
                 ;    2895 		*fp = file_data & 0xFF;
001125 940e 2611 	CALL SUBOPT_0x5D
                 ;    2896 		file_data >>= 8;
                 ;    2897 		fp++;
001127 5f1f
001128 4f2f      	__ADDWRN 17,18,1
                 ;    2898 	}
001129 5f0f      	SUBI R16,-1
00112a cff8      	RJMP _0x1C1
                 _0x1C2:
                 ;    2899 	
                 ;    2900 	
                 ;    2901 	fp = &_FF_buff[rp->entry_offset+0x16];
00112b 940e 2605 	CALL SUBOPT_0x5B
00112d 5beb
00112e 4ff8      	__ADDW1MN __FF_buff,22
00112f 2f1e
001130 2f2f      	__PUTW1R 17,18
                 ;    2902 	#ifdef _RTC_ON_ 	// Date/Time Stamp file w/ RTC
                 ;    2903 		rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
                 ;    2904 		calc_temp = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
                 ;    2905 		*fp++ = calc_temp&0x00FF;	// File create Time 
                 ;    2906 		*fp++ = (calc_temp&0xFF00) >> 8;
                 ;    2907 		calc_date = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
                 ;    2908 		*fp++ = calc_date&0x00FF;	// File create Date
                 ;    2909 		*fp++ = (calc_date&0xFF00) >> 8;
                 ;    2910 	#else		// Increment Date Code, no RTC used 
                 ;    2911 		file_data = 0;
001131 e0e0
001132 83ef
001133 87e8
001134 87e9
001135 87ea      	__CLRD1S 7
                 ;    2912 		for (n=0; n<4; n++)
001136 e000      	LDI  R16,LOW(0)
                 _0x1C4:
001137 3004      	CPI  R16,4
001138 f4f8      	BRSH _0x1C5
                 ;    2913 		{
                 ;    2914 			file_data <<= 8;
001139 81af
00113a 85b8
00113b 8589
00113c 859a      	__GETD2S 7
00113d e0e8      	LDI  R30,LOW(8)
00113e 940e 2986 	CALL __LSLD12
001140 83ef
001141 87f8
001142 8769
001143 877a      	__PUTD1S 7
                 ;    2915 			file_data |= *fp;
001144 2fa1
001145 2fb2      	__GETW2R 17,18
001146 91ec      	LD   R30,X
001147 81af
001148 85b8
001149 8589
00114a 859a      	__GETD2S 7
00114b 27ff      	CLR  R31
00114c 2766      	CLR  R22
00114d 2777      	CLR  R23
00114e 940e 2970 	CALL __ORD12
001150 83ef
001151 87f8
001152 8769
001153 877a      	__PUTD1S 7
                 ;    2916 			fp--;
001154 5011
001155 4020      	__SUBWRN 17,18,1
                 ;    2917 		}
001156 5f0f      	SUBI R16,-1
001157 cfdf      	RJMP _0x1C4
                 _0x1C5:
                 ;    2918 		file_data++;
001158 81ef
001159 85f8
00115a 8569
00115b 857a      	__GETD1S 7
00115c 5fef
00115d 4fff
00115e 4f6f
00115f 4f7f      	__SUBD1N -1
001160 83ef
001161 87f8
001162 8769
001163 877a      	__PUTD1S 7
                 ;    2919 		for (n=0; n<4; n++)
001164 e000      	LDI  R16,LOW(0)
                 _0x1C7:
001165 3004      	CPI  R16,4
001166 f430      	BRSH _0x1C8
                 ;    2920 		{
                 ;    2921 			fp++;
001167 5f1f
001168 4f2f      	__ADDWRN 17,18,1
                 ;    2922 			*fp = file_data & 0xFF;
001169 940e 2611 	CALL SUBOPT_0x5D
                 ;    2923 			file_data >>=8;
                 ;    2924 		}
00116b 5f0f      	SUBI R16,-1
00116c cff8      	RJMP _0x1C7
                 _0x1C8:
                 ;    2925 	#endif
                 ;    2926 	if (_FF_write(rp->entry_sec_addr)==0)
00116d 940e 25fc 	CALL SUBOPT_0x5A
00116f 940e 0bab 	CALL __FF_write
001171 30e0      	CPI  R30,0
001172 f411      	BRNE _0x1C9
                 ;    2927 		return(0);
001173 e0e0      	LDI  R30,LOW(0)
001174 c001      	RJMP _0x4D0
                 ;    2928 	
                 ;    2929 	return(1);
                 _0x1C9:
001175 e0e1      	LDI  R30,LOW(1)
                 _0x4D0:
001176 940e 2ac4 	CALL __LOADLOCR5
001178 962d      	ADIW R28,13
001179 9508      	RET
                 ;    2930 }
                 ;    2931 #endif
                 ;    2932 
                 ;    2933 #ifndef _READ_ONLY_
                 ;    2934 // Erase a chain of clusters (set table entries to 0 for clusters in chain)
                 ;    2935 unsigned char erase_clus_chain(unsigned int start_clus)
                 ;    2936 {
                 _erase_clus_chain:
                 ;    2937 	unsigned int clus_temp, clus_use;
                 ;    2938 	
                 ;    2939 	if (start_clus==0)
00117a 940e 2abe 	CALL __SAVELOCR4
                 ;	start_clus -> Y+4
                 ;	clus_temp -> R16,R17
                 ;	clus_use -> R18,R19
00117c 81ec      	LDD  R30,Y+4
00117d 81fd      	LDD  R31,Y+4+1
00117e 9730      	SBIW R30,0
00117f f411      	BRNE _0x1CA
                 ;    2940 		return (0);
001180 e0e0      	LDI  R30,LOW(0)
001181 c045      	RJMP _0x4CF
                 ;    2941 	clus_use = start_clus;
                 _0x1CA:
001182 812c
001183 813d      	__GETWRS 18,19,4
                 ;    2942 	_FF_buff_addr = 0;
001184 e0e0      	LDI  R30,0
001185 93e0 0973 	STS  __FF_buff_addr,R30
001187 93e0 0974 	STS  __FF_buff_addr+1,R30
001189 93e0 0975 	STS  __FF_buff_addr+2,R30
00118b 93e0 0976 	STS  __FF_buff_addr+3,R30
                 ;    2943 	while(clus_use <= 0xFFF8)
                 _0x1CB:
00118d 3f29
00118e efef
00118f 073e      	__CPWRN 18,19,65529
001190 f4d8      	BRSH _0x1CD
                 ;    2944 	{
                 ;    2945 		clus_temp = next_cluster(clus_use, CHAIN);
001191 940e 2628 	CALL SUBOPT_0x5E
001193 018f      	MOVW R16,R30
                 ;    2946 		if ((clus_temp >= 0xFFF8) || (clus_temp == 0))
001194 3f08
001195 efef
001196 071e      	__CPWRN 16,17,65528
001197 f420      	BRSH _0x1CF
001198 2400      	CLR  R0
001199 1600      	CP   R0,R16
00119a 0601      	CPC  R0,R17
00119b f409      	BRNE _0x1CE
                 _0x1CF:
                 ;    2947 			break;
00119c c00f      	RJMP _0x1CD
                 ;    2948 		if (write_clus_table(clus_use, 0, CHAIN) == 0)
                 _0x1CE:
00119d 933a      	ST   -Y,R19
00119e 932a      	ST   -Y,R18
00119f e0e0      	LDI  R30,LOW(0)
0011a0 e0f0      	LDI  R31,HIGH(0)
0011a1 940e 23f6 	CALL SUBOPT_0x22
0011a3 940e 1054 	CALL _write_clus_table
0011a5 30e0      	CPI  R30,0
0011a6 f411      	BRNE _0x1D1
                 ;    2949 			return (0);
0011a7 e0e0      	LDI  R30,LOW(0)
0011a8 c01e      	RJMP _0x4CF
                 ;    2950 		clus_use = clus_temp;
                 _0x1D1:
0011a9 2f20
0011aa 2f31      	__MOVEWRR 18,19,16,17
                 ;    2951 	}
0011ab cfe1      	RJMP _0x1CB
                 _0x1CD:
                 ;    2952 	if (write_clus_table(clus_use, 0, END_CHAIN) == 0)
0011ac 933a      	ST   -Y,R19
0011ad 932a      	ST   -Y,R18
0011ae e0e0      	LDI  R30,LOW(0)
0011af e0f0      	LDI  R31,HIGH(0)
0011b0 940e 2333 	CALL SUBOPT_0x7
0011b2 940e 1054 	CALL _write_clus_table
0011b4 30e0      	CPI  R30,0
0011b5 f411      	BRNE _0x1D2
                 ;    2953 		return (0);
0011b6 e0e0      	LDI  R30,LOW(0)
0011b7 c00f      	RJMP _0x4CF
                 ;    2954 	clus_0_addr = 0;
                 _0x1D2:
0011b8 e0e0      	LDI  R30,0
0011b9 93e0 0982 	STS  _clus_0_addr,R30
0011bb 93e0 0983 	STS  _clus_0_addr+1,R30
0011bd 93e0 0984 	STS  _clus_0_addr+2,R30
0011bf 93e0 0985 	STS  _clus_0_addr+3,R30
                 ;    2955 	c_counter = 0;
0011c1 e0e0      	LDI  R30,0
0011c2 93e0 098a 	STS  _c_counter,R30
0011c4 93e0 098b 	STS  _c_counter+1,R30
                 ;    2956 	
                 ;    2957 	return (1);	
0011c6 e0e1      	LDI  R30,LOW(1)
                 _0x4CF:
0011c7 940e 2ac5 	CALL __LOADLOCR4
0011c9 9626      	ADIW R28,6
0011ca 9508      	RET
                 ;    2958 }
                 ;    2959 
                 ;    2960 // Quickformat of a card (erase cluster table and root directory
                 ;    2961 int fquickformat(void)
                 ;    2962 {
                 ;    2963 	long c;
                 ;    2964 	
                 ;    2965 	for (c=0; c<BPB_BytsPerSec; c++)
                 ;	c -> Y+0
                 ;    2966 		_FF_buff[c] = 0;
                 ;    2967 	
                 ;    2968 	c = _FF_FAT1_ADDR + 0x200;
                 ;    2969 	while (c < (_FF_ROOT_ADDR + (0x400 * BPB_SecPerClus)))
                 ;    2970 	{
                 ;    2971 		if (_FF_write(c)==0)
                 ;    2972 		{
                 ;    2973 			_FF_error = WRITE_ERR;
                 ;    2974 			return (EOF);
                 ;    2975 		}
                 ;    2976 		c += 0x200;
                 ;    2977 	}	
                 ;    2978 	_FF_buff[0] = 0xF8;
                 ;    2979 	_FF_buff[1] = 0xFF;
                 ;    2980 	_FF_buff[2] = 0xFF;
                 ;    2981 	if (BPB_FATType == 0x36)
                 ;    2982 		_FF_buff[3] = 0xFF;
                 ;    2983 	if ((_FF_write(_FF_FAT1_ADDR)==0) || (_FF_write(_FF_FAT2_ADDR)==0))
                 ;    2984 	{
                 ;    2985 		_FF_error = WRITE_ERR;
                 ;    2986 		return (EOF);
                 ;    2987 	}
                 ;    2988 	return (0);
                 ;    2989 }
                 ;    2990 #endif
                 ;    2991 
                 ;    2992 // function that checks for directory changes then gets into a working form
                 ;    2993 int _FF_checkdir(char *F_PATH, unsigned long *SAVE_ADDR, char *path_temp)
                 ;    2994 {
                 __FF_checkdir:
                 ;    2995 	unsigned char *sp, *qp;
                 ;    2996     
                 ;    2997     *SAVE_ADDR = _FF_DIR_ADDR;	// save local dir addr
0011cb 940e 2abe 	CALL __SAVELOCR4
                 ;	*F_PATH -> Y+8
                 ;	*SAVE_ADDR -> Y+6
                 ;	*path_temp -> Y+4
                 ;	*sp -> R16,R17
                 ;	*qp -> R18,R19
0011cd 91e0 095c 	LDS  R30,__FF_DIR_ADDR
0011cf 91f0 095d 	LDS  R31,__FF_DIR_ADDR+1
0011d1 9160 095e 	LDS  R22,__FF_DIR_ADDR+2
0011d3 9170 095f 	LDS  R23,__FF_DIR_ADDR+3
0011d5 81ae      	LDD  R26,Y+6
0011d6 81bf      	LDD  R27,Y+6+1
0011d7 940e 2a54 	CALL __PUTDP1
                 ;    2998     
                 ;    2999     qp = F_PATH;
0011d9 8528
0011da 8539      	__GETWRS 18,19,8
                 ;    3000     if (*qp=='\\')
0011db 940e 262e 	CALL SUBOPT_0x5F
0011dd f491      	BRNE _0x1DE
                 ;    3001     {
                 ;    3002     	_FF_DIR_ADDR = _FF_ROOT_ADDR;
0011de 91e0 0958 	LDS  R30,__FF_ROOT_ADDR
0011e0 91f0 0959 	LDS  R31,__FF_ROOT_ADDR+1
0011e2 9160 095a 	LDS  R22,__FF_ROOT_ADDR+2
0011e4 9170 095b 	LDS  R23,__FF_ROOT_ADDR+3
0011e6 93e0 095c 	STS  __FF_DIR_ADDR,R30
0011e8 93f0 095d 	STS  __FF_DIR_ADDR+1,R31
0011ea 9360 095e 	STS  __FF_DIR_ADDR+2,R22
0011ec 9370 095f 	STS  __FF_DIR_ADDR+3,R23
                 ;    3003 		qp++;
0011ee 5f2f
0011ef 4f3f      	__ADDWRN 18,19,1
                 ;    3004 	}
                 ;    3005 
                 ;    3006 	sp = path_temp;
                 _0x1DE:
0011f0 810c
0011f1 811d      	__GETWRS 16,17,4
                 ;    3007 	while(*qp)
                 _0x1DF:
0011f2 01d9      	MOVW R26,R18
0011f3 91ec      	LD   R30,X
0011f4 30e0      	CPI  R30,0
0011f5 f161      	BREQ _0x1E1
                 ;    3008 	{
                 ;    3009 		if ((valid_file_char(*qp)==0) || (*qp=='.'))
0011f6 940e 24f5 	CALL SUBOPT_0x41
0011f8 f021      	BREQ _0x1E3
0011f9 01d9      	MOVW R26,R18
0011fa 91ac      	LD   R26,X
0011fb 32ae      	CPI  R26,LOW(0x2E)
0011fc f469      	BRNE _0x1E2
                 _0x1E3:
                 ;    3010 			*sp++ = toupper(*qp++);
0011fd 931f      	PUSH R17
0011fe 930f      	PUSH R16
0011ff 5f0f
001200 4f1f      	__ADDWRN 16,17,1
001201 01d9      	MOVW R26,R18
001202 5f2f
001203 4f3f      	__ADDWRN 18,19,1
001204 940e 2632 	CALL SUBOPT_0x60
001206 91af      	POP  R26
001207 91bf      	POP  R27
001208 93ec      	ST   X,R30
                 ;    3011 		else if (*qp=='\\')
001209 c017      	RJMP _0x1E5
                 _0x1E2:
00120a 940e 262e 	CALL SUBOPT_0x5F
00120c f489      	BRNE _0x1E6
                 ;    3012 		{
                 ;    3013 			*sp = 0;	// terminate string
00120d 940e 2636 	CALL SUBOPT_0x61
                 ;    3014 			if (_FF_chdir(path_temp))
00120f 81ec      	LDD  R30,Y+4
001210 81fd      	LDD  R31,Y+4+1
001211 93fa      	ST   -Y,R31
001212 93ea      	ST   -Y,R30
001213 d016      	RCALL __FF_chdir
001214 9730      	SBIW R30,0
001215 f019      	BREQ _0x1E7
                 ;    3015 			{
                 ;    3016 				return (EOF);
001216 efef      	LDI  R30,LOW(65535)
001217 efff      	LDI  R31,HIGH(65535)
001218 c00d      	RJMP _0x4CE
                 ;    3017 			}
                 ;    3018 			sp = path_temp;
                 _0x1E7:
001219 810c
00121a 811d      	__GETWRS 16,17,4
                 ;    3019 			qp++;
00121b 5f2f
00121c 4f3f      	__ADDWRN 18,19,1
                 ;    3020 		}
                 ;    3021 		else
00121d c003      	RJMP _0x1E8
                 _0x1E6:
                 ;    3022 			return (EOF);
00121e efef      	LDI  R30,LOW(65535)
00121f efff      	LDI  R31,HIGH(65535)
001220 c005      	RJMP _0x4CE
                 ;    3023 	}
                 _0x1E8:
                 _0x1E5:
001221 cfd0      	RJMP _0x1DF
                 _0x1E1:
                 ;    3024 	
                 ;    3025 	*sp = 0;		// terminate string
001222 940e 2636 	CALL SUBOPT_0x61
                 ;    3026 	return (0);
001224 e0e0      	LDI  R30,LOW(0)
001225 e0f0      	LDI  R31,HIGH(0)
                 _0x4CE:
001226 940e 2ac5 	CALL __LOADLOCR4
001228 962a      	ADIW R28,10
001229 9508      	RET
                 ;    3027 }
                 ;    3028 
                 ;    3029 #ifndef _READ_ONLY_
                 ;    3030 int mkdir(char *F_PATH)
                 ;    3031 {
                 ;    3032 	unsigned char *sp, *qp;
                 ;    3033 	unsigned char fpath[14];
                 ;    3034 	unsigned int c, calc_temp, clus_temp, calc_time, calc_date;
                 ;    3035 	int s;
                 ;    3036 	unsigned long addr_temp, path_addr_temp;
                 ;    3037     
                 ;    3038     addr_temp = 0;	// save local dir addr
                 ;	*F_PATH -> Y+38
                 ;	*sp -> R16,R17
                 ;	*qp -> R18,R19
                 ;	fpath -> Y+24
                 ;	c -> R20,R21
                 ;	calc_temp -> Y+22
                 ;	clus_temp -> Y+20
                 ;	calc_time -> Y+18
                 ;	calc_date -> Y+16
                 ;	s -> Y+14
                 ;	addr_temp -> Y+10
                 ;	path_addr_temp -> Y+6
                 ;    3039     
                 ;    3040     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
                 ;    3041 	{
                 ;    3042 		_FF_DIR_ADDR = addr_temp;
                 ;    3043 		return (EOF);
                 ;    3044 	}
                 ;    3045     
                 ;    3046 	path_addr_temp = _FF_DIR_ADDR;
                 ;    3047 	s = scan_directory(&path_addr_temp, fpath);
                 ;    3048 	if ((s) || (path_addr_temp==0))
                 ;    3049 	{
                 ;    3050 		_FF_DIR_ADDR = addr_temp;
                 ;    3051 		return (EOF);
                 ;    3052 	}
                 ;    3053 	clus_temp = prev_cluster(0);				
                 ;    3054 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    3055 	path_addr_temp -= calc_temp;
                 ;    3056 	if (_FF_read(path_addr_temp)==0)	
                 ;    3057 	{
                 ;    3058 		_FF_DIR_ADDR = addr_temp;
                 ;    3059 		return (EOF);
                 ;    3060 	}
                 ;    3061 	
                 ;    3062 	sp = &_FF_buff[calc_temp];
                 ;    3063 	qp = fpath;
                 ;    3064 
                 ;    3065 	for (c=0; c<11; c++)	// Write Folder name
                 ;    3066 	{
                 ;    3067 	 	if (*qp)
                 ;    3068 		 	*sp++ = *qp++;
                 ;    3069 		else 
                 ;    3070 			*sp++ = 0x20;	// '0' pad
                 ;    3071 	}
                 ;    3072 	*sp++ = 0x10;				// Attribute bit auto set to "Directory"
                 ;    3073 	*sp++ = 0;					// Reserved for WinNT
                 ;    3074 	*sp++ = 0;					// Mili-second stamp for create
                 ;    3075 	for (c=0; c<4; c++)			// set create and modify time to '0'
                 ;    3076 		*sp++ = 0;
                 ;    3077 	*sp++ = 0;					// File access date (2 bytes)
                 ;    3078 	*sp++ = 0;
                 ;    3079 	*sp++ = 0;					// 0 for FAT12/16 (2 bytes)
                 ;    3080 	*sp++ = 0;
                 ;    3081 	#ifdef _RTC_ON_
                 ;    3082 		rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
                 ;    3083 		calc_time = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
                 ;    3084 		*sp++ = calc_time&0x00FF;	// File modify Time 
                 ;    3085 		*sp++ = (calc_time&0xFF00) >> 8;
                 ;    3086 		calc_date = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
                 ;    3087 		*sp++ = calc_date&0x00FF;	// File modify Date
                 ;    3088 		*sp++ = (calc_date&0xFF00) >> 8;
                 ;    3089 	#else
                 ;    3090 		for (c=0; c<4; c++)			// set file create and modify time to '0'
                 ;    3091 			*sp++ = 0;
                 ;    3092 	#endif
                 ;    3093 	
                 ;    3094 	*sp++ = clus_temp & 0xFF;				// Starting cluster (2 bytes)
                 ;    3095 	*sp++ = (clus_temp >> 8) & 0xFF;
                 ;    3096 	for (c=0; c<4; c++)
                 ;    3097 		*sp++ = 0;			// File length (0 for folder)
                 ;    3098 
                 ;    3099 	
                 ;    3100 	if (_FF_write(path_addr_temp)==0)	// write entry to card
                 ;    3101 	{
                 ;    3102 		_FF_DIR_ADDR = addr_temp;
                 ;    3103 		return (EOF);
                 ;    3104 	}
                 ;    3105 	if (write_clus_table(clus_temp, 0xFFFF, SINGLE)==0)
                 ;    3106 	{
                 ;    3107 		_FF_DIR_ADDR = addr_temp;
                 ;    3108 		return (EOF);
                 ;    3109 	}
                 ;    3110 	if (_FF_read(_FF_DIR_ADDR)==0)	
                 ;    3111 	{
                 ;    3112 		_FF_DIR_ADDR = addr_temp;
                 ;    3113 		return (EOF);
                 ;    3114 	}
                 ;    3115 	if (_FF_DIR_ADDR != _FF_ROOT_ADDR)
                 ;    3116 	{
                 ;    3117 		sp = &_FF_buff[0];
                 ;    3118 		qp = &_FF_buff[0x20];
                 ;    3119 		for (c=0; c<0x20; c++)
                 ;    3120 			*qp++ = *sp++;
                 ;    3121 		_FF_buff[1] = ' ';
                 ;    3122 		for (c=0x3C; c<0x40; c++)
                 ;    3123 			_FF_buff[c] = 0;
                 ;    3124 	}
                 ;    3125 	else
                 ;    3126 	{
                 ;    3127 		for (c=0x01; c<0x0B; c++)
                 ;    3128 			_FF_buff[c] = 0x20;
                 ;    3129 		for (c=0x0C; c<0x20; c++)
                 ;    3130 			_FF_buff[c] = 0;
                 ;    3131 		_FF_buff[0] = '.';
                 ;    3132 		_FF_buff[0x0B] = 0x10;
                 ;    3133 		#ifdef _RTC_ON_
                 ;    3134 			_FF_buff[0x0E] = calc_time&0x00FF;	// File modify Time 
                 ;    3135 			_FF_buff[0x0F] = (calc_time&0xFF00) >> 8;
                 ;    3136 			_FF_buff[0x10] = calc_date&0x00FF;	// File modify Date
                 ;    3137 			_FF_buff[0x11] = (calc_date&0xFF00) >> 8;
                 ;    3138 			_FF_buff[0x16] = calc_time&0x00FF;	// File modify Time 
                 ;    3139 			_FF_buff[0x17] = (calc_time&0xFF00) >> 8;
                 ;    3140 			_FF_buff[0x18] = calc_date&0x00FF;	// File modify Date
                 ;    3141 			_FF_buff[0x19] = (calc_date&0xFF00) >> 8;
                 ;    3142 		#endif
                 ;    3143 		for (c=0x3A; c<0x40; c++)
                 ;    3144 			_FF_buff[c] = 0;
                 ;    3145 	}
                 ;    3146 	for (c=0x22; c<0x2B; c++)
                 ;    3147 		_FF_buff[c] = 0x20;
                 ;    3148 	#ifdef _RTC_ON_
                 ;    3149 		_FF_buff[0x2E] = calc_time&0x00FF;	// File modify Time 
                 ;    3150 		_FF_buff[0x2F] = (calc_time&0xFF00) >> 8;
                 ;    3151 		_FF_buff[0x30] = calc_date&0x00FF;	// File modify Date
                 ;    3152 		_FF_buff[0x31] = (calc_date&0xFF00) >> 8;
                 ;    3153 		_FF_buff[0x36] = calc_time&0x00FF;	// File modify Time 
                 ;    3154 		_FF_buff[0x37] = (calc_time&0xFF00) >> 8;
                 ;    3155 		_FF_buff[0x38] = calc_date&0x00FF;	// File modify Date
                 ;    3156 		_FF_buff[0x39] = (calc_date&0xFF00) >> 8;
                 ;    3157 	#endif
                 ;    3158 	_FF_buff[0x20] = '.';
                 ;    3159 	_FF_buff[0x21] = '.';
                 ;    3160 	_FF_buff[0x2B] = 0x10;
                 ;    3161 
                 ;    3162 	_FF_buff[0x1A] = clus_temp & 0xFF;				// Starting cluster (2 bytes)
                 ;    3163 	_FF_buff[0x1B] = (clus_temp >> 8) & 0xFF;
                 ;    3164 	for (c=0x40; c<BPB_BytsPerSec; c++)
                 ;    3165 		_FF_buff[c] = 0;
                 ;    3166 	path_addr_temp = clust_to_addr(clus_temp);
                 ;    3167 
                 ;    3168 	_FF_DIR_ADDR = addr_temp;	// reset dir addr
                 ;    3169 	if (_FF_write(path_addr_temp)==0)	
                 ;    3170 		return (EOF);
                 ;    3171 	for (c=0; c<0x40; c++)
                 ;    3172 		_FF_buff[c] = 0;
                 ;    3173 	for (c=1; c<BPB_SecPerClus; c++)
                 ;    3174 	{
                 ;    3175 		if (_FF_write(path_addr_temp+((long)c*0x200))==0)	
                 ;    3176 			return (EOF);
                 ;    3177 	}
                 ;    3178 	return (0);		
                 ;    3179 }
                 ;    3180 
                 ;    3181 int rmdir(char *F_PATH)
                 ;    3182 {
                 ;    3183 	unsigned char *sp;
                 ;    3184 	unsigned char fpath[14];
                 ;    3185 	unsigned int c, n, calc_temp, clus_temp;
                 ;    3186 	int s;
                 ;    3187 	unsigned long addr_temp, path_addr_temp;
                 ;    3188 	
                 ;    3189 	addr_temp = 0;	// save local dir addr
                 ;	*F_PATH -> Y+34
                 ;	*sp -> R16,R17
                 ;	fpath -> Y+20
                 ;	c -> R18,R19
                 ;	n -> R20,R21
                 ;	calc_temp -> Y+18
                 ;	clus_temp -> Y+16
                 ;	s -> Y+14
                 ;	addr_temp -> Y+10
                 ;	path_addr_temp -> Y+6
                 ;    3190     
                 ;    3191     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
                 ;    3192 	{
                 ;    3193 		_FF_DIR_ADDR = addr_temp;
                 ;    3194 		return (EOF);
                 ;    3195 	}
                 ;    3196 	if (fpath[0]==0)
                 ;    3197 	{
                 ;    3198 		_FF_DIR_ADDR = addr_temp;
                 ;    3199 		return (EOF);
                 ;    3200 	}
                 ;    3201 
                 ;    3202     path_addr_temp = _FF_DIR_ADDR;	// save addr for later
                 ;    3203 	
                 ;    3204 	if (_FF_chdir(fpath))	// Change directory to dir to be deleted
                 ;    3205 	{	
                 ;    3206 		_FF_DIR_ADDR = addr_temp;
                 ;    3207 		return (EOF);
                 ;    3208 	}
                 ;    3209 	if ((_FF_DIR_ADDR==_FF_ROOT_ADDR)||(_FF_DIR_ADDR==addr_temp))
                 ;    3210 	{	// if trying to delete root, or current dir error
                 ;    3211 		_FF_DIR_ADDR = addr_temp;
                 ;    3212 		return (EOF);
                 ;    3213 	}
                 ;    3214 	
                 ;    3215 	for (c=0; c<BPB_SecPerClus; c++)
                 ;    3216 	{	// scan through dir to see if it is empty
                 ;    3217 		if (_FF_read(_FF_DIR_ADDR+((long)c*0x200))==0)
                 ;    3218 		{	// read sectors 	
                 ;    3219 			_FF_DIR_ADDR = addr_temp;
                 ;    3220 			return (EOF);
                 ;    3221 		}
                 ;    3222 		for (n=0; n<0x10; n++)
                 ;    3223 		{
                 ;    3224 			if ((c==0)&&(n==0))	// skip first 2 entries 
                 ;    3225 				n=2;
                 ;    3226 			sp = &_FF_buff[n*0x20];
                 ;    3227 			if (*sp==0)
                 ;    3228 			{	// 
                 ;    3229 				c = BPB_SecPerClus;
                 ;    3230 				break;
                 ;    3231 			}
                 ;    3232 			while (valid_file_char(*sp)==0)
                 ;    3233 			{
                 ;    3234 				sp++;
                 ;    3235 				if (sp == &_FF_buff[(n*0x20)+0x0A])
                 ;    3236 				{	// a valid file or folder found
                 ;    3237 					_FF_DIR_ADDR = addr_temp;
                 ;    3238 					return (EOF);
                 ;    3239 				}
                 ;    3240 			}
                 ;    3241 		}
                 ;    3242 	}
                 ;    3243 	// directory empty, delete dir
                 ;    3244 	_FF_DIR_ADDR = path_addr_temp;	// go back to previous directory 
                 ;    3245 
                 ;    3246 	s = scan_directory(&path_addr_temp, fpath);
                 ;    3247 
                 ;    3248 	_FF_DIR_ADDR = addr_temp;	// reset address
                 ;    3249 
                 ;    3250 	if (s == 0)
                 ;    3251 		return (EOF);
                 ;    3252 	
                 ;    3253 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    3254 	path_addr_temp -= calc_temp;
                 ;    3255 
                 ;    3256 	if (_FF_read(path_addr_temp)==0)	
                 ;    3257 		return (EOF);
                 ;    3258     
                 ;    3259 	clus_temp = ((int) _FF_buff[calc_temp+0x1B] << 8) | _FF_buff[calc_temp+0x1A];
                 ;    3260 	_FF_buff[calc_temp] = 0xE5;
                 ;    3261 	
                 ;    3262 	if (_FF_buff[calc_temp+0x0B]&0x02)
                 ;    3263 		return (EOF);
                 ;    3264 	if (_FF_write(path_addr_temp)==0) 
                 ;    3265 		return (EOF);
                 ;    3266 	if (erase_clus_chain(clus_temp)==0)
                 ;    3267 		return (EOF);
                 ;    3268 	
                 ;    3269     return (0);
                 ;    3270 }
                 ;    3271 #endif
                 ;    3272 
                 ;    3273 int chdirc(char flash *F_PATH)
                 ;    3274 {
                 ;    3275 	unsigned char fpath[_FF_PATH_LENGTH];
                 ;    3276 	int c;
                 ;    3277 	
                 ;    3278 	for (c=0; c<_FF_PATH_LENGTH; c++)
                 ;	*F_PATH -> Y+102
                 ;	fpath -> Y+2
                 ;	c -> R16,R17
                 ;    3279 	{
                 ;    3280 		fpath[c] = F_PATH[c];
                 ;    3281 		if (F_PATH[c]==0)
                 ;    3282 			break;
                 ;    3283 	}
                 ;    3284 	return (chdir(fpath));
                 ;    3285 }
                 ;    3286 
                 ;    3287 int chdir(char *F_PATH)
                 ;    3288 {
                 ;    3289 	unsigned char *qp, *sp, fpath[14], valid_flag;
                 ;    3290 	unsigned int m, n, c, d, calc;
                 ;    3291 	unsigned long addr_temp;
                 ;    3292 
                 ;    3293     
                 ;    3294     addr_temp = 0;	// save local dir addr
                 ;	*F_PATH -> Y+33
                 ;	*qp -> R16,R17
                 ;	*sp -> R18,R19
                 ;	fpath -> Y+19
                 ;	valid_flag -> R20
                 ;	m -> Y+17
                 ;	n -> Y+15
                 ;	c -> Y+13
                 ;	d -> Y+11
                 ;	calc -> Y+9
                 ;	addr_temp -> Y+5
                 ;    3295     
                 ;    3296 	if ((F_PATH[0]=='\\') && (F_PATH[1]==0))
                 ;    3297 	{
                 ;    3298 		_FF_DIR_ADDR = _FF_ROOT_ADDR;
                 ;    3299 		_FF_FULL_PATH[1] = 0;
                 ;    3300 		return (0);
                 ;    3301 	}
                 ;    3302 	
                 ;    3303     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
                 ;    3304 	{
                 ;    3305 		_FF_DIR_ADDR = addr_temp;
                 ;    3306 		return (EOF);
                 ;    3307 	}
                 ;    3308 	if (fpath[0]==0)
                 ;    3309 		return (EOF);
                 ;    3310 
                 ;    3311 	if ((fpath[0]=='.') && (fpath[1]=='.') && (fpath[2]==0))
                 ;    3312 	{	// trying to get back to prev dir
                 ;    3313 		if (_FF_DIR_ADDR == _FF_ROOT_ADDR)		// already as far back as can go
                 ;    3314 			return (EOF);
                 ;    3315 		if (_FF_read(_FF_DIR_ADDR)==0)
                 ;    3316 			return (EOF);
                 ;    3317 		m = ((unsigned int) _FF_buff[0x3B] << 8) | (unsigned int) _FF_buff[0x3A];
                 ;    3318 		if (m)
                 ;    3319 			_FF_DIR_ADDR = clust_to_addr(m);
                 ;    3320 		else
                 ;    3321 			_FF_DIR_ADDR = _FF_ROOT_ADDR;
                 ;    3322 		
                 ;    3323 					sp = F_PATH;
                 ;    3324 					qp = _FF_FULL_PATH + strlen(_FF_FULL_PATH);
                 ;    3325 					while (*sp)
                 ;    3326 					{
                 ;    3327 						if ((*sp=='.')&&(*(sp+1)=='.'))
                 ;    3328 						{
                 ;    3329 							#ifdef _ICCAVR_
                 ;    3330 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3331 								if (qp==0)
                 ;    3332 								   return (EOF);
                 ;    3333 								*qp = 0;
                 ;    3334 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3335 								if (qp==0)
                 ;    3336 								   return (EOF);
                 ;    3337 								qp++;
                 ;    3338 							#endif
                 ;    3339 							#ifdef _CVAVR_
                 ;    3340 								_FF_FULL_PATH[strrpos(_FF_FULL_PATH, '\\')] = 0;
                 ;    3341 							    c = strrpos(_FF_FULL_PATH, '\\');
                 ;    3342 								if (c==EOF)
                 ;    3343 									return (EOF);
                 ;    3344 								qp = _FF_FULL_PATH + c;
                 ;    3345 							#endif
                 ;    3346 							*qp = 0;
                 ;    3347 							sp += 2;
                 ;    3348 						}
                 ;    3349 						else 
                 ;    3350 							*qp++ = toupper(*sp++);
                 ;    3351 					}
                 ;    3352 					*qp++ = '\\';
                 ;    3353 					*qp = 0;
                 ;    3354 
                 ;    3355 		return (0);
                 ;    3356 	}
                 ;    3357 		
                 ;    3358 	qp = fpath;
                 ;    3359 	sp = fpath;
                 ;    3360 	while(sp < (fpath+11))
                 ;    3361 	{
                 ;    3362 		if (*qp)
                 ;    3363 			*sp++ = toupper(*qp++);
                 ;    3364 		else	// (*qp==0)
                 ;    3365 			*sp++ = 0x20;
                 ;    3366 	}     
                 ;    3367 	*sp = 0;
                 ;    3368 
                 ;    3369 	qp = fpath;
                 ;    3370 	m = 0;
                 ;    3371 	d = 0;
                 ;    3372 	valid_flag = 0;
                 ;    3373 	while (d<BPB_RootEntCnt)
                 ;    3374 	{
                 ;    3375     	_FF_read(_FF_DIR_ADDR+(m*0x200));
                 ;    3376 		for (n=0; n<16; n++)
                 ;    3377 		{
                 ;    3378 			if (_FF_buff[n*0x20] == 0)	// no more entries in dir
                 ;    3379 			{
                 ;    3380 				_FF_DIR_ADDR = addr_temp;
                 ;    3381 				return (EOF);
                 ;    3382 			}
                 ;    3383 			calc = (n*0x20);
                 ;    3384 			for (c=0; c<11; c++)
                 ;    3385 			{	// check for name match
                 ;    3386 				if (fpath[c] == _FF_buff[calc+c])
                 ;    3387 					valid_flag = 1;
                 ;    3388 				else if (fpath[c] == 0)
                 ;    3389 				{
                 ;    3390 					if (_FF_buff[calc+c]==0x20)
                 ;    3391 						break;
                 ;    3392 				}
                 ;    3393 				else
                 ;    3394 				{
                 ;    3395 					valid_flag = 0;	
                 ;    3396 					break;
                 ;    3397 				}
                 ;    3398 		    }   
                 ;    3399 		    if (valid_flag)
                 ;    3400 	  		{
                 ;    3401 	  			if (_FF_buff[calc+0xB] != 0x10)	// not a directory
                 ;    3402 	  				valid_flag = 0;
                 ;    3403 	  			else
                 ;    3404 	  			{
                 ;    3405 	  				c = ((int) _FF_buff[calc+0x1B] << 8) | ((int) _FF_buff[calc+0x1A]);
                 ;    3406 					_FF_DIR_ADDR = clust_to_addr(c);
                 ;    3407 					sp = F_PATH;
                 ;    3408 					if (*sp=='\\')
                 ;    3409 					{	// Restart String @root
                 ;    3410 						qp = _FF_FULL_PATH + 1;
                 ;    3411 						*qp = 0;
                 ;    3412 						sp++;
                 ;    3413 					}
                 ;    3414 					else
                 ;    3415 						qp = _FF_FULL_PATH + strlen(_FF_FULL_PATH);
                 ;    3416 					while (*sp)
                 ;    3417 					{
                 ;    3418 						if ((*sp=='.')&&(*(sp+1)=='.'))
                 ;    3419 						{
                 ;    3420 							#ifdef _ICCAVR_
                 ;    3421 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3422 								if (qp==0)
                 ;    3423 								   return (EOF);
                 ;    3424 								*qp = 0;
                 ;    3425 								qp = strrchr(_FF_FULL_PATH, '\\');
                 ;    3426 								if (qp==0)
                 ;    3427 								   return (EOF);
                 ;    3428 								qp++;
                 ;    3429 							#endif
                 ;    3430 							#ifdef _CVAVR_
                 ;    3431 								_FF_FULL_PATH[strrpos(_FF_FULL_PATH, '\\')] = 0;
                 ;    3432 								c = strrpos(_FF_FULL_PATH, '\\');
                 ;    3433 								if (c==EOF)
                 ;    3434 								   return (EOF);
                 ;    3435 								qp = _FF_FULL_PATH + c;
                 ;    3436 							#endif
                 ;    3437 							*qp = 0;
                 ;    3438 							sp += 2;
                 ;    3439 						}
                 ;    3440 						else 
                 ;    3441 							*qp++ = toupper(*sp++);
                 ;    3442 					}
                 ;    3443 					*qp++ = '\\';
                 ;    3444 					*qp = 0;
                 ;    3445 					return (0);
                 ;    3446 				}
                 ;    3447 			}
                 ;    3448 		  	d++;		  		
                 ;    3449 		}
                 ;    3450 		m++;
                 ;    3451 	}
                 ;    3452 	_FF_DIR_ADDR = addr_temp;
                 ;    3453 	return (EOF);
                 ;    3454 }
                 ;    3455 
                 ;    3456 // Function to change directories one at a time, not effecting the working dir string
                 ;    3457 int _FF_chdir(char *F_PATH)
                 ;    3458 {
                 __FF_chdir:
                 ;    3459 	unsigned char *qp, *sp, valid_flag, fpath[14];
                 ;    3460 	unsigned int m, n, c, d, calc;
                 ;    3461     
                 ;    3462 	if ((F_PATH[0]=='.') && (F_PATH[1]=='.') && (F_PATH[2]==0))
00122a 9768      	SBIW R28,24
00122b 940e 2abd 	CALL __SAVELOCR5
                 ;	*F_PATH -> Y+29
                 ;	*qp -> R16,R17
                 ;	*sp -> R18,R19
                 ;	valid_flag -> R20
                 ;	fpath -> Y+15
                 ;	m -> Y+13
                 ;	n -> Y+11
                 ;	c -> Y+9
                 ;	d -> Y+7
                 ;	calc -> Y+5
00122d 8dad      	LDD  R26,Y+29
00122e 8dbe      	LDD  R27,Y+29+1
00122f 91ac      	LD   R26,X
001230 32ae      	CPI  R26,LOW(0x2E)
001231 f461      	BRNE _0x272
001232 8dad      	LDD  R26,Y+29
001233 8dbe      	LDD  R27,Y+29+1
001234 9611      	ADIW R26,1
001235 91ac      	LD   R26,X
001236 32ae      	CPI  R26,LOW(0x2E)
001237 f431      	BRNE _0x272
001238 8dad      	LDD  R26,Y+29
001239 8dbe      	LDD  R27,Y+29+1
00123a 9612      	ADIW R26,2
00123b 91ac      	LD   R26,X
00123c 30a0      	CPI  R26,LOW(0x0)
00123d f009      	BREQ _0x273
                 _0x272:
00123e c048      	RJMP _0x271
                 _0x273:
                 ;    3463 	{	// trying to get back to prev dir
                 ;    3464 		if (_FF_DIR_ADDR == _FF_ROOT_ADDR)		// already as far back as can go
00123f 91e0 0958 	LDS  R30,__FF_ROOT_ADDR
001241 91f0 0959 	LDS  R31,__FF_ROOT_ADDR+1
001243 9160 095a 	LDS  R22,__FF_ROOT_ADDR+2
001245 9170 095b 	LDS  R23,__FF_ROOT_ADDR+3
001247 91a0 095c 	LDS  R26,__FF_DIR_ADDR
001249 91b0 095d 	LDS  R27,__FF_DIR_ADDR+1
00124b 9180 095e 	LDS  R24,__FF_DIR_ADDR+2
00124d 9190 095f 	LDS  R25,__FF_DIR_ADDR+3
00124f 940e 2ab2 	CALL __CPD12
001251 f419      	BRNE _0x274
                 ;    3465 			return (EOF);
001252 efef      	LDI  R30,LOW(65535)
001253 efff      	LDI  R31,HIGH(65535)
001254 c0f2      	RJMP _0x4CD
                 ;    3466 		if (_FF_read(_FF_DIR_ADDR)==0)
                 _0x274:
001255 91e0 095c 	LDS  R30,__FF_DIR_ADDR
001257 91f0 095d 	LDS  R31,__FF_DIR_ADDR+1
001259 9160 095e 	LDS  R22,__FF_DIR_ADDR+2
00125b 9170 095f 	LDS  R23,__FF_DIR_ADDR+3
00125d 940e 2488 	CALL SUBOPT_0x34
00125f f419      	BRNE _0x275
                 ;    3467 			return (EOF);
001260 efef      	LDI  R30,LOW(65535)
001261 efff      	LDI  R31,HIGH(65535)
001262 c0e4      	RJMP _0x4CD
                 ;    3468 		m = ((unsigned int) _FF_buff[0x3B] << 8) | (unsigned int) _FF_buff[0x3A];
                 _0x275:
001263 91b0 076a 	__GETBRMN 27,__FF_buff,59
001265 e0a0      	LDI  R26,LOW(0)
001266 91e0 0769 	__GETB1MN __FF_buff,58
001268 e0f0      	LDI  R31,0
001269 2bea      	OR   R30,R26
00126a 2bfb      	OR   R31,R27
00126b 87ed      	STD  Y+13,R30
00126c 87fe      	STD  Y+13+1,R31
                 ;    3469 		if (m)
00126d 9730      	SBIW R30,0
00126e f029      	BREQ _0x276
                 ;    3470 			_FF_DIR_ADDR = clust_to_addr(m);
00126f 93fa      	ST   -Y,R31
001270 93ea      	ST   -Y,R30
001271 940e 0da9 	CALL _clust_to_addr
001273 c008      	RJMP _0x4ED
                 ;    3471 		else
                 _0x276:
                 ;    3472 			_FF_DIR_ADDR = _FF_ROOT_ADDR;
001274 91e0 0958 	LDS  R30,__FF_ROOT_ADDR
001276 91f0 0959 	LDS  R31,__FF_ROOT_ADDR+1
001278 9160 095a 	LDS  R22,__FF_ROOT_ADDR+2
00127a 9170 095b 	LDS  R23,__FF_ROOT_ADDR+3
                 _0x4ED:
00127c 93e0 095c 	STS  __FF_DIR_ADDR,R30
00127e 93f0 095d 	STS  __FF_DIR_ADDR+1,R31
001280 9360 095e 	STS  __FF_DIR_ADDR+2,R22
001282 9370 095f 	STS  __FF_DIR_ADDR+3,R23
                 ;    3473 		return (0);
001284 e0e0      	LDI  R30,LOW(0)
001285 e0f0      	LDI  R31,HIGH(0)
001286 c0c0      	RJMP _0x4CD
                 ;    3474 	}
                 ;    3475 		
                 ;    3476 	qp = F_PATH;
                 _0x271:
001287 8d0d
001288 8d1e      	__GETWRS 16,17,29
                 ;    3477 	sp = fpath;
001289 01fe      	MOVW R30,R28
00128a 963f      	ADIW R30,15
00128b 019f      	MOVW R18,R30
                 ;    3478 	while(sp < (fpath+11))
                 _0x278:
00128c 01fe      	MOVW R30,R28
00128d 967a      	ADIW R30,26
00128e 172e      	CP   R18,R30
00128f 073f      	CPC  R19,R31
001290 f4f8      	BRSH _0x27A
                 ;    3479 	{
                 ;    3480 		if (valid_file_char(*qp)==0)
001291 01d8      	MOVW R26,R16
001292 940e 24f5 	CALL SUBOPT_0x41
001294 f469      	BRNE _0x27B
                 ;    3481 			*sp++ = toupper(*qp++);
001295 933f      	PUSH R19
001296 932f      	PUSH R18
001297 5f2f
001298 4f3f      	__ADDWRN 18,19,1
001299 01d8      	MOVW R26,R16
00129a 5f0f
00129b 4f1f      	__ADDWRN 16,17,1
00129c 940e 2632 	CALL SUBOPT_0x60
00129e 91af      	POP  R26
00129f 91bf      	POP  R27
0012a0 93ec      	ST   X,R30
                 ;    3482 		else if (*qp==0)
0012a1 c00d      	RJMP _0x27C
                 _0x27B:
0012a2 01d8      	MOVW R26,R16
0012a3 91ec      	LD   R30,X
0012a4 30e0      	CPI  R30,0
0012a5 f431      	BRNE _0x27D
                 ;    3483 			*sp++ = 0x20;
0012a6 01d9      	MOVW R26,R18
0012a7 5f2f
0012a8 4f3f      	__ADDWRN 18,19,1
0012a9 e2e0      	LDI  R30,LOW(32)
0012aa 93ec      	ST   X,R30
                 ;    3484 		else
0012ab c003      	RJMP _0x27E
                 _0x27D:
                 ;    3485 			return (EOF);
0012ac efef      	LDI  R30,LOW(65535)
0012ad efff      	LDI  R31,HIGH(65535)
0012ae c098      	RJMP _0x4CD
                 ;    3486 	}     
                 _0x27E:
                 _0x27C:
0012af cfdc      	RJMP _0x278
                 _0x27A:
                 ;    3487 	*sp = 0;
0012b0 01d9      	MOVW R26,R18
0012b1 e0e0      	LDI  R30,LOW(0)
0012b2 93ec      	ST   X,R30
                 ;    3488 	m = 0;
0012b3 e0e0      	LDI  R30,0
0012b4 87ed      	STD  Y+13,R30
0012b5 87ee      	STD  Y+13+1,R30
                 ;    3489 	d = 0;
0012b6 e0e0      	LDI  R30,0
0012b7 83ef      	STD  Y+7,R30
0012b8 87e8      	STD  Y+7+1,R30
                 ;    3490 	valid_flag = 0;
0012b9 e040      	LDI  R20,LOW(0)
                 ;    3491 	while (d<BPB_RootEntCnt)
                 _0x27F:
0012ba 91e0 093b 	LDS  R30,_BPB_RootEntCnt
0012bc 91f0 093c 	LDS  R31,_BPB_RootEntCnt+1
0012be 81af      	LDD  R26,Y+7
0012bf 85b8      	LDD  R27,Y+7+1
0012c0 17ae      	CP   R26,R30
0012c1 07bf      	CPC  R27,R31
0012c2 f010      	BRLO PC+3
0012c3 940c 1345 	JMP _0x281
                 ;    3492 	{
                 ;    3493     	_FF_read(_FF_DIR_ADDR+(m*0x200));
0012c5 85ed      	LDD  R30,Y+13
0012c6 85fe      	LDD  R31,Y+13+1
0012c7 940e 263a 	CALL SUBOPT_0x62
0012c9 940e 295c 	CALL __ADDD12
0012cb 940e 2a63 	CALL __PUTPARD1
0012cd 940e 0b3d 	CALL __FF_read
                 ;    3494 		for (n=0; n<16; n++)
0012cf e0e0      	LDI  R30,0
0012d0 87eb      	STD  Y+11,R30
0012d1 87ec      	STD  Y+11+1,R30
                 _0x283:
0012d2 85ab      	LDD  R26,Y+11
0012d3 85bc      	LDD  R27,Y+11+1
0012d4 9750      	SBIW R26,16
0012d5 f010      	BRLO PC+3
0012d6 940c 133f 	JMP _0x284
                 ;    3495 		{
                 ;    3496 			calc = (n*0x20);
0012d8 85eb      	LDD  R30,Y+11
0012d9 85fc      	LDD  R31,Y+11+1
0012da 0fee      	LSL  R30
0012db 1fff      	ROL  R31
0012dc 940e 299e 	CALL __LSLW4
0012de 83ed      	STD  Y+5,R30
0012df 83fe      	STD  Y+5+1,R31
                 ;    3497 			if (_FF_buff[calc] == 0)	// no more entries in dir
0012e0 5de1      	SUBI R30,LOW(-__FF_buff)
0012e1 4ff8      	SBCI R31,HIGH(-__FF_buff)
0012e2 81e0      	LD   R30,Z
0012e3 30e0      	CPI  R30,0
0012e4 f419      	BRNE _0x285
                 ;    3498 				return (EOF);
0012e5 efef      	LDI  R30,LOW(65535)
0012e6 efff      	LDI  R31,HIGH(65535)
0012e7 c05f      	RJMP _0x4CD
                 ;    3499 			for (c=0; c<11; c++)
                 _0x285:
0012e8 e0e0      	LDI  R30,0
0012e9 87e9      	STD  Y+9,R30
0012ea 87ea      	STD  Y+9+1,R30
                 _0x287:
0012eb 85a9      	LDD  R26,Y+9
0012ec 85ba      	LDD  R27,Y+9+1
0012ed 971b      	SBIW R26,11
0012ee f4e8      	BRSH _0x288
                 ;    3500 			{	// check for name match
                 ;    3501 				if (fpath[c] == _FF_buff[calc+c])
0012ef 85e9      	LDD  R30,Y+9
0012f0 85fa      	LDD  R31,Y+9+1
0012f1 01de      	MOVW R26,R28
0012f2 961f      	ADIW R26,15
0012f3 0fae      	ADD  R26,R30
0012f4 1fbf      	ADC  R27,R31
0012f5 900c      	LD   R0,X
0012f6 81ad      	LDD  R26,Y+5
0012f7 81be      	LDD  R27,Y+5+1
0012f8 0fea      	ADD  R30,R26
0012f9 1ffb      	ADC  R31,R27
0012fa 5de1      	SUBI R30,LOW(-__FF_buff)
0012fb 4ff8      	SBCI R31,HIGH(-__FF_buff)
0012fc 81e0      	LD   R30,Z
0012fd 15e0      	CP   R30,R0
0012fe f411      	BRNE _0x289
                 ;    3502 					valid_flag = 1;
0012ff e041      	LDI  R20,LOW(1)
                 ;    3503 				else
001300 c005      	RJMP _0x28A
                 _0x289:
                 ;    3504 				{
                 ;    3505 					valid_flag = 0;	
001301 e040      	LDI  R20,LOW(0)
                 ;    3506 					c = 11;
001302 e0eb      	LDI  R30,LOW(11)
001303 e0f0      	LDI  R31,HIGH(11)
001304 87e9      	STD  Y+9,R30
001305 87fa      	STD  Y+9+1,R31
                 ;    3507 				}
                 _0x28A:
                 ;    3508 		    }   
001306 85e9      	LDD  R30,Y+9
001307 85fa      	LDD  R31,Y+9+1
001308 9631      	ADIW R30,1
001309 87e9      	STD  Y+9,R30
00130a 87fa      	STD  Y+9+1,R31
00130b cfdf      	RJMP _0x287
                 _0x288:
                 ;    3509 		    if (valid_flag)
00130c 3040      	CPI  R20,0
00130d f131      	BREQ _0x28B
                 ;    3510 	  		{
                 ;    3511 	  			if (_FF_buff[calc+0xB] != 0x10)	// not a directory
00130e 81ed      	LDD  R30,Y+5
00130f 81fe      	LDD  R31,Y+5+1
001310 5ce6
001311 4ff8      	__ADDW1MN __FF_buff,11
001312 81e0      	LD   R30,Z
001313 31e0      	CPI  R30,LOW(0x10)
001314 f011      	BREQ _0x28C
                 ;    3512 	  				valid_flag = 0;
001315 e040      	LDI  R20,LOW(0)
                 ;    3513 	  			else
001316 c01d      	RJMP _0x28D
                 _0x28C:
                 ;    3514 	  			{
                 ;    3515 	  				c = ((int) _FF_buff[calc+0x1B] << 8) | ((int) _FF_buff[calc+0x1A]);
001317 81ed      	LDD  R30,Y+5
001318 81fe      	LDD  R31,Y+5+1
001319 5be6
00131a 4ff8      	__ADDW1MN __FF_buff,27
00131b 940e 25db 	CALL SUBOPT_0x55
00131d 81ed      	LDD  R30,Y+5
00131e 81fe      	LDD  R31,Y+5+1
00131f 5be7
001320 4ff8      	__ADDW1MN __FF_buff,26
001321 940e 2649 	CALL SUBOPT_0x63
001323 87e9      	STD  Y+9,R30
001324 87fa      	STD  Y+9+1,R31
                 ;    3516 					_FF_DIR_ADDR = clust_to_addr(c);
001325 93fa      	ST   -Y,R31
001326 93ea      	ST   -Y,R30
001327 940e 0da9 	CALL _clust_to_addr
001329 93e0 095c 	STS  __FF_DIR_ADDR,R30
00132b 93f0 095d 	STS  __FF_DIR_ADDR+1,R31
00132d 9360 095e 	STS  __FF_DIR_ADDR+2,R22
00132f 9370 095f 	STS  __FF_DIR_ADDR+3,R23
                 ;    3517 					return (0);
001331 e0e0      	LDI  R30,LOW(0)
001332 e0f0      	LDI  R31,HIGH(0)
001333 c013      	RJMP _0x4CD
                 ;    3518 				}
                 _0x28D:
                 ;    3519 			}
                 ;    3520 		  	d++;		  		
                 _0x28B:
001334 81ef      	LDD  R30,Y+7
001335 85f8      	LDD  R31,Y+7+1
001336 9631      	ADIW R30,1
001337 83ef      	STD  Y+7,R30
001338 87f8      	STD  Y+7+1,R31
                 ;    3521 		}
001339 85eb      	LDD  R30,Y+11
00133a 85fc      	LDD  R31,Y+11+1
00133b 9631      	ADIW R30,1
00133c 87eb      	STD  Y+11,R30
00133d 87fc      	STD  Y+11+1,R31
00133e cf93      	RJMP _0x283
                 _0x284:
                 ;    3522 		m++;
00133f 85ed      	LDD  R30,Y+13
001340 85fe      	LDD  R31,Y+13+1
001341 9631      	ADIW R30,1
001342 87ed      	STD  Y+13,R30
001343 87fe      	STD  Y+13+1,R31
                 ;    3523 	}
001344 cf75      	RJMP _0x27F
                 _0x281:
                 ;    3524 	return (EOF);
001345 efef      	LDI  R30,LOW(65535)
001346 efff      	LDI  R31,HIGH(65535)
                 _0x4CD:
001347 940e 2ac4 	CALL __LOADLOCR5
001349 966f      	ADIW R28,31
00134a 9508      	RET
                 ;    3525 }
                 ;    3526 
                 ;    3527 #ifndef _SECOND_FAT_ON_
                 ;    3528 // Function that clears the secondary FAT table
                 ;    3529 int clear_second_FAT(void)
                 ;    3530 {
                 ;    3531 	unsigned int c, d;
                 ;    3532 	unsigned long n;
                 ;    3533 	
                 ;    3534 	for (n=1; n<BPB_FATSz16; n++)
                 ;    3535 	{
                 ;    3536 		if (_FF_read(_FF_FAT2_ADDR+(n*0x200))==0)
                 ;    3537 			return (EOF);
                 ;    3538 		for (c=0; c<BPB_BytsPerSec; c++)
                 ;    3539 		{
                 ;    3540 			if (_FF_buff[c] != 0)
                 ;    3541 			{
                 ;    3542 				for (d=0; d<BPB_BytsPerSec; d++)
                 ;    3543 					_FF_buff[d] = 0;
                 ;    3544 				if (_FF_write(_FF_FAT2_ADDR+(n*0x200))==0)
                 ;    3545 					return (EOF);
                 ;    3546 				break;
                 ;    3547 			}
                 ;    3548 		}
                 ;    3549 	}
                 ;    3550 	for (d=2; d<BPB_BytsPerSec; d++)
                 ;    3551 		_FF_buff[d] = 0;
                 ;    3552 	_FF_buff[0] = 0xF8;
                 ;    3553 	_FF_buff[1] = 0xFF;
                 ;    3554 	_FF_buff[2] = 0xFF;
                 ;    3555 	if (BPB_FATType == 0x36)
                 ;    3556 		_FF_buff[3] = 0xFF;
                 ;    3557 	if (_FF_write(_FF_FAT2_ADDR)==0)
                 ;    3558 		return (EOF);
                 ;    3559 	
                 ;    3560 	return (1);
                 ;    3561 }
                 ;    3562 #endif
                 ;    3563  
                 ;    3564 // Open a file, name stored in string fileopen
                 ;    3565 FILE *fopenc(unsigned char flash *NAMEC, unsigned char MODEC)
                 ;    3566 {
                 _fopenc:
                 ;    3567 	unsigned char c, temp_data[12];
                 ;    3568 	FILE *tp;
                 ;    3569 	
                 ;    3570 	for (c=0; c<12; c++)
00134b 972c      	SBIW R28,12
00134c 940e 2abf 	CALL __SAVELOCR3
                 ;	*NAMEC -> Y+16
                 ;	MODEC -> Y+15
                 ;	c -> R16
                 ;	temp_data -> Y+3
                 ;	*tp -> R17,R18
00134e e000      	LDI  R16,LOW(0)
                 _0x28F:
00134f 300c      	CPI  R16,12
001350 f468      	BRSH _0x290
                 ;    3571 		temp_data[c] = NAMEC[c];
001351 2fe0      	MOV  R30,R16
001352 e0f0      	LDI  R31,0
001353 01de      	MOVW R26,R28
001354 9613      	ADIW R26,3
001355 940e 264e 	CALL SUBOPT_0x64
001357 89a8      	LDD  R26,Y+16
001358 89b9      	LDD  R27,Y+16+1
001359 e0f0      	LDI  R31,0
00135a 940e 2653 	CALL SUBOPT_0x65
                 ;    3572 	
                 ;    3573 	tp = fopen(temp_data, MODEC);
00135c 5f0f      	SUBI R16,-1
00135d cff1      	RJMP _0x28F
                 _0x290:
00135e 01fe      	MOVW R30,R28
00135f 9633      	ADIW R30,3
001360 93fa      	ST   -Y,R31
001361 93ea      	ST   -Y,R30
001362 89e9      	LDD  R30,Y+17
001363 93ea      	ST   -Y,R30
001364 d008      	RCALL _fopen
001365 2f1e
001366 2f2f      	__PUTW1R 17,18
                 ;    3574 	return(tp);
001367 2fe1
001368 2ff2      	__GETW1R 17,18
001369 940e 2ac6 	CALL __LOADLOCR3
00136b 9662      	ADIW R28,18
00136c 9508      	RET
                 ;    3575 }
                 ;    3576 
                 ;    3577 FILE *fopen(unsigned char *NAME, unsigned char MODE)
                 ;    3578 {
                 _fopen:
                 ;    3579 	unsigned char fpath[14];
                 ;    3580 	unsigned int c, s, calc_temp;
                 ;    3581 	unsigned char *sp, *qp;
                 ;    3582 	unsigned long addr_temp, path_addr_temp;
                 ;    3583 	FILE *rp;
                 ;    3584 	
                 ;    3585 	#ifdef _READ_ONLY_
                 ;    3586 		if (MODE!=READ)
                 ;    3587 			return (0);
                 ;    3588 	#endif
                 ;    3589 	
                 ;    3590     addr_temp = 0;	// save local dir addr
00136d 940e 2659 	CALL SUBOPT_0x66
                 ;	*NAME -> Y+35
                 ;	MODE -> Y+34
                 ;	fpath -> Y+20
                 ;	c -> R16,R17
                 ;	s -> R18,R19
                 ;	calc_temp -> R20,R21
                 ;	*sp -> Y+18
                 ;	*qp -> Y+16
                 ;	addr_temp -> Y+12
                 ;	path_addr_temp -> Y+8
                 ;	*rp -> Y+6
                 ;    3591     
                 ;    3592     if (_FF_checkdir(NAME, &addr_temp, fpath))
00136f f019      	BREQ _0x291
                 ;    3593 	{
                 ;    3594 		_FF_DIR_ADDR = addr_temp;
001370 940e 2671 	CALL SUBOPT_0x67
                 ;    3595 		return (0);
001372 c279      	RJMP _0x4CC
                 ;    3596 	}
                 ;    3597 	if (fpath[0]==0)
                 _0x291:
001373 89ec      	LDD  R30,Y+20
001374 30e0      	CPI  R30,0
001375 f419      	BRNE _0x292
                 ;    3598 	{
                 ;    3599 		_FF_DIR_ADDR = addr_temp;
001376 940e 2671 	CALL SUBOPT_0x67
                 ;    3600 		return (0);
001378 c273      	RJMP _0x4CC
                 ;    3601 	}
                 ;    3602     
                 ;    3603 	path_addr_temp = _FF_DIR_ADDR;
                 _0x292:
001379 940e 2680 	CALL SUBOPT_0x68
                 ;    3604 	s = scan_directory(&path_addr_temp, fpath);
                 ;    3605 	if ((path_addr_temp==0) || (s==0))
00137b 85a8
00137c 85b9
00137d 858a
00137e 859b      	__GETD2S 8
00137f 940e 2aac 	CALL __CPD02
001381 f021      	BREQ _0x294
001382 2400      	CLR  R0
001383 1602      	CP   R0,R18
001384 0603      	CPC  R0,R19
001385 f419      	BRNE _0x293
                 _0x294:
                 ;    3606 	{
                 ;    3607 		_FF_DIR_ADDR = addr_temp;
001386 940e 2671 	CALL SUBOPT_0x67
                 ;    3608 		return (0);
001388 c263      	RJMP _0x4CC
                 ;    3609 	}
                 ;    3610 
                 ;    3611 	rp = 0;
                 _0x293:
001389 e0e0      	LDI  R30,0
00138a 83ee      	STD  Y+6,R30
00138b 83ef      	STD  Y+6+1,R30
                 ;    3612 	rp = malloc(sizeof(FILE));
00138c e2e9      	LDI  R30,LOW(553)
00138d e0f2      	LDI  R31,HIGH(553)
00138e 93fa      	ST   -Y,R31
00138f 93ea      	ST   -Y,R30
001390 940e 22e7 	CALL _malloc
001392 940e 2698 	CALL SUBOPT_0x69
                 ;    3613 	if (rp == 0)
001394 f431      	BRNE _0x296
                 ;    3614 	{	// Could not allocate requested memory
                 ;    3615 		_FF_error = ALLOC_ERR;
001395 e0e9      	LDI  R30,LOW(9)
001396 93e0 0972 	STS  __FF_error,R30
                 ;    3616 		_FF_DIR_ADDR = addr_temp;
001398 940e 2671 	CALL SUBOPT_0x67
                 ;    3617 		return (0);
00139a c251      	RJMP _0x4CC
                 ;    3618 	}
                 ;    3619 	rp->length = 0x46344456;
                 _0x296:
00139b 81ae      	LDD  R26,Y+6
00139c 81bf      	LDD  R27,Y+6+1
00139d 5ea4      	SUBI R26,LOW(-540)
00139e 4fbd      	SBCI R27,HIGH(-540)
00139f e5e6
0013a0 e4f4
0013a1 e364
0013a2 e476      	__GETD1N 0x46344456
0013a3 940e 2a54 	CALL __PUTDP1
                 ;    3620 	rp->clus_start = 0xe4;
0013a5 81ae      	LDD  R26,Y+6
0013a6 81bf      	LDD  R27,Y+6+1
0013a7 961c      	ADIW R26,12
0013a8 eee4      	LDI  R30,LOW(228)
0013a9 e0f0      	LDI  R31,HIGH(228)
0013aa 93ed      	ST   X+,R30
0013ab 93fc      	ST   X,R31
                 ;    3621 	rp->position = 0x45664446;
0013ac 81ae      	LDD  R26,Y+6
0013ad 81bf      	LDD  R27,Y+6+1
0013ae 5ea0      	SUBI R26,LOW(-544)
0013af 4fbd      	SBCI R27,HIGH(-544)
0013b0 e4e6
0013b1 e4f4
0013b2 e666
0013b3 e475      	__GETD1N 0x45664446
0013b4 940e 2a54 	CALL __PUTDP1
                 ;    3622 
                 ;    3623 	calc_temp = path_addr_temp % BPB_BytsPerSec;
0013b6 940e 269c 	CALL SUBOPT_0x6A
                 ;    3624 	path_addr_temp -= calc_temp;
                 ;    3625 	if (_FF_read(path_addr_temp)==0)	
0013b8 f419      	BRNE _0x297
                 ;    3626 	{
                 ;    3627 		_FF_DIR_ADDR = addr_temp;
0013b9 940e 2671 	CALL SUBOPT_0x67
                 ;    3628 		return (0);
0013bb c230      	RJMP _0x4CC
                 ;    3629 	}
                 ;    3630 	
                 ;    3631 	// Get the filename into a form we can use to compare
                 ;    3632 	qp = file_name_conversion(fpath);
                 _0x297:
0013bc 940e 26bb 	CALL SUBOPT_0x6B
                 ;    3633 	if (qp==0)
0013be f419      	BRNE _0x298
                 ;    3634 	{	// If File name entered is NOT valid, return 0
                 ;    3635 		free(rp);
0013bf 940e 26c5 	CALL SUBOPT_0x6C
                 ;    3636 		_FF_DIR_ADDR = addr_temp;
                 ;    3637 		return (0);
0013c1 c22a      	RJMP _0x4CC
                 ;    3638 	}
                 ;    3639 	
                 ;    3640 	sp = &_FF_buff[calc_temp];
                 _0x298:
0013c2 940e 26cb 	CALL SUBOPT_0x6D
                 ;    3641 
                 ;    3642 	if (s)
0013c4 f411      	BRNE PC+3
0013c5 940c 14ed 	JMP _0x299
                 ;    3643 	{	// File exists, open 
                 ;    3644 		if (((MODE==WRITE) || (MODE==APPEND)) && (_FF_buff[calc_temp+0x0B]&0x01))
0013c7 a1aa      	LDD  R26,Y+34
0013c8 30a2      	CPI  R26,LOW(0x2)
0013c9 f011      	BREQ _0x29B
0013ca 30a3      	CPI  R26,LOW(0x3)
0013cb f431      	BRNE _0x29D
                 _0x29B:
0013cc 01fa      	MOVW R30,R20
0013cd 5ce6
0013ce 4ff8      	__ADDW1MN __FF_buff,11
0013cf 81e0      	LD   R30,Z
0013d0 70e1      	ANDI R30,LOW(0x1)
0013d1 f409      	BRNE _0x29E
                 _0x29D:
0013d2 c003      	RJMP _0x29A
                 _0x29E:
                 ;    3645 		{	// if writing to file verify it is not "READ ONLY"
                 ;    3646 			_FF_error = MODE_ERR;
0013d3 940e 26d3 	CALL SUBOPT_0x6E
                 ;    3647 			free(rp);
                 ;    3648 			_FF_DIR_ADDR = addr_temp;
                 ;    3649 			return (0);
0013d5 c216      	RJMP _0x4CC
                 ;    3650 		}
                 ;    3651 		for (c=0; c<12; c++)	// Save Filename to Buffer
                 _0x29A:
0013d6 e000
0013d7 e010      	__GETWRN 16,17,0
                 _0x2A0:
0013d8 300c
0013d9 e0e0
0013da 071e      	__CPWRN 16,17,12
0013db f468      	BRSH _0x2A1
                 ;    3652 			rp->name[c] = FILENAME[c];
0013dc 01f8      	MOVW R30,R16
0013dd 81ae      	LDD  R26,Y+6
0013de 81bf      	LDD  R27,Y+6+1
0013df 0fea      	ADD  R30,R26
0013e0 1ffb      	ADC  R31,R27
0013e1 010f      	MOVW R0,R30
0013e2 efa0      	LDI  R26,LOW(_FILENAME)
0013e3 e0b9      	LDI  R27,HIGH(_FILENAME)
0013e4 940e 26d7 	CALL SUBOPT_0x6F
                 ;    3653 		// Save Starting Cluster
                 ;    3654 		rp->clus_start = ((int) _FF_buff[calc_temp+0x1B] << 8) | (int) _FF_buff[calc_temp+0x1A];
0013e6 5f0f
0013e7 4f1f      	__ADDWRN 16,17,1
0013e8 cfef      	RJMP _0x2A0
                 _0x2A1:
0013e9 01fa      	MOVW R30,R20
0013ea 5be6
0013eb 4ff8      	__ADDW1MN __FF_buff,27
0013ec 940e 25db 	CALL SUBOPT_0x55
0013ee 01fa      	MOVW R30,R20
0013ef 5be7
0013f0 4ff8      	__ADDW1MN __FF_buff,26
0013f1 940e 2649 	CALL SUBOPT_0x63
0013f3 81ae
0013f4 81bf
0013f5 961c
0013f6 93ed
0013f7 93fc      	__PUTW1SNS 6,12
                 ;    3655 		// Set Current Cluster
                 ;    3656 		rp->clus_current = rp->clus_start;
0013f8 940e 26dd 	CALL SUBOPT_0x70
0013fa 81ae
0013fb 81bf
0013fc 961e
0013fd 93ed
0013fe 93fc      	__PUTW1SNS 6,14
                 ;    3657 		// Set Previous Cluster to 0 (indicating @start)
                 ;    3658 		rp->clus_prev = 0;
0013ff 81ae      	LDD  R26,Y+6
001400 81bf      	LDD  R27,Y+6+1
001401 940e 26e3 	CALL SUBOPT_0x71
                 ;    3659 		// Save file length
                 ;    3660 		rp->length = 0;
001403 940e 26e9 	CALL SUBOPT_0x72
                 ;    3661 		sp = _FF_buff + calc_temp + 0x1F;
001405 940e 26f4 	CALL SUBOPT_0x73
                 ;    3662 		for (c=0; c<4; c++)
001407 e000
001408 e010      	__GETWRN 16,17,0
                 _0x2A3:
001409 3004
00140a e0e0
00140b 071e      	__CPWRN 16,17,4
00140c f580      	BRSH _0x2A4
                 ;    3663 		{
                 ;    3664 			rp->length <<= 8;
00140d 81ee      	LDD  R30,Y+6
00140e 81ff      	LDD  R31,Y+6+1
00140f 5ee4      	SUBI R30,LOW(-540)
001410 4ffd      	SBCI R31,HIGH(-540)
001411 93ff      	PUSH R31
001412 93ef      	PUSH R30
001413 01df      	MOVW R26,R30
001414 940e 2a4e 	CALL __GETD1P
001416 01df      	MOVW R26,R30
001417 01cb      	MOVW R24,R22
001418 e0e8      	LDI  R30,LOW(8)
001419 940e 2986 	CALL __LSLD12
00141b 91af      	POP  R26
00141c 91bf      	POP  R27
00141d 940e 2a54 	CALL __PUTDP1
                 ;    3665 			rp->length |= *sp--;
00141f 81ee      	LDD  R30,Y+6
001420 81ff      	LDD  R31,Y+6+1
001421 5ee4      	SUBI R30,LOW(-540)
001422 4ffd      	SBCI R31,HIGH(-540)
001423 010f      	MOVW R0,R30
001424 01df      	MOVW R26,R30
001425 940e 2a4e 	CALL __GETD1P
001427 937f      	PUSH R23
001428 936f      	PUSH R22
001429 93ff      	PUSH R31
00142a 93ef      	PUSH R30
00142b 940e 26fb 	CALL SUBOPT_0x74
00142d 91ec      	LD   R30,X
00142e 91af      	POP  R26
00142f 91bf      	POP  R27
001430 918f      	POP  R24
001431 919f      	POP  R25
001432 27ff      	CLR  R31
001433 2766      	CLR  R22
001434 2777      	CLR  R23
001435 940e 2970 	CALL __ORD12
001437 01d0      	MOVW R26,R0
001438 940e 2a54 	CALL __PUTDP1
                 ;    3666 		}
00143a 5f0f
00143b 4f1f      	__ADDWRN 16,17,1
00143c cfcc      	RJMP _0x2A3
                 _0x2A4:
                 ;    3667 		// Set Current Position to 0
                 ;    3668 		rp->position = 0;
00143d 81ae      	LDD  R26,Y+6
00143e 81bf      	LDD  R27,Y+6+1
00143f 5ea0      	SUBI R26,LOW(-544)
001440 4fbd      	SBCI R27,HIGH(-544)
001441 e0e0
001442 e0f0
001443 e060
001444 e070      	__GETD1N 0x0
001445 940e 2a54 	CALL __PUTDP1
                 ;    3669 		#ifndef _READ_ONLY_
                 ;    3670 			if (MODE==WRITE)
001447 a1aa      	LDD  R26,Y+34
001448 30a2      	CPI  R26,LOW(0x2)
001449 f541      	BRNE _0x2A5
                 ;    3671 			{	// Change file to blank
                 ;    3672 				sp = _FF_buff + calc_temp + 0x1F;
00144a 940e 26f4 	CALL SUBOPT_0x73
                 ;    3673 				for (c=0; c<6; c++)
00144c e000
00144d e010      	__GETWRN 16,17,0
                 _0x2A7:
00144e 3006
00144f e0e0
001450 071e      	__CPWRN 16,17,6
001451 f438      	BRSH _0x2A8
                 ;    3674 					*sp-- = 0;
001452 940e 26fb 	CALL SUBOPT_0x74
001454 e0e0      	LDI  R30,LOW(0)
001455 93ec      	ST   X,R30
                 ;    3675 				if (rp->length)
001456 5f0f
001457 4f1f      	__ADDWRN 16,17,1
001458 cff5      	RJMP _0x2A7
                 _0x2A8:
001459 940e 2702 	CALL SUBOPT_0x75
00145b f0b1      	BREQ _0x2A9
                 ;    3676 				{
                 ;    3677 					if (_FF_write(_FF_DIR_ADDR + (0x200 * s))==0)
00145c 01f9      	MOVW R30,R18
00145d 940e 263a 	CALL SUBOPT_0x62
00145f 940e 25ee 	CALL SUBOPT_0x58
001461 f419      	BRNE _0x2AA
                 ;    3678 					{
                 ;    3679 						free(rp);
001462 940e 26c5 	CALL SUBOPT_0x6C
                 ;    3680 						_FF_DIR_ADDR = addr_temp;
                 ;    3681 						return (0);
001464 c187      	RJMP _0x4CC
                 ;    3682 					}
                 ;    3683 					rp->length = 0;
                 _0x2AA:
001465 940e 26e9 	CALL SUBOPT_0x72
                 ;    3684 					erase_clus_chain(rp->clus_start);
001467 940e 270b 	CALL SUBOPT_0x76
001469 940e 117a 	CALL _erase_clus_chain
                 ;    3685 					rp->clus_start = 0;
00146b 81ae      	LDD  R26,Y+6
00146c 81bf      	LDD  R27,Y+6+1
00146d 961c      	ADIW R26,12
00146e e0e0      	LDI  R30,LOW(0)
00146f e0f0      	LDI  R31,HIGH(0)
001470 93ed      	ST   X+,R30
001471 93fc      	ST   X,R31
                 ;    3686 				}
                 ;    3687 			}
                 _0x2A9:
                 ;    3688 		#endif
                 ;    3689 		// Set and save next cluster #
                 ;    3690 		rp->clus_next = next_cluster(rp->clus_current, SINGLE);
                 _0x2A5:
001472 940e 2712 	CALL SUBOPT_0x77
001474 940e 2719 	CALL SUBOPT_0x78
001476 81ae
001477 81bf
001478 9650
001479 93ed
00147a 93fc      	__PUTW1SNS 6,16
                 ;    3691 		if ((rp->length==0) && (rp->clus_start==0))
00147b 940e 2702 	CALL SUBOPT_0x75
00147d f421      	BRNE _0x2AC
00147e 940e 26dd 	CALL SUBOPT_0x70
001480 9730      	SBIW R30,0
001481 f009      	BREQ _0x2AD
                 _0x2AC:
001482 c008      	RJMP _0x2AB
                 _0x2AD:
                 ;    3692 		{	// Check for Blank File 
                 ;    3693 			if (MODE==READ)
001483 a1aa      	LDD  R26,Y+34
001484 30a1      	CPI  R26,LOW(0x1)
001485 f419      	BRNE _0x2AE
                 ;    3694 			{	// IF trying to open a blank file to read, ERROR
                 ;    3695 				_FF_error = MODE_ERR;
001486 940e 26d3 	CALL SUBOPT_0x6E
                 ;    3696 				free(rp);
                 ;    3697 				_FF_DIR_ADDR = addr_temp;
                 ;    3698 				return (0);
001488 c163      	RJMP _0x4CC
                 ;    3699 			}
                 ;    3700 			//Setup blank FILE characteristics
                 ;    3701 			#ifndef _READ_ONLY_
                 ;    3702 				MODE = WRITE; 
                 _0x2AE:
001489 e0e2      	LDI  R30,LOW(2)
00148a a3ea      	STD  Y+34,R30
                 ;    3703 			#endif
                 ;    3704 		}
                 ;    3705 		// Save the file offset to read entry
                 ;    3706 		rp->entry_sec_addr = path_addr_temp;
                 _0x2AB:
00148b 85e8
00148c 85f9
00148d 856a
00148e 857b      	__GETD1S 8
00148f 81ae
001490 81bf
001491 9656
001492 940e 2a54 	__PUTD1SNS 6,22
                 ;    3707 		rp->entry_offset =  calc_temp;
001494 01fa      	MOVW R30,R20
001495 81ae
001496 81bf
001497 965a
001498 93ed
001499 93fc      	__PUTW1SNS 6,26
                 ;    3708 		// Set sector offset to 1
                 ;    3709 		rp->sec_offset = 1;
00149a 940e 271d 	CALL SUBOPT_0x79
                 ;    3710 		if (MODE==APPEND)
00149c a1aa      	LDD  R26,Y+34
00149d 30a3      	CPI  R26,LOW(0x3)
00149e f4a9      	BRNE _0x2AF
                 ;    3711 		{
                 ;    3712 			if (fseek(rp, 0,SEEK_END)==EOF)
00149f 81ee      	LDD  R30,Y+6
0014a0 81ff      	LDD  R31,Y+6+1
0014a1 93fa      	ST   -Y,R31
0014a2 93ea      	ST   -Y,R30
0014a3 e0e0
0014a4 e0f0
0014a5 e060
0014a6 e070      	__GETD1N 0x0
0014a7 940e 2a63 	CALL __PUTPARD1
0014a9 e0e1      	LDI  R30,LOW(1)
0014aa 93ea      	ST   -Y,R30
0014ab d46c      	RCALL _fseek
0014ac 3fef      	CPI  R30,LOW(0xFFFF)
0014ad efaf      	LDI  R26,HIGH(0xFFFF)
0014ae 07fa      	CPC  R31,R26
0014af f419      	BRNE _0x2B0
                 ;    3713 			{
                 ;    3714 				free(rp);
0014b0 940e 26c5 	CALL SUBOPT_0x6C
                 ;    3715 				_FF_DIR_ADDR = addr_temp;
                 ;    3716 				return (0);
0014b2 c139      	RJMP _0x4CC
                 ;    3717 			}
                 ;    3718 		}
                 _0x2B0:
                 ;    3719 		else
0014b3 c021      	RJMP _0x2B1
                 _0x2AF:
                 ;    3720 		{	// Set pointer to the begining of the file
                 ;    3721 			_FF_read(clust_to_addr(rp->clus_current));
0014b4 940e 2712 	CALL SUBOPT_0x77
0014b6 940e 0da9 	CALL _clust_to_addr
0014b8 940e 2a63 	CALL __PUTPARD1
0014ba 940e 0b3d 	CALL __FF_read
                 ;    3722 			for (c=0; c<BPB_BytsPerSec; c++)
0014bc e000
0014bd e010      	__GETWRN 16,17,0
                 _0x2B3:
0014be 91e0 0935 	LDS  R30,_BPB_BytsPerSec
0014c0 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
0014c2 170e      	CP   R16,R30
0014c3 071f      	CPC  R17,R31
0014c4 f438      	BRSH _0x2B4
                 ;    3723 				rp->buff[c] = _FF_buff[c];
0014c5 940e 2725 	CALL SUBOPT_0x7A
0014c7 940e 272b 	CALL SUBOPT_0x7B
                 ;    3724 			rp->pntr = &rp->buff[0];
0014c9 5f0f
0014ca 4f1f      	__ADDWRN 16,17,1
0014cb cff2      	RJMP _0x2B3
                 _0x2B4:
0014cc 81ee      	LDD  R30,Y+6
0014cd 81ff      	LDD  R31,Y+6+1
0014ce 967c      	ADIW R30,28
0014cf 81ae
0014d0 81bf
0014d1 5da9
0014d2 4fbd
0014d3 93ed
0014d4 93fc      	__PUTW1SN 6,551
                 ;    3725 		}
                 _0x2B1:
                 ;    3726 		#ifndef _READ_ONLY_
                 ;    3727 			#ifndef _SECOND_FAT_ON_
                 ;    3728 				if ((MODE==WRITE) || (MODE==APPEND))
                 ;    3729 					clear_second_FAT();
                 ;    3730 			#endif
                 ;    3731     	#endif
                 ;    3732 		rp->mode = MODE;
0014d5 a1ea      	LDD  R30,Y+34
0014d6 81ae
0014d7 81bf
0014d8 5dac
0014d9 4fbd
0014da 93ec      	__PUTB1SN 6,548
                 ;    3733 		_FF_error = NO_ERR;
0014db e0e0      	LDI  R30,LOW(0)
0014dc 93e0 0972 	STS  __FF_error,R30
                 ;    3734 		_FF_DIR_ADDR = addr_temp;
0014de 85ec
0014df 85fd
0014e0 856e
0014e1 857f      	__GETD1S 12
0014e2 93e0 095c 	STS  __FF_DIR_ADDR,R30
0014e4 93f0 095d 	STS  __FF_DIR_ADDR+1,R31
0014e6 9360 095e 	STS  __FF_DIR_ADDR+2,R22
0014e8 9370 095f 	STS  __FF_DIR_ADDR+3,R23
                 ;    3735 		return(rp);
0014ea 81ee      	LDD  R30,Y+6
0014eb 81ff      	LDD  R31,Y+6+1
0014ec c0ff      	RJMP _0x4CC
                 ;    3736 	}
                 ;    3737 	else
                 _0x299:
                 ;    3738 	{                          		
                 ;    3739 		_FF_error = FILE_ERR;
0014ed e0e2      	LDI  R30,LOW(2)
0014ee 93e0 0972 	STS  __FF_error,R30
                 ;    3740 		free(rp);
0014f0 940e 26c5 	CALL SUBOPT_0x6C
                 ;    3741 		_FF_DIR_ADDR = addr_temp;
                 ;    3742 		return(0);
0014f2 c0f9      	RJMP _0x4CC
                 ;    3743 	}
                 ;    3744 }
                 ;    3745 
                 ;    3746 #ifndef _READ_ONLY_
                 ;    3747 // Create a file
                 ;    3748 FILE *fcreatec(unsigned char flash *NAMEC, unsigned char MODE)
                 ;    3749 {
                 _fcreatec:
                 ;    3750 	unsigned char sd_temp[12];
                 ;    3751 	int c;
                 ;    3752 
                 ;    3753 	for (c=0; c<12; c++)
0014f3 972c      	SBIW R28,12
0014f4 931a      	ST   -Y,R17
0014f5 930a      	ST   -Y,R16
                 ;	*NAMEC -> Y+15
                 ;	MODE -> Y+14
                 ;	sd_temp -> Y+2
                 ;	c -> R16,R17
0014f6 e000
0014f7 e010      	__GETWRN 16,17,0
                 _0x2B7:
0014f8 300c
0014f9 e0e0
0014fa 071e      	__CPWRN 16,17,12
0014fb f464      	BRGE _0x2B8
                 ;    3754 		sd_temp[c] = NAMEC[c];
0014fc 01f8      	MOVW R30,R16
0014fd 01de      	MOVW R26,R28
0014fe 9612      	ADIW R26,2
0014ff 940e 272f 	CALL SUBOPT_0x7C
001501 85af      	LDD  R26,Y+15
001502 89b8      	LDD  R27,Y+15+1
001503 940e 2653 	CALL SUBOPT_0x65
                 ;    3755 	
                 ;    3756 	return (fcreate(sd_temp, MODE));
001505 5f0f
001506 4f1f      	__ADDWRN 16,17,1
001507 cff0      	RJMP _0x2B7
                 _0x2B8:
001508 01fe      	MOVW R30,R28
001509 9632      	ADIW R30,2
00150a 93fa      	ST   -Y,R31
00150b 93ea      	ST   -Y,R30
00150c 89e8      	LDD  R30,Y+16
00150d 93ea      	ST   -Y,R30
00150e d004      	RCALL _fcreate
00150f 8119      	LDD  R17,Y+1
001510 8108      	LDD  R16,Y+0
001511 9661      	ADIW R28,17
001512 9508      	RET
                 ;    3757 }
                 ;    3758 
                 ;    3759 FILE *fcreate(unsigned char *NAME, unsigned char MODE)
                 ;    3760 {
                 _fcreate:
                 ;    3761 	unsigned char fpath[14];
                 ;    3762 	unsigned int c, s, calc_temp;
                 ;    3763 	unsigned char *sp, *qp;
                 ;    3764 	unsigned long addr_temp, path_addr_temp;
                 ;    3765 	FILE *temp_file_pntr;
                 ;    3766 
                 ;    3767     addr_temp = 0;	// save local dir addr
001513 940e 2659 	CALL SUBOPT_0x66
                 ;	*NAME -> Y+35
                 ;	MODE -> Y+34
                 ;	fpath -> Y+20
                 ;	c -> R16,R17
                 ;	s -> R18,R19
                 ;	calc_temp -> R20,R21
                 ;	*sp -> Y+18
                 ;	*qp -> Y+16
                 ;	addr_temp -> Y+12
                 ;	path_addr_temp -> Y+8
                 ;	*temp_file_pntr -> Y+6
                 ;    3768     
                 ;    3769     if (_FF_checkdir(NAME, &addr_temp, fpath))
001515 f031      	BREQ _0x2B9
                 ;    3770 	{
                 ;    3771 		_FF_error = PATH_ERR;
001516 e0ee      	LDI  R30,LOW(14)
001517 93e0 0972 	STS  __FF_error,R30
                 ;    3772 		_FF_DIR_ADDR = addr_temp;
001519 940e 2671 	CALL SUBOPT_0x67
                 ;    3773 		return (0);
00151b c0d0      	RJMP _0x4CC
                 ;    3774 	}
                 ;    3775 	if (fpath[0]==0)
                 _0x2B9:
00151c 89ec      	LDD  R30,Y+20
00151d 30e0      	CPI  R30,0
00151e f419      	BRNE _0x2BA
                 ;    3776 	{
                 ;    3777 		_FF_error = NAME_ERR; 
00151f 940e 2734 	CALL SUBOPT_0x7D
                 ;    3778 		_FF_DIR_ADDR = addr_temp;
                 ;    3779 		return (0);
001521 c0ca      	RJMP _0x4CC
                 ;    3780 	}
                 ;    3781     
                 ;    3782 	path_addr_temp = _FF_DIR_ADDR;
                 _0x2BA:
001522 940e 2680 	CALL SUBOPT_0x68
                 ;    3783 	s = scan_directory(&path_addr_temp, fpath);
                 ;    3784 	if (path_addr_temp==0)
001524 85e8
001525 85f9
001526 856a
001527 857b      	__GETD1S 8
001528 940e 2aa4 	CALL __CPD10
00152a f431      	BRNE _0x2BB
                 ;    3785 	{
                 ;    3786 		_FF_error = NO_ENTRY_AVAL;
00152b e0ef      	LDI  R30,LOW(15)
00152c 93e0 0972 	STS  __FF_error,R30
                 ;    3787 		_FF_DIR_ADDR = addr_temp;
00152e 940e 2671 	CALL SUBOPT_0x67
                 ;    3788 		return (0);
001530 c0bb      	RJMP _0x4CC
                 ;    3789 	}
                 ;    3790 
                 ;    3791 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 _0x2BB:
001531 940e 269c 	CALL SUBOPT_0x6A
                 ;    3792 	path_addr_temp -= calc_temp;
                 ;    3793 	if (_FF_read(path_addr_temp)==0)	
001533 f431      	BRNE _0x2BC
                 ;    3794 	{
                 ;    3795 		_FF_error = READ_ERR;
001534 e0e4      	LDI  R30,LOW(4)
001535 93e0 0972 	STS  __FF_error,R30
                 ;    3796 		_FF_DIR_ADDR = addr_temp;
001537 940e 2671 	CALL SUBOPT_0x67
                 ;    3797 		return (0);
001539 c0b2      	RJMP _0x4CC
                 ;    3798 	}
                 ;    3799 
                 ;    3800 	// Get the filename into a form we can use to compare
                 ;    3801 	qp = file_name_conversion(fpath);
                 _0x2BC:
00153a 940e 26bb 	CALL SUBOPT_0x6B
                 ;    3802 	if (qp==0)
00153c f419      	BRNE _0x2BD
                 ;    3803 	{
                 ;    3804 		_FF_error = NAME_ERR; 
00153d 940e 2734 	CALL SUBOPT_0x7D
                 ;    3805 		_FF_DIR_ADDR = addr_temp;
                 ;    3806 		return (0);
00153f c0ac      	RJMP _0x4CC
                 ;    3807 	}
                 ;    3808 	sp = &_FF_buff[calc_temp];
                 _0x2BD:
001540 940e 26cb 	CALL SUBOPT_0x6D
                 ;    3809 	
                 ;    3810 	if (s)
001542 f071      	BREQ _0x2BE
                 ;    3811 	{
                 ;    3812 		if ((_FF_buff[calc_temp+0x0B]&0x1)==1)	// is file read only
001543 01fa      	MOVW R30,R20
001544 5ce6
001545 4ff8      	__ADDW1MN __FF_buff,11
001546 81e0      	LD   R30,Z
001547 70e1      	ANDI R30,LOW(0x1)
001548 30e1      	CPI  R30,LOW(0x1)
001549 f431      	BRNE _0x2BF
                 ;    3813 		{
                 ;    3814 			_FF_error = READONLY_ERR;
00154a e0e6      	LDI  R30,LOW(6)
00154b 93e0 0972 	STS  __FF_error,R30
                 ;    3815 			_FF_DIR_ADDR = addr_temp;
00154d 940e 2671 	CALL SUBOPT_0x67
                 ;    3816 			return (0);
00154f c09c      	RJMP _0x4CC
                 ;    3817 		}
                 ;    3818 	}
                 _0x2BF:
                 ;    3819 	else
001550 c058      	RJMP _0x2C0
                 _0x2BE:
                 ;    3820 	{
                 ;    3821 		for (c=0; c<11; c++)	// Write Filename
001551 e000
001552 e010      	__GETWRN 16,17,0
                 _0x2C2:
001553 300b
001554 e0e0
001555 071e      	__CPWRN 16,17,11
001556 f470      	BRSH _0x2C3
                 ;    3822 			*sp++ = *qp++;
001557 940e 2738 	CALL SUBOPT_0x7E
001559 9731      	SBIW R30,1
00155a 010f      	MOVW R0,R30
00155b 89a8      	LDD  R26,Y+16
00155c 89b9      	LDD  R27,Y+16+1
00155d 91ed      	LD   R30,X+
00155e 8ba8      	STD  Y+16,R26
00155f 8bb9      	STD  Y+16+1,R27
001560 01d0      	MOVW R26,R0
001561 93ec      	ST   X,R30
                 ;    3823 		*sp = 0x20;				// Attribute bit auto set to "ARCHIVE"
001562 5f0f
001563 4f1f      	__ADDWRN 16,17,1
001564 cfee      	RJMP _0x2C2
                 _0x2C3:
001565 89aa      	LDD  R26,Y+18
001566 89bb      	LDD  R27,Y+18+1
001567 e2e0      	LDI  R30,LOW(32)
001568 93ec      	ST   X,R30
                 ;    3824 		sp++;		
001569 940e 2738 	CALL SUBOPT_0x7E
                 ;    3825 		*sp++ = 0;				// Reserved for WinNT
00156b 940e 273e 	CALL SUBOPT_0x7F
                 ;    3826 		*sp++ = 0;				// Mili-second stamp for create
00156d 940e 273e 	CALL SUBOPT_0x7F
                 ;    3827 	
                 ;    3828 		#ifdef _RTC_ON_
                 ;    3829 			rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
                 ;    3830     	    calc_temp = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
                 ;    3831 			*sp++ = calc_temp&0x00FF;	// File create Time 
                 ;    3832 			*sp++ = (calc_temp&0xFF00) >> 8;
                 ;    3833 			calc_temp = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
                 ;    3834 			*sp++ = calc_temp&0x00FF;	// File create Date
                 ;    3835 			*sp++ = (calc_temp&0xFF00) >> 8;
                 ;    3836 		#else
                 ;    3837 			for (c=0; c<4; c++)
00156f e000
001570 e010      	__GETWRN 16,17,0
                 _0x2C5:
001571 3004
001572 e0e0
001573 071e      	__CPWRN 16,17,4
001574 f428      	BRSH _0x2C6
                 ;    3838 				*sp++ = 0;
001575 940e 273e 	CALL SUBOPT_0x7F
                 ;    3839 		#endif
                 ;    3840 
                 ;    3841 		*sp++ = 0;				// File access date (2 bytes)
001577 5f0f
001578 4f1f      	__ADDWRN 16,17,1
001579 cff7      	RJMP _0x2C5
                 _0x2C6:
00157a 940e 273e 	CALL SUBOPT_0x7F
                 ;    3842 		*sp++ = 0;
00157c 940e 273e 	CALL SUBOPT_0x7F
                 ;    3843 		*sp++ = 0;				// 0 for FAT12/16 (2 bytes)
00157e 940e 273e 	CALL SUBOPT_0x7F
                 ;    3844 		*sp++ = 0;
001580 940e 273e 	CALL SUBOPT_0x7F
                 ;    3845 		for (c=0; c<4; c++)		// Modify time/date
001582 e000
001583 e010      	__GETWRN 16,17,0
                 _0x2C8:
001584 3004
001585 e0e0
001586 071e      	__CPWRN 16,17,4
001587 f428      	BRSH _0x2C9
                 ;    3846 			*sp++ = 0;
001588 940e 273e 	CALL SUBOPT_0x7F
                 ;    3847 		*sp++ = 0;				// Starting cluster (2 bytes)
00158a 5f0f
00158b 4f1f      	__ADDWRN 16,17,1
00158c cff7      	RJMP _0x2C8
                 _0x2C9:
00158d 940e 273e 	CALL SUBOPT_0x7F
                 ;    3848 		*sp++ = 0;
00158f 940e 273e 	CALL SUBOPT_0x7F
                 ;    3849 		for (c=0; c<4; c++)
001591 e000
001592 e010      	__GETWRN 16,17,0
                 _0x2CB:
001593 3004
001594 e0e0
001595 071e      	__CPWRN 16,17,4
001596 f428      	BRSH _0x2CC
                 ;    3850 			*sp++ = 0;			// File length (0 for new)
001597 940e 273e 	CALL SUBOPT_0x7F
                 ;    3851 	
                 ;    3852 		if (_FF_write(path_addr_temp)==0)
001599 5f0f
00159a 4f1f      	__ADDWRN 16,17,1
00159b cff7      	RJMP _0x2CB
                 _0x2CC:
00159c 85e8
00159d 85f9
00159e 856a
00159f 857b      	__GETD1S 8
0015a0 940e 25f6 	CALL SUBOPT_0x59
0015a2 f431      	BRNE _0x2CD
                 ;    3853 		{
                 ;    3854 			_FF_error = WRITE_ERR;
0015a3 e0e3      	LDI  R30,LOW(3)
0015a4 93e0 0972 	STS  __FF_error,R30
                 ;    3855 			_FF_DIR_ADDR = addr_temp;
0015a6 940e 2671 	CALL SUBOPT_0x67
                 ;    3856 			return (0);				
0015a8 c043      	RJMP _0x4CC
                 ;    3857 		}
                 ;    3858 	}
                 _0x2CD:
                 _0x2C0:
                 ;    3859 	_FF_DIR_ADDR = addr_temp;
0015a9 85ec
0015aa 85fd
0015ab 856e
0015ac 857f      	__GETD1S 12
0015ad 93e0 095c 	STS  __FF_DIR_ADDR,R30
0015af 93f0 095d 	STS  __FF_DIR_ADDR+1,R31
0015b1 9360 095e 	STS  __FF_DIR_ADDR+2,R22
0015b3 9370 095f 	STS  __FF_DIR_ADDR+3,R23
                 ;    3860 	temp_file_pntr = fopen(NAME, WRITE);
0015b5 a1eb      	LDD  R30,Y+35
0015b6 a1fc      	LDD  R31,Y+35+1
0015b7 940e 2333 	CALL SUBOPT_0x7
0015b9 940e 136d 	CALL _fopen
0015bb 940e 2698 	CALL SUBOPT_0x69
                 ;    3861 	if (temp_file_pntr == 0)	// Will file open
0015bd f419      	BRNE _0x2CE
                 ;    3862 		return (0);				
0015be e0e0      	LDI  R30,LOW(0)
0015bf e0f0      	LDI  R31,HIGH(0)
0015c0 c02b      	RJMP _0x4CC
                 ;    3863 	if (MODE)
                 _0x2CE:
0015c1 a1ea      	LDD  R30,Y+34
0015c2 30e0      	CPI  R30,0
0015c3 f119      	BREQ _0x2CF
                 ;    3864 	{
                 ;    3865 		if (_FF_read(addr_temp)==0)
0015c4 85ec
0015c5 85fd
0015c6 856e
0015c7 857f      	__GETD1S 12
0015c8 940e 2488 	CALL SUBOPT_0x34
0015ca f431      	BRNE _0x2D0
                 ;    3866 		{
                 ;    3867 			_FF_error = READ_ERR;
0015cb e0e4      	LDI  R30,LOW(4)
0015cc 93e0 0972 	STS  __FF_error,R30
                 ;    3868 			return (0);
0015ce e0e0      	LDI  R30,LOW(0)
0015cf e0f0      	LDI  R31,HIGH(0)
0015d0 c01b      	RJMP _0x4CC
                 ;    3869 		}
                 ;    3870 		_FF_buff[calc_temp+12] |= MODE;		
                 _0x2D0:
0015d1 01fa      	MOVW R30,R20
0015d2 5ce5
0015d3 4ff8      	__ADDW1MN __FF_buff,12
0015d4 010f      	MOVW R0,R30
0015d5 81e0      	LD   R30,Z
0015d6 a1aa      	LDD  R26,Y+34
0015d7 2bea      	OR   R30,R26
0015d8 01d0      	MOVW R26,R0
0015d9 93ec      	ST   X,R30
                 ;    3871 		if (_FF_write(addr_temp)==0)
0015da 85ec
0015db 85fd
0015dc 856e
0015dd 857f      	__GETD1S 12
0015de 940e 25f6 	CALL SUBOPT_0x59
0015e0 f431      	BRNE _0x2D1
                 ;    3872 		{
                 ;    3873 			_FF_error = WRITE_ERR;
0015e1 e0e3      	LDI  R30,LOW(3)
0015e2 93e0 0972 	STS  __FF_error,R30
                 ;    3874 			return (0);
0015e4 e0e0      	LDI  R30,LOW(0)
0015e5 e0f0      	LDI  R31,HIGH(0)
0015e6 c005      	RJMP _0x4CC
                 ;    3875 		}
                 ;    3876 	}
                 _0x2D1:
                 ;    3877 	_FF_error = NO_ERR;
                 _0x2CF:
0015e7 e0e0      	LDI  R30,LOW(0)
0015e8 93e0 0972 	STS  __FF_error,R30
                 ;    3878 	return (temp_file_pntr);
0015ea 81ee      	LDD  R30,Y+6
0015eb 81ff      	LDD  R31,Y+6+1
                 _0x4CC:
0015ec 940e 2ac3 	CALL __LOADLOCR6
0015ee 96a5      	ADIW R28,37
0015ef 9508      	RET
                 ;    3879 }
                 ;    3880 #endif
                 ;    3881 
                 ;    3882 #ifndef _READ_ONLY_
                 ;    3883 // Open a file, name stored in string fileopen
                 ;    3884 int removec(unsigned char flash *NAMEC)
                 ;    3885 {
                 ;    3886 	int c;
                 ;    3887 	unsigned char sd_temp[12];
                 ;    3888 	
                 ;    3889 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+14
                 ;	c -> R16,R17
                 ;	sd_temp -> Y+2
                 ;    3890 		sd_temp[c] = NAMEC[c];
                 ;    3891 	
                 ;    3892 	c = remove(sd_temp);
                 ;    3893 	return (c);
                 ;    3894 }
                 ;    3895 
                 ;    3896 // Remove a file from the root directory
                 ;    3897 int remove(unsigned char *NAME)
                 ;    3898 {
                 ;    3899 	unsigned char fpath[14];
                 ;    3900 	unsigned int s, calc_temp;
                 ;    3901 	unsigned long addr_temp, path_addr_temp;
                 ;    3902 	
                 ;    3903 	#ifndef _SECOND_FAT_ON_
                 ;    3904 		clear_second_FAT();
                 ;    3905     #endif
                 ;    3906     
                 ;    3907     addr_temp = 0;	// save local dir addr
                 ;	*NAME -> Y+26
                 ;	fpath -> Y+12
                 ;	s -> R16,R17
                 ;	calc_temp -> R18,R19
                 ;	addr_temp -> Y+8
                 ;	path_addr_temp -> Y+4
                 ;    3908     
                 ;    3909     if (_FF_checkdir(NAME, &addr_temp, fpath))
                 ;    3910 	{
                 ;    3911 		_FF_error = PATH_ERR;
                 ;    3912 		_FF_DIR_ADDR = addr_temp;
                 ;    3913 		return (EOF);
                 ;    3914 	}
                 ;    3915 	if (fpath[0]==0)
                 ;    3916 	{
                 ;    3917 		_FF_error = NAME_ERR; 
                 ;    3918 		_FF_DIR_ADDR = addr_temp;
                 ;    3919 		return (EOF);
                 ;    3920 	}
                 ;    3921     
                 ;    3922 	path_addr_temp = _FF_DIR_ADDR;
                 ;    3923 	s = scan_directory(&path_addr_temp, fpath);
                 ;    3924 	if ((path_addr_temp==0) || (s==0))
                 ;    3925 	{
                 ;    3926 		_FF_error = NO_ENTRY_AVAL;
                 ;    3927 		_FF_DIR_ADDR = addr_temp;
                 ;    3928 		return (EOF);
                 ;    3929 	}
                 ;    3930 	_FF_DIR_ADDR = addr_temp;		// Reset current dir
                 ;    3931 
                 ;    3932 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    3933 	path_addr_temp -= calc_temp;
                 ;    3934 	if (_FF_read(path_addr_temp)==0)	
                 ;    3935 	{
                 ;    3936 		_FF_error = READ_ERR;
                 ;    3937 		return (EOF);
                 ;    3938 	}
                 ;    3939 	
                 ;    3940 	// Erase entry (put 0xE5 into start of the filename
                 ;    3941 	_FF_buff[calc_temp] = 0xE5;
                 ;    3942 	if (_FF_write(path_addr_temp)==0)
                 ;    3943 	{
                 ;    3944 		_FF_error = WRITE_ERR;
                 ;    3945 		return (EOF);
                 ;    3946 	}
                 ;    3947 	// Save Starting Cluster
                 ;    3948 	calc_temp = ((int) _FF_buff[calc_temp+0x1B] << 8) | (int) _FF_buff[calc_temp+0x1A];
                 ;    3949 	// Destroy cluster chain
                 ;    3950 	if (calc_temp)
                 ;    3951 		if (erase_clus_chain(calc_temp) == 0)
                 ;    3952 			return (EOF);
                 ;    3953 			
                 ;    3954 	return (1);
                 ;    3955 }
                 ;    3956 #endif
                 ;    3957 
                 ;    3958 #ifndef _READ_ONLY_
                 ;    3959 // Rename a file in the Root Directory
                 ;    3960 int rename(unsigned char *NAME_OLD, unsigned char *NAME_NEW)
                 ;    3961 {
                 ;    3962 	unsigned char c;
                 ;    3963 	unsigned int calc_temp;
                 ;    3964 	unsigned long addr_temp, path_addr_temp;
                 ;    3965 	unsigned char *sp, *qp;
                 ;    3966 	unsigned char fpath[14];
                 ;    3967 
                 ;    3968 	// Get the filename into a form we can use to compare
                 ;    3969 	qp = file_name_conversion(NAME_NEW);
                 ;	*NAME_OLD -> Y+31
                 ;	*NAME_NEW -> Y+29
                 ;	c -> R16
                 ;	calc_temp -> R17,R18
                 ;	addr_temp -> Y+25
                 ;	path_addr_temp -> Y+21
                 ;	*sp -> R19,R20
                 ;	*qp -> Y+19
                 ;	fpath -> Y+5
                 ;    3970 	if (qp==0)
                 ;    3971 	{
                 ;    3972 		_FF_error = NAME_ERR;
                 ;    3973 		return (EOF);
                 ;    3974 	}
                 ;    3975 	
                 ;    3976     addr_temp = 0;	// save local dir addr
                 ;    3977     
                 ;    3978     if (_FF_checkdir(NAME_OLD, &addr_temp, fpath))
                 ;    3979 	{
                 ;    3980 		_FF_error = PATH_ERR;
                 ;    3981 		_FF_DIR_ADDR = addr_temp;
                 ;    3982 		return (EOF);
                 ;    3983 	}
                 ;    3984 	if (fpath[0]==0)
                 ;    3985 	{
                 ;    3986 		_FF_error = NAME_ERR; 
                 ;    3987 		_FF_DIR_ADDR = addr_temp;
                 ;    3988 		return (EOF);
                 ;    3989 	}
                 ;    3990 
                 ;    3991 	path_addr_temp = _FF_DIR_ADDR;
                 ;    3992 	calc_temp = scan_directory(&path_addr_temp, NAME_NEW);
                 ;    3993 	if (calc_temp)
                 ;    3994 	{	// does new name alread exist?
                 ;    3995 		_FF_DIR_ADDR = addr_temp;
                 ;    3996 		_FF_error = EXIST_ERR;
                 ;    3997 		return (EOF);
                 ;    3998 	}
                 ;    3999 
                 ;    4000 	path_addr_temp = _FF_DIR_ADDR;
                 ;    4001 	calc_temp = scan_directory(&path_addr_temp, fpath);
                 ;    4002 	if ((path_addr_temp==0) || (calc_temp==0))
                 ;    4003 	{
                 ;    4004 		_FF_DIR_ADDR = addr_temp;
                 ;    4005 		_FF_error = EXIST_ERR;
                 ;    4006 		return (EOF);
                 ;    4007 	}
                 ;    4008 
                 ;    4009 
                 ;    4010 	_FF_DIR_ADDR = addr_temp;		// Reset current dir
                 ;    4011 
                 ;    4012 	calc_temp = path_addr_temp % BPB_BytsPerSec;
                 ;    4013 	path_addr_temp -= calc_temp;
                 ;    4014 	if (_FF_read(path_addr_temp)==0)	
                 ;    4015 	{
                 ;    4016 		_FF_error = READ_ERR;
                 ;    4017 		return (EOF);
                 ;    4018 	}
                 ;    4019 	
                 ;    4020 	// Rename entry
                 ;    4021 	sp = &_FF_buff[calc_temp];
                 ;    4022 	for (c=0; c<11; c++)
                 ;    4023 		*sp++ = *qp++;
                 ;    4024 	if (_FF_write(path_addr_temp)==0)
                 ;    4025 		return (EOF);
                 ;    4026 
                 ;    4027 	return(0);
                 ;    4028 }
                 ;    4029 #endif
                 ;    4030 
                 ;    4031 #ifndef _READ_ONLY_
                 ;    4032 // Save Contents of file, w/o closing
                 ;    4033 int fflush(FILE *rp)	
                 ;    4034 {
                 _fflush:
                 ;    4035 	unsigned int  n;
                 ;    4036 	unsigned long addr_temp;
                 ;    4037 	
                 ;    4038 	if ((rp==NULL) || (rp->mode==READ))
0015f0 940e 2747 	CALL SUBOPT_0x80
                 ;	*rp -> Y+6
                 ;	n -> R16,R17
                 ;	addr_temp -> Y+2
0015f2 81ae      	LDD  R26,Y+6
0015f3 81bf      	LDD  R27,Y+6+1
0015f4 940e 2aa8 	CALL __CPW02
0015f6 f021      	BREQ _0x2EB
0015f7 940e 274b 	CALL SUBOPT_0x81
0015f9 30a1      	CPI  R26,LOW(0x1)
0015fa f419      	BRNE _0x2EA
                 _0x2EB:
                 ;    4039 		return (EOF);
0015fb efef      	LDI  R30,LOW(65535)
0015fc efff      	LDI  R31,HIGH(65535)
0015fd c03a      	RJMP _0x4CB
                 ;    4040 	
                 ;    4041 	if ((rp->mode==WRITE) || (rp->mode==APPEND))
                 _0x2EA:
0015fe 940e 274b 	CALL SUBOPT_0x81
001600 30a2      	CPI  R26,LOW(0x2)
001601 f021      	BREQ _0x2EE
001602 940e 274b 	CALL SUBOPT_0x81
001604 30a3      	CPI  R26,LOW(0x3)
001605 f581      	BRNE _0x2ED
                 _0x2EE:
                 ;    4042 	{
                 ;    4043 		addr_temp = (clust_to_addr(rp->clus_current) + ((rp->sec_offset-1)*BPB_BytsPerSec));
001606 940e 2712 	CALL SUBOPT_0x77
001608 940e 0da9 	CALL _clust_to_addr
00160a 937f      	PUSH R23
00160b 936f      	PUSH R22
00160c 93ff      	PUSH R31
00160d 93ef      	PUSH R30
00160e 940e 2751 	CALL SUBOPT_0x82
001610 91af      	POP  R26
001611 91bf      	POP  R27
001612 918f      	POP  R24
001613 919f      	POP  R25
001614 940e 275e 	CALL SUBOPT_0x83
                 ;    4044 		for (n=0; n<BPB_BytsPerSec; n++)	// Save file buffer to SD buffer
001616 e000
001617 e010      	__GETWRN 16,17,0
                 _0x2F1:
001618 91e0 0935 	LDS  R30,_BPB_BytsPerSec
00161a 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
00161c 170e      	CP   R16,R30
00161d 071f      	CPC  R17,R31
00161e f438      	BRSH _0x2F2
                 ;    4045 			_FF_buff[n] = rp->buff[n];
00161f 940e 2767 	CALL SUBOPT_0x84
001621 81e0      	LD   R30,Z
001622 93ec      	ST   X,R30
                 ;    4046 		if (_FF_write(addr_temp)==0)	// Write SD buffer to disk
001623 5f0f
001624 4f1f      	__ADDWRN 16,17,1
001625 cff2      	RJMP _0x2F1
                 _0x2F2:
001626 81ea
001627 81fb
001628 816c
001629 817d      	__GETD1S 2
00162a 940e 25f6 	CALL SUBOPT_0x59
00162c f419      	BRNE _0x2F3
                 ;    4047 			return (EOF);
00162d efef      	LDI  R30,LOW(65535)
00162e efff      	LDI  R31,HIGH(65535)
00162f c008      	RJMP _0x4CB
                 ;    4048 		if (append_toc(rp)==0)	// Update Entry or Error
                 _0x2F3:
001630 940e 276b 	CALL SUBOPT_0x85
001632 f419      	BRNE _0x2F4
                 ;    4049 			return (EOF);
001633 efef      	LDI  R30,LOW(65535)
001634 efff      	LDI  R31,HIGH(65535)
001635 c002      	RJMP _0x4CB
                 ;    4050 	}
                 _0x2F4:
                 ;    4051 	
                 ;    4052 	return (0);
                 _0x2ED:
001636 e0e0      	LDI  R30,LOW(0)
001637 e0f0      	LDI  R31,HIGH(0)
                 _0x4CB:
001638 8119      	LDD  R17,Y+1
001639 8108      	LDD  R16,Y+0
00163a 9628      	ADIW R28,8
00163b 9508      	RET
                 ;    4053 }
                 ;    4054 #endif		
                 ;    4055 
                 ;    4056 
                 ;    4057 // Close an open file
                 ;    4058 int fclose(FILE *rp)	
                 ;    4059 {
                 _fclose:
                 ;    4060 	#ifndef _READ_ONLY_
                 ;    4061 	if (rp->mode!=READ)
00163c 81a8      	LD   R26,Y
00163d 81b9      	LDD  R27,Y+1
00163e 940e 2773 	CALL SUBOPT_0x86
001640 f069      	BREQ _0x2F5
                 ;    4062 		if (fflush(rp)==EOF)
001641 81e8      	LD   R30,Y
001642 81f9      	LDD  R31,Y+1
001643 93fa      	ST   -Y,R31
001644 93ea      	ST   -Y,R30
001645 940e 15f0 	CALL _fflush
001647 3fef      	CPI  R30,LOW(0xFFFF)
001648 efaf      	LDI  R26,HIGH(0xFFFF)
001649 07fa      	CPC  R31,R26
00164a f419      	BRNE _0x2F6
                 ;    4063 			return (EOF);
00164b efef      	LDI  R30,LOW(65535)
00164c efff      	LDI  R31,HIGH(65535)
00164d c45a      	RJMP _0x4C7
                 ;    4064 	#endif	
                 ;    4065 	// Clear File Structure
                 ;    4066 	free(rp);
                 _0x2F6:
                 _0x2F5:
00164e 81e8      	LD   R30,Y
00164f 81f9      	LDD  R31,Y+1
001650 93fa      	ST   -Y,R31
001651 93ea      	ST   -Y,R30
001652 940e 2304 	CALL _free
                 ;    4067 	rp = 0;
001654 e0e0      	LDI  R30,0
001655 83e8      	STD  Y+0,R30
001656 83e9      	STD  Y+0+1,R30
                 ;    4068 	return(0);
001657 e0e0      	LDI  R30,LOW(0)
001658 e0f0      	LDI  R31,HIGH(0)
001659 c44e      	RJMP _0x4C7
                 ;    4069 }
                 ;    4070 
                 ;    4071 int ffreemem(FILE *rp)	
                 ;    4072 {
                 ;    4073 	// Clear File Structure
                 ;    4074 	if (rp==0)
                 ;    4075 		return (EOF);
                 ;    4076 	free(rp);
                 ;    4077 	return(0);
                 ;    4078 }
                 ;    4079 
                 ;    4080 int fget_file_infoc(unsigned char flash *NAMEC, unsigned long *F_SIZE, unsigned char *F_CREATE,
                 ;    4081 				unsigned char *F_MODIFY, unsigned char *F_ATTRIBUTE, unsigned int *F_CLUS_START)
                 ;    4082 {
                 ;    4083 	int c;
                 ;    4084 	unsigned char sd_temp[12];
                 ;    4085 	
                 ;    4086 	for (c=0; c<12; c++)
                 ;	*NAMEC -> Y+24
                 ;	*F_SIZE -> Y+22
                 ;	*F_CREATE -> Y+20
                 ;	*F_MODIFY -> Y+18
                 ;	*F_ATTRIBUTE -> Y+16
                 ;	*F_CLUS_START -> Y+14
                 ;	c -> R16,R17
                 ;	sd_temp -> Y+2
                 ;    4087 		sd_temp[c] = NAMEC[c];
                 ;    4088 	
                 ;    4089 	c = fget_file_info(sd_temp, F_SIZE, F_CREATE, F_MODIFY, F_ATTRIBUTE, F_CLUS_START);
                 ;    4090 	return (c);
                 ;    4091 }
                 ;    4092 
                 ;    4093 int fget_file_info(unsigned char *NAME, unsigned long *F_SIZE, unsigned char *F_CREATE,
                 ;    4094 				unsigned char *F_MODIFY, unsigned char *F_ATTRIBUTE, unsigned int *F_CLUS_START)
                 ;    4095 {
                 ;    4096 	unsigned char n;
                 ;    4097 	unsigned int s, calc_temp;
                 ;    4098 	unsigned long addr_temp, file_calc_temp;
                 ;    4099 	unsigned char *sp, *qp;
                 ;    4100 	
                 ;    4101 	// Get the filename into a form we can use to compare
                 ;    4102 	qp = file_name_conversion(NAME);
                 ;	*NAME -> Y+27
                 ;	*F_SIZE -> Y+25
                 ;	*F_CREATE -> Y+23
                 ;	*F_MODIFY -> Y+21
                 ;	*F_ATTRIBUTE -> Y+19
                 ;	*F_CLUS_START -> Y+17
                 ;	n -> R16
                 ;	s -> R17,R18
                 ;	calc_temp -> R19,R20
                 ;	addr_temp -> Y+13
                 ;	file_calc_temp -> Y+9
                 ;	*sp -> Y+7
                 ;	*qp -> Y+5
                 ;    4103 	if (qp==0)
                 ;    4104 	{
                 ;    4105 		_FF_error = NAME_ERR;
                 ;    4106 		return (EOF);
                 ;    4107 	}
                 ;    4108 	
                 ;    4109 	for (s=0; s<BPB_BytsPerSec; s++)
                 ;    4110 	{	// Scan through directory entries to find file
                 ;    4111 		addr_temp = _FF_DIR_ADDR + (0x200 * s);
                 ;    4112 		if (_FF_read(addr_temp)==0)
                 ;    4113 			return (EOF);
                 ;    4114 		for (n=0; n<16; n++)
                 ;    4115 		{
                 ;    4116 			calc_temp = (int) n * 0x20;
                 ;    4117 			qp = &FILENAME[0];
                 ;    4118 			sp = &_FF_buff[calc_temp];
                 ;    4119 			if (*sp == 0)
                 ;    4120 				return (EOF);
                 ;    4121 			if (strncmp(qp, sp, 11)==0)		// Does this entry == Filename
                 ;    4122 			{
                 ;    4123 				*F_ATTRIBUTE = _FF_buff[calc_temp+11];	// Save ATTRIBUTE Byte to location
                 ;    4124 				*F_SIZE = ((long) _FF_buff[calc_temp+31] << 24) | ((long) _FF_buff[calc_temp+30] << 16)
                 ;    4125 							| ((long) _FF_buff[calc_temp+29] << 8) | ((long) _FF_buff[calc_temp+28]);
                 ;    4126 							// Save SIZE of file to location
                 ;    4127                 *F_CLUS_START = ((unsigned int) _FF_buff[calc_temp+27] << 8) | ((unsigned int) _FF_buff[calc_temp+26]);
                 ;    4128 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+17] << 8) | ((unsigned int) _FF_buff[calc_temp+16]);
                 ;    4129 				qp = F_CREATE;
                 ;    4130 				*qp++ = (((file_calc_temp >> 5) & 0x0F) / 10) + '0';
                 ;    4131 				*qp++ = (((file_calc_temp >> 5) & 0x0F) % 10) + '0';
                 ;    4132 				*qp++ = '/';
                 ;    4133 				*qp++ = ((file_calc_temp & 0x1F) / 10) + '0';
                 ;    4134 				*qp++ = ((file_calc_temp & 0x1F) % 10) + '0';
                 ;    4135 				*qp++ = '/';
                 ;    4136 				file_calc_temp = ((file_calc_temp >> 9) & 0x7F) + 1980;
                 ;    4137 				*qp++ = (file_calc_temp / 1000) + '0';
                 ;    4138 				file_calc_temp %= 1000;
                 ;    4139 				*qp++ = (file_calc_temp / 100) + '0';
                 ;    4140 				file_calc_temp %= 100;
                 ;    4141 				*qp++ = (file_calc_temp / 10) + '0';
                 ;    4142 				*qp++ = (file_calc_temp % 10) + '0';
                 ;    4143 				*qp++ = ' ';
                 ;    4144 				*qp++ = ' ';
                 ;    4145 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+15] << 8) | ((unsigned int) _FF_buff[calc_temp+14]);
                 ;    4146 				*qp++ = (((file_calc_temp >> 11) & 0x1F) / 10) + '0';
                 ;    4147 				*qp++ = (((file_calc_temp >> 11) & 0x1F) % 10) + '0';
                 ;    4148 				*qp++ = ':';
                 ;    4149 				*qp++ = (((file_calc_temp >> 5) & 0x3F) / 10) + '0';
                 ;    4150 				*qp++ = (((file_calc_temp >> 5) & 0x3F) % 10) + '0';
                 ;    4151 				*qp++ = ':';
                 ;    4152 				*qp++ = (((file_calc_temp & 0x1F) * 2) / 10) + '0';
                 ;    4153 				*qp++ = (((file_calc_temp & 0x1F) * 2) % 10) + '0';
                 ;    4154 				*qp = 0;
                 ;    4155 				
                 ;    4156 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+25] << 8) | ((unsigned int) _FF_buff[calc_temp+24]);
                 ;    4157 				qp = F_MODIFY;
                 ;    4158 				*qp++ = (((file_calc_temp >> 5) & 0x0F) / 10) + '0';
                 ;    4159 				*qp++ = (((file_calc_temp >> 5) & 0x0F) % 10) + '0';
                 ;    4160 				*qp++ = '/';
                 ;    4161 				*qp++ = ((file_calc_temp & 0x1F) / 10) + '0';
                 ;    4162 				*qp++ = ((file_calc_temp & 0x1F) % 10) + '0';
                 ;    4163 				*qp++ = '/';
                 ;    4164 				file_calc_temp = ((file_calc_temp >> 9) & 0x7F) + 1980;
                 ;    4165 				*qp++ = (file_calc_temp / 1000) + '0';
                 ;    4166 				file_calc_temp %= 1000;
                 ;    4167 				*qp++ = (file_calc_temp / 100) + '0';
                 ;    4168 				file_calc_temp %= 100;
                 ;    4169 				*qp++ = (file_calc_temp / 10) + '0';
                 ;    4170 				*qp++ = (file_calc_temp % 10) + '0';
                 ;    4171 				*qp++ = ' ';
                 ;    4172 				*qp++ = ' ';
                 ;    4173 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+23] << 8) | ((unsigned int) _FF_buff[calc_temp+22]);
                 ;    4174 				*qp++ = (((file_calc_temp >> 11) & 0x1F) / 10) + '0';
                 ;    4175 				*qp++ = (((file_calc_temp >> 11) & 0x1F) % 10) + '0';
                 ;    4176 				*qp++ = ':';
                 ;    4177 				*qp++ = (((file_calc_temp >> 5) & 0x3F) / 10) + '0';
                 ;    4178 				*qp++ = (((file_calc_temp >> 5) & 0x3F) % 10) + '0';
                 ;    4179 				*qp++ = ':';
                 ;    4180 				*qp++ = (((file_calc_temp & 0x1F) * 2) / 10) + '0';
                 ;    4181 				*qp++ = (((file_calc_temp & 0x1F) * 2) % 10) + '0';
                 ;    4182 				*qp = 0;
                 ;    4183 				
                 ;    4184 				return (0);
                 ;    4185 			}
                 ;    4186 		}                          		
                 ;    4187 	}
                 ;    4188 	_FF_error = FILE_ERR;
                 ;    4189 	return(EOF);
                 ;    4190 }
                 ;    4191 
                 ;    4192 // Get File data and increment file pointer
                 ;    4193 int fgetc(FILE *rp)
                 ;    4194 {
                 _fgetc:
                 ;    4195 	unsigned char get_data;
                 ;    4196 	unsigned int n;
                 ;    4197 	unsigned long addr_temp;
                 ;    4198 	
                 ;    4199 	if (rp==NULL)
00165a 9724      	SBIW R28,4
00165b 940e 2abf 	CALL __SAVELOCR3
                 ;	*rp -> Y+7
                 ;	get_data -> R16
                 ;	n -> R17,R18
                 ;	addr_temp -> Y+3
00165d 81ef      	LDD  R30,Y+7
00165e 85f8      	LDD  R31,Y+7+1
00165f 9730      	SBIW R30,0
001660 f419      	BRNE _0x305
                 ;    4200 		return (EOF);
001661 efef      	LDI  R30,LOW(65535)
001662 efff      	LDI  R31,HIGH(65535)
001663 c0f8      	RJMP _0x4CA
                 ;    4201 
                 ;    4202 	if (rp->position == rp->length)
                 _0x305:
001664 940e 2778 	CALL SUBOPT_0x87
001666 937f      	PUSH R23
001667 936f      	PUSH R22
001668 93ff      	PUSH R31
001669 93ef      	PUSH R30
00166a 81af      	LDD  R26,Y+7
00166b 85b8      	LDD  R27,Y+7+1
00166c 5ea4      	SUBI R26,LOW(-540)
00166d 4fbd      	SBCI R27,HIGH(-540)
00166e 940e 2a4e 	CALL __GETD1P
001670 91af      	POP  R26
001671 91bf      	POP  R27
001672 918f      	POP  R24
001673 919f      	POP  R25
001674 940e 2ab2 	CALL __CPD12
001676 f439      	BRNE _0x306
                 ;    4203 	{
                 ;    4204 		rp->error = POS_ERR;
001677 81af      	LDD  R26,Y+7
001678 85b8      	LDD  R27,Y+7+1
001679 940e 277f 	CALL SUBOPT_0x88
                 ;    4205 		return (EOF);
00167b efef      	LDI  R30,LOW(65535)
00167c efff      	LDI  R31,HIGH(65535)
00167d c0de      	RJMP _0x4CA
                 ;    4206 	}
                 ;    4207 	
                 ;    4208 	get_data = *rp->pntr;
                 _0x306:
00167e 940e 2784 	CALL SUBOPT_0x89
001680 8100      	LD   R16,Z
                 ;    4209 	
                 ;    4210 	if ((rp->pntr)==(&rp->buff[BPB_BytsPerSec-1]))
001681 81af      	LDD  R26,Y+7
001682 85b8      	LDD  R27,Y+7+1
001683 5da9      	SUBI R26,LOW(-551)
001684 4fbd      	SBCI R27,HIGH(-551)
001685 900d      	LD   R0,X+
001686 901c      	LD   R1,X
001687 81af      	LDD  R26,Y+7
001688 85b8      	LDD  R27,Y+7+1
001689 940e 278b 	CALL SUBOPT_0x8A
00168b f011      	BREQ PC+3
00168c 940c 1753 	JMP _0x307
                 ;    4211 	{	// Check to see if pointer is at the end of a sector
                 ;    4212 		#ifndef _READ_ONLY_
                 ;    4213 		if ((rp->mode==WRITE) || (rp->mode==APPEND))
00168e 940e 2796 	CALL SUBOPT_0x8B
001690 30a2      	CPI  R26,LOW(0x2)
001691 f021      	BREQ _0x309
001692 940e 2796 	CALL SUBOPT_0x8B
001694 30a3      	CPI  R26,LOW(0x3)
001695 f599      	BRNE _0x308
                 _0x309:
                 ;    4214 		{	// if in write or append mode, update the current sector before loading next
                 ;    4215 			for (n=0; n<BPB_BytsPerSec; n++)
001696 e010
001697 e020      	__GETWRN 17,18,0
                 _0x30C:
001698 91e0 0935 	LDS  R30,_BPB_BytsPerSec
00169a 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
00169c 171e      	CP   R17,R30
00169d 072f      	CPC  R18,R31
00169e f458      	BRSH _0x30D
                 ;    4216 				_FF_buff[n] = rp->buff[n];
00169f 2fa1
0016a0 2fb2      	__GETW2R 17,18
0016a1 5da1      	SUBI R26,LOW(-__FF_buff)
0016a2 4fb8      	SBCI R27,HIGH(-__FF_buff)
0016a3 940e 279c 	CALL SUBOPT_0x8C
0016a5 81e0      	LD   R30,Z
0016a6 93ec      	ST   X,R30
                 ;    4217 			addr_temp = clust_to_addr(rp->clus_current) + (((rp->sec_offset)-1)*BPB_BytsPerSec);
0016a7 5f1f
0016a8 4f2f      	__ADDWRN 17,18,1
0016a9 cfee      	RJMP _0x30C
                 _0x30D:
0016aa 940e 27a2 	CALL SUBOPT_0x8D
0016ac 937f      	PUSH R23
0016ad 936f      	PUSH R22
0016ae 93ff      	PUSH R31
0016af 93ef      	PUSH R30
0016b0 940e 27aa 	CALL SUBOPT_0x8E
0016b2 9731      	SBIW R30,1
0016b3 91a0 0935 	LDS  R26,_BPB_BytsPerSec
0016b5 91b0 0936 	LDS  R27,_BPB_BytsPerSec+1
0016b7 940e 29c5 	CALL __MULW12U
0016b9 91af      	POP  R26
0016ba 91bf      	POP  R27
0016bb 918f      	POP  R24
0016bc 919f      	POP  R25
0016bd 940e 27b0 	CALL SUBOPT_0x8F
                 ;    4218 			if (_FF_write(addr_temp)==0)
0016bf 81eb
0016c0 81fc
0016c1 816d
0016c2 817e      	__GETD1S 3
0016c3 940e 25f6 	CALL SUBOPT_0x59
0016c5 f419      	BRNE _0x30E
                 ;    4219 				return (EOF);
0016c6 efef      	LDI  R30,LOW(65535)
0016c7 efff      	LDI  R31,HIGH(65535)
0016c8 c093      	RJMP _0x4CA
                 ;    4220 		}
                 _0x30E:
                 ;    4221 		#endif
                 ;    4222 		if (rp->sec_offset < BPB_SecPerClus)
                 _0x308:
0016c9 81ef      	LDD  R30,Y+7
0016ca 85f8      	LDD  R31,Y+7+1
0016cb 940e 27b9 	CALL SUBOPT_0x90
0016cd f4d0      	BRSH _0x30F
                 ;    4223 		{	// Goto next sector if not at the end of a cluster
                 ;    4224 			addr_temp = clust_to_addr(rp->clus_current) + (rp->sec_offset*BPB_BytsPerSec);
0016ce 940e 27a2 	CALL SUBOPT_0x8D
0016d0 937f      	PUSH R23
0016d1 936f      	PUSH R22
0016d2 93ff      	PUSH R31
0016d3 93ef      	PUSH R30
0016d4 940e 27aa 	CALL SUBOPT_0x8E
0016d6 91a0 0935 	LDS  R26,_BPB_BytsPerSec
0016d8 91b0 0936 	LDS  R27,_BPB_BytsPerSec+1
0016da 940e 29c5 	CALL __MULW12U
0016dc 91af      	POP  R26
0016dd 91bf      	POP  R27
0016de 918f      	POP  R24
0016df 919f      	POP  R25
0016e0 940e 27b0 	CALL SUBOPT_0x8F
                 ;    4225 			rp->sec_offset++;
0016e2 940e 27aa 	CALL SUBOPT_0x8E
0016e4 9631      	ADIW R30,1
0016e5 93ed      	ST   X+,R30
0016e6 93fc      	ST   X,R31
                 ;    4226 		}
                 ;    4227 		else
0016e7 c042      	RJMP _0x310
                 _0x30F:
                 ;    4228 		{	// End of Cluster, find next
                 ;    4229 			if (rp->clus_next>=0xFFF8)	// No next cluster, EOF marker
0016e8 81ef      	LDD  R30,Y+7
0016e9 85f8      	LDD  R31,Y+7+1
0016ea 89a0      	LDD  R26,Z+16
0016eb 89b1      	LDD  R27,Z+17
0016ec 3fa8      	CPI  R26,LOW(0xFFF8)
0016ed efef      	LDI  R30,HIGH(0xFFF8)
0016ee 07be      	CPC  R27,R30
0016ef f048      	BRLO _0x311
                 ;    4230 			{
                 ;    4231 				rp->EOF_flag = 1;	// Set flag so Putchar knows to get new cluster
0016f0 81af      	LDD  R26,Y+7
0016f1 85b8      	LDD  R27,Y+7+1
0016f2 940e 27c1 	CALL SUBOPT_0x91
                 ;    4232 				rp->position++;		// Only time doing this, position + 1 should equal length
0016f4 940e 2778 	CALL SUBOPT_0x87
0016f6 940e 27c6 	CALL SUBOPT_0x92
                 ;    4233 				return(get_data);
0016f8 c063      	RJMP _0x4CA
                 ;    4234 			}
                 ;    4235 			addr_temp = clust_to_addr(rp->clus_next);
                 _0x311:
0016f9 81ef      	LDD  R30,Y+7
0016fa 85f8      	LDD  R31,Y+7+1
0016fb 89a0      	LDD  R26,Z+16
0016fc 89b1      	LDD  R27,Z+17
0016fd 93ba      	ST   -Y,R27
0016fe 93aa      	ST   -Y,R26
0016ff 940e 0da9 	CALL _clust_to_addr
001701 83eb
001702 83fc
001703 836d
001704 837e      	__PUTD1S 3
                 ;    4236 			rp->sec_offset = 1;
001705 81af      	LDD  R26,Y+7
001706 85b8      	LDD  R27,Y+7+1
001707 940e 27cf 	CALL SUBOPT_0x93
                 ;    4237 			rp->clus_prev = rp->clus_current;
001709 81af      	LDD  R26,Y+7
00170a 85b8      	LDD  R27,Y+7+1
00170b 961e      	ADIW R26,14
00170c 940e 2a4a 	CALL __GETW1P
00170e 81af
00170f 85b8
001710 9652
001711 93ed
001712 93fc      	__PUTW1SNS 7,18
                 ;    4238 			rp->clus_current = rp->clus_next;
001713 81af      	LDD  R26,Y+7
001714 85b8      	LDD  R27,Y+7+1
001715 9650      	ADIW R26,16
001716 940e 2a4a 	CALL __GETW1P
001718 81af
001719 85b8
00171a 961e
00171b 93ed
00171c 93fc      	__PUTW1SNS 7,14
                 ;    4239 			rp->clus_next = next_cluster(rp->clus_current, SINGLE);
00171d 81ef      	LDD  R30,Y+7
00171e 85f8      	LDD  R31,Y+7+1
00171f 85a6      	LDD  R26,Z+14
001720 85b7      	LDD  R27,Z+15
001721 93ba      	ST   -Y,R27
001722 93aa      	ST   -Y,R26
001723 940e 2719 	CALL SUBOPT_0x78
001725 81af
001726 85b8
001727 9650
001728 93ed
001729 93fc      	__PUTW1SNS 7,16
                 ;    4240 		}
                 _0x310:
                 ;    4241 		if (_FF_read(addr_temp)==0)
00172a 81eb
00172b 81fc
00172c 816d
00172d 817e      	__GETD1S 3
00172e 940e 2488 	CALL SUBOPT_0x34
001730 f419      	BRNE _0x312
                 ;    4242 			return (EOF);
001731 efef      	LDI  R30,LOW(65535)
001732 efff      	LDI  R31,HIGH(65535)
001733 c028      	RJMP _0x4CA
                 ;    4243 		for (n=0; n<BPB_BytsPerSec; n++)
                 _0x312:
001734 e010
001735 e020      	__GETWRN 17,18,0
                 _0x314:
001736 91e0 0935 	LDS  R30,_BPB_BytsPerSec
001738 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
00173a 171e      	CP   R17,R30
00173b 072f      	CPC  R18,R31
00173c f460      	BRSH _0x315
                 ;    4244 			rp->buff[n] = _FF_buff[n];
00173d 940e 279c 	CALL SUBOPT_0x8C
00173f 010f      	MOVW R0,R30
001740 e2af      	LDI  R26,LOW(__FF_buff)
001741 e0b7      	LDI  R27,HIGH(__FF_buff)
001742 0fa1      	ADD  R26,R17
001743 1fb2      	ADC  R27,R18
001744 940e 27d5 	CALL SUBOPT_0x94
                 ;    4245 		rp->pntr = &rp->buff[0];
001746 5f1f
001747 4f2f      	__ADDWRN 17,18,1
001748 cfed      	RJMP _0x314
                 _0x315:
001749 81ef      	LDD  R30,Y+7
00174a 85f8      	LDD  R31,Y+7+1
00174b 967c      	ADIW R30,28
00174c 81af
00174d 85b8
00174e 5da9
00174f 4fbd
001750 93ed
001751 93fc      	__PUTW1SN 7,551
                 ;    4246 	}
                 ;    4247 	else
001752 c005      	RJMP _0x316
                 _0x307:
                 ;    4248 		rp->pntr++;
001753 940e 2784 	CALL SUBOPT_0x89
001755 9631      	ADIW R30,1
001756 93ed      	ST   X+,R30
001757 93fc      	ST   X,R31
                 ;    4249 	
                 ;    4250 	rp->position++;	
                 _0x316:
001758 940e 2778 	CALL SUBOPT_0x87
00175a 940e 27c6 	CALL SUBOPT_0x92
                 ;    4251 	return(get_data);		
                 _0x4CA:
00175c 940e 2ac6 	CALL __LOADLOCR3
00175e 9629      	ADIW R28,9
00175f 9508      	RET
                 ;    4252 }
                 ;    4253 
                 ;    4254 char *fgets(char *buffer, int n, FILE *rp)
                 ;    4255 {
                 ;    4256 	int c, temp_data;
                 ;    4257 	
                 ;    4258 	for (c=0; c<n; c++)
                 ;	*buffer -> Y+8
                 ;	n -> Y+6
                 ;	*rp -> Y+4
                 ;	c -> R16,R17
                 ;	temp_data -> R18,R19
                 ;    4259 	{
                 ;    4260 		temp_data = fgetc(rp);
                 ;    4261 		*buffer = temp_data & 0xFF;
                 ;    4262 		if (temp_data == '\n')
                 ;    4263 			break;
                 ;    4264 		else if (temp_data == EOF)
                 ;    4265 			break;
                 ;    4266 		buffer++;
                 ;    4267 	}
                 ;    4268 	if (c==n)
                 ;    4269 		buffer++;
                 ;    4270 	*buffer-- = '\0';
                 ;    4271 	if (temp_data == EOF)
                 ;    4272 		return (NULL);
                 ;    4273 	return (buffer);
                 ;    4274 }
                 ;    4275 
                 ;    4276 #ifndef _READ_ONLY_
                 ;    4277 // Decrement file pointer, then get file data
                 ;    4278 int ungetc(unsigned char file_data, FILE *rp)
                 ;    4279 {
                 ;    4280 	unsigned int n;
                 ;    4281 	unsigned long addr_temp;
                 ;    4282 	
                 ;    4283 	if ((rp==NULL) || (rp->position==0))
                 ;	file_data -> Y+8
                 ;	*rp -> Y+6
                 ;	n -> R16,R17
                 ;	addr_temp -> Y+2
                 ;    4284 		return (EOF);
                 ;    4285 	if ((rp->mode!=APPEND) && (rp->mode!=WRITE))
                 ;    4286 		return (EOF);	// needs to be in WRITE or APPEND mode
                 ;    4287 
                 ;    4288 	if (((rp->position) == rp->length) && (rp->EOF_flag))
                 ;    4289 	{	// if the file posisition is equal to the length, return data, turn flag off
                 ;    4290 		rp->EOF_flag = 0;
                 ;    4291 		*rp->pntr = file_data;
                 ;    4292 		return (*rp->pntr);
                 ;    4293 	}
                 ;    4294 	if ((rp->pntr)==(&rp->buff[0]))
                 ;    4295 	{	// Check to see if pointer is at the beginning of a Sector
                 ;    4296 		// Update the current sector before loading next
                 ;    4297 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4298 			_FF_buff[n] = rp->buff[n];
                 ;    4299 		addr_temp = clust_to_addr(rp->clus_current) + (((rp->sec_offset)-1)*BPB_BytsPerSec);
                 ;    4300 		if (_FF_write(addr_temp)==0)
                 ;    4301 			return (EOF);
                 ;    4302 			
                 ;    4303 		if (rp->sec_offset > 1)
                 ;    4304 		{	// Goto previous sector if not at the beginning of a cluster
                 ;    4305 			addr_temp = clust_to_addr(rp->clus_current) + ((rp->sec_offset-2)*BPB_BytsPerSec);
                 ;    4306 			rp->sec_offset--;
                 ;    4307 		}
                 ;    4308 		else
                 ;    4309 		{	// Beginning of Cluster, find previous
                 ;    4310 			if (rp->clus_start==rp->clus_current)
                 ;    4311 			{	// Positioned @ Beginning of File
                 ;    4312 				_FF_error = SOF_ERR;
                 ;    4313 				return(EOF);
                 ;    4314 			}
                 ;    4315 			rp->sec_offset = BPB_SecPerClus;	// Set sector offset to last sector
                 ;    4316 			rp->clus_next = rp->clus_current;
                 ;    4317 			rp->clus_current = rp->clus_prev;
                 ;    4318 			if (rp->clus_current != rp->clus_start)
                 ;    4319 				rp->clus_prev = prev_cluster(rp->clus_current);
                 ;    4320 			else
                 ;    4321 				rp->clus_prev = 0;
                 ;    4322 			addr_temp = clust_to_addr(rp->clus_current) + (((long) BPB_SecPerClus-1) * (long) BPB_BytsPerSec);
                 ;    4323 		}
                 ;    4324 		_FF_read(addr_temp);
                 ;    4325 		for (n=0; n<BPB_BytsPerSec; n++)
                 ;    4326 			rp->buff[n] = _FF_buff[n];
                 ;    4327 		rp->pntr = &rp->buff[511];
                 ;    4328 	}
                 ;    4329 	else
                 ;    4330 		rp->pntr--;
                 ;    4331 	
                 ;    4332 	rp->position--;
                 ;    4333 	*rp->pntr = file_data;	
                 ;    4334 	return(*rp->pntr);	// Get data	
                 ;    4335 }
                 ;    4336 #endif
                 ;    4337 
                 ;    4338 #ifndef _READ_ONLY_
                 ;    4339 int fputc(unsigned char file_data, FILE *rp)	
                 ;    4340 {
                 _fputc:
                 ;    4341 	unsigned int n;
                 ;    4342 	unsigned long addr_temp;
                 ;    4343 	
                 ;    4344 	if (rp==NULL)
001760 940e 2747 	CALL SUBOPT_0x80
                 ;	file_data -> Y+8
                 ;	*rp -> Y+6
                 ;	n -> R16,R17
                 ;	addr_temp -> Y+2
001762 81ee      	LDD  R30,Y+6
001763 81ff      	LDD  R31,Y+6+1
001764 9730      	SBIW R30,0
001765 f419      	BRNE _0x336
                 ;    4345 		return (EOF);
001766 efef      	LDI  R30,LOW(65535)
001767 efff      	LDI  R31,HIGH(65535)
001768 c1ab      	RJMP _0x4C9
                 ;    4346 
                 ;    4347 	if (rp->mode == READ)
                 _0x336:
001769 940e 274b 	CALL SUBOPT_0x81
00176b 30a1      	CPI  R26,LOW(0x1)
00176c f431      	BRNE _0x337
                 ;    4348 	{
                 ;    4349 		_FF_error = READONLY_ERR;
00176d e0e6      	LDI  R30,LOW(6)
00176e 93e0 0972 	STS  __FF_error,R30
                 ;    4350 		return(EOF);
001770 efef      	LDI  R30,LOW(65535)
001771 efff      	LDI  R31,HIGH(65535)
001772 c1a1      	RJMP _0x4C9
                 ;    4351 	}
                 ;    4352 	if (rp->length == 0)
                 _0x337:
001773 940e 2702 	CALL SUBOPT_0x75
001775 f4d9      	BRNE _0x338
                 ;    4353 	{	// Blank file start writing cluster table
                 ;    4354 		rp->clus_start = prev_cluster(0);
001776 940e 27d9 	CALL SUBOPT_0x95
001778 81ae
001779 81bf
00177a 961c
00177b 93ed
00177c 93fc      	__PUTW1SNS 6,12
                 ;    4355 		rp->clus_next = 0xFFFF;
00177d 940e 27df 	CALL SUBOPT_0x96
                 ;    4356 		rp->clus_current = rp->clus_start;
00177f 940e 26dd 	CALL SUBOPT_0x70
001781 81ae
001782 81bf
001783 961e
001784 93ed
001785 93fc      	__PUTW1SNS 6,14
                 ;    4357 		if (write_clus_table(rp->clus_start, rp->clus_next, SINGLE)==0)
001786 940e 270b 	CALL SUBOPT_0x76
001788 940e 27e7 	CALL SUBOPT_0x97
00178a e0e1      	LDI  R30,LOW(1)
00178b 940e 27ee 	CALL SUBOPT_0x98
00178d f419      	BRNE _0x339
                 ;    4358 		{
                 ;    4359 			return (EOF);
00178e efef      	LDI  R30,LOW(65535)
00178f efff      	LDI  R31,HIGH(65535)
001790 c183      	RJMP _0x4C9
                 ;    4360 		}
                 ;    4361 	}
                 _0x339:
                 ;    4362 	
                 ;    4363 	if ((rp->position==rp->length) && (rp->EOF_flag))
                 _0x338:
001791 940e 27f3 	CALL SUBOPT_0x99
001793 937f      	PUSH R23
001794 936f      	PUSH R22
001795 93ff      	PUSH R31
001796 93ef      	PUSH R30
001797 940e 27fa 	CALL SUBOPT_0x9A
001799 91af      	POP  R26
00179a 91bf      	POP  R27
00179b 918f      	POP  R24
00179c 919f      	POP  R25
00179d 940e 2ab2 	CALL __CPD12
00179f f419      	BRNE _0x33B
0017a0 940e 2801 	CALL SUBOPT_0x9B
0017a2 f409      	BRNE _0x33C
                 _0x33B:
0017a3 c043      	RJMP _0x33A
                 _0x33C:
                 ;    4364 	{	// At end of file, and end of cluster, flagged
                 ;    4365 		rp->clus_prev = rp->clus_current;
0017a4 940e 2808 	CALL SUBOPT_0x9C
0017a6 81ae
0017a7 81bf
0017a8 9652
0017a9 93ed
0017aa 93fc      	__PUTW1SNS 6,18
                 ;    4366 		rp->clus_current = prev_cluster(0);	// Find first cluster pointing to '0'
0017ab 940e 27d9 	CALL SUBOPT_0x95
0017ad 81ae
0017ae 81bf
0017af 961e
0017b0 93ed
0017b1 93fc      	__PUTW1SNS 6,14
                 ;    4367 		rp->clus_next = 0xFFFF;
0017b2 940e 27df 	CALL SUBOPT_0x96
                 ;    4368 		rp->sec_offset = 1;
0017b4 940e 271d 	CALL SUBOPT_0x79
                 ;    4369 		if (write_clus_table(rp->clus_prev, rp->clus_current, CHAIN)==0)
0017b6 81ee      	LDD  R30,Y+6
0017b7 81ff      	LDD  R31,Y+6+1
0017b8 89a2      	LDD  R26,Z+18
0017b9 89b3      	LDD  R27,Z+19
0017ba 93ba      	ST   -Y,R27
0017bb 93aa      	ST   -Y,R26
0017bc 85e8      	LDD  R30,Y+8
0017bd 85f9      	LDD  R31,Y+8+1
0017be 85a6      	LDD  R26,Z+14
0017bf 85b7      	LDD  R27,Z+15
0017c0 93ba      	ST   -Y,R27
0017c1 93aa      	ST   -Y,R26
0017c2 e0e0      	LDI  R30,LOW(0)
0017c3 940e 27ee 	CALL SUBOPT_0x98
0017c5 f419      	BRNE _0x33D
                 ;    4370 		{
                 ;    4371 			return (EOF);
0017c6 efef      	LDI  R30,LOW(65535)
0017c7 efff      	LDI  R31,HIGH(65535)
0017c8 c14b      	RJMP _0x4C9
                 ;    4372 		}
                 ;    4373 		if (write_clus_table(rp->clus_current, rp->clus_next, END_CHAIN)==0)
                 _0x33D:
0017c9 940e 2712 	CALL SUBOPT_0x77
0017cb 940e 27e7 	CALL SUBOPT_0x97
0017cd e0e2      	LDI  R30,LOW(2)
0017ce 940e 27ee 	CALL SUBOPT_0x98
0017d0 f419      	BRNE _0x33E
                 ;    4374 		{
                 ;    4375 			return (EOF);
0017d1 efef      	LDI  R30,LOW(65535)
0017d2 efff      	LDI  R31,HIGH(65535)
0017d3 c140      	RJMP _0x4C9
                 ;    4376 		}
                 ;    4377 		if (append_toc(rp)==0)
                 _0x33E:
0017d4 940e 276b 	CALL SUBOPT_0x85
0017d6 f419      	BRNE _0x33F
                 ;    4378 		{
                 ;    4379 			return (EOF);
0017d7 efef      	LDI  R30,LOW(65535)
0017d8 efff      	LDI  R31,HIGH(65535)
0017d9 c13a      	RJMP _0x4C9
                 ;    4380 		}
                 ;    4381 		rp->EOF_flag = 0;
                 _0x33F:
0017da 81ae      	LDD  R26,Y+6
0017db 81bf      	LDD  R27,Y+6+1
0017dc 940e 280e 	CALL SUBOPT_0x9D
                 ;    4382 		rp->pntr = &rp->buff[0];		
0017de 81ee      	LDD  R30,Y+6
0017df 81ff      	LDD  R31,Y+6+1
0017e0 967c      	ADIW R30,28
0017e1 81ae
0017e2 81bf
0017e3 5da9
0017e4 4fbd
0017e5 93ed
0017e6 93fc      	__PUTW1SN 6,551
                 ;    4383 	}
                 ;    4384 	
                 ;    4385 	*rp->pntr = file_data;
                 _0x33A:
0017e7 940e 2813 	CALL SUBOPT_0x9E
0017e9 85a8      	LDD  R26,Y+8
0017ea 83a0      	STD  Z+0,R26
                 ;    4386 	
                 ;    4387 	if (rp->pntr == &rp->buff[BPB_BytsPerSec-1])
0017eb 81ae      	LDD  R26,Y+6
0017ec 81bf      	LDD  R27,Y+6+1
0017ed 5da9      	SUBI R26,LOW(-551)
0017ee 4fbd      	SBCI R27,HIGH(-551)
0017ef 900d      	LD   R0,X+
0017f0 901c      	LD   R1,X
0017f1 81ae      	LDD  R26,Y+6
0017f2 81bf      	LDD  R27,Y+6+1
0017f3 940e 278b 	CALL SUBOPT_0x8A
0017f5 f011      	BREQ PC+3
0017f6 940c 18ee 	JMP _0x340
                 ;    4388 	{	// This is on the Sector Limit
                 ;    4389 		if (rp->position > rp->length)
0017f8 940e 27f3 	CALL SUBOPT_0x99
0017fa 937f      	PUSH R23
0017fb 936f      	PUSH R22
0017fc 93ff      	PUSH R31
0017fd 93ef      	PUSH R30
0017fe 940e 27fa 	CALL SUBOPT_0x9A
001800 91af      	POP  R26
001801 91bf      	POP  R27
001802 918f      	POP  R24
001803 919f      	POP  R25
001804 940e 2ab2 	CALL __CPD12
001806 f430      	BRSH _0x341
                 ;    4390 		{	// ERROR, position should never be greater than length
                 ;    4391 			_FF_error = 0x10;		// file position ERROR
001807 e1e0      	LDI  R30,LOW(16)
001808 93e0 0972 	STS  __FF_error,R30
                 ;    4392 			return (EOF); 
00180a efef      	LDI  R30,LOW(65535)
00180b efff      	LDI  R31,HIGH(65535)
00180c c107      	RJMP _0x4C9
                 ;    4393 		}
                 ;    4394 		// Position is at end of a sector?
                 ;    4395 		
                 ;    4396 		addr_temp = (clust_to_addr(rp->clus_current) + ((rp->sec_offset-1)*BPB_BytsPerSec));
                 _0x341:
00180d 940e 2712 	CALL SUBOPT_0x77
00180f 940e 0da9 	CALL _clust_to_addr
001811 937f      	PUSH R23
001812 936f      	PUSH R22
001813 93ff      	PUSH R31
001814 93ef      	PUSH R30
001815 940e 2751 	CALL SUBOPT_0x82
001817 91af      	POP  R26
001818 91bf      	POP  R27
001819 918f      	POP  R24
00181a 919f      	POP  R25
00181b 940e 275e 	CALL SUBOPT_0x83
                 ;    4397 		for (n=0; n<BPB_BytsPerSec; n++)
00181d e000
00181e e010      	__GETWRN 16,17,0
                 _0x343:
00181f 91e0 0935 	LDS  R30,_BPB_BytsPerSec
001821 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
001823 170e      	CP   R16,R30
001824 071f      	CPC  R17,R31
001825 f438      	BRSH _0x344
                 ;    4398 			_FF_buff[n] = rp->buff[n];
001826 940e 2767 	CALL SUBOPT_0x84
001828 81e0      	LD   R30,Z
001829 93ec      	ST   X,R30
                 ;    4399 		_FF_write(addr_temp);
00182a 5f0f
00182b 4f1f      	__ADDWRN 16,17,1
00182c cff2      	RJMP _0x343
                 _0x344:
00182d 81ea
00182e 81fb
00182f 816c
001830 817d      	__GETD1S 2
001831 940e 2a63 	CALL __PUTPARD1
001833 940e 0bab 	CALL __FF_write
                 ;    4400 			// Save MMC buffer to card, set pointer to begining of new buffer
                 ;    4401 		if (rp->sec_offset < BPB_SecPerClus)
001835 81ee      	LDD  R30,Y+6
001836 81ff      	LDD  R31,Y+6+1
001837 940e 27b9 	CALL SUBOPT_0x90
001839 f4e0      	BRSH _0x345
                 ;    4402 		{	// Are there more sectors in this cluster?
                 ;    4403 			addr_temp = clust_to_addr(rp->clus_current) + (rp->sec_offset * BPB_BytsPerSec);
00183a 940e 2712 	CALL SUBOPT_0x77
00183c 940e 0da9 	CALL _clust_to_addr
00183e 937f      	PUSH R23
00183f 936f      	PUSH R22
001840 93ff      	PUSH R31
001841 93ef      	PUSH R30
001842 940e 281a 	CALL SUBOPT_0x9F
001844 91a0 0935 	LDS  R26,_BPB_BytsPerSec
001846 91b0 0936 	LDS  R27,_BPB_BytsPerSec+1
001848 940e 29c5 	CALL __MULW12U
00184a 91af      	POP  R26
00184b 91bf      	POP  R27
00184c 918f      	POP  R24
00184d 919f      	POP  R25
00184e 940e 275e 	CALL SUBOPT_0x83
                 ;    4404 			rp->sec_offset++;
001850 940e 281a 	CALL SUBOPT_0x9F
001852 9631      	ADIW R30,1
001853 93ed      	ST   X+,R30
001854 93fc      	ST   X,R31
                 ;    4405 		}
                 ;    4406 		else
001855 c057      	RJMP _0x346
                 _0x345:
                 ;    4407 		{	// Find next cluster, load first sector into file.buff
                 ;    4408 			if (((rp->clus_next>=0xFFF8)&&(BPB_FATType==0x36)) ||
                 ;    4409 				((rp->clus_next>=0xFF8)&&(BPB_FATType==0x32)))
001856 81ee      	LDD  R30,Y+6
001857 81ff      	LDD  R31,Y+6+1
001858 89a0      	LDD  R26,Z+16
001859 89b1      	LDD  R27,Z+17
00185a 3fa8      	CPI  R26,LOW(0xFFF8)
00185b efef      	LDI  R30,HIGH(0xFFF8)
00185c 07be      	CPC  R27,R30
00185d f020      	BRLO _0x348
00185e 91a0 093f 	LDS  R26,_BPB_FATType
001860 33a6      	CPI  R26,LOW(0x36)
001861 f069      	BREQ _0x34A
                 _0x348:
001862 81ee      	LDD  R30,Y+6
001863 81ff      	LDD  R31,Y+6+1
001864 89a0      	LDD  R26,Z+16
001865 89b1      	LDD  R27,Z+17
001866 3fa8      	CPI  R26,LOW(0xFF8)
001867 e0ef      	LDI  R30,HIGH(0xFF8)
001868 07be      	CPC  R27,R30
001869 f020      	BRLO _0x34B
00186a 91a0 093f 	LDS  R26,_BPB_FATType
00186c 33a2      	CPI  R26,LOW(0x32)
00186d f009      	BREQ _0x34A
                 _0x34B:
00186e c01a      	RJMP _0x347
                 _0x34A:
                 ;    4410 			{	// EOF, need to find new empty cluster
                 ;    4411 				if (rp->position != rp->length)
00186f 940e 27f3 	CALL SUBOPT_0x99
001871 937f      	PUSH R23
001872 936f      	PUSH R22
001873 93ff      	PUSH R31
001874 93ef      	PUSH R30
001875 940e 27fa 	CALL SUBOPT_0x9A
001877 91af      	POP  R26
001878 91bf      	POP  R27
001879 918f      	POP  R24
00187a 919f      	POP  R25
00187b 940e 2ab2 	CALL __CPD12
00187d f031      	BREQ _0x34E
                 ;    4412 				{	// if not equal there's an error
                 ;    4413 					_FF_error = 0x20;		// EOF position error
00187e e2e0      	LDI  R30,LOW(32)
00187f 93e0 0972 	STS  __FF_error,R30
                 ;    4414 					return (EOF);
001881 efef      	LDI  R30,LOW(65535)
001882 efff      	LDI  R31,HIGH(65535)
001883 c090      	RJMP _0x4C9
                 ;    4415 				}
                 ;    4416 				rp->EOF_flag = 1;
                 _0x34E:
001884 81ae      	LDD  R26,Y+6
001885 81bf      	LDD  R27,Y+6+1
001886 940e 27c1 	CALL SUBOPT_0x91
                 ;    4417 			}
                 ;    4418 			else
001888 c01a      	RJMP _0x34F
                 _0x347:
                 ;    4419 			{	// Not EOF, find next cluster
                 ;    4420 				rp->clus_prev = rp->clus_current;
001889 940e 2808 	CALL SUBOPT_0x9C
00188b 81ae
00188c 81bf
00188d 9652
00188e 93ed
00188f 93fc      	__PUTW1SNS 6,18
                 ;    4421 				rp->clus_current = rp->clus_next;
001890 81ae      	LDD  R26,Y+6
001891 81bf      	LDD  R27,Y+6+1
001892 9650      	ADIW R26,16
001893 940e 2a4a 	CALL __GETW1P
001895 81ae
001896 81bf
001897 961e
001898 93ed
001899 93fc      	__PUTW1SNS 6,14
                 ;    4422 				rp->clus_next = next_cluster(rp->clus_current, SINGLE);
00189a 940e 2712 	CALL SUBOPT_0x77
00189c 940e 2719 	CALL SUBOPT_0x78
00189e 81ae
00189f 81bf
0018a0 9650
0018a1 93ed
0018a2 93fc      	__PUTW1SNS 6,16
                 ;    4423 			}
                 _0x34F:
                 ;    4424 			rp->sec_offset = 1;
0018a3 940e 271d 	CALL SUBOPT_0x79
                 ;    4425 			addr_temp = clust_to_addr(rp->clus_current);
0018a5 940e 2712 	CALL SUBOPT_0x77
0018a7 940e 0da9 	CALL _clust_to_addr
0018a9 83ea
0018aa 83fb
0018ab 836c
0018ac 837d      	__PUTD1S 2
                 ;    4426 		}
                 _0x346:
                 ;    4427 		
                 ;    4428 		if (rp->EOF_flag == 0)
0018ad 940e 2801 	CALL SUBOPT_0x9B
0018af f501      	BRNE _0x350
                 ;    4429 		{
                 ;    4430 			if (_FF_read(addr_temp)==0)
0018b0 81ea
0018b1 81fb
0018b2 816c
0018b3 817d      	__GETD1S 2
0018b4 940e 2488 	CALL SUBOPT_0x34
0018b6 f419      	BRNE _0x351
                 ;    4431 				return(EOF);
0018b7 efef      	LDI  R30,LOW(65535)
0018b8 efff      	LDI  R31,HIGH(65535)
0018b9 c05a      	RJMP _0x4C9
                 ;    4432 			for (n=0; n<512; n++)
                 _0x351:
0018ba e000
0018bb e010      	__GETWRN 16,17,0
                 _0x353:
0018bc 3000
0018bd e0e2
0018be 071e      	__CPWRN 16,17,512
0018bf f438      	BRSH _0x354
                 ;    4433 				rp->buff[n] = _FF_buff[n];
0018c0 940e 2725 	CALL SUBOPT_0x7A
0018c2 940e 272b 	CALL SUBOPT_0x7B
                 ;    4434 			rp->pntr = &rp->buff[0];	// Set pointer to next location				
0018c4 5f0f
0018c5 4f1f      	__ADDWRN 16,17,1
0018c6 cff5      	RJMP _0x353
                 _0x354:
0018c7 81ee      	LDD  R30,Y+6
0018c8 81ff      	LDD  R31,Y+6+1
0018c9 967c      	ADIW R30,28
0018ca 81ae
0018cb 81bf
0018cc 5da9
0018cd 4fbd
0018ce 93ed
0018cf 93fc      	__PUTW1SN 6,551
                 ;    4435 		}
                 ;    4436 		if (rp->length==rp->position)
                 _0x350:
0018d0 940e 27fa 	CALL SUBOPT_0x9A
0018d2 937f      	PUSH R23
0018d3 936f      	PUSH R22
0018d4 93ff      	PUSH R31
0018d5 93ef      	PUSH R30
0018d6 940e 27f3 	CALL SUBOPT_0x99
0018d8 91af      	POP  R26
0018d9 91bf      	POP  R27
0018da 918f      	POP  R24
0018db 919f      	POP  R25
0018dc 940e 2ab2 	CALL __CPD12
0018de f441      	BRNE _0x355
                 ;    4437 			rp->length++;
0018df 940e 27fa 	CALL SUBOPT_0x9A
0018e1 5fef
0018e2 4fff
0018e3 4f6f
0018e4 4f7f      	__SUBD1N -1
0018e5 940e 2a54 	CALL __PUTDP1
                 ;    4438 		if (append_toc(rp)==0)
                 _0x355:
0018e7 940e 276b 	CALL SUBOPT_0x85
0018e9 f419      	BRNE _0x356
                 ;    4439 			return(EOF);
0018ea efef      	LDI  R30,LOW(65535)
0018eb efff      	LDI  R31,HIGH(65535)
0018ec c027      	RJMP _0x4C9
                 ;    4440 	}
                 _0x356:
                 ;    4441 	else
0018ed c01c      	RJMP _0x357
                 _0x340:
                 ;    4442 	{
                 ;    4443 		rp->pntr++;
0018ee 940e 2813 	CALL SUBOPT_0x9E
0018f0 9631      	ADIW R30,1
0018f1 93ed      	ST   X+,R30
0018f2 93fc      	ST   X,R31
                 ;    4444 		if (rp->length==rp->position)
0018f3 940e 27fa 	CALL SUBOPT_0x9A
0018f5 937f      	PUSH R23
0018f6 936f      	PUSH R22
0018f7 93ff      	PUSH R31
0018f8 93ef      	PUSH R30
0018f9 940e 27f3 	CALL SUBOPT_0x99
0018fb 91af      	POP  R26
0018fc 91bf      	POP  R27
0018fd 918f      	POP  R24
0018fe 919f      	POP  R25
0018ff 940e 2ab2 	CALL __CPD12
001901 f441      	BRNE _0x358
                 ;    4445 			rp->length++;
001902 940e 27fa 	CALL SUBOPT_0x9A
001904 5fef
001905 4fff
001906 4f6f
001907 4f7f      	__SUBD1N -1
001908 940e 2a54 	CALL __PUTDP1
                 ;    4446 	}
                 _0x358:
                 _0x357:
                 ;    4447 	rp->position++;
00190a 940e 27f3 	CALL SUBOPT_0x99
00190c 5fef
00190d 4fff
00190e 4f6f
00190f 4f7f      	__SUBD1N -1
001910 940e 2a54 	CALL __PUTDP1
                 ;    4448 	return(file_data);
001912 85e8      	LDD  R30,Y+8
001913 e0f0      	LDI  R31,0
                 _0x4C9:
001914 8119      	LDD  R17,Y+1
001915 8108      	LDD  R16,Y+0
001916 9629      	ADIW R28,9
001917 9508      	RET
                 ;    4449 }
                 ;    4450 
                 ;    4451 int fputs(unsigned char *file_data, FILE *rp)
                 ;    4452 {
                 ;    4453 	while(*file_data)
                 ;    4454 		if (fputc(*file_data++,rp) == EOF)
                 ;    4455 			return (EOF);
                 ;    4456 	if (fputc('\r',rp) == EOF)
                 ;    4457 		return (EOF);
                 ;    4458 	if (fputc('\n',rp) == EOF)
                 ;    4459 		return (EOF);
                 ;    4460 	return (0);
                 ;    4461 }
                 ;    4462 
                 ;    4463 int fputsc(flash unsigned char *file_data, FILE *rp)
                 ;    4464 {
                 ;    4465 	while(*file_data)
                 ;    4466 		if (fputc(*file_data++,rp) == EOF)
                 ;    4467 			return (EOF);
                 ;    4468 	if (fputc('\r',rp) == EOF)
                 ;    4469 		return (EOF);
                 ;    4470 	if (fputc('\n',rp) == EOF)
                 ;    4471 		return (EOF);
                 ;    4472 	return (0);
                 ;    4473 }
                 ;    4474 #endif
                 ;    4475 
                 ;    4476 //#ifndef _READ_ONLY_
                 ;    4477 #ifdef _CVAVR_
                 ;    4478 void fprintf(FILE *rp, unsigned char flash *pstr, ...)
                 ;    4479 {
                 ;    4480 	va_list arglist;
                 ;    4481 	unsigned char temp_buff[_FF_MAX_FPRINT], *fp;
                 ;    4482 	
                 ;    4483 	va_start(arglist, pstr);
                 ;	*rp -> Y+106
                 ;	*pstr -> Y+104
                 ;	*arglist -> R16,R17
                 ;	temp_buff -> Y+4
                 ;	*fp -> R18,R19
                 ;    4484 	vsprintf(temp_buff, pstr, arglist);
                 ;    4485 	va_end(arglist);
                 ;    4486 	
                 ;    4487 	fp = temp_buff;
                 ;    4488 	while (*fp)
                 ;    4489 		fputc(*fp++, rp);	
                 ;    4490 }
                 ;    4491 #endif
                 ;    4492 #ifdef _ICCAVR_
                 ;    4493 void fprintf(FILE *rp, unsigned char flash *pstr, long var)
                 ;    4494 {
                 ;    4495 	unsigned char temp_buff[_FF_MAX_FPRINT], *fp;
                 ;    4496 	
                 ;    4497 	csprintf(temp_buff, pstr, var);
                 ;    4498 	
                 ;    4499 	fp = temp_buff;
                 ;    4500 	while (*fp)
                 ;    4501 		fputc(*fp++, rp);	
                 ;    4502 }
                 ;    4503 #endif
                 ;    4504 //#endif
                 ;    4505 
                 ;    4506 // Set file pointer to the end of the file
                 ;    4507 int fend(FILE *rp)
                 ;    4508 {
                 ;    4509 	return (fseek(rp, 0, SEEK_END));	
                 ;    4510 }
                 ;    4511 
                 ;    4512 // Goto position "off_set" of a file
                 ;    4513 int fseek(FILE *rp, unsigned long off_set, unsigned char mode)
                 ;    4514 {
                 _fseek:
                 ;    4515 	unsigned int n, clus_temp;
                 ;    4516 	unsigned long length_check, addr_calc;
                 ;    4517 	
                 ;    4518 	if (rp==NULL)
001918 9728      	SBIW R28,8
001919 940e 2abe 	CALL __SAVELOCR4
                 ;	*rp -> Y+17
                 ;	off_set -> Y+13
                 ;	mode -> Y+12
                 ;	n -> R16,R17
                 ;	clus_temp -> R18,R19
                 ;	length_check -> Y+8
                 ;	addr_calc -> Y+4
00191b 89e9      	LDD  R30,Y+17
00191c 89fa      	LDD  R31,Y+17+1
00191d 9730      	SBIW R30,0
00191e f431      	BRNE _0x368
                 ;    4519 	{	// ERROR if FILE pointer is NULL
                 ;    4520 		_FF_error = FILE_ERR;
00191f e0e2      	LDI  R30,LOW(2)
001920 93e0 0972 	STS  __FF_error,R30
                 ;    4521 		return (EOF);
001922 efef      	LDI  R30,LOW(65535)
001923 efff      	LDI  R31,HIGH(65535)
001924 c154      	RJMP _0x4C8
                 ;    4522 	}
                 ;    4523 	if (mode==SEEK_CUR)
                 _0x368:
001925 85ec      	LDD  R30,Y+12
001926 30e0      	CPI  R30,0
001927 f481      	BRNE _0x369
                 ;    4524 	{	// Trying to position pointer to offset from current position
                 ;    4525 		off_set += rp->position;
001928 89a9      	LDD  R26,Y+17
001929 89ba      	LDD  R27,Y+17+1
00192a 5ea0      	SUBI R26,LOW(-544)
00192b 4fbd      	SBCI R27,HIGH(-544)
00192c 940e 2a4e 	CALL __GETD1P
00192e 85ad
00192f 85be
001930 858f
001931 8998      	__GETD2S 13
001932 940e 295c 	CALL __ADDD12
001934 87ed
001935 87fe
001936 876f
001937 8b78      	__PUTD1S 13
                 ;    4526 	}
                 ;    4527 	if (off_set > rp->length)
                 _0x369:
001938 940e 2820 	CALL SUBOPT_0xA0
00193a 940e 2ab2 	CALL __CPD12
00193c f438      	BRSH _0x36A
                 ;    4528 	{	// trying to position beyond or before file
                 ;    4529 		rp->error = POS_ERR;
00193d 89a9      	LDD  R26,Y+17
00193e 89ba      	LDD  R27,Y+17+1
00193f 940e 277f 	CALL SUBOPT_0x88
                 ;    4530 		_FF_error = POS_ERR;
001941 940e 282b 	CALL SUBOPT_0xA1
                 ;    4531 		return (EOF);
001943 c135      	RJMP _0x4C8
                 ;    4532 	}
                 ;    4533 	if (mode==SEEK_END)
                 _0x36A:
001944 85ac      	LDD  R26,Y+12
001945 30a1      	CPI  R26,LOW(0x1)
001946 f441      	BRNE _0x36B
                 ;    4534 	{	// Trying to position pointer to offset from EOF
                 ;    4535 		off_set = rp->length - off_set;
001947 940e 2820 	CALL SUBOPT_0xA0
001949 940e 2966 	CALL __SUBD12
00194b 87ed
00194c 87fe
00194d 876f
00194e 8b78      	__PUTD1S 13
                 ;    4536 	}
                 ;    4537 	#ifndef _READ_ONLY_
                 ;    4538 	if (rp->mode != READ)
                 _0x36B:
00194f 89a9      	LDD  R26,Y+17
001950 89ba      	LDD  R27,Y+17+1
001951 940e 2773 	CALL SUBOPT_0x86
001953 f059      	BREQ _0x36C
                 ;    4539 		if (fflush(rp))
001954 89e9      	LDD  R30,Y+17
001955 89fa      	LDD  R31,Y+17+1
001956 93fa      	ST   -Y,R31
001957 93ea      	ST   -Y,R30
001958 940e 15f0 	CALL _fflush
00195a 9730      	SBIW R30,0
00195b f019      	BREQ _0x36D
                 ;    4540 			return (EOF);
00195c efef      	LDI  R30,LOW(65535)
00195d efff      	LDI  R31,HIGH(65535)
00195e c11a      	RJMP _0x4C8
                 ;    4541 	#endif
                 ;    4542 	clus_temp = rp->clus_start;
                 _0x36D:
                 _0x36C:
00195f 89a9      	LDD  R26,Y+17
001960 89ba      	LDD  R27,Y+17+1
001961 961c      	ADIW R26,12
001962 912d      	LD   R18,X+
001963 913c      	LD   R19,X
                 ;    4543 	rp->clus_current = clus_temp;
001964 01f9      	MOVW R30,R18
001965 89a9
001966 89ba
001967 961e
001968 93ed
001969 93fc      	__PUTW1SNS 17,14
                 ;    4544 	rp->clus_next = next_cluster(clus_temp, SINGLE);
00196a 933a      	ST   -Y,R19
00196b 932a      	ST   -Y,R18
00196c 940e 2719 	CALL SUBOPT_0x78
00196e 89a9
00196f 89ba
001970 9650
001971 93ed
001972 93fc      	__PUTW1SNS 17,16
                 ;    4545 	rp->clus_prev = 0;
001973 89a9      	LDD  R26,Y+17
001974 89ba      	LDD  R27,Y+17+1
001975 940e 26e3 	CALL SUBOPT_0x71
                 ;    4546 	
                 ;    4547 	addr_calc = off_set / ((long) BPB_BytsPerSec * (long) BPB_SecPerClus);
001977 940e 2519 	CALL SUBOPT_0x45
001979 85ad
00197a 85be
00197b 858f
00197c 8998      	__GETD2S 13
00197d 940e 2a05 	CALL __DIVD21U
00197f 83ec
001980 83fd
001981 836e
001982 837f      	__PUTD1S 4
                 ;    4548 	length_check = off_set % ((long) BPB_BytsPerSec * (long) BPB_SecPerClus);
001983 940e 2519 	CALL SUBOPT_0x45
001985 85ad
001986 85be
001987 858f
001988 8998      	__GETD2S 13
001989 940e 2a33 	CALL __MODD21U
00198b 87e8
00198c 87f9
00198d 876a
00198e 877b      	__PUTD1S 8
                 ;    4549 	rp->EOF_flag = 0;
00198f 89a9      	LDD  R26,Y+17
001990 89ba      	LDD  R27,Y+17+1
001991 940e 280e 	CALL SUBOPT_0x9D
                 ;    4550 
                 ;    4551 	while (addr_calc)
                 _0x36E:
001993 81ec
001994 81fd
001995 816e
001996 817f      	__GETD1S 4
001997 940e 2aa4 	CALL __CPD10
001999 f411      	BRNE PC+3
00199a 940c 19ec 	JMP _0x370
                 ;    4552 	{
                 ;    4553 		if (rp->clus_next >= 0xFFF8)
00199c 89e9      	LDD  R30,Y+17
00199d 89fa      	LDD  R31,Y+17+1
00199e 89a0      	LDD  R26,Z+16
00199f 89b1      	LDD  R27,Z+17
0019a0 3fa8      	CPI  R26,LOW(0xFFF8)
0019a1 efef      	LDI  R30,HIGH(0xFFF8)
0019a2 07be      	CPC  R27,R30
0019a3 f100      	BRLO _0x371
                 ;    4554 		{	// trying to position beyond or before file
                 ;    4555 			if ((addr_calc==1) && (length_check==0))
0019a4 81ac
0019a5 81bd
0019a6 818e
0019a7 819f      	__GETD2S 4
0019a8 30a1
0019a9 e0e0
0019aa 07be
0019ab e0e0
0019ac 078e
0019ad e0e0
0019ae 079e      	__CPD2N 0x1
0019af f439      	BRNE _0x373
0019b0 85a8
0019b1 85b9
0019b2 858a
0019b3 859b      	__GETD2S 8
0019b4 940e 2aac 	CALL __CPD02
0019b6 f009      	BREQ _0x374
                 _0x373:
0019b7 c005      	RJMP _0x372
                 _0x374:
                 ;    4556 			{
                 ;    4557 				rp->EOF_flag = 1;
0019b8 89a9      	LDD  R26,Y+17
0019b9 89ba      	LDD  R27,Y+17+1
0019ba 940e 27c1 	CALL SUBOPT_0x91
                 ;    4558 				break;
0019bc c02f      	RJMP _0x370
                 ;    4559 			}				
                 ;    4560 			rp->error = POS_ERR;
                 _0x372:
0019bd 89a9      	LDD  R26,Y+17
0019be 89ba      	LDD  R27,Y+17+1
0019bf 940e 277f 	CALL SUBOPT_0x88
                 ;    4561 			_FF_error = POS_ERR;
0019c1 940e 282b 	CALL SUBOPT_0xA1
                 ;    4562 			return (EOF);
0019c3 c0b5      	RJMP _0x4C8
                 ;    4563 		}
                 ;    4564 		clus_temp = rp->clus_next;
                 _0x371:
0019c4 89a9      	LDD  R26,Y+17
0019c5 89ba      	LDD  R27,Y+17+1
0019c6 9650      	ADIW R26,16
0019c7 912d      	LD   R18,X+
0019c8 913c      	LD   R19,X
                 ;    4565 		rp->clus_prev = rp->clus_current;
0019c9 89a9      	LDD  R26,Y+17
0019ca 89ba      	LDD  R27,Y+17+1
0019cb 961e      	ADIW R26,14
0019cc 940e 2a4a 	CALL __GETW1P
0019ce 89a9
0019cf 89ba
0019d0 9652
0019d1 93ed
0019d2 93fc      	__PUTW1SNS 17,18
                 ;    4566 		rp->clus_current = clus_temp;
0019d3 01f9      	MOVW R30,R18
0019d4 89a9
0019d5 89ba
0019d6 961e
0019d7 93ed
0019d8 93fc      	__PUTW1SNS 17,14
                 ;    4567 		rp->clus_next = next_cluster(clus_temp, CHAIN);
0019d9 940e 2628 	CALL SUBOPT_0x5E
0019db 89a9
0019dc 89ba
0019dd 9650
0019de 93ed
0019df 93fc      	__PUTW1SNS 17,16
                 ;    4568 		addr_calc--;
0019e0 81ec
0019e1 81fd
0019e2 816e
0019e3 817f      	__GETD1S 4
0019e4 9731      	SBIW R30,1
0019e5 4060      	SBCI R22,0
0019e6 4070      	SBCI R23,0
0019e7 83ec
0019e8 83fd
0019e9 836e
0019ea 837f      	__PUTD1S 4
                 ;    4569 	}
0019eb cfa7      	RJMP _0x36E
                 _0x370:
                 ;    4570 	
                 ;    4571 	addr_calc = clust_to_addr(rp->clus_current);
0019ec 89e9      	LDD  R30,Y+17
0019ed 89fa      	LDD  R31,Y+17+1
0019ee 85a6      	LDD  R26,Z+14
0019ef 85b7      	LDD  R27,Z+15
0019f0 93ba      	ST   -Y,R27
0019f1 93aa      	ST   -Y,R26
0019f2 940e 0da9 	CALL _clust_to_addr
0019f4 83ec
0019f5 83fd
0019f6 836e
0019f7 837f      	__PUTD1S 4
                 ;    4572 	rp->sec_offset = 1;			// Reset Reading Sector
0019f8 89a9      	LDD  R26,Y+17
0019f9 89ba      	LDD  R27,Y+17+1
0019fa 940e 27cf 	CALL SUBOPT_0x93
                 ;    4573 	while (length_check >= BPB_BytsPerSec)
                 _0x375:
0019fc 940e 2831 	CALL SUBOPT_0xA2
0019fe 940e 2ab7 	CALL __CPD21
001a00 f108      	BRLO _0x377
                 ;    4574 	{
                 ;    4575 		addr_calc += BPB_BytsPerSec;
001a01 91e0 0935 	LDS  R30,_BPB_BytsPerSec
001a03 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
001a05 81ac
001a06 81bd
001a07 818e
001a08 819f      	__GETD2S 4
001a09 2766      	CLR  R22
001a0a 2777      	CLR  R23
001a0b 940e 295c 	CALL __ADDD12
001a0d 83ec
001a0e 83fd
001a0f 836e
001a10 837f      	__PUTD1S 4
                 ;    4576 		length_check -= BPB_BytsPerSec;
001a11 940e 2831 	CALL SUBOPT_0xA2
001a13 940e 296b 	CALL __SUBD21
001a15 87a8
001a16 87b9
001a17 878a
001a18 879b      	__PUTD2S 8
                 ;    4577 		rp->sec_offset++;
001a19 89a9      	LDD  R26,Y+17
001a1a 89ba      	LDD  R27,Y+17+1
001a1b 9654      	ADIW R26,20
001a1c 940e 2a4a 	CALL __GETW1P
001a1e 9631      	ADIW R30,1
001a1f 93ed      	ST   X+,R30
001a20 93fc      	ST   X,R31
                 ;    4578 	}
001a21 cfda      	RJMP _0x375
                 _0x377:
                 ;    4579 	
                 ;    4580 	if (_FF_read(addr_calc)==0)		// Read Current Data Sector
001a22 81ec
001a23 81fd
001a24 816e
001a25 817f      	__GETD1S 4
001a26 940e 2488 	CALL SUBOPT_0x34
001a28 f419      	BRNE _0x378
                 ;    4581 		return(EOF);		// Read Error  
001a29 efef      	LDI  R30,LOW(65535)
001a2a efff      	LDI  R31,HIGH(65535)
001a2b c04d      	RJMP _0x4C8
                 ;    4582 		
                 ;    4583 	for (n=0; n<BPB_BytsPerSec; n++)
                 _0x378:
001a2c e000
001a2d e010      	__GETWRN 16,17,0
                 _0x37A:
001a2e 91e0 0935 	LDS  R30,_BPB_BytsPerSec
001a30 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
001a32 170e      	CP   R16,R30
001a33 071f      	CPC  R17,R31
001a34 f450      	BRSH _0x37B
                 ;    4584 		rp->buff[n] = _FF_buff[n];
001a35 89e9      	LDD  R30,Y+17
001a36 89fa      	LDD  R31,Y+17+1
001a37 967c      	ADIW R30,28
001a38 0fe0      	ADD  R30,R16
001a39 1ff1      	ADC  R31,R17
001a3a 940e 272b 	CALL SUBOPT_0x7B
                 ;    4585     
                 ;    4586     if ((rp->EOF_flag == 1) && (length_check == 0))
001a3c 5f0f
001a3d 4f1f      	__ADDWRN 16,17,1
001a3e cfef      	RJMP _0x37A
                 _0x37B:
001a3f 89a9      	LDD  R26,Y+17
001a40 89ba      	LDD  R27,Y+17+1
001a41 5daa      	SUBI R26,LOW(-550)
001a42 4fbd      	SBCI R27,HIGH(-550)
001a43 91ac      	LD   R26,X
001a44 30a1      	CPI  R26,LOW(0x1)
001a45 f439      	BRNE _0x37D
001a46 85a8
001a47 85b9
001a48 858a
001a49 859b      	__GETD2S 8
001a4a 940e 2aac 	CALL __CPD02
001a4c f009      	BREQ _0x37E
                 _0x37D:
001a4d c010      	RJMP _0x37C
                 _0x37E:
                 ;    4587     	rp->pntr = &rp->buff[BPB_BytsPerSec-1];
001a4e 89a9      	LDD  R26,Y+17
001a4f 89ba      	LDD  R27,Y+17+1
001a50 965c      	ADIW R26,28
001a51 91e0 0935 	LDS  R30,_BPB_BytsPerSec
001a53 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
001a55 9731      	SBIW R30,1
001a56 0fea      	ADD  R30,R26
001a57 1ffb      	ADC  R31,R27
001a58 89a9
001a59 89ba
001a5a 5da9
001a5b 4fbd
001a5c 93ed
001a5d 93fc      	__PUTW1SN 17,551
                 ;    4588 	rp->pntr = &rp->buff[length_check];
                 _0x37C:
001a5e 89a9      	LDD  R26,Y+17
001a5f 89ba      	LDD  R27,Y+17+1
001a60 965c      	ADIW R26,28
001a61 85e8
001a62 85f9
001a63 856a
001a64 857b      	__GETD1S 8
001a65 0fea      	ADD  R30,R26
001a66 1ffb      	ADC  R31,R27
001a67 89a9
001a68 89ba
001a69 5da9
001a6a 4fbd
001a6b 93ed
001a6c 93fc      	__PUTW1SN 17,551
                 ;    4589 	rp->position = off_set;
001a6d 85ed
001a6e 85fe
001a6f 856f
001a70 8978      	__GETD1S 13
001a71 89a9
001a72 89ba
001a73 5ea0
001a74 4fbd
001a75 940e 2a54 	__PUTD1SN 17,544
                 ;    4590 		
                 ;    4591 	return (0);	
001a77 e0e0      	LDI  R30,LOW(0)
001a78 e0f0      	LDI  R31,HIGH(0)
                 _0x4C8:
001a79 940e 2ac5 	CALL __LOADLOCR4
001a7b 9663      	ADIW R28,19
001a7c 9508      	RET
                 ;    4592 }
                 ;    4593 
                 ;    4594 // Return the current position of the file rp with respect to the begining of the file
                 ;    4595 long ftell(FILE *rp)
                 ;    4596 {
                 _ftell:
                 ;    4597 	if (rp==NULL)
001a7d 81e8      	LD   R30,Y
001a7e 81f9      	LDD  R31,Y+1
001a7f 9730      	SBIW R30,0
001a80 f429      	BRNE _0x37F
                 ;    4598 		return (EOF);
001a81 efef
001a82 efff
001a83 ef6f
001a84 ef7f      	__GETD1N 0xFFFFFFFF
001a85 c022      	RJMP _0x4C7
                 ;    4599 	else
                 _0x37F:
                 ;    4600 		return (rp->position);
001a86 940e 283c 	CALL SUBOPT_0xA3
001a88 c01f      	RJMP _0x4C7
                 ;    4601 }
                 ;    4602 
                 ;    4603 // Funtion that returns a '1' for @EOF, '0' otherwise
                 ;    4604 int feof(FILE *rp)
                 ;    4605 {
                 _feof:
                 ;    4606 	if (rp==NULL)
001a89 81e8      	LD   R30,Y
001a8a 81f9      	LDD  R31,Y+1
001a8b 9730      	SBIW R30,0
001a8c f419      	BRNE _0x381
                 ;    4607 		return (EOF);
001a8d efef      	LDI  R30,LOW(65535)
001a8e efff      	LDI  R31,HIGH(65535)
001a8f c018      	RJMP _0x4C7
                 ;    4608 	
                 ;    4609 	if (rp->length==rp->position)
                 _0x381:
001a90 81a8      	LD   R26,Y
001a91 81b9      	LDD  R27,Y+1
001a92 5ea4      	SUBI R26,LOW(-540)
001a93 4fbd      	SBCI R27,HIGH(-540)
001a94 940e 2a4e 	CALL __GETD1P
001a96 937f      	PUSH R23
001a97 936f      	PUSH R22
001a98 93ff      	PUSH R31
001a99 93ef      	PUSH R30
001a9a 940e 283c 	CALL SUBOPT_0xA3
001a9c 91af      	POP  R26
001a9d 91bf      	POP  R27
001a9e 918f      	POP  R24
001a9f 919f      	POP  R25
001aa0 940e 2ab2 	CALL __CPD12
001aa2 f419      	BRNE _0x382
                 ;    4610 		return (1);
001aa3 e0e1      	LDI  R30,LOW(1)
001aa4 e0f0      	LDI  R31,HIGH(1)
001aa5 c002      	RJMP _0x4C7
                 ;    4611 	else
                 _0x382:
                 ;    4612 		return (0);
001aa6 e0e0      	LDI  R30,LOW(0)
001aa7 e0f0      	LDI  R31,HIGH(0)
                 ;    4613 }
                 _0x4C7:
001aa8 9622      	ADIW R28,2
001aa9 9508      	RET
                 ;    4614 		
                 ;    4615 void dump_file_data_hex(FILE *rp)
                 ;    4616 {
                 ;    4617 	unsigned int n, c;
                 ;    4618 	
                 ;    4619 	if (rp==NULL)
                 ;	*rp -> Y+4
                 ;	n -> R16,R17
                 ;	c -> R18,R19
                 ;    4620 		return;
                 ;    4621 
                 ;    4622 	for (n=0; n<0x20; n++)
                 ;    4623 	{   
                 ;    4624 		printf("\n\r");
                 ;    4625 		for (c=0; c<0x10; c++)
                 ;    4626 			printf("%02X ", rp->buff[(n*0x20)+c]);
                 ;    4627 	}
                 ;    4628 }
                 ;    4629 ////////////////////////////////////////////////////////////////////////////
                 ;    4630 // секция формирования пакета закрытия
                 ;    4631 
                 ;    4632 #include "Coding.h"
                 ;    4633 
                 ;    4634 #define koef_pd_kl 		0x7//3//1//3
                 ;    4635 #define Koef_men_kl 	0x7f//07//03//7
                 ;    4636 #define  kolvo_ciklov		0x04			// цикличность передачи циклового пакета
                 ;    4637 //#define Koef_men_kl 0x7f
                 ;    4638 //#define Koef_pd_soft 0x1	//max skorost if 01
                 ;    4639 
                 ;    4640 
                 ;    4641 
                 ;    4642 u8 kluchi_koderu[8] = {0x2,0x45,0x1,0x89,0x6,0x42,0x5,0xf6};//wyh буффер na kluchi
                 
                 	.DSEG
                 _kluchi_koderu:
0009fc           	.BYTE 0x8
                 ;    4643 u8 kluchi_dekoderu[16];//wyh буффер na kluchi
                 _kluchi_dekoderu:
000a04           	.BYTE 0x10
                 ;    4644 
                 ;    4645 u16 gshch1 	=	0xCD;	//shumovoe chislo-jachejka генераторa случайных чисел 1	kluch1  confkluch1;	
                 _gshch1:
000a14           	.BYTE 0x2
                 ;    4646 u16 gshch2	=	0xAE;	//jachejka генераторa случайных чисел 2	kluch2	confkluch2;	
                 _gshch2:
000a16           	.BYTE 0x2
                 ;    4647 u16 gshch3	=	0xBA;	//jachejka генераторa случайных чисел 3 for kazakov
                 _gshch3:
000a18           	.BYTE 0x2
                 ;    4648 u16 gshch4	=	0x35;		//jachejka генераторa случайных чисел 4 dlja maskirovki
                 _gshch4:
000a1a           	.BYTE 0x2
                 ;    4649 u16 gshch5	=	0x43;		//jachejka генераторa случайных чисел 5 dlja maskirovki
                 _gshch5:
000a1c           	.BYTE 0x2
                 ;    4650 u16 gshch6;					//декодирование файла mask.chm
                 _gshch6:
000a1e           	.BYTE 0x2
                 ;    4651 u16 gshch7	=	0x166;	//генерация ключа
                 _gshch7:
000a20           	.BYTE 0x2
                 ;    4652 
                 ;    4653 
                 ;    4654 int confkluch1 = 0xb2;;		//konfiguracija gen klucha1
                 _confkluch1:
000a22           	.BYTE 0x2
                 ;    4655 int confkluch2 = 0xa6;		//konfiguracija gen klucha2
                 _confkluch2:
000a24           	.BYTE 0x2
                 ;    4656 int krutnut		=	0x7;
                 _krutnut:
000a26           	.BYTE 0x2
                 ;    4657 int ver_kl		=	0x7d;
                 _ver_kl:
000a28           	.BYTE 0x2
                 ;    4658 
                 ;    4659 u8	komu;	//=0x25-paket koderu,0x26-paket v liniju
                 _komu:
000a2a           	.BYTE 0x1
                 ;    4660 u8 schetchic_paketov_zakrytija = 0;//для 4-го байта пакета
                 _schetchic_paketov_zakrytija:
000a2b           	.BYTE 0x1
                 ;    4661 int kolvo_abonentov		=0;
                 _kolvo_abonentov:
000a2c           	.BYTE 0x2
                 ;    4662 u8 kolvo_stvolov	=	0;
                 _kolvo_stvolov:
000a2e           	.BYTE 0x1
                 ;    4663 
                 ;    4664 u8 scrambCond = TX_g_p_koderu;		// текущее состояние скремблера
                 _scrambCond:
000a2f           	.BYTE 0x1
                 ;    4665 
                 ;    4666 u8 N_sektora		=	122;//pri programirovanii
                 _N_sektora:
000a30           	.BYTE 0x1
                 ;    4667 u8 ver_zeleza	=	0;
                 _ver_zeleza:
000a31           	.BYTE 0x1
                 ;    4668 u8 flag_est_obnovlenie_flash	=	1;
                 _flag_est_obnovlenie_flash:
000a32           	.BYTE 0x1
                 ;    4669 u8 flag_est_obnovlenie_eeprom;
                 _flag_est_obnovlenie_eeprom:
000a33           	.BYTE 0x1
                 ;    4670 int l_flash;							//длина флеша для прог.
                 _l_flash:
000a34           	.BYTE 0x2
                 ;    4671 //u8 tip;	
                 ;    4672 u8 pozklucha;
                 _pozklucha:
000a36           	.BYTE 0x1
                 ;    4673 int count_paket	=	0;// счетчик пакетов для организации циклов передачи спец.пакетов
                 _count_paket:
000a37           	.BYTE 0x2
                 ;    4674 u16 schetchic_abonentov;
                 _schetchic_abonentov:
000a39           	.BYTE 0x2
                 ;    4675 #define time_OFF_scremb 2000000		//таймаут между принятым по UART пакету и работой внутр скремблера
                 ;    4676 
                 ;    4677 
                 ;    4678 // При работе с COM портом не работает скремблер 
                 ;    4679 void	scrambOff (void)
                 ;    4680 {
                 
                 	.CSEG
                 _scrambOff:
                 ;    4681 		EndTimePack = 0;		// сброс признака
001aaa 94e8      	CLT
001aab f820      	BLD  R2,0
                 ;    4682 		
                 ;    4683 		TCCR3A=0x00;			// делитель до 7.813кГц (128uS)
001aac 940e 2375 	CALL SUBOPT_0x13
                 ;    4684 		TCCR3B=0x05;
                 ;    4685 
                 ;    4686 		TCNT3H=(0xFFFF - (time_OFF_scremb/128)) >>8;			// иниц. величины 8с
001aae ece2      	LDI  R30,LOW(194)
001aaf 93e0 0089 	STS  137,R30
                 ;    4687 		TCNT3L=0xFFFF - (time_OFF_scremb/128);			// иниц. величины 8с
001ab1 efe6      	LDI  R30,LOW(49910)
001ab2 93e0 0088 	STS  136,R30
                 ;    4688 }
001ab4 9508      	RET
                 ;    4689 
                 ;    4690 // возвращает число введенных абонентов
                 ;    4691 u32 getAbons (void)
                 ;    4692 { 
                 _getAbons:
                 ;    4693 	u32 a = 0;
                 ;    4694 
                 ;    4695 				if (fseek (fu_user, 0, SEEK_SET) == EOF) 
001ab5 9724      	SBIW R28,4
001ab6 e084      	LDI  R24,4
001ab7 e0a0      	LDI  R26,LOW(0)
001ab8 e0b0      	LDI  R27,HIGH(0)
001ab9 ebec      	LDI  R30,LOW(_0x399*2)
001aba e0f1      	LDI  R31,HIGH(_0x399*2)
001abb 940e 2aca 	CALL __INITLOCB
                 ;	a -> Y+0
001abd 940e 23ab 	CALL SUBOPT_0x1B
001abf f429      	BRNE _0x39A
                 ;    4696 				{
                 ;    4697 
                 ;    4698 				#ifdef print
                 ;    4699 				printf("getAbons - ERROR\n\r");
                 ;    4700 	 			#endif
                 ;    4701 
                 ;    4702 					return 0 ;//поставить указатель на начало файла
001ac0 e0e0
001ac1 e0f0
001ac2 e060
001ac3 e070      	__GETD1N 0x0
001ac4 c0b1      	RJMP _0x4C6
                 ;    4703 				}
                 ;    4704 
                 ;    4705 				kolvo_abonentov = fgetc(fu_user);
                 _0x39A:
001ac5 940e 23fb 	CALL SUBOPT_0x23
001ac7 93e0 0a2c 	STS  _kolvo_abonentov,R30
001ac9 93f0 0a2d 	STS  _kolvo_abonentov+1,R31
                 ;    4706 				kolvo_abonentov |= fgetc(fu_user)*256;
001acb 940e 23fb 	CALL SUBOPT_0x23
001acd 940e 2843 	CALL SUBOPT_0xA4
                 ;    4707 				kolvo_abonentov |= fgetc(fu_user)*256*256;
001acf 940e 23fb 	CALL SUBOPT_0x23
001ad1 2ffe      	MOV  R31,R30
001ad2 e0e0      	LDI  R30,0
001ad3 2ffe      	MOV  R31,R30
001ad4 e0e0      	LDI  R30,0
001ad5 91a0 0a2c 	LDS  R26,_kolvo_abonentov
001ad7 91b0 0a2d 	LDS  R27,_kolvo_abonentov+1
001ad9 2bea      	OR   R30,R26
001ada 2bfb      	OR   R31,R27
001adb 93e0 0a2c 	STS  _kolvo_abonentov,R30
001add 93f0 0a2d 	STS  _kolvo_abonentov+1,R31
                 ;    4708 				kolvo_abonentov |= fgetc(fu_user)*256*256*256;         
001adf 940e 23fb 	CALL SUBOPT_0x23
001ae1 2ffe      	MOV  R31,R30
001ae2 e0e0      	LDI  R30,0
001ae3 2ffe      	MOV  R31,R30
001ae4 e0e0      	LDI  R30,0
001ae5 940e 2843 	CALL SUBOPT_0xA4
                 ;    4709 				
                 ;    4710                 return kolvo_abonentov;
001ae7 91e0 0a2c 	LDS  R30,_kolvo_abonentov
001ae9 91f0 0a2d 	LDS  R31,_kolvo_abonentov+1
001aeb 940e 29bb 	CALL __CWD1
001aed c088      	RJMP _0x4C6
                 ;    4711 }
                 ;    4712 
                 ;    4713 
                 ;    4714 u8 scrambling (void)
                 ;    4715 {
                 _scrambling:
                 ;    4716 		u32 a;
                 ;    4717 		static u8 count_ciklovogo = 0;		// для счета цикловых пакетов  
                 
                 	.DSEG
                 _count_ciklovogo_S64:
000a3b           	.BYTE 0x1
                 
                 	.CSEG
                 ;    4718 
                 ;    4719 		switch (scrambCond)
001aee 9724      	SBIW R28,4
                 ;	a -> Y+0
001aef 91e0 0a2f 	LDS  R30,_scrambCond
                 ;    4720 		{
                 ;    4721 			case startScremb:
001af1 30e0      	CPI  R30,0
001af2 f4c1      	BRNE _0x39E
                 ;    4722 				eefprog=f_buff_prog;            //поставить указатель на начало 
001af3 e0e5      	LDI  R30,LOW(_f_buff_prog)
001af4 e0f0      	LDI  R31,HIGH(_f_buff_prog)
001af5 012f      	MOVW R4,R30
                 ;    4723 				kolvo_stvolov= *eefprog++;
001af6 940e 238d 	CALL SUBOPT_0x17
001af8 940e 2a76 	CALL __EEPROMRDB
001afa 93e0 0a2e 	STS  _kolvo_stvolov,R30
                 ;    4724 
                 ;    4725 				#ifdef print
                 ;    4726 				printf("kolvo_stvolov=%d \n\r",kolvo_stvolov);
                 ;    4727 		 		#endif
                 ;    4728 
                 ;    4729 				kolvo_abonentov = getAbons();
001afc 940e 1ab5 	CALL _getAbons
001afe 93e0 0a2c 	STS  _kolvo_abonentov,R30
001b00 93f0 0a2d 	STS  _kolvo_abonentov+1,R31
                 ;    4730 	
                 ;    4731 				#ifdef print
                 ;    4732 				printf("kolvo_abonentov=%d \n\r",kolvo_abonentov);
                 ;    4733 				#endif
                 ;    4734 
                 ;    4735 				schetchic_abonentov = 0;
001b02 e0e0      	LDI  R30,0
001b03 93e0 0a39 	STS  _schetchic_abonentov,R30
001b05 93e0 0a3a 	STS  _schetchic_abonentov+1,R30
                 ;    4736 				scrambCond = TX_g_p_razresh;				// переходим к передаче пакетов абонентам
001b07 e0e1      	LDI  R30,LOW(1)
001b08 93e0 0a2f 	STS  _scrambCond,R30
                 ;    4737 				break;
001b0a c06a      	RJMP _0x39D
                 ;    4738 				////////////////////////////////////////////////////////////////////////////////////////////////
                 ;    4739 			case TX_g_p_razresh:
                 _0x39E:
001b0b 30e1      	CPI  R30,LOW(0x1)
001b0c f559      	BRNE _0x39F
                 ;    4740 				if (schetchic_abonentov < kolvo_abonentov)
001b0d 91e0 0a2c 	LDS  R30,_kolvo_abonentov
001b0f 91f0 0a2d 	LDS  R31,_kolvo_abonentov+1
001b11 91a0 0a39 	LDS  R26,_schetchic_abonentov
001b13 91b0 0a3a 	LDS  R27,_schetchic_abonentov+1
001b15 17ae      	CP   R26,R30
001b16 07bf      	CPC  R27,R31
001b17 f4e0      	BRSH _0x3A0
                 ;    4741 				{
                 ;    4742 					#ifdef print
                 ;    4743 					printf("Generation g_p_razresh No- %d \n\r",schetchic_abonentov);
                 ;    4744 					#endif
                 ;    4745 			 		g_p_razresh();													//генерация пакета разрешений
001b18 d41d      	RCALL _g_p_razresh
                 ;    4746 			 		schetchic_abonentov++;
001b19 91e0 0a39 	LDS  R30,_schetchic_abonentov
001b1b 91f0 0a3a 	LDS  R31,_schetchic_abonentov+1
001b1d 9631      	ADIW R30,1
001b1e 93e0 0a39 	STS  _schetchic_abonentov,R30
001b20 93f0 0a3a 	STS  _schetchic_abonentov+1,R31
                 ;    4747 					count_paket++;
001b22 91e0 0a37 	LDS  R30,_count_paket
001b24 91f0 0a38 	LDS  R31,_count_paket+1
001b26 9631      	ADIW R30,1
001b27 93e0 0a37 	STS  _count_paket,R30
001b29 93f0 0a38 	STS  _count_paket+1,R31
                 ;    4748 
                 ;    4749 					if ((count_paket & koef_pd_kl)==0)						// Генерация 
001b2b 91e0 0a37 	LDS  R30,_count_paket
001b2d 70e7      	ANDI R30,LOW(0x7)
001b2e f421      	BRNE _0x3A1
                 ;    4750 					{
                 ;    4751 					 	scrambCond = TX_g_p_kluchi;
001b2f e0e7      	LDI  R30,LOW(7)
001b30 93e0 0a2f 	STS  _scrambCond,R30
                 ;    4752 					 	break;
001b32 c042      	RJMP _0x39D
                 ;    4753 					}
                 ;    4754 				}	
                 _0x3A1:
                 ;    4755 //				else scrambCond = TX_g_p_flash; 	// переходим к передаче обновления ПО	
                 ;    4756 				else 	scrambCond = TX_g_p_ciklovogo; 	// переходим к передаче  циклового пакета
001b33 c003      	RJMP _0x3A2
                 _0x3A0:
001b34 e0e4      	LDI  R30,LOW(4)
001b35 93e0 0a2f 	STS  _scrambCond,R30
                 ;    4757 
                 ;    4758 				break;
                 _0x3A2:
001b37 c03d      	RJMP _0x39D
                 ;    4759 				////////////////////////////////////////////////////////////////////////////////////////////////
                 ;    4760 			case TX_g_p_kluchi:                
                 _0x39F:
001b38 30e7      	CPI  R30,LOW(0x7)
001b39 f4a1      	BRNE _0x3A3
                 ;    4761 				#ifdef print
                 ;    4762 				printf("Generation g_p_kluch...\n\r ");
                 ;    4763 				#endif
                 ;    4764 				g_p_kluchi();             
001b3a d44a      	RCALL _g_p_kluchi
                 ;    4765 				if ((count_paket & Koef_men_kl)==0)					// Генерация 
001b3b 91e0 0a37 	LDS  R30,_count_paket
001b3d 77ef      	ANDI R30,0x7F
001b3e f459      	BRNE _0x3A4
                 ;    4766 				{
                 ;    4767 //					if (count_paket & (Koef_men_kl+1)) scrambCond = TX_men_ver_kl;
                 ;    4768 					if (count_paket & (Koef_men_kl+1)) 
001b3f 91e0 0a37 	LDS  R30,_count_paket
001b41 78e0      	ANDI R30,LOW(0x80)
001b42 f019      	BREQ _0x3A5
                 ;    4769 					{
                 ;    4770 						#ifdef print
                 ;    4771 						printf("Generation men_ver_k... \n\r");
                 ;    4772 						#endif
                 ;    4773 					 	men_ver_kl();
001b43 d0b8      	RCALL _men_ver_kl
                 ;    4774 
                 ;    4775 						scrambCond = TX_g_p_razresh; 	
001b44 e0e1      	LDI  R30,LOW(1)
001b45 c001      	RJMP _0x4EE
                 ;    4776 					}
                 ;    4777 					else 	scrambCond = TX_g_p_koderu;
                 _0x3A5:
001b46 e0e6      	LDI  R30,LOW(6)
                 _0x4EE:
001b47 93e0 0a2f 	STS  _scrambCond,R30
                 ;    4778 					break;
001b49 c02b      	RJMP _0x39D
                 ;    4779 				}
                 ;    4780 
                 ;    4781 				scrambCond = TX_g_p_razresh; 	
                 _0x3A4:
001b4a e0e1      	LDI  R30,LOW(1)
001b4b 93e0 0a2f 	STS  _scrambCond,R30
                 ;    4782 				break;                        
001b4d c027      	RJMP _0x39D
                 ;    4783 				////////////////////////////////////////////////////////////////////////////////////////////////
                 ;    4784 			case TX_men_ver_kl:			
                 _0x3A3:
001b4e 30e5      	CPI  R30,LOW(0x5)
001b4f f429      	BRNE _0x3A7
                 ;    4785 				#ifdef print
                 ;    4786 				printf("Generation men_ver_k... \n\r");
                 ;    4787 				#endif
                 ;    4788 			 	men_ver_kl();
001b50 d0ab      	RCALL _men_ver_kl
                 ;    4789 
                 ;    4790 				scrambCond = TX_g_p_razresh; 	
001b51 e0e1      	LDI  R30,LOW(1)
001b52 93e0 0a2f 	STS  _scrambCond,R30
                 ;    4791 				break;                        
001b54 c020      	RJMP _0x39D
                 ;    4792 				////////////////////////////////////////////////////////////////////////////////////////////////
                 ;    4793 			case	TX_g_p_koderu:
                 _0x3A7:
001b55 30e6      	CPI  R30,LOW(0x6)
001b56 f431      	BRNE _0x3A8
                 ;    4794 				#ifdef print
                 ;    4795 				printf("Generation g_p_koderu... \n\r");
                 ;    4796 				#endif
                 ;    4797 				g_kod();							//подготовка ключей кодеру     
001b57 d078      	RCALL _g_kod
                 ;    4798 				g_p_koderu();					//кодирование и передача пакета
001b58 d227      	RCALL _g_p_koderu
                 ;    4799 
                 ;    4800 				scrambCond = TX_g_p_flagov; 	
001b59 e0e8      	LDI  R30,LOW(8)
001b5a 93e0 0a2f 	STS  _scrambCond,R30
                 ;    4801 				break;                        
001b5c c018      	RJMP _0x39D
                 ;    4802 				////////////////////////////////////////////////////////////////////////////////////////////////
                 ;    4803 			case TX_g_p_flagov:
                 _0x3A8:
001b5d 30e8      	CPI  R30,LOW(0x8)
001b5e f429      	BRNE _0x3A9
                 ;    4804 				#ifdef print
                 ;    4805 				printf("Generation g_p_flagov... \n\r");
                 ;    4806 				#endif
                 ;    4807 				g_p_flagov();
001b5f d3cb      	RCALL _g_p_flagov
                 ;    4808 
                 ;    4809 				scrambCond = TX_g_p_razresh; 	
001b60 e0e1      	LDI  R30,LOW(1)
001b61 93e0 0a2f 	STS  _scrambCond,R30
                 ;    4810 
                 ;    4811 				break;                        
001b63 c011      	RJMP _0x39D
                 ;    4812 				////////////////////////////////////////////////////////////////////////////////////////////////
                 ;    4813 /*			case TX_g_p_flash:
                 ;    4814 
                 ;    4815 				scrambCond = TX_g_p_obnovlenie; 	// переходим к передаче обновления ПО	
                 ;    4816 				break;
                 ;    4817 				////////////////////////////////////////////////////////////////////////////////////////////////
                 ;    4818 			case TX_g_p_obnovlenie:
                 ;    4819 				// Генерация 
                 ;    4820 				if ((count_paket & Koef_pd_soft)==0)
                 ;    4821 				{
                 ;    4822 					if (flag_est_obnovlenie_flash==1)
                 ;    4823 					{
                 ;    4824 						#ifdef print
                 ;    4825 						printf("N_sec=%d ...\n\r" ,N_sektora);
                 ;    4826 						#endif
                 ;    4827 //						g_p_progf();				//генерация пакета флэш
                 ;    4828 					}
                 ;    4829 
                 ;    4830 					if (flag_est_obnovlenie_eeprom ==1)
                 ;    4831 					{	
                 ;    4832 			//			g_p_proge(port);//генерация пакета   ЕЕПРОМ
                 ;    4833 						#ifdef print
                 ;    4834 						printf("g_p_proge...\n\r  " );
                 ;    4835 						#endif
                 ;    4836 					}
                 ;    4837 				}	
                 ;    4838 
                 ;    4839 				scrambCond = TX_g_p_ciklovogo; 	// переходим к передаче  циклового пакета
                 ;    4840 				break;*/
                 ;    4841 
                 ;    4842 				////////////////////////////////////////////////////////////////////////////////////////////////
                 ;    4843 			case TX_g_p_ciklovogo:
                 _0x3A9:
001b64 30e4      	CPI  R30,LOW(0x4)
001b65 f479      	BRNE _0x3AD
                 ;    4844 				#ifdef print
                 ;    4845 				printf("\n\r-------------------------Generation g_p_ciklovogo...-------------------- \n\r");
                 ;    4846 				#endif
                 ;    4847 				if (count_ciklovogo >= kolvo_ciklov)
001b66 91a0 0a3b 	LDS  R26,_count_ciklovogo_S64
001b68 30a4      	CPI  R26,LOW(0x4)
001b69 f018      	BRLO _0x3AB
                 ;    4848 				{
                 ;    4849 				  	 	g_p_ciklovogo();
001b6a d43b      	RCALL _g_p_ciklovogo
                 ;    4850 				  	 	count_ciklovogo = 0;
001b6b e0e0      	LDI  R30,LOW(0)
001b6c c003      	RJMP _0x4EF
                 ;    4851 				}                                    
                 ;    4852 				else count_ciklovogo ++; 
                 _0x3AB:
001b6d 91e0 0a3b 	LDS  R30,_count_ciklovogo_S64
001b6f 5fef      	SUBI R30,-LOW(1)
                 _0x4EF:
001b70 93e0 0a3b 	STS  _count_ciklovogo_S64,R30
                 ;    4853 
                 ;    4854 				scrambCond = startScremb;	//  переходим к установке стартовых параметров
001b72 e0e0      	LDI  R30,LOW(0)
001b73 93e0 0a2f 	STS  _scrambCond,R30
                 ;    4855 				break;
                 ;    4856 
                 ;    4857 			default: break;
                 _0x3AD:
                 ;    4858 		}
                 _0x39D:
                 ;    4859 
                 ;    4860 		return TRUE;		
001b75 e0e1      	LDI  R30,LOW(1)
                 _0x4C6:
001b76 9624      	ADIW R28,4
001b77 9508      	RET
                 ;    4861 }
                 ;    4862 #include "Coding.h"
                 ;    4863 
                 ;    4864 void ini_kluchej(void)
                 ;    4865 {
                 ;    4866 	confkluch1	=0xb2;	//konfiguracija gen klucha1
                 ;    4867 	confkluch2	=0xa6;	//konfiguracija gen klucha2
                 ;    4868 	krutnut		=0x7;
                 ;    4869 	ver_kl		=0x7d;
                 ;    4870 
                 ;    4871 	kluchi_koderu[0]=0x2;//kl0h
                 ;    4872 	kluchi_koderu[1]=0x45;//kl0l
                 ;    4873 	kluchi_koderu[2]=0x1;//kl1h
                 ;    4874 	kluchi_koderu[3]=0x89;//kl1l
                 ;    4875 	kluchi_koderu[4]=0x6;//kl2h
                 ;    4876 	kluchi_koderu[5]=0x42;//kl2l
                 ;    4877 	kluchi_koderu[6]=0x5;//kl3h
                 ;    4878 	kluchi_koderu[7]=0xf6;//kl3l
                 ;    4879 
                 ;    4880 }
                 ;    4881 
                 ;    4882 void podgotovka_kluch_dekoderu(void)
                 ;    4883 {
                 _podgotovka_kluch_dekoderu:
                 ;    4884 int a,i;
                 ;    4885 
                 ;    4886 	kluchi_dekoderu[0]=0x55;//confkluch1;
001b78 940e 2abe 	CALL __SAVELOCR4
                 ;	a -> R16,R17
                 ;	i -> R18,R19
001b7a e5e5      	LDI  R30,LOW(85)
001b7b 93e0 0a04 	STS  _kluchi_dekoderu,R30
                 ;    4887 	kluchi_dekoderu[1]=confkluch2;
001b7d e0a5
001b7e e0ba      	__POINTW2MN _kluchi_dekoderu,1
001b7f 91e0 0a24 	LDS  R30,_confkluch2
001b81 91f0 0a25 	LDS  R31,_confkluch2+1
001b83 93ec      	ST   X,R30
                 ;    4888 	kluchi_dekoderu[2]=0x55;//krutnut;
001b84 e5e5      	LDI  R30,LOW(85)
001b85 93e0 0a06 	__PUTB1MN _kluchi_dekoderu,2
                 ;    4889 	kluchi_dekoderu[3]=0x55;//kolvo_abonentov;
001b87 93e0 0a07 	__PUTB1MN _kluchi_dekoderu,3
                 ;    4890 	kluchi_dekoderu[4]=kolvo_stvolov;
001b89 e0a8
001b8a e0ba      	__POINTW2MN _kluchi_dekoderu,4
001b8b 91e0 0a2e 	LDS  R30,_kolvo_stvolov
001b8d 93ec      	ST   X,R30
                 ;    4891 	kluchi_dekoderu[5]=0x55;//rezerv
001b8e e5e5      	LDI  R30,LOW(85)
001b8f 93e0 0a09 	__PUTB1MN _kluchi_dekoderu,5
                 ;    4892 	kluchi_dekoderu[6]=0x55;//rezerv
001b91 93e0 0a0a 	__PUTB1MN _kluchi_dekoderu,6
                 ;    4893 
                 ;    4894 
                 ;    4895 	kluchi_dekoderu[7]=kluchi_koderu[0];//f_buff_kluch[86]^f_buff_kluch[225];//kl0h
001b93 91e0 09fc 	LDS  R30,_kluchi_koderu
001b95 93e0 0a0b 	__PUTB1MN _kluchi_dekoderu,7
                 ;    4896 	kluchi_dekoderu[8]=kluchi_koderu[1];//	f_buff_kluch[89]^f_buff_kluch[225];//kl0l
001b97 91e0 09fd 	__GETB1MN _kluchi_koderu,1
001b99 93e0 0a0c 	__PUTB1MN _kluchi_dekoderu,8
                 ;    4897 	kluchi_dekoderu[9]=kluchi_koderu[2];//f_buff_kluch[131]^f_buff_kluch[225];//kl1h
001b9b 91e0 09fe 	__GETB1MN _kluchi_koderu,2
001b9d 93e0 0a0d 	__PUTB1MN _kluchi_dekoderu,9
                 ;    4898 	kluchi_dekoderu[10]=kluchi_koderu[3];//f_buff_kluch[141]^f_buff_kluch[225];//kl1l
001b9f 91e0 09ff 	__GETB1MN _kluchi_koderu,3
001ba1 93e0 0a0e 	__PUTB1MN _kluchi_dekoderu,10
                 ;    4899 	kluchi_dekoderu[11]=kluchi_koderu[4];//f_buff_kluch[215]^f_buff_kluch[225];//kl2h
001ba3 91e0 0a00 	__GETB1MN _kluchi_koderu,4
001ba5 93e0 0a0f 	__PUTB1MN _kluchi_dekoderu,11
                 ;    4900 	kluchi_dekoderu[12]=kluchi_koderu[5];//f_buff_kluch[241]^f_buff_kluch[225];//kl2l
001ba7 91e0 0a01 	__GETB1MN _kluchi_koderu,5
001ba9 93e0 0a10 	__PUTB1MN _kluchi_dekoderu,12
                 ;    4901 	kluchi_dekoderu[13]=kluchi_koderu[6];//f_buff_kluch[162]^f_buff_kluch[225];//kl3h
001bab 91e0 0a02 	__GETB1MN _kluchi_koderu,6
001bad 93e0 0a11 	__PUTB1MN _kluchi_dekoderu,13
                 ;    4902 	kluchi_dekoderu[14]=kluchi_koderu[7];//f_buff_kluch[169]^f_buff_kluch[225];//kl3l
001baf 91e0 0a03 	__GETB1MN _kluchi_koderu,7
001bb1 93e0 0a12 	__PUTB1MN _kluchi_dekoderu,14
                 ;    4903 
                 ;    4904 	a=0;
001bb3 e000
001bb4 e010      	__GETWRN 16,17,0
                 ;    4905 	for (i=0;i<15;i++)
001bb5 e020
001bb6 e030      	__GETWRN 18,19,0
                 _0x3AF:
001bb7 302f
001bb8 e0e0
001bb9 073e      	__CPWRN 18,19,15
001bba f46c      	BRGE _0x3B0
                 ;    4906 	{
                 ;    4907 		a=a+kluchi_dekoderu[i];
001bbb e0a4      	LDI  R26,LOW(_kluchi_dekoderu)
001bbc e0ba      	LDI  R27,HIGH(_kluchi_dekoderu)
001bbd 0fa2      	ADD  R26,R18
001bbe 1fb3      	ADC  R27,R19
001bbf 91ec      	LD   R30,X
001bc0 01d8      	MOVW R26,R16
001bc1 e0f0      	LDI  R31,0
001bc2 0fea      	ADD  R30,R26
001bc3 1ffb      	ADC  R31,R27
001bc4 018f      	MOVW R16,R30
                 ;    4908 	}
001bc5 5f2f
001bc6 4f3f      	__ADDWRN 18,19,1
001bc7 cfef      	RJMP _0x3AF
                 _0x3B0:
                 ;    4909 	a=-1-a;
001bc8 efef      	LDI  R30,LOW(65535)
001bc9 efff      	LDI  R31,HIGH(65535)
001bca 1be0      	SUB  R30,R16
001bcb 0bf1      	SBC  R31,R17
001bcc 018f      	MOVW R16,R30
                 ;    4910 	kluchi_dekoderu[15]=a;
001bcd 9300 0a13 	__PUTBMRN _kluchi_dekoderu,15,16
                 ;    4911 }
001bcf c249      	RJMP _0x4C4
                 ;    4912 
                 ;    4913 //генерация ключей
                 ;    4914 void g_kod(void)	
                 ;    4915 {
                 _g_kod:
                 ;    4916 	if  (ver_kl & 0x80)
001bd0 91e0 0a28 	LDS  R30,_ver_kl
001bd2 78e0      	ANDI R30,LOW(0x80)
001bd3 f089      	BREQ _0x3B1
                 ;    4917 	{
                 ;    4918 	gshum7();
001bd4 d134      	RCALL _gshum7
                 ;    4919 	kluchi_koderu[0]=gshch7;//f_buff_kluch[86]^f_buff_kluch[225];//kl0h
001bd5 91e0 0a20 	LDS  R30,_gshch7
001bd7 93e0 09fc 	STS  _kluchi_koderu,R30
                 ;    4920 	gshum7();
001bd9 d12f      	RCALL _gshum7
                 ;    4921 	kluchi_koderu[1]=gshch7;//f_buff_kluch[89]^f_buff_kluch[225];//kl0l
001bda efad
001bdb e0b9      	__POINTW2MN _kluchi_koderu,1
001bdc 940e 2850 	CALL SUBOPT_0xA5
                 ;    4922 	gshum7();
                 ;    4923 	kluchi_koderu[4]=gshch7;//f_buff_kluch[215]^f_buff_kluch[225];//kl2h
001bde e0a0
001bdf e0ba      	__POINTW2MN _kluchi_koderu,4
001be0 940e 2850 	CALL SUBOPT_0xA5
                 ;    4924 	gshum7();
                 ;    4925 	kluchi_koderu[5]=gshch7;//f_buff_kluch[241]^f_buff_kluch[225];//kl2l
001be2 e0a1
001be3 e0ba      	__POINTW2MN _kluchi_koderu,5
001be4 c00f      	RJMP _0x4F0
                 ;    4926 	
                 ;    4927 	}
                 ;    4928 	else
                 _0x3B1:
                 ;    4929 	{
                 ;    4930 	gshum7();
001be5 d123      	RCALL _gshum7
                 ;    4931 	kluchi_koderu[2]=gshch7;//f_buff_kluch[131]^f_buff_kluch[225];//kl1h
001be6 efae
001be7 e0b9      	__POINTW2MN _kluchi_koderu,2
001be8 940e 2850 	CALL SUBOPT_0xA5
                 ;    4932 	gshum7();
                 ;    4933 	kluchi_koderu[3]=gshch7;//f_buff_kluch[141]^f_buff_kluch[225];//kl1l
001bea efaf
001beb e0b9      	__POINTW2MN _kluchi_koderu,3
001bec 940e 2850 	CALL SUBOPT_0xA5
                 ;    4934 	gshum7();
                 ;    4935 	kluchi_koderu[6]=gshch7;//f_buff_kluch[162]^f_buff_kluch[225];//kl3h
001bee e0a2
001bef e0ba      	__POINTW2MN _kluchi_koderu,6
001bf0 940e 2850 	CALL SUBOPT_0xA5
                 ;    4936 	gshum7();
                 ;    4937 	kluchi_koderu[7]=gshch7;//f_buff_kluch[169]^f_buff_kluch[225];//kl3l           
001bf2 e0a3
001bf3 e0ba      	__POINTW2MN _kluchi_koderu,7
                 _0x4F0:
001bf4 91e0 0a20 	LDS  R30,_gshch7
001bf6 91f0 0a21 	LDS  R31,_gshch7+1
001bf8 93ec      	ST   X,R30
                 ;    4938 	
                 ;    4939 	}	 
                 ;    4940 	podgotovka_kluch_dekoderu();
001bf9 940e 1b78 	CALL _podgotovka_kluch_dekoderu
                 ;    4941 }
001bfb 9508      	RET
                 ;    4942 
                 ;    4943 //переключение версии ключей
                 ;    4944 void men_ver_kl(void)	
                 ;    4945 {
                 _men_ver_kl:
                 ;    4946 	if  (ver_kl & 0x80)
001bfc 91e0 0a28 	LDS  R30,_ver_kl
001bfe 78e0      	ANDI R30,LOW(0x80)
001bff f059      	BREQ _0x3B3
                 ;    4947 	{
                 ;    4948 		ver_kl=ver_kl & 0x7f;
001c00 91e0 0a28 	LDS  R30,_ver_kl
001c02 91f0 0a29 	LDS  R31,_ver_kl+1
001c04 77ef      	ANDI R30,LOW(0x7F)
001c05 70f0      	ANDI R31,HIGH(0x7F)
001c06 93e0 0a28 	STS  _ver_kl,R30
001c08 93f0 0a29 	STS  _ver_kl+1,R31
                 ;    4949 	}
                 ;    4950 	else
001c0a c005      	RJMP _0x3B4
                 _0x3B3:
                 ;    4951 	{
                 ;    4952 		ver_kl=ver_kl | 0x80;
001c0b 91e0 0a28 	LDS  R30,_ver_kl
001c0d 68e0      	ORI  R30,0x80
001c0e 93e0 0a28 	STS  _ver_kl,R30
                 ;    4953 	}
                 _0x3B4:
                 ;    4954 }
001c10 9508      	RET
                 ;    4955 
                 ;    4956 	
                 ;    4957 //для закрутки буфера передачи
                 ;    4958 void g_klucha1(void) 
                 ;    4959 {
                 _g_klucha1:
                 ;    4960 int a,b,i;
                 ;    4961 		a=gshch1 & confkluch1;
001c11 940e 2abc 	CALL __SAVELOCR6
                 ;	a -> R16,R17
                 ;	b -> R18,R19
                 ;	i -> R20,R21
001c13 91e0 0a22 	LDS  R30,_confkluch1
001c15 91f0 0a23 	LDS  R31,_confkluch1+1
001c17 91a0 0a14 	LDS  R26,_gshch1
001c19 91b0 0a15 	LDS  R27,_gshch1+1
001c1b 23ea      	AND  R30,R26
001c1c 23fb      	AND  R31,R27
001c1d 018f      	MOVW R16,R30
                 ;    4962 		b=0;
001c1e e020
001c1f e030      	__GETWRN 18,19,0
                 ;    4963 		for (i=0;i<16;i++)
001c20 e040
001c21 e050      	__GETWRN 20,21,0
                 _0x3B6:
001c22 3140
001c23 e0e0
001c24 075e      	__CPWRN 20,21,16
001c25 f44c      	BRGE _0x3B7
                 ;    4964 		{
                 ;    4965 			b=b^a;
001c26 2720
001c27 2731      	__EORWRR 18,19,16,17
                 ;    4966 			b=b & 1;
001c28 7021
001c29 7030      	__ANDWRN 18,19,1
                 ;    4967 			a>>=1;
001c2a 9515      	ASR  R17
001c2b 9507      	ROR  R16
                 ;    4968 		}
001c2c 5f4f
001c2d 4f5f      	__ADDWRN 20,21,1
001c2e cff3      	RJMP _0x3B6
                 _0x3B7:
                 ;    4969 		gshch1<<=1;
001c2f 91e0 0a14 	LDS  R30,_gshch1
001c31 91f0 0a15 	LDS  R31,_gshch1+1
001c33 0fee      	LSL  R30
001c34 1fff      	ROL  R31
001c35 93e0 0a14 	STS  _gshch1,R30
001c37 93f0 0a15 	STS  _gshch1+1,R31
                 ;    4970 		gshch1=gshch1 | b;	//or
001c39 01f9      	MOVW R30,R18
001c3a 91a0 0a14 	LDS  R26,_gshch1
001c3c 91b0 0a15 	LDS  R27,_gshch1+1
001c3e 2bea      	OR   R30,R26
001c3f 2bfb      	OR   R31,R27
001c40 93e0 0a14 	STS  _gshch1,R30
001c42 93f0 0a15 	STS  _gshch1+1,R31
                 ;    4971 }
001c44 c137      	RJMP _0x4C5
                 ;    4972 
                 ;    4973 //кодирование некоторых параметров лдя совместимости
                 ;    4974 void g_klucha2(void)	
                 ;    4975 {
                 _g_klucha2:
                 ;    4976 int a,b,i;
                 ;    4977 		a=gshch2 & confkluch2;
001c45 940e 2abc 	CALL __SAVELOCR6
                 ;	a -> R16,R17
                 ;	b -> R18,R19
                 ;	i -> R20,R21
001c47 91e0 0a24 	LDS  R30,_confkluch2
001c49 91f0 0a25 	LDS  R31,_confkluch2+1
001c4b 91a0 0a16 	LDS  R26,_gshch2
001c4d 91b0 0a17 	LDS  R27,_gshch2+1
001c4f 23ea      	AND  R30,R26
001c50 23fb      	AND  R31,R27
001c51 018f      	MOVW R16,R30
                 ;    4978 		b=0;
001c52 e020
001c53 e030      	__GETWRN 18,19,0
                 ;    4979 		for (i=0;i<16;i++)
001c54 e040
001c55 e050      	__GETWRN 20,21,0
                 _0x3B9:
001c56 3140
001c57 e0e0
001c58 075e      	__CPWRN 20,21,16
001c59 f44c      	BRGE _0x3BA
                 ;    4980 		{
                 ;    4981 			b=b^a;
001c5a 2720
001c5b 2731      	__EORWRR 18,19,16,17
                 ;    4982 			b=b & 1;
001c5c 7021
001c5d 7030      	__ANDWRN 18,19,1
                 ;    4983 			a>>=1;
001c5e 9515      	ASR  R17
001c5f 9507      	ROR  R16
                 ;    4984 		}
001c60 5f4f
001c61 4f5f      	__ADDWRN 20,21,1
001c62 cff3      	RJMP _0x3B9
                 _0x3BA:
                 ;    4985 		gshch2<<=1;
001c63 91e0 0a16 	LDS  R30,_gshch2
001c65 91f0 0a17 	LDS  R31,_gshch2+1
001c67 0fee      	LSL  R30
001c68 1fff      	ROL  R31
001c69 93e0 0a16 	STS  _gshch2,R30
001c6b 93f0 0a17 	STS  _gshch2+1,R31
                 ;    4986 		gshch2=gshch2 | b;	//or
001c6d 01f9      	MOVW R30,R18
001c6e 91a0 0a16 	LDS  R26,_gshch2
001c70 91b0 0a17 	LDS  R27,_gshch2+1
001c72 2bea      	OR   R30,R26
001c73 2bfb      	OR   R31,R27
001c74 93e0 0a16 	STS  _gshch2,R30
001c76 93f0 0a17 	STS  _gshch2+1,R31
                 ;    4987 }
001c78 c103      	RJMP _0x4C5
                 ;    4988 
                 ;    4989 
                 ;    4990 //dlja peredachi Kazakovu
                 ;    4991 void gshum3(void)	
                 ;    4992 {
                 _gshum3:
                 ;    4993 int a,b,i;
                 ;    4994 		a=gshch3 & conf3;
001c79 940e 2abc 	CALL __SAVELOCR6
                 ;	a -> R16,R17
                 ;	b -> R18,R19
                 ;	i -> R20,R21
001c7b 91e0 0a18 	LDS  R30,_gshch3
001c7d 91f0 0a19 	LDS  R31,_gshch3+1
001c7f 7be8      	ANDI R30,LOW(0xB8)
001c80 70f0      	ANDI R31,HIGH(0xB8)
001c81 018f      	MOVW R16,R30
                 ;    4995 		b=0;
001c82 e020
001c83 e030      	__GETWRN 18,19,0
                 ;    4996 		for (i=0;i<16;i++)
001c84 e040
001c85 e050      	__GETWRN 20,21,0
                 _0x3BC:
001c86 3140
001c87 e0e0
001c88 075e      	__CPWRN 20,21,16
001c89 f44c      	BRGE _0x3BD
                 ;    4997 		{
                 ;    4998 			b=b^a;
001c8a 2720
001c8b 2731      	__EORWRR 18,19,16,17
                 ;    4999 			b=b & 1;
001c8c 7021
001c8d 7030      	__ANDWRN 18,19,1
                 ;    5000 			a>>=1;
001c8e 9515      	ASR  R17
001c8f 9507      	ROR  R16
                 ;    5001 
                 ;    5002 		}
001c90 5f4f
001c91 4f5f      	__ADDWRN 20,21,1
001c92 cff3      	RJMP _0x3BC
                 _0x3BD:
                 ;    5003 		gshch3<<=1;
001c93 91e0 0a18 	LDS  R30,_gshch3
001c95 91f0 0a19 	LDS  R31,_gshch3+1
001c97 0fee      	LSL  R30
001c98 1fff      	ROL  R31
001c99 93e0 0a18 	STS  _gshch3,R30
001c9b 93f0 0a19 	STS  _gshch3+1,R31
                 ;    5004 		gshch3=gshch3 | b;
001c9d 01f9      	MOVW R30,R18
001c9e 91a0 0a18 	LDS  R26,_gshch3
001ca0 91b0 0a19 	LDS  R27,_gshch3+1
001ca2 2bea      	OR   R30,R26
001ca3 2bfb      	OR   R31,R27
001ca4 93e0 0a18 	STS  _gshch3,R30
001ca6 93f0 0a19 	STS  _gshch3+1,R31
                 ;    5005 }
001ca8 c0d3      	RJMP _0x4C5
                 ;    5006 
                 ;    5007 //маскировка пакета в линю
                 ;    5008 void gshum4(void)	
                 ;    5009 {
                 _gshum4:
                 ;    5010 int a,b,i; 
                 ;    5011 
                 ;    5012 		a=gshch4 & conf4;
001ca9 940e 2abc 	CALL __SAVELOCR6
                 ;	a -> R16,R17
                 ;	b -> R18,R19
                 ;	i -> R20,R21
001cab 91e0 0a1a 	LDS  R30,_gshch4
001cad 91f0 0a1b 	LDS  R31,_gshch4+1
001caf 70e0      	ANDI R30,LOW(0x500)
001cb0 70f5      	ANDI R31,HIGH(0x500)
001cb1 018f      	MOVW R16,R30
                 ;    5013 		b=0;
001cb2 e020
001cb3 e030      	__GETWRN 18,19,0
                 ;    5014 		for (i=0;i<16;i++)
001cb4 e040
001cb5 e050      	__GETWRN 20,21,0
                 _0x3BF:
001cb6 3140
001cb7 e0e0
001cb8 075e      	__CPWRN 20,21,16
001cb9 f44c      	BRGE _0x3C0
                 ;    5015 		{
                 ;    5016 			b=b^a;
001cba 2720
001cbb 2731      	__EORWRR 18,19,16,17
                 ;    5017 			b=b & 1;
001cbc 7021
001cbd 7030      	__ANDWRN 18,19,1
                 ;    5018 			a>>=1;
001cbe 9515      	ASR  R17
001cbf 9507      	ROR  R16
                 ;    5019 
                 ;    5020 		}
001cc0 5f4f
001cc1 4f5f      	__ADDWRN 20,21,1
001cc2 cff3      	RJMP _0x3BF
                 _0x3C0:
                 ;    5021 		gshch4<<=1;
001cc3 91e0 0a1a 	LDS  R30,_gshch4
001cc5 91f0 0a1b 	LDS  R31,_gshch4+1
001cc7 0fee      	LSL  R30
001cc8 1fff      	ROL  R31
001cc9 93e0 0a1a 	STS  _gshch4,R30
001ccb 93f0 0a1b 	STS  _gshch4+1,R31
                 ;    5022 		gshch4=gshch4 | b;	//or
001ccd 01f9      	MOVW R30,R18
001cce 91a0 0a1a 	LDS  R26,_gshch4
001cd0 91b0 0a1b 	LDS  R27,_gshch4+1
001cd2 2bea      	OR   R30,R26
001cd3 2bfb      	OR   R31,R27
001cd4 93e0 0a1a 	STS  _gshch4,R30
001cd6 93f0 0a1b 	STS  _gshch4+1,R31
                 ;    5023 }
001cd8 c0a3      	RJMP _0x4C5
                 ;    5024 
                 ;    5025 //маскировка пакета Казакову
                 ;    5026 void gshum5(void)		
                 ;    5027 {
                 _gshum5:
                 ;    5028 int a,b,i;
                 ;    5029 		a=gshch5 & conf5;
001cd9 940e 2abc 	CALL __SAVELOCR6
                 ;	a -> R16,R17
                 ;	b -> R18,R19
                 ;	i -> R20,R21
001cdb 91e0 0a1c 	LDS  R30,_gshch5
001cdd 91f0 0a1d 	LDS  R31,_gshch5+1
001cdf 74e0      	ANDI R30,LOW(0x740)
001ce0 70f7      	ANDI R31,HIGH(0x740)
001ce1 018f      	MOVW R16,R30
                 ;    5030 		b=0;
001ce2 e020
001ce3 e030      	__GETWRN 18,19,0
                 ;    5031 		for (i=0;i<16;i++)
001ce4 e040
001ce5 e050      	__GETWRN 20,21,0
                 _0x3C2:
001ce6 3140
001ce7 e0e0
001ce8 075e      	__CPWRN 20,21,16
001ce9 f44c      	BRGE _0x3C3
                 ;    5032 		{
                 ;    5033 			b=b^a;
001cea 2720
001ceb 2731      	__EORWRR 18,19,16,17
                 ;    5034 			b=b & 1;
001cec 7021
001ced 7030      	__ANDWRN 18,19,1
                 ;    5035 			a>>=1;
001cee 9515      	ASR  R17
001cef 9507      	ROR  R16
                 ;    5036 
                 ;    5037 		}
001cf0 5f4f
001cf1 4f5f      	__ADDWRN 20,21,1
001cf2 cff3      	RJMP _0x3C2
                 _0x3C3:
                 ;    5038 		gshch5<<=1;
001cf3 91e0 0a1c 	LDS  R30,_gshch5
001cf5 91f0 0a1d 	LDS  R31,_gshch5+1
001cf7 0fee      	LSL  R30
001cf8 1fff      	ROL  R31
001cf9 93e0 0a1c 	STS  _gshch5,R30
001cfb 93f0 0a1d 	STS  _gshch5+1,R31
                 ;    5039 		gshch5=gshch5 | b;	//or
001cfd 01f9      	MOVW R30,R18
001cfe 91a0 0a1c 	LDS  R26,_gshch5
001d00 91b0 0a1d 	LDS  R27,_gshch5+1
001d02 2bea      	OR   R30,R26
001d03 2bfb      	OR   R31,R27
001d04 93e0 0a1c 	STS  _gshch5,R30
001d06 93f0 0a1d 	STS  _gshch5+1,R31
                 ;    5040 }
001d08 c073      	RJMP _0x4C5
                 ;    5041 
                 ;    5042 //декодирование файла flash.bin
                 ;    5043 void gshum6(void)		
                 ;    5044 {
                 ;    5045 int a,b,i;
                 ;    5046 		a=gshch6 & conf6;
                 ;	a -> R16,R17
                 ;	b -> R18,R19
                 ;	i -> R20,R21
                 ;    5047 		b=0;
                 ;    5048 		for (i=0;i<16;i++)
                 ;    5049 		{
                 ;    5050 			b=b^a;
                 ;    5051 			b=b & 1;
                 ;    5052 			a>>=1;
                 ;    5053 
                 ;    5054 		}
                 ;    5055 		gshch6<<=1;
                 ;    5056 		gshch6=gshch6 | b;	//or
                 ;    5057 }
                 ;    5058 
                 ;    5059 //генерация ключей
                 ;    5060 //декодирование файла flash.bin при загрузке из файла
                 ;    5061 void gshum7(void)	
                 ;    5062 {
                 _gshum7:
                 ;    5063 int a,b,i;
                 ;    5064 gshum7st:
001d09 940e 2abc 	CALL __SAVELOCR6
                 ;	a -> R16,R17
                 ;	b -> R18,R19
                 ;	i -> R20,R21
                 _0x3C7:
                 ;    5065 		a=gshch7 & conf7;
001d0b 91e0 0a20 	LDS  R30,_gshch7
001d0d 91f0 0a21 	LDS  R31,_gshch7+1
001d0f 75e1      	ANDI R30,LOW(0x751)
001d10 70f7      	ANDI R31,HIGH(0x751)
001d11 018f      	MOVW R16,R30
                 ;    5066 		b=0;
001d12 e020
001d13 e030      	__GETWRN 18,19,0
                 ;    5067 		for (i=0;i<16;i++)
001d14 e040
001d15 e050      	__GETWRN 20,21,0
                 _0x3C9:
001d16 3140
001d17 e0e0
001d18 075e      	__CPWRN 20,21,16
001d19 f44c      	BRGE _0x3CA
                 ;    5068 		{
                 ;    5069 			b=b^a;
001d1a 2720
001d1b 2731      	__EORWRR 18,19,16,17
                 ;    5070 			b=b & 1;
001d1c 7021
001d1d 7030      	__ANDWRN 18,19,1
                 ;    5071 			a>>=1;
001d1e 9515      	ASR  R17
001d1f 9507      	ROR  R16
                 ;    5072 
                 ;    5073 		}
001d20 5f4f
001d21 4f5f      	__ADDWRN 20,21,1
001d22 cff3      	RJMP _0x3C9
                 _0x3CA:
                 ;    5074 		gshch7<<=1;
001d23 91e0 0a20 	LDS  R30,_gshch7
001d25 91f0 0a21 	LDS  R31,_gshch7+1
001d27 0fee      	LSL  R30
001d28 1fff      	ROL  R31
001d29 93e0 0a20 	STS  _gshch7,R30
001d2b 93f0 0a21 	STS  _gshch7+1,R31
                 ;    5075 		gshch7=gshch7 | b;	//or
001d2d 01f9      	MOVW R30,R18
001d2e 91a0 0a20 	LDS  R26,_gshch7
001d30 91b0 0a21 	LDS  R27,_gshch7+1
001d32 2bea      	OR   R30,R26
001d33 2bfb      	OR   R31,R27
001d34 93e0 0a20 	STS  _gshch7,R30
001d36 93f0 0a21 	STS  _gshch7+1,R31
                 ;    5076 		a=gshch7 &0xff;
001d38 70f0      	ANDI R31,HIGH(0xFF)
001d39 018f      	MOVW R16,R30
                 ;    5077 		if (a==0) goto gshum7st;
001d3a 2e00      	MOV  R0,R16
001d3b 2a01      	OR   R0,R17
001d3c f271      	BREQ _0x3C7
                 ;    5078 }
001d3d c03e      	RJMP _0x4C5
                 ;    5079 #include "Coding.h"
                 ;    5080 
                 ;    5081 #define ver_po 2					// Версия данного ПО
                 ;    5082 #define pozkl 26					//позиция ключа для совместимости с ver 1.
                 ;    5083 #define kolvo_sektorov 123     
                 ;    5084 
                 ;    5085 #define	p_progf			1
                 ;    5086 #define	p_koderu		3
                 ;    5087 #define	p_kluchi		5
                 ;    5088 #define p_razresh		6
                 ;    5089 #define p_ciklovogo	8
                 ;    5090 #define	p_flagov		9			//пакет флагов
                 ;    5091 
                 ;    5092 // формируем пакет для передачи в линию
                 ;    5093 void packCRC (void)
                 ;    5094 {
                 _packCRC:
                 ;    5095 		u16 b, crc=0, temp = Start_point_of_Dann_TX_TWI;
                 ;    5096     
                 ;    5097     	txBuffer[temp++] = PACKHDR;		 	// заголовок
001d3e 940e 2abc 	CALL __SAVELOCR6
                 ;	b -> R16,R17
                 ;	crc -> R18,R19
                 ;	temp -> R20,R21
001d40 e020      	LDI  R18,0
001d41 e030      	LDI  R19,0
001d42 e042      	LDI  R20,2
001d43 e050      	LDI  R21,0
001d44 01fa      	MOVW R30,R20
001d45 5f4f
001d46 4f5f      	__ADDWRN 20,21,1
001d47 940e 2857 	CALL SUBOPT_0xA6
                 ;    5098 		txBuffer[temp++] = lbuff+3;            		// длина (+3 - тк. вычлось при приеме)
001d49 01fa      	MOVW R30,R20
001d4a 5f4f
001d4b 4f5f      	__ADDWRN 20,21,1
001d4c 58e0      	SUBI R30,LOW(-_txBuffer)
001d4d 4ffc      	SBCI R31,HIGH(-_txBuffer)
001d4e 01df      	MOVW R26,R30
001d4f eeef      	LDI  R30,LOW(239)
001d50 93ec      	ST   X,R30
                 ;    5099 //		txBuffer[temp++] = 255;                		// адрес
                 ;    5100 		txBuffer[temp++] =Internal_Packet; 		// адрес
001d51 01fa      	MOVW R30,R20
001d52 5f4f
001d53 4f5f      	__ADDWRN 20,21,1
001d54 940e 285d 	CALL SUBOPT_0xA7
                 ;    5101 		txBuffer[temp++] = PT_SCRDATA ;	 	// тип
001d56 01fa      	MOVW R30,R20
001d57 5f4f
001d58 4f5f      	__ADDWRN 20,21,1
001d59 58e0      	SUBI R30,LOW(-_txBuffer)
001d5a 4ffc      	SBCI R31,HIGH(-_txBuffer)
001d5b 01df      	MOVW R26,R30
001d5c eae1      	LDI  R30,LOW(161)
001d5d 93ec      	ST   X,R30
                 ;    5102 
                 ;    5103 		for (b=0; b<=txBuffer[Start_point_of_Dann_TX_TWI+1]; b++)	crc +=txBuffer[Start_point_of_Dann_TX_TWI+b] ;				
001d5e e000
001d5f e010      	__GETWRN 16,17,0
                 _0x3CD:
001d60 91e0 0383 	__GETB1MN _txBuffer,3
001d62 01d8      	MOVW R26,R16
001d63 e0f0      	LDI  R31,0
001d64 17ea      	CP   R30,R26
001d65 07fb      	CPC  R31,R27
001d66 f040      	BRLO _0x3CE
001d67 01f8      	MOVW R30,R16
001d68 57ee
001d69 4ffc      	__ADDW1MN _txBuffer,2
001d6a 940e 2863 	CALL SUBOPT_0xA8
                 ;    5104 		txBuffer[Start_point_of_Dann_TX_TWI+lbuff+4] = crc;					// CRC
001d6c 5f0f
001d6d 4f1f      	__ADDWRN 16,17,1
001d6e cff1      	RJMP _0x3CD
                 _0x3CE:
001d6f 9320 0472 	__PUTBMRN _txBuffer,242,18
                 ;    5105 		
                 ;    5106 		// передача в канал
                 ;    5107 		TWI_operation = SEND_DATA; 
001d71 e0e1      	LDI  R30,LOW(1)
001d72 93e0 0621 	STS  _TWI_operation,R30
                 ;    5108 		while (! RUN_TWI ( TWI_GEN_CALL, TWI_CMD_MASTER_WRITE,
                 _0x3CF:
                 ;    5109 								 txBuffer[Start_point_of_Dann_TX_TWI+1] +4 ) );
001d74 e0e0      	LDI  R30,LOW(0)
001d75 940e 286a 	CALL SUBOPT_0xA9
001d77 91e0 0383 	__GETB1MN _txBuffer,3
001d79 940e 286e 	CALL SUBOPT_0xAA
001d7b f3c1      	BREQ _0x3CF
                 ;    5110 
                 ;    5111 }
                 _0x4C5:
001d7c 940e 2ac3 	CALL __LOADLOCR6
001d7e 9626      	ADIW R28,6
001d7f 9508      	RET
                 ;    5112 
                 ;    5113 
                 ;    5114 
                 ;    5115 
                 ;    5116 //генерация пакета koderu
                 ;    5117 void g_p_koderu(void)
                 ;    5118 {
                 _g_p_koderu:
                 ;    5119 	u16 i,crc=0;
                 ;    5120 	komu=0x25;	//paket koderu
001d80 940e 2abe 	CALL __SAVELOCR4
                 ;	i -> R16,R17
                 ;	crc -> R18,R19
001d82 e020      	LDI  R18,0
001d83 e030      	LDI  R19,0
001d84 e2e5      	LDI  R30,LOW(37)
001d85 93e0 0a2a 	STS  _komu,R30
                 ;    5121 
                 ;    5122 	for (i=0;i<lbuff;i++)										// заполняем шумом буфер
001d87 e000
001d88 e010      	__GETWRN 16,17,0
                 _0x3D3:
001d89 3e0c
001d8a e0e0
001d8b 071e      	__CPWRN 16,17,236
001d8c f4d0      	BRSH _0x3D4
                 ;    5123 	{
                 ;    5124 		gshum5();
001d8d 940e 1cd9 	CALL _gshum5
                 ;    5125 		buff_kazakovu[i]= gshch5 & 0xff;
001d8f e8e6
001d90 e0f3      	__POINTW1MN _txBuffer,6
001d91 0fe0      	ADD  R30,R16
001d92 1ff1      	ADC  R31,R17
001d93 01df      	MOVW R26,R30
001d94 940e 2874 	CALL SUBOPT_0xAB
                 ;    5126 		if (buff_kazakovu[i]==0x47) buff_kazakovu[i]=0x78;		//na vsjakij sluchaj
001d96 e8e6
001d97 e0f3      	__POINTW1MN _txBuffer,6
001d98 0fe0      	ADD  R30,R16
001d99 1ff1      	ADC  R31,R17
001d9a 81e0      	LD   R30,Z
001d9b 34e7      	CPI  R30,LOW(0x47)
001d9c f439      	BRNE _0x3D5
001d9d e8e6
001d9e e0f3      	__POINTW1MN _txBuffer,6
001d9f 0fe0      	ADD  R30,R16
001da0 1ff1      	ADC  R31,R17
001da1 01df      	MOVW R26,R30
001da2 e7e8      	LDI  R30,LOW(120)
001da3 93ec      	ST   X,R30
                 ;    5127 	}
                 _0x3D5:
001da4 5f0f
001da5 4f1f      	__ADDWRN 16,17,1
001da6 cfe2      	RJMP _0x3D3
                 _0x3D4:
                 ;    5128 
                 ;    5129 	buff_kazakovu[0]=0x47;								// накладываем полезную информацию сверху
001da7 e4e7      	LDI  R30,LOW(71)
001da8 93e0 0386 	__PUTB1MN _txBuffer,6
                 ;    5130 	buff_kazakovu[1]=0x1f;	//pid h
001daa e1ef      	LDI  R30,LOW(31)
001dab 93e0 0387 	__PUTB1MN _txBuffer,7
                 ;    5131 	buff_kazakovu[2]=0xfe;	//pid l
001dad efee      	LDI  R30,LOW(254)
001dae 93e0 0388 	__PUTB1MN _txBuffer,8
                 ;    5132 
                 ;    5133 
                 ;    5134 //buff_kazakovu[6]=0;	
                 ;    5135     gshch3=buff_kazakovu[6];
001db0 91e0 038c 	__GETB1MN _txBuffer,12
001db2 e0f0      	LDI  R31,0
001db3 93e0 0a18 	STS  _gshch3,R30
001db5 93f0 0a19 	STS  _gshch3+1,R31
                 ;    5136 
                 ;    5137 	buff_kazakovu[17]=conf3 ^ buff_kazakovu[6];	//config
001db7 91e0 038c 	__GETB1MN _txBuffer,12
001db9 eba8      	LDI  R26,LOW(184)
001dba 27ea      	EOR  R30,R26
001dbb 93e0 0397 	__PUTB1MN _txBuffer,23
                 ;    5138 	buff_kazakovu[11]=komu^buff_kazakovu[6];	//komu
001dbd 91e0 038c 	__GETB1MN _txBuffer,12
001dbf 91a0 0a2a 	LDS  R26,_komu
001dc1 27ea      	EOR  R30,R26
001dc2 93e0 0391 	__PUTB1MN _txBuffer,17
                 ;    5139 
                 ;    5140 	for (i = 0; i<124; i ++)
001dc4 e000
001dc5 e010      	__GETWRN 16,17,0
                 _0x3D7:
001dc6 370c
001dc7 e0e0
001dc8 071e      	__CPWRN 16,17,124
001dc9 f4d0      	BRSH _0x3D8
                 ;    5141 	{
                 ;    5142 		gshum3();
001dca 940e 1c79 	CALL _gshum3
                 ;    5143 		buff_kazakovu[i+32] = f_buff_prog[i+1] ^ gshch3;
001dcc e8a6
001dcd e0b3      	__POINTW2MN _txBuffer,6
001dce 01f8      	MOVW R30,R16
001dcf 96b0      	ADIW R30,32
001dd0 940e 272f 	CALL SUBOPT_0x7C
001dd2 5fea
001dd3 4fff      	__ADDW1MN _f_buff_prog,1
001dd4 01df      	MOVW R26,R30
001dd5 940e 2a76 	CALL __EEPROMRDB
001dd7 940e 287b 	CALL SUBOPT_0xAC
                 ;    5144 		crc+= f_buff_prog[i+1];
001dd9 01f8      	MOVW R30,R16
001dda 5fea
001ddb 4fff      	__ADDW1MN _f_buff_prog,1
001ddc 01df      	MOVW R26,R30
001ddd 940e 2a76 	CALL __EEPROMRDB
001ddf 940e 2884 	CALL SUBOPT_0xAD
                 ;    5145 	}                                       
001de1 5f0f
001de2 4f1f      	__ADDWRN 16,17,1
001de3 cfe2      	RJMP _0x3D7
                 _0x3D8:
                 ;    5146 
                 ;    5147 	for (i = 0; i<8; i ++)
001de4 e000
001de5 e010      	__GETWRN 16,17,0
                 _0x3DA:
001de6 3008
001de7 e0e0
001de8 071e      	__CPWRN 16,17,8
001de9 f508      	BRSH _0x3DB
                 ;    5148 	{
                 ;    5149 		gshum3();
001dea 940e 1c79 	CALL _gshum3
                 ;    5150 		buff_kazakovu[i+32+124] = kluchi_koderu[i]^gshch3;
001dec e8a6
001ded e0b3      	__POINTW2MN _txBuffer,6
001dee 01f8      	MOVW R30,R16
001def 96b0      	ADIW R30,32
001df0 58e4      	SUBI R30,LOW(-124)
001df1 4fff      	SBCI R31,HIGH(-124)
001df2 0fea      	ADD  R30,R26
001df3 1ffb      	ADC  R31,R27
001df4 010f      	MOVW R0,R30
001df5 efac      	LDI  R26,LOW(_kluchi_koderu)
001df6 e0b9      	LDI  R27,HIGH(_kluchi_koderu)
001df7 0fa0      	ADD  R26,R16
001df8 1fb1      	ADC  R27,R17
001df9 91ac      	LD   R26,X
001dfa 91e0 0a18 	LDS  R30,_gshch3
001dfc 91f0 0a19 	LDS  R31,_gshch3+1
001dfe 27ea      	EOR  R30,R26
001dff 01d0      	MOVW R26,R0
001e00 93ec      	ST   X,R30
                 ;    5151 		crc+=kluchi_koderu[i];   
001e01 efac      	LDI  R26,LOW(_kluchi_koderu)
001e02 e0b9      	LDI  R27,HIGH(_kluchi_koderu)
001e03 0fa0      	ADD  R26,R16
001e04 1fb1      	ADC  R27,R17
001e05 91ec      	LD   R30,X
001e06 940e 2884 	CALL SUBOPT_0xAD
                 ;    5152 	}
001e08 5f0f
001e09 4f1f      	__ADDWRN 16,17,1
001e0a cfdb      	RJMP _0x3DA
                 _0x3DB:
                 ;    5153 
                 ;    5154 	crc = -1 -crc;
001e0b 940e 288a 	CALL SUBOPT_0xAE
                 ;    5155 	gshum3();
001e0d 940e 1c79 	CALL _gshum3
                 ;    5156 
                 ;    5157 	buff_kazakovu[32+124+8] = crc^gshch3;
001e0f 91e0 0a18 	LDS  R30,_gshch3
001e11 91f0 0a19 	LDS  R31,_gshch3+1
001e13 27e2      	EOR  R30,R18
001e14 27f3      	EOR  R31,R19
001e15 93e0 042a 	__PUTB1MN _txBuffer,170
                 ;    5158 
                 ;    5159 	packCRC();
001e17 940e 1d3e 	CALL _packCRC
                 ;    5160 }
                 _0x4C4:
001e19 940e 2ac5 	CALL __LOADLOCR4
001e1b 9624      	ADIW R28,4
001e1c 9508      	RET
                 ;    5161 
                 ;    5162 
                 ;    5163 void g_tx_kazakovu(void)
                 ;    5164 {
                 _g_tx_kazakovu:
                 ;    5165 	u8 i;
                 ;    5166 
                 ;    5167 	for (i=0;i<lbuff;i++)
001e1d 930a      	ST   -Y,R16
                 ;	i -> R16
001e1e e000      	LDI  R16,LOW(0)
                 _0x3DD:
001e1f 3e0c      	CPI  R16,236
001e20 f4b8      	BRSH _0x3DE
                 ;    5168 	{
                 ;    5169 		gshum5();
001e21 940e 1cd9 	CALL _gshum5
                 ;    5170 		buff_kazakovu[i]= (gshch5) & 0xff;
001e23 e8a6
001e24 e0b3      	__POINTW2MN _txBuffer,6
001e25 940e 2890 	CALL SUBOPT_0xAF
001e27 940e 2874 	CALL SUBOPT_0xAB
                 ;    5171 		if (buff_kazakovu[i]==0x47) buff_kazakovu[i]=0x78;		//na vsjakij sluchaj
001e29 e8a6
001e2a e0b3      	__POINTW2MN _txBuffer,6
001e2b 940e 2890 	CALL SUBOPT_0xAF
001e2d 91ac      	LD   R26,X
001e2e 34a7      	CPI  R26,LOW(0x47)
001e2f f431      	BRNE _0x3DF
001e30 e8a6
001e31 e0b3      	__POINTW2MN _txBuffer,6
001e32 940e 2890 	CALL SUBOPT_0xAF
001e34 e7e8      	LDI  R30,LOW(120)
001e35 93ec      	ST   X,R30
                 ;    5172 	}
                 _0x3DF:
001e36 5f0f      	SUBI R16,-1
001e37 cfe7      	RJMP _0x3DD
                 _0x3DE:
                 ;    5173 
                 ;    5174 	buff_kazakovu[0]=0x47;
001e38 e4e7      	LDI  R30,LOW(71)
001e39 93e0 0386 	__PUTB1MN _txBuffer,6
                 ;    5175 	buff_kazakovu[1]=0x1f;	//pid h
001e3b e1ef      	LDI  R30,LOW(31)
001e3c 93e0 0387 	__PUTB1MN _txBuffer,7
                 ;    5176 	buff_kazakovu[2]=0xfe;	//pid l
001e3e efee      	LDI  R30,LOW(254)
001e3f 93e0 0388 	__PUTB1MN _txBuffer,8
                 ;    5177                                           
                 ;    5178 	gshch3=buff_kazakovu[6];
001e41 91e0 038c 	__GETB1MN _txBuffer,12
001e43 e0f0      	LDI  R31,0
001e44 93e0 0a18 	STS  _gshch3,R30
001e46 93f0 0a19 	STS  _gshch3+1,R31
                 ;    5179 	buff_kazakovu[17]=conf3 ^ buff_kazakovu[6];	//config
001e48 91e0 038c 	__GETB1MN _txBuffer,12
001e4a eba8      	LDI  R26,LOW(184)
001e4b 27ea      	EOR  R30,R26
001e4c 93e0 0397 	__PUTB1MN _txBuffer,23
                 ;    5180 	buff_kazakovu[11]=komu^buff_kazakovu[6];	//komu
001e4e 91e0 038c 	__GETB1MN _txBuffer,12
001e50 91a0 0a2a 	LDS  R26,_komu
001e52 27ea      	EOR  R30,R26
001e53 93e0 0391 	__PUTB1MN _txBuffer,17
                 ;    5181 
                 ;    5182 	for (i = 0; i<188; i ++)
001e55 e000      	LDI  R16,LOW(0)
                 _0x3E1:
001e56 3b0c      	CPI  R16,188
001e57 f488      	BRSH _0x3E2
                 ;    5183 	{
                 ;    5184 		gshum3();
001e58 940e 1c79 	CALL _gshum3
                 ;    5185 		buff_kazakovu[i+32] =buff_wyh_paket[i]^gshch3;
001e5a e8a6
001e5b e0b3      	__POINTW2MN _txBuffer,6
001e5c 2fe0      	MOV  R30,R16
001e5d 5ee0      	SUBI R30,-LOW(32)
001e5e e0f0      	LDI  R31,0
001e5f 940e 264e 	CALL SUBOPT_0x64
001e61 e0f0      	LDI  R31,0
001e62 58e1      	SUBI R30,LOW(-_buff_wyh_paket)
001e63 4ffb      	SBCI R31,HIGH(-_buff_wyh_paket)
001e64 81e0      	LD   R30,Z
001e65 940e 287b 	CALL SUBOPT_0xAC
                 ;    5186 	}
001e67 5f0f      	SUBI R16,-1
001e68 cfed      	RJMP _0x3E1
                 _0x3E2:
                 ;    5187 
                 ;    5188 	// Передаю очередной пакет
                 ;    5189 	packCRC();
001e69 940e 1d3e 	CALL _packCRC
                 ;    5190 	
                 ;    5191 }
001e6b c3c6      	RJMP _0x4BE
                 ;    5192 
                 ;    5193 
                 ;    5194 
                 ;    5195 //генерация маскировочного пакета с помощью gshum4
                 ;    5196 void g_jadra_paketa(u8 tip)	
                 ;    5197 {
                 _g_jadra_paketa:
                 ;    5198 	int i;
                 ;    5199 
                 ;    5200 	for (i=0;i<lbuff;i++)
001e6c 931a      	ST   -Y,R17
001e6d 930a      	ST   -Y,R16
                 ;	tip -> Y+2
                 ;	i -> R16,R17
001e6e e000
001e6f e010      	__GETWRN 16,17,0
                 _0x3E4:
001e70 3e0c
001e71 e0e0
001e72 071e      	__CPWRN 16,17,236
001e73 f4dc      	BRGE _0x3E5
                 ;    5201 	{
                 ;    5202 		gshum4();
001e74 940e 1ca9 	CALL _gshum4
                 ;    5203 
                 ;    5204 		buff_wyh_paket[i]=gshch4 & 0xff;
001e76 01d8      	MOVW R26,R16
001e77 58a1      	SUBI R26,LOW(-_buff_wyh_paket)
001e78 4fbb      	SBCI R27,HIGH(-_buff_wyh_paket)
001e79 91e0 0a1a 	LDS  R30,_gshch4
001e7b 91f0 0a1b 	LDS  R31,_gshch4+1
001e7d 70f0      	ANDI R31,HIGH(0xFF)
001e7e 93ec      	ST   X,R30
                 ;    5205 		if (buff_wyh_paket[i]==0x47) buff_wyh_paket[i]=0x78;		//na vsjakij sluchaj
001e7f e7af      	LDI  R26,LOW(_buff_wyh_paket)
001e80 e0b4      	LDI  R27,HIGH(_buff_wyh_paket)
001e81 0fa0      	ADD  R26,R16
001e82 1fb1      	ADC  R27,R17
001e83 91ac      	LD   R26,X
001e84 34a7      	CPI  R26,LOW(0x47)
001e85 f431      	BRNE _0x3E6
001e86 e7af      	LDI  R26,LOW(_buff_wyh_paket)
001e87 e0b4      	LDI  R27,HIGH(_buff_wyh_paket)
001e88 0fa0      	ADD  R26,R16
001e89 1fb1      	ADC  R27,R17
001e8a e7e8      	LDI  R30,LOW(120)
001e8b 93ec      	ST   X,R30
                 ;    5206 	}
                 _0x3E6:
001e8c 5f0f
001e8d 4f1f      	__ADDWRN 16,17,1
001e8e cfe1      	RJMP _0x3E4
                 _0x3E5:
                 ;    5207 
                 ;    5208 
                 ;    5209 
                 ;    5210 	buff_wyh_paket[0]=0x47;
001e8f e4e7      	LDI  R30,LOW(71)
001e90 93e0 047f 	STS  _buff_wyh_paket,R30
                 ;    5211 	buff_wyh_paket[1]=0x1f;	//pid h
001e92 e1ef      	LDI  R30,LOW(31)
001e93 93e0 0480 	__PUTB1MN _buff_wyh_paket,1
                 ;    5212 	buff_wyh_paket[2]=0xfe;	//pid l
001e95 efee      	LDI  R30,LOW(254)
001e96 93e0 0481 	__PUTB1MN _buff_wyh_paket,2
                 ;    5213 	buff_wyh_paket[3]=schetchic_paketov_zakrytija & 0x0f;
001e98 91e0 0a2b 	LDS  R30,_schetchic_paketov_zakrytija
001e9a 70ef      	ANDI R30,LOW(0xF)
001e9b 93e0 0482 	__PUTB1MN _buff_wyh_paket,3
                 ;    5214 	schetchic_paketov_zakrytija++;
001e9d 91e0 0a2b 	LDS  R30,_schetchic_paketov_zakrytija
001e9f 5fef      	SUBI R30,-LOW(1)
001ea0 93e0 0a2b 	STS  _schetchic_paketov_zakrytija,R30
                 ;    5215 
                 ;    5216 	#ifdef DEBUG_schetchic_paketov_zakrytija
                 ;    5217 	buff_wyh_paket[8]=schetchic_paketov_zakrytija & 0xff;//
                 ;    5218 	#endif DEBUG_schetchic_paketov_zakrytija
                 ;    5219 
                 ;    5220 	buff_wyh_paket[29]=tip ;//					tip
001ea2 81ea      	LDD  R30,Y+2
001ea3 93e0 049c 	__PUTB1MN _buff_wyh_paket,29
                 ;    5221 
                 ;    5222 	i=ver_kl & 0x80;
001ea5 91e0 0a28 	LDS  R30,_ver_kl
001ea7 91f0 0a29 	LDS  R31,_ver_kl+1
001ea9 78e0      	ANDI R30,LOW(0x80)
001eaa 70f0      	ANDI R31,HIGH(0x80)
001eab 018f      	MOVW R16,R30
                 ;    5223 	buff_wyh_paket[23]=((buff_wyh_paket[23] & 0x7f) | i);//версия ключей
001eac 91e0 0496 	__GETB1MN _buff_wyh_paket,23
001eae 77ef      	ANDI R30,0x7F
001eaf 2fae      	MOV  R26,R30
001eb0 01f8      	MOVW R30,R16
001eb1 2bea      	OR   R30,R26
001eb2 93e0 0496 	__PUTB1MN _buff_wyh_paket,23
                 ;    5224 
                 ;    5225 	gshch2=buff_wyh_paket[26];
001eb4 91e0 0499 	__GETB1MN _buff_wyh_paket,26
001eb6 e0f0      	LDI  R31,0
001eb7 93e0 0a16 	STS  _gshch2,R30
001eb9 93f0 0a17 	STS  _gshch2+1,R31
                 ;    5226 	g_klucha2();
001ebb 940e 1c45 	CALL _g_klucha2
                 ;    5227 	buff_wyh_paket[17]=ver_po^gshch2 ;
001ebd 91e0 0a16 	LDS  R30,_gshch2
001ebf 91f0 0a17 	LDS  R31,_gshch2+1
001ec1 e0a2      	LDI  R26,LOW(2)
001ec2 e0b0      	LDI  R27,HIGH(2)
001ec3 27ea      	EOR  R30,R26
001ec4 93e0 0490 	__PUTB1MN _buff_wyh_paket,17
                 ;    5228 	
                 ;    5229 	i=buff_wyh_paket[7];
001ec6 9100 0486 	__GETBRMN 16,_buff_wyh_paket,7
001ec8 2711      	CLR  R17
                 ;    5230 	i=(i & 0x0f)+171;
001ec9 01f8      	MOVW R30,R16
001eca 70ef      	ANDI R30,LOW(0xF)
001ecb 70f0      	ANDI R31,HIGH(0xF)
001ecc 55e5      	SUBI R30,LOW(-171)
001ecd 4fff      	SBCI R31,HIGH(-171)
001ece 018f      	MOVW R16,R30
                 ;    5231 	gshch1=buff_wyh_paket[i];
001ecf e7af      	LDI  R26,LOW(_buff_wyh_paket)
001ed0 e0b4      	LDI  R27,HIGH(_buff_wyh_paket)
001ed1 0fa0      	ADD  R26,R16
001ed2 1fb1      	ADC  R27,R17
001ed3 91ec      	LD   R30,X
001ed4 e0f0      	LDI  R31,0
001ed5 93e0 0a14 	STS  _gshch1,R30
001ed7 93f0 0a15 	STS  _gshch1+1,R31
                 ;    5232 	buff_wyh_paket[10]=confkluch1 ^ gshch1;
001ed9 91a0 0a22 	LDS  R26,_confkluch1
001edb 91b0 0a23 	LDS  R27,_confkluch1+1
001edd 27ea      	EOR  R30,R26
001ede 93e0 0489 	__PUTB1MN _buff_wyh_paket,10
                 ;    5233 			
                 ;    5234 }
001ee0 8119      	LDD  R17,Y+1
001ee1 8108      	LDD  R16,Y+0
001ee2 c202      	RJMP _0x4C1
                 ;    5235 
                 ;    5236 
                 ;    5237 void zakrutbuf(u8 tip)
                 ;    5238 {
                 _zakrutbuf:
                 ;    5239 	u16 i,a=0;
                 ;    5240 
                 ;    5241 	for (i = 0; i<142; i ++)	a=a+buff_wyh_paket[27+i];	//a - crc
001ee3 940e 2abe 	CALL __SAVELOCR4
                 ;	tip -> Y+4
                 ;	i -> R16,R17
                 ;	a -> R18,R19
001ee5 e020      	LDI  R18,0
001ee6 e030      	LDI  R19,0
001ee7 e000
001ee8 e010      	__GETWRN 16,17,0
                 _0x3E8:
001ee9 380e
001eea e0e0
001eeb 071e      	__CPWRN 16,17,142
001eec f440      	BRSH _0x3E9
001eed 01f8      	MOVW R30,R16
001eee 56e6
001eef 4ffb      	__ADDW1MN _buff_wyh_paket,27
001ef0 940e 2863 	CALL SUBOPT_0xA8
                 ;    5242 
                 ;    5243 	a=-1-a;
001ef2 5f0f
001ef3 4f1f      	__ADDWRN 16,17,1
001ef4 cff4      	RJMP _0x3E8
                 _0x3E9:
001ef5 940e 288a 	CALL SUBOPT_0xAE
                 ;    5244 	buff_wyh_paket[27+142]=a;
001ef7 9320 0528 	__PUTBMRN _buff_wyh_paket,169,18
                 ;    5245 	buff_wyh_paket[27+143]=a/256;	//crc
001ef9 9330 0529 	__PUTBMRN _buff_wyh_paket,170,19
                 ;    5246 
                 ;    5247 	for (i = 0; i<144; i ++)
001efb e000
001efc e010      	__GETWRN 16,17,0
                 _0x3EB:
001efd 3900
001efe e0e0
001eff 071e      	__CPWRN 16,17,144
001f00 f4c8      	BRSH _0x3EC
                 ;    5248 	{
                 ;    5249 
                 ;    5250 		g_klucha1();
001f01 940e 1c11 	CALL _g_klucha1
                 ;    5251 		buff_wyh_paket[27+i]=buff_wyh_paket[27+i] ^ gshch1 ^ 0xff;
001f03 01f8      	MOVW R30,R16
001f04 56e6
001f05 4ffb      	__ADDW1MN _buff_wyh_paket,27
001f06 010f      	MOVW R0,R30
001f07 01f8      	MOVW R30,R16
001f08 56e6
001f09 4ffb      	__ADDW1MN _buff_wyh_paket,27
001f0a 81e0      	LD   R30,Z
001f0b 2fae      	MOV  R26,R30
001f0c 91e0 0a14 	LDS  R30,_gshch1
001f0e 91f0 0a15 	LDS  R31,_gshch1+1
001f10 27ea      	EOR  R30,R26
001f11 efaf      	LDI  R26,LOW(255)
001f12 e0b0      	LDI  R27,HIGH(255)
001f13 27ea      	EOR  R30,R26
001f14 27fb      	EOR  R31,R27
001f15 01d0      	MOVW R26,R0
001f16 93ec      	ST   X,R30
                 ;    5252 	}
001f17 5f0f
001f18 4f1f      	__ADDWRN 16,17,1
001f19 cfe3      	RJMP _0x3EB
                 _0x3EC:
                 ;    5253 
                 ;    5254 	if (tip==9)	buff_wyh_paket[11]=buff_wyh_paket[26]^0x09;			
001f1a 81ac      	LDD  R26,Y+4
001f1b 30a9      	CPI  R26,LOW(0x9)
001f1c f439      	BRNE _0x3ED
001f1d 91e0 0499 	__GETB1MN _buff_wyh_paket,26
001f1f e0a9      	LDI  R26,LOW(9)
001f20 27ea      	EOR  R30,R26
001f21 93e0 048a 	__PUTB1MN _buff_wyh_paket,11
                 ;    5255 	else	buff_wyh_paket[11]=buff_wyh_paket[26]^0x56;			
001f23 c006      	RJMP _0x3EE
                 _0x3ED:
001f24 91e0 0499 	__GETB1MN _buff_wyh_paket,26
001f26 e5a6      	LDI  R26,LOW(86)
001f27 27ea      	EOR  R30,R26
001f28 93e0 048a 	__PUTB1MN _buff_wyh_paket,11
                 ;    5256    
                 ;    5257 }
                 _0x3EE:
001f2a c2ea      	RJMP _0x4BF
                 ;    5258 
                 ;    5259 //пакет передачи флагов закрытия программ ///////////////////
                 ;    5260 void g_p_flagov(void)
                 ;    5261 {
                 _g_p_flagov:
                 ;    5262 	komu=0x27;					//paket v liniju
001f2b e2e7      	LDI  R30,LOW(39)
001f2c 93e0 0a2a 	STS  _komu,R30
                 ;    5263 	g_jadra_paketa(p_flagov);			//генерация маскировочного пакета и ключей с помощью gshum4
001f2e e0e9      	LDI  R30,LOW(9)
001f2f 93ea      	ST   -Y,R30
001f30 940e 1e6c 	CALL _g_jadra_paketa
                 ;    5264 	zakrutbuf(p_flagov);
001f32 e0e9      	LDI  R30,LOW(9)
001f33 940e 2895 	CALL SUBOPT_0xB0
                 ;    5265 	g_tx_kazakovu();
                 ;    5266 }
001f35 9508      	RET
                 ;    5267 
                 ;    5268 
                 ;    5269 
                 ;    5270 //генерация пакета абонентам (user.bin)
                 ;    5271 void g_p_razresh(void)	
                 ;    5272 {
                 _g_p_razresh:
                 ;    5273 	u16 i; 
                 ;    5274 	u32 position = 0;
                 ;    5275 
                 ;    5276 	komu=0x26;	//paket v liniju
001f36 9724      	SBIW R28,4
001f37 e084      	LDI  R24,4
001f38 e0a0      	LDI  R26,LOW(0)
001f39 e0b0      	LDI  R27,HIGH(0)
001f3a ece0      	LDI  R30,LOW(_0x3EF*2)
001f3b e0f1      	LDI  R31,HIGH(_0x3EF*2)
001f3c 940e 2aca 	CALL __INITLOCB
001f3e 940e 289a 	CALL SUBOPT_0xB1
                 ;	i -> R16,R17
                 ;	position -> Y+2
                 ;    5277 
                 ;    5278 	g_jadra_paketa(p_razresh);//генерация маскировочного пакета и ключей с помощью gshum4
001f40 e0e6      	LDI  R30,LOW(6)
001f41 93ea      	ST   -Y,R30
001f42 940e 1e6c 	CALL _g_jadra_paketa
                 ;    5279 
                 ;    5280 	position = ((u32)schetchic_abonentov * (u32)dann_1_abon) + 4;
001f44 91e0 0a39 	LDS  R30,_schetchic_abonentov
001f46 91f0 0a3a 	LDS  R31,_schetchic_abonentov+1
001f48 2766      	CLR  R22
001f49 2777      	CLR  R23
001f4a e8a4
001f4b e0b0
001f4c e080
001f4d e090      	__GETD2N 0x84
001f4e 940e 29cd 	CALL __MULD12U
001f50 5fec
001f51 4fff
001f52 4f6f
001f53 4f7f      	__ADDD1N 4
001f54 83ea
001f55 83fb
001f56 836c
001f57 837d      	__PUTD1S 2
                 ;    5281 	fseek (fu_user,position,SEEK_SET);	// смещаем относительно текущей позиции
001f58 91e0 0729 	LDS  R30,_fu_user
001f5a 91f0 072a 	LDS  R31,_fu_user+1
001f5c 93fa      	ST   -Y,R31
001f5d 93ea      	ST   -Y,R30
001f5e 81ec
001f5f 81fd
001f60 816e
001f61 817f      	__GETD1S 4
001f62 940e 2a63 	CALL __PUTPARD1
001f64 e0e2      	LDI  R30,LOW(2)
001f65 93ea      	ST   -Y,R30
001f66 940e 1918 	CALL _fseek
                 ;    5282 
                 ;    5283 	for (i = 0; i<dann_1_abon; i ++)
001f68 e000
001f69 e010      	__GETWRN 16,17,0
                 _0x3F1:
001f6a 3804
001f6b e0e0
001f6c 071e      	__CPWRN 16,17,132
001f6d f480      	BRSH _0x3F2
                 ;    5284 	{
                 ;    5285 		if (feof(fu_user)) 
001f6e 940e 241f 	CALL SUBOPT_0x27
001f70 f469      	BRNE _0x3F2
                 ;    5286 		{
                 ;    5287 			#ifdef print
                 ;    5288 			printf("Error read base from card\n");
                 ;    5289 			#endif
                 ;    5290 			break;
                 ;    5291 		}
                 ;    5292 
                 ;    5293 		buff_wyh_paket[i+32] =fgetc(fu_user);
001f71 01f8      	MOVW R30,R16
001f72 56e1
001f73 4ffb      	__ADDW1MN _buff_wyh_paket,32
001f74 93ff      	PUSH R31
001f75 93ef      	PUSH R30
001f76 940e 23fb 	CALL SUBOPT_0x23
001f78 91af      	POP  R26
001f79 91bf      	POP  R27
001f7a 93ec      	ST   X,R30
                 ;    5294 //		#ifdef print
                 ;    5295 //		printf("%x ",buff_wyh_paket[i+32]);
                 ;    5296 //		#endif
                 ;    5297 	
                 ;    5298 	}
001f7b 5f0f
001f7c 4f1f      	__ADDWRN 16,17,1
001f7d cfec      	RJMP _0x3F1
                 _0x3F2:
                 ;    5299 //	#ifdef print
                 ;    5300 //	printf("\n -------------------------------------------------------------- \n ");
                 ;    5301 //	#endif
                 ;    5302 
                 ;    5303 	zakrutbuf(p_razresh);
001f7e e0e6      	LDI  R30,LOW(6)
001f7f 940e 2895 	CALL SUBOPT_0xB0
                 ;    5304 	g_tx_kazakovu();
                 ;    5305 }
001f81 8119      	LDD  R17,Y+1
001f82 8108      	LDD  R16,Y+0
001f83 9626      	ADIW R28,6
001f84 9508      	RET
                 ;    5306 
                 ;    5307 //генерация пакета в линию
                 ;    5308 void g_p_kluchi(void)	
                 ;    5309 {
                 _g_p_kluchi:
                 ;    5310 	u16 i;                            
                 ;    5311 	komu=0x26;						//тип пакета - в линию
001f85 940e 289a 	CALL SUBOPT_0xB1
                 ;	i -> R16,R17
                 ;    5312 
                 ;    5313 	g_jadra_paketa(p_kluchi);				//генерация маскировочного пакета и ключей с помощью gshum4
001f87 e0e5      	LDI  R30,LOW(5)
001f88 93ea      	ST   -Y,R30
001f89 940e 1e6c 	CALL _g_jadra_paketa
                 ;    5314 
                 ;    5315 	for (i = 0; i<16; i ++)
001f8b e000
001f8c e010      	__GETWRN 16,17,0
                 _0x3F5:
001f8d 3100
001f8e e0e0
001f8f 071e      	__CPWRN 16,17,16
001f90 f478      	BRSH _0x3F6
                 ;    5316 	{
                 ;    5317 		buff_wyh_paket[32+3*i]=kluchi_dekoderu[i];
001f91 01f8      	MOVW R30,R16
001f92 e0a3      	LDI  R26,LOW(3)
001f93 e0b0      	LDI  R27,HIGH(3)
001f94 940e 29c5 	CALL __MULW12U
001f96 56e1
001f97 4ffb      	__ADDW1MN _buff_wyh_paket,32
001f98 010f      	MOVW R0,R30
001f99 e0a4      	LDI  R26,LOW(_kluchi_dekoderu)
001f9a e0ba      	LDI  R27,HIGH(_kluchi_dekoderu)
001f9b 940e 26d7 	CALL SUBOPT_0x6F
                 ;    5318 	}
001f9d 5f0f
001f9e 4f1f      	__ADDWRN 16,17,1
001f9f cfed      	RJMP _0x3F5
                 _0x3F6:
                 ;    5319 	zakrutbuf(p_kluchi);
001fa0 e0e5      	LDI  R30,LOW(5)
001fa1 940e 2895 	CALL SUBOPT_0xB0
                 ;    5320 	g_tx_kazakovu();
                 ;    5321 }
001fa3 9109      	LD   R16,Y+
001fa4 9119      	LD   R17,Y+
001fa5 9508      	RET
                 ;    5322 
                 ;    5323 //пакет об окончании цикла//////////////////////////////
                 ;    5324 void g_p_ciklovogo(void)
                 ;    5325 {
                 _g_p_ciklovogo:
                 ;    5326 		komu=0x26;	//paket v liniju
001fa6 e2e6      	LDI  R30,LOW(38)
001fa7 93e0 0a2a 	STS  _komu,R30
                 ;    5327 
                 ;    5328 		g_jadra_paketa(p_ciklovogo);//генерация маскировочного пакета и ключей с помощью gshum4
001fa9 e0e8      	LDI  R30,LOW(8)
001faa 93ea      	ST   -Y,R30
001fab 940e 1e6c 	CALL _g_jadra_paketa
                 ;    5329 		zakrutbuf(p_ciklovogo);
001fad e0e8      	LDI  R30,LOW(8)
001fae 940e 2895 	CALL SUBOPT_0xB0
                 ;    5330 		g_tx_kazakovu();
                 ;    5331 
                 ;    5332 }
001fb0 9508      	RET
                 ;    5333 
                 ;    5334 // генерация пакета прошивки  FLASH для приемников
                 ;    5335 void g_p_progf(void)	
                 ;    5336 {
                 ;    5337 			u16 i;                            
                 ;    5338 
                 ;    5339 			komu=0x26;	//paket v liniju
                 ;	i -> R16,R17
                 ;    5340 
                 ;    5341 			g_jadra_paketa(p_progf);//генерация маскировочного пакета и ключей с помощью gshum4
                 ;    5342 
                 ;    5343 			buff_wyh_paket[21]=(N_sektora^buff_wyh_paket[pozkl])^0xff ;//for old
                 ;    5344 			buff_wyh_paket[19]=(ver_zeleza^buff_wyh_paket[pozkl])^0xff ;//for old
                 ;    5345 
                 ;    5346 			buff_wyh_paket[28]=N_sektora;
                 ;    5347 			buff_wyh_paket[27]=ver_zeleza;
                 ;    5348 
                 ;    5349 //			fseek (fprogflas,N_sektora*128,SEEK_SET);	// смещаем относительно текущей позиции
                 ;    5350 			fseek (fprogflas,0,SEEK_SET);	// смещаем относительно текущей позиции
                 ;    5351 			for (i = 0; i<dann_1_abon; i ++)
                 ;    5352 			{
                 ;    5353 				if (feof(fprogflas)) 
                 ;    5354 				{
                 ;    5355 //					printf ("file MASK.CHM- ERROR!");
                 ;    5356 					break;
                 ;    5357 				}
                 ;    5358 		
                 ;    5359 			buff_wyh_paket[i+32] =fgetc(fprogflas);
                 ;    5360 			}
                 ;    5361 
                 ;    5362 			zakrutbuf(p_progf);
                 ;    5363 	
                 ;    5364 			if (N_sektora<kolvo_sektorov) 	N_sektora++;
                 ;    5365 			else	N_sektora=0;
                 ;    5366 
                 ;    5367 			g_tx_kazakovu();
                 ;    5368 }
                 ;    5369 /*****************************************************************************
                 ;    5370 *
                 ;    5371 * Atmel Corporation
                 ;    5372 *
                 ;    5373 * File              : TWI_Master.c
                 ;    5374 * Compiler          : IAR EWAAVR 2.28a/3.10c
                 ;    5375 * Revision          : $Revision: 1.13 $
                 ;    5376 * Date              : $Date: 24. mai 2004 11:31:20 $
                 ;    5377 * Updated by        : $Author: ltwa $
                 ;    5378 *
                 ;    5379 * Support mail      : avr@atmel.com
                 ;    5380 *
                 ;    5381 * Supported devices : All devices with a TWI module can be used.
                 ;    5382 *                     The example is written for the ATmega16
                 ;    5383 *
                 ;    5384 * AppNote           : AVR315 - TWI Master Implementation
                 ;    5385 *
                 ;    5386 * Description       : This is a sample driver for the TWI hardware modules.
                 ;    5387 *                     It is interrupt driveren. All functionality is controlled through 
                 ;    5388 *                     passing information to and from functions. Se main.c for samples
                 ;    5389 *                     of how to use the driver.
                 ;    5390 *
                 ;    5391 *
                 ;    5392 ****************************************************************************/
                 ;    5393 
                 ;    5394 #include "TWI_Master.h"
                 ;    5395 
                 ;    5396 
                 ;    5397 static unsigned char TWI_buf[ TWI_BUFFER_SIZE ];    // Transceiver buffer
                 
                 	.DSEG
                 _TWI_buf_GA:
000a3c           	.BYTE 0xFF
                 ;    5398 static unsigned char TWI_msgSize;                   // Number of bytes to be transmitted.
                 _TWI_msgSize_GA:
000b3b           	.BYTE 0x1
                 ;    5399 static unsigned char TWI_state = TWI_NO_STATE;      // State byte. Default set to TWI_NO_STATE.
                 _TWI_state_GA:
000b3c           	.BYTE 0x1
                 ;    5400 
                 ;    5401 //union TWI_statusReg TWI_statusReg = {0};            // TWI_statusReg is defined in TWI_Master.h
                 ;    5402 
                 ;    5403 /****************************************************************************
                 ;    5404 Call this function to set up the TWI master to its initial standby state.
                 ;    5405 Remember to enable interrupts from the main application after initializing the TWI.
                 ;    5406 ****************************************************************************/
                 ;    5407 void TWI_Master_Initialise(void)
                 ;    5408 {
                 
                 	.CSEG
                 _TWI_Master_Initialise:
                 ;    5409   TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
001fb1 e0ec      	LDI  R30,LOW(12)
001fb2 93e0 0070 	STS  112,R30
                 ;    5410 // TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
                 ;    5411   TWDR = 0xFF;                                      // Default content = SDA released.
001fb4 efef      	LDI  R30,LOW(255)
001fb5 93e0 0073 	STS  115,R30
                 ;    5412   TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
                 ;    5413          (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
                 ;    5414          (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
                 ;    5415          (0<<TWWC);                                 //
001fb7 e0e4      	LDI  R30,LOW(4)
001fb8 93e0 0074 	STS  116,R30
                 ;    5416 }                                                                                                              
001fba 9508      	RET
                 ;    5417 
                 ;    5418 
                 ;    5419     
                 ;    5420 /****************************************************************************
                 ;    5421 Call this function to test if the TWI_ISR is busy transmitting.
                 ;    5422 ****************************************************************************/
                 ;    5423 unsigned char TWI_Transceiver_Busy( void )
                 ;    5424 {
                 _TWI_Transceiver_Busy:
                 ;    5425   return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
001fbb 91e0 0074 	LDS  R30,116
001fbd 70e1      	ANDI R30,LOW(0x1)
001fbe 9508      	RET
                 ;    5426 }
                 ;    5427 
                 ;    5428 /****************************************************************************
                 ;    5429 Call this function to fetch the state information of the previous operation. The function will hold execution (loop)
                 ;    5430 until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
                 ;    5431 will return the TWI State code. 
                 ;    5432 ****************************************************************************/
                 ;    5433 unsigned char TWI_Get_State_Info( void )
                 ;    5434 {
                 _TWI_Get_State_Info:
                 ;    5435   while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
                 _0x3FE:
001fbf 940e 1fbb 	CALL _TWI_Transceiver_Busy
001fc1 30e0      	CPI  R30,0
001fc2 f7e1      	BRNE _0x3FE
                 ;    5436   return ( TWI_state );                         // Return error state.
001fc3 91e0 0b3c 	LDS  R30,_TWI_state_GA
001fc5 9508      	RET
                 ;    5437 }
                 ;    5438 
                 ;    5439 /****************************************************************************
                 ;    5440 Call this function to send a prepared message. The first byte must contain the slave address and the
                 ;    5441 read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
                 ;    5442 from the slave. Also include how many bytes that should be sent/read including the address byte.
                 ;    5443 The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
                 ;    5444 then initialize the next operation and return.
                 ;    5445 	Данная функция вызывается для отправки подготовленного сообщения. Первый байт
                 ;    5446  должен содержать адрес подчиненного устройства и бит выбора операции чтения/записи. 
                 ;    5447  В последующих байтах содержатся передаваемые данные или пустые позиции для считывания 
                 ;    5448  данных из подчиненного устройства. В параметрах также указывается количество 
                 ;    5449  отправляемых/принимаемых байт с учетом адресного байта. Нахождение в теле функции 
                 ;    5450  задерживается до тех пор, пока TWI_ISR завершит обработку предыдущего задания, а затем 
                 ;    5451  инициализируется следующее действие и выполняется возврат в основную программу.
                 ;    5452 ****************************************************************************/
                 ;    5453 void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
                 ;    5454 {
                 _TWI_Start_Transceiver_With_Data:
                 ;    5455   unsigned char temp;
                 ;    5456 
                 ;    5457   while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
001fc6 930a      	ST   -Y,R16
                 ;	*msg -> Y+2
                 ;	msgSize -> Y+1
                 ;	temp -> R16
                 _0x401:
001fc7 940e 1fbb 	CALL _TWI_Transceiver_Busy
001fc9 30e0      	CPI  R30,0
001fca f7e1      	BRNE _0x401
                 ;    5458 
                 ;    5459   TWI_msgSize = msgSize;                        // Number of data to transmit.
001fcb 81e9      	LDD  R30,Y+1
001fcc 93e0 0b3b 	STS  _TWI_msgSize_GA,R30
                 ;    5460   TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
001fce 81aa      	LDD  R26,Y+2
001fcf 81bb      	LDD  R27,Y+2+1
001fd0 91ec      	LD   R30,X
001fd1 93e0 0a3c 	STS  _TWI_buf_GA,R30
                 ;    5461   if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
001fd3 70e1      	ANDI R30,LOW(0x1)
001fd4 f469      	BRNE _0x404
                 ;    5462   {
                 ;    5463     for ( temp = 1; temp < msgSize; temp++ )
001fd5 e001      	LDI  R16,LOW(1)
                 _0x406:
001fd6 81e9      	LDD  R30,Y+1
001fd7 170e      	CP   R16,R30
001fd8 f448      	BRSH _0x407
                 ;    5464       TWI_buf[ temp ] = msg[ temp ];
001fd9 940e 28a0 	CALL SUBOPT_0xB2
001fdb 010f      	MOVW R0,R30
001fdc 940e 25cd 	CALL SUBOPT_0x53
001fde 940e 27d5 	CALL SUBOPT_0x94
                 ;    5465   }
001fe0 5f0f      	SUBI R16,-1
001fe1 cff4      	RJMP _0x406
                 _0x407:
                 ;    5466   TWI_statusReg.all = 0;      
                 _0x404:
001fe2 940e 28a5 	CALL SUBOPT_0xB3
                 ;    5467   TWI_state         = TWI_NO_STATE ;
                 ;    5468   TWCR = (1<<TWEN)|                             // TWI Interface enabled.
                 ;    5469          (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
                 ;    5470          (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
                 ;    5471          (0<<TWWC);                             //
                 ;    5472 }
001fe4 c01f      	RJMP _0x4C3
                 ;    5473 
                 ;    5474 /****************************************************************************
                 ;    5475 Call this function to resend the last message. The driver will reuse the data previously put in the transceiver buffers.
                 ;    5476 The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
                 ;    5477 then initialize the next operation and return.
                 ;    5478 ****************************************************************************/
                 ;    5479 void TWI_Start_Transceiver( void )
                 ;    5480 {
                 _TWI_Start_Transceiver:
                 ;    5481   while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
                 _0x408:
001fe5 940e 1fbb 	CALL _TWI_Transceiver_Busy
001fe7 30e0      	CPI  R30,0
001fe8 f7e1      	BRNE _0x408
                 ;    5482   TWI_statusReg.all = 0;      
001fe9 940e 28a5 	CALL SUBOPT_0xB3
                 ;    5483   TWI_state         = TWI_NO_STATE ;
                 ;    5484   TWCR = (1<<TWEN)|                             // TWI Interface enabled.
                 ;    5485          (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
                 ;    5486          (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
                 ;    5487          (0<<TWWC);                             //
                 ;    5488 }
001feb 9508      	RET
                 ;    5489 
                 ;    5490 /****************************************************************************
                 ;    5491 Call this function to read out the requested data from the TWI transceiver buffer. I.e. first call
                 ;    5492 TWI_Start_Transceiver to send a request for data to the slave. Then Run this function to collect the
                 ;    5493 data when they have arrived. Include a pointer to where to place the data and the number of bytes
                 ;    5494 requested (including the address field) in the function call. The function will hold execution (loop)
                 ;    5495 until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
                 ;    5496 If there was an error in the previous transmission the function will return the TWI error code.
                 ;    5497 ****************************************************************************/
                 ;    5498 unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
                 ;    5499 {
                 _TWI_Get_Data_From_Transceiver:
                 ;    5500   unsigned char i;
                 ;    5501 
                 ;    5502   while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
001fec 930a      	ST   -Y,R16
                 ;	*msg -> Y+2
                 ;	msgSize -> Y+1
                 ;	i -> R16
                 _0x40B:
001fed 940e 1fbb 	CALL _TWI_Transceiver_Busy
001fef 30e0      	CPI  R30,0
001ff0 f7e1      	BRNE _0x40B
                 ;    5503 
                 ;    5504   if( TWI_statusReg.bits.lastTransOK )               // Last transmission competed successfully.              
001ff1 91e0 0620 	LDS  R30,_TWI_statusReg
001ff3 70e1      	ANDI R30,LOW(0x1)
001ff4 f061      	BREQ _0x40E
                 ;    5505   {                                             
                 ;    5506     for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
001ff5 e000      	LDI  R16,LOW(0)
                 _0x410:
001ff6 81e9      	LDD  R30,Y+1
001ff7 170e      	CP   R16,R30
001ff8 f440      	BRSH _0x411
                 ;    5507     {
                 ;    5508       msg[ i ] = TWI_buf[ i ];
001ff9 940e 25cd 	CALL SUBOPT_0x53
001ffb 940e 28a0 	CALL SUBOPT_0xB2
001ffd 81e0      	LD   R30,Z
001ffe 93ec      	ST   X,R30
                 ;    5509     }
001fff 5f0f      	SUBI R16,-1
002000 cff5      	RJMP _0x410
                 _0x411:
                 ;    5510   }
                 ;    5511   return( TWI_statusReg.bits.lastTransOK );                                   
                 _0x40E:
002001 91e0 0620 	LDS  R30,_TWI_statusReg
002003 70e1      	ANDI R30,LOW(0x1)
                 _0x4C3:
002004 8108      	LDD  R16,Y+0
002005 9624      	ADIW R28,4
002006 9508      	RET
                 ;    5512 }
                 ;    5513 
                 ;    5514 // 2 Wire bus interrupt service routine
                 ;    5515 /****************************************************************************
                 ;    5516 This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
                 ;    5517 that is whenever a TWI event has occurred. This function should not be called directly from the main
                 ;    5518 application.
                 ;    5519 ****************************************************************************/
                 ;    5520 interrupt [TWI] void TWI_ISR(void)
                 ;    5521 {
                 _TWI_ISR:
002007 93aa      	ST   -Y,R26
002008 93ba      	ST   -Y,R27
002009 93ea      	ST   -Y,R30
00200a 93fa      	ST   -Y,R31
00200b b7ef      	IN   R30,SREG
00200c 93ea      	ST   -Y,R30
                 ;    5522   static unsigned char TWI_bufPtr;
                 
                 	.DSEG
                 _TWI_bufPtr_S80:
000b3d           	.BYTE 0x1
                 
                 	.CSEG
                 ;    5523  
                 ;    5524   switch (TWSR)
00200d 91e0 0071 	LDS  R30,113
                 ;    5525   {
                 ;    5526     case TWI_START:             // START has been transmitted  
00200f 30e8      	CPI  R30,LOW(0x8)
002010 f011      	BREQ _0x416
                 ;    5527     case TWI_REP_START:         // Repeated START has been transmitted
002011 31e0      	CPI  R30,LOW(0x10)
002012 f421      	BRNE _0x417
                 _0x416:
                 ;    5528       TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
002013 e0e0      	LDI  R30,LOW(0)
002014 93e0 0b3d 	STS  _TWI_bufPtr_S80,R30
                 ;    5529     case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
002016 c002      	RJMP _0x418
                 _0x417:
002017 31e8      	CPI  R30,LOW(0x18)
002018 f409      	BRNE _0x419
                 _0x418:
                 ;    5530     case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
002019 c002      	RJMP _0x41A
                 _0x419:
00201a 32e8      	CPI  R30,LOW(0x28)
00201b f491      	BRNE _0x41B
                 _0x41A:
                 ;    5531       if (TWI_bufPtr < TWI_msgSize)
00201c 91e0 0b3b 	LDS  R30,_TWI_msgSize_GA
00201e 91a0 0b3d 	LDS  R26,_TWI_bufPtr_S80
002020 17ae      	CP   R26,R30
002021 f438      	BRSH _0x41C
                 ;    5532       {
                 ;    5533         TWDR = TWI_buf[TWI_bufPtr++];
002022 940e 28af 	CALL SUBOPT_0xB4
002024 81e0      	LD   R30,Z
002025 93e0 0073 	STS  115,R30
                 ;    5534         TWCR = (1<<TWEN)|                                 // TWI Interface enabled
                 ;    5535                (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
                 ;    5536                (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
                 ;    5537                (0<<TWWC);                                 //  
002027 e8e5      	LDI  R30,LOW(133)
002028 c002      	RJMP _0x4F1
                 ;    5538       }else                    // Send STOP after last byte
                 _0x41C:
                 ;    5539       {
                 ;    5540         TWI_statusReg.bits.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
002029 940e 28b9 	CALL SUBOPT_0xB5
                 ;    5541         TWCR = (1<<TWEN)|                                 // TWI Interface enabled
                 ;    5542                (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
                 ;    5543                (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
                 ;    5544                (0<<TWWC);                                 //
                 _0x4F1:
00202b 93e0 0074 	STS  116,R30
                 ;    5545       }
                 ;    5546       break;
00202d c03a      	RJMP _0x414
                 ;    5547     case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
                 _0x41B:
00202e 35e0      	CPI  R30,LOW(0x50)
00202f f439      	BRNE _0x41E
                 ;    5548       TWI_buf[TWI_bufPtr++] = TWDR;
002030 940e 28af 	CALL SUBOPT_0xB4
002032 01df      	MOVW R26,R30
002033 91e0 0073 	LDS  R30,115
002035 93ec      	ST   X,R30
                 ;    5549     case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
002036 c002      	RJMP _0x41F
                 _0x41E:
002037 34e0      	CPI  R30,LOW(0x40)
002038 f469      	BRNE _0x420
                 _0x41F:
                 ;    5550       if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
002039 91e0 0b3b 	LDS  R30,_TWI_msgSize_GA
00203b 50e1      	SUBI R30,LOW(1)
00203c 91a0 0b3d 	LDS  R26,_TWI_bufPtr_S80
00203e 17ae      	CP   R26,R30
00203f f410      	BRSH _0x421
                 ;    5551       {
                 ;    5552         TWCR = (1<<TWEN)|                                 // TWI Interface enabled
                 ;    5553                (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
                 ;    5554                (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
                 ;    5555                (0<<TWWC);                                 //  
002040 ece5      	LDI  R30,LOW(197)
002041 c001      	RJMP _0x4F2
                 ;    5556       }else                    // Send NACK after next reception
                 _0x421:
                 ;    5557       {
                 ;    5558         TWCR = (1<<TWEN)|                                 // TWI Interface enabled
                 ;    5559                (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
                 ;    5560                (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
                 ;    5561                (0<<TWWC);                                 // 
002042 e8e5      	LDI  R30,LOW(133)
                 _0x4F2:
002043 93e0 0074 	STS  116,R30
                 ;    5562       }    
                 ;    5563       break; 
002045 c022      	RJMP _0x414
                 ;    5564     case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
                 _0x420:
002046 35e8      	CPI  R30,LOW(0x58)
002047 f459      	BRNE _0x423
                 ;    5565       TWI_buf[TWI_bufPtr] = TWDR;
002048 91a0 0b3d 	LDS  R26,_TWI_bufPtr_S80
00204a e0b0      	LDI  R27,0
00204b 5ca4      	SUBI R26,LOW(-_TWI_buf_GA)
00204c 4fb5      	SBCI R27,HIGH(-_TWI_buf_GA)
00204d 91e0 0073 	LDS  R30,115
00204f 93ec      	ST   X,R30
                 ;    5566       TWI_statusReg.bits.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
002050 940e 28b9 	CALL SUBOPT_0xB5
                 ;    5567       TWCR = (1<<TWEN)|                                 // TWI Interface enabled
                 ;    5568              (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
                 ;    5569              (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
                 ;    5570              (0<<TWWC);                                 //
002052 c013      	RJMP _0x4F3
                 ;    5571       break;      
                 ;    5572     case TWI_ARB_LOST:          // Arbitration lost
                 _0x423:
002053 33e8      	CPI  R30,LOW(0x38)
002054 f411      	BRNE _0x424
                 ;    5573       TWCR = (1<<TWEN)|                                 // TWI Interface enabled
                 ;    5574              (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
                 ;    5575              (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
                 ;    5576              (0<<TWWC);                                 //
002055 eae5      	LDI  R30,LOW(165)
002056 c00f      	RJMP _0x4F3
                 ;    5577       break;
                 ;    5578     case TWI_MTX_ADR_NACK:      // SLA+W has been tramsmitted and NACK received
                 _0x424:
002057 32e0      	CPI  R30,LOW(0x20)
002058 f011      	BREQ _0x426
                 ;    5579     case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
002059 34e8      	CPI  R30,LOW(0x48)
00205a f409      	BRNE _0x427
                 _0x426:
                 ;    5580     case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
00205b c002      	RJMP _0x428
                 _0x427:
00205c 33e0      	CPI  R30,LOW(0x30)
00205d f409      	BRNE _0x429
                 _0x428:
                 ;    5581 //    case TWI_NO_STATE              // No relevant state information available; TWINT = “0”
                 ;    5582     case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
00205e c002      	RJMP _0x42A
                 _0x429:
00205f 30e0      	CPI  R30,0
002060 f401      	BRNE _0x42C
                 _0x42A:
                 ;    5583     default:     
                 _0x42C:
                 ;    5584       TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
002061 91e0 0071 	LDS  R30,113
002063 93e0 0b3c 	STS  _TWI_state_GA,R30
                 ;    5585                                                         // Reset TWI Interface
                 ;    5586       TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
                 ;    5587              (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
                 ;    5588              (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
                 ;    5589              (0<<TWWC);                                 //
002065 e0e4      	LDI  R30,LOW(4)
                 _0x4F3:
002066 93e0 0074 	STS  116,R30
                 ;    5590   }
                 _0x414:
                 ;    5591 }
002068 91e9      	LD   R30,Y+
002069 bfef      	OUT  SREG,R30
00206a 91f9      	LD   R31,Y+
00206b 91e9      	LD   R30,Y+
00206c 91b9      	LD   R27,Y+
00206d 91a9      	LD   R26,Y+
00206e 9518      	RETI
                 ;    5592 ////////////////////////////////////////////////////////
                 ;    5593 // Функции работы с TWI
                 ;    5594 
                 ;    5595 #include "coding.h"
                 ;    5596 
                 ;    5597 
                 ;    5598 // Считаем CRC пакета
                 ;    5599 unsigned char calc_CRC (unsigned char *Position_in_Packet)
                 ;    5600 {                    
                 _calc_CRC:
                 ;    5601 	unsigned char CRC = 0, a;                                   
                 ;    5602 
                 ;    5603 	a = *Position_in_Packet ;
00206f 931a      	ST   -Y,R17
002070 930a      	ST   -Y,R16
                 ;	*Position_in_Packet -> Y+2
                 ;	CRC -> R16
                 ;	a -> R17
002071 e000      	LDI  R16,0
002072 81aa      	LDD  R26,Y+2
002073 81bb      	LDD  R27,Y+2+1
002074 911c      	LD   R17,X
                 ;    5604 	
                 ;    5605 	while(a--)
                 _0x42D:
002075 2fe1      	MOV  R30,R17
002076 5011      	SUBI R17,1
002077 30e0      	CPI  R30,0
002078 f021      	BREQ _0x42F
                 ;    5606 	{
                 ;    5607 		CRC += *Position_in_Packet++;
002079 940e 28c0 	CALL SUBOPT_0xB6
00207b 0f0e      	ADD  R16,R30
                 ;    5608 	}
00207c cff8      	RJMP _0x42D
                 _0x42F:
                 ;    5609 
                 ;    5610 	return CRC;
00207d 2fe0      	MOV  R30,R16
00207e c016      	RJMP _0x4C2
                 ;    5611 }
                 ;    5612 
                 ;    5613 
                 ;    5614 // считаем КС принятого пакета. Указатель - на байт длины пакета.
                 ;    5615 unsigned char check_RX_CRC_TWI (unsigned char *Position_in_Packet)
                 ;    5616 {                    
                 _check_RX_CRC_TWI:
                 ;    5617 	unsigned char CRC = 0, a;		
                 ;    5618 
                 ;    5619 	a = *Position_in_Packet ;
00207f 931a      	ST   -Y,R17
002080 930a      	ST   -Y,R16
                 ;	*Position_in_Packet -> Y+2
                 ;	CRC -> R16
                 ;	a -> R17
002081 e000      	LDI  R16,0
002082 81aa      	LDD  R26,Y+2
002083 81bb      	LDD  R27,Y+2+1
002084 911c      	LD   R17,X
                 ;    5620 	
                 ;    5621 	while(a--)
                 _0x430:
002085 2fe1      	MOV  R30,R17
002086 5011      	SUBI R17,1
002087 30e0      	CPI  R30,0
002088 f021      	BREQ _0x432
                 ;    5622 	{
                 ;    5623 		CRC += *Position_in_Packet++;
002089 940e 28c0 	CALL SUBOPT_0xB6
00208b 0f0e      	ADD  R16,R30
                 ;    5624 	}
00208c cff8      	RJMP _0x430
                 _0x432:
                 ;    5625 
                 ;    5626 	if (CRC == *Position_in_Packet)	
00208d 81aa      	LDD  R26,Y+2
00208e 81bb      	LDD  R27,Y+2+1
00208f 91ec      	LD   R30,X
002090 17e0      	CP   R30,R16
002091 f411      	BRNE _0x433
                 ;    5627 			return TRUE; 										//Ok
002092 e0e1      	LDI  R30,LOW(1)
002093 c001      	RJMP _0x4C2
                 ;    5628 
                 ;    5629 	else	return FALSE;                                      // Error
                 _0x433:
002094 e0e0      	LDI  R30,LOW(0)
                 ;    5630 }
                 _0x4C2:
002095 8119      	LDD  R17,Y+1
002096 8108      	LDD  R16,Y+0
002097 9624      	ADIW R28,4
002098 9508      	RET
                 ;    5631 
                 ;    5632 
                 ;    5633 unsigned char TWI_Act_On_Failure_In_Last_Transmission ( unsigned char TWIerrorMsg )
                 ;    5634 {
                 _TWI_Act_On_Failure_In_Last_Transmission:
                 ;    5635                     // A failure has occurred, use TWIerrorMsg to determine the nature of the failure
                 ;    5636                     // and take appropriate actions.
                 ;    5637                     // Se header file for a list of possible failures messages.
                 ;    5638                     
                 ;    5639                     // Here is a simple sample, where if received a NACK on the slave address,
                 ;    5640                     // then a retransmission will be initiated.
                 ;    5641  
                 ;    5642   if ( (TWIerrorMsg == TWI_MTX_ADR_NACK) | (TWIerrorMsg == TWI_MRX_ADR_NACK) )
002099 81a8      	LD   R26,Y
00209a e2e0      	LDI  R30,LOW(32)
00209b 940e 29c0 	CALL __EQB12
00209d 2e0e      	MOV  R0,R30
00209e e4e8      	LDI  R30,LOW(72)
00209f 940e 29c0 	CALL __EQB12
0020a1 29e0      	OR   R30,R0
0020a2 f011      	BREQ _0x435
                 ;    5643     TWI_Start_Transceiver();
0020a3 940e 1fe5 	CALL _TWI_Start_Transceiver
                 ;    5644     
                 ;    5645   return TWIerrorMsg; 
                 _0x435:
0020a5 81e8      	LD   R30,Y
0020a6 c0cb      	RJMP _0x4C0
                 ;    5646 }
                 ;    5647 
                 ;    5648 
                 ;    5649 // Исполняем команды TWI
                 ;    5650 u8 RUN_TWI (u8 TWI_targetSlaveAddress, u8 TWI_sendCommand,	u8 Count_Bytes )
                 ;    5651 {
                 _RUN_TWI:
                 ;    5652 
                 ;    5653 	    if ( ! TWI_Transceiver_Busy() )                              
0020a7 940e 1fbb 	CALL _TWI_Transceiver_Busy
0020a9 30e0      	CPI  R30,0
0020aa f5c9      	BRNE _0x436
                 ;    5654 	    {
                 ;    5655     	// Check if the last operation was successful
                 ;    5656 	      if ( TWI_statusReg.bits.lastTransOK )
0020ab 91e0 0620 	LDS  R30,_TWI_statusReg
0020ad 70e1      	ANDI R30,LOW(0x1)
0020ae f161      	BREQ _0x437
                 ;    5657     	  {
                 ;    5658 			LedGreen ();			// TWI   в норме
0020af 9ad0      	SBI  0x1A,0
0020b0 9ad1      	SBI  0x1A,1
0020b1 9ad8      	SBI  0x1B,0
0020b2 98d9      	CBI  0x1B,1
                 ;    5659 			
                 ;    5660 	        if (TWI_operation == SEND_DATA)
0020b3 91a0 0621 	LDS  R26,_TWI_operation
0020b5 30a1      	CPI  R26,LOW(0x1)
0020b6 f451      	BRNE _0x438
                 ;    5661 	        { // Send data to slave
                 ;    5662     	      txBuffer[0] = (TWI_targetSlaveAddress<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT);
0020b7 81ea      	LDD  R30,Y+2
0020b8 0fee      	LSL  R30
0020b9 93e0 0380 	STS  _txBuffer,R30
                 ;    5663 			  txBuffer[1] = TWI_sendCommand;             // The first byte is used for commands.
0020bb 81e9      	LDD  R30,Y+1
0020bc 93e0 0381 	__PUTB1MN _txBuffer,1
                 ;    5664 
                 ;    5665         	  TWI_Start_Transceiver_With_Data( txBuffer, Count_Bytes ); 
0020be 940e 28c6 	CALL SUBOPT_0xB7
                 ;    5666         	}  
                 ;    5667 
                 ;    5668 	        else if (TWI_operation == REQUEST_DATA)
0020c0 c018      	RJMP _0x439
                 _0x438:
0020c1 91a0 0621 	LDS  R26,_TWI_operation
0020c3 30a2      	CPI  R26,LOW(0x2)
0020c4 f441      	BRNE _0x43A
                 ;    5669     	    { // Request data from slave
                 ;    5670         	  txBuffer[0] = (TWI_targetSlaveAddress<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT);
0020c5 81ea      	LDD  R30,Y+2
0020c6 0fee      	LSL  R30
0020c7 60e1      	ORI  R30,1
0020c8 93e0 0380 	STS  _txBuffer,R30
                 ;    5671         	  TWI_Start_Transceiver_With_Data( txBuffer, Count_Bytes );
0020ca 940e 28c6 	CALL SUBOPT_0xB7
                 ;    5672 	        }
                 ;    5673 
                 ;    5674     	    else if (TWI_operation == READ_DATA_FROM_BUFFER)
0020cc c00c      	RJMP _0x43B
                 _0x43A:
0020cd 91a0 0621 	LDS  R26,_TWI_operation
0020cf 30a3      	CPI  R26,LOW(0x3)
0020d0 f441      	BRNE _0x43C
                 ;    5675         	{ // Get the received data from the transceiver buffer
                 ;    5676 	          TWI_Get_Data_From_Transceiver( rxBuffer, Count_Bytes ); // число принятых байт с учетом адреса 	
0020d1 e7ee      	LDI  R30,LOW(_rxBuffer)
0020d2 e0f5      	LDI  R31,HIGH(_rxBuffer)
0020d3 93fa      	ST   -Y,R31
0020d4 93ea      	ST   -Y,R30
0020d5 81ea      	LDD  R30,Y+2
0020d6 93ea      	ST   -Y,R30
0020d7 940e 1fec 	CALL _TWI_Get_Data_From_Transceiver
                 ;    5677 	        }
                 ;    5678 			return TRUE;
                 _0x43C:
                 _0x43B:
                 _0x439:
0020d9 e0e1      	LDI  R30,LOW(1)
0020da c00a      	RJMP _0x4C1
                 ;    5679     	  }
                 ;    5680 	      else // Got an error during the last transmission
                 _0x437:
                 ;    5681     	  {
                 ;    5682         	// Use TWI status information to detemine cause of failure and take appropriate actions. 
                 ;    5683 	        TWI_Act_On_Failure_In_Last_Transmission( TWI_Get_State_Info( ) );
0020db 940e 1fbf 	CALL _TWI_Get_State_Info
0020dd 93ea      	ST   -Y,R30
0020de 940e 2099 	CALL _TWI_Act_On_Failure_In_Last_Transmission
                 ;    5684 			LedRed ();			// авария TWI
0020e0 9ad0      	SBI  0x1A,0
0020e1 9ad1      	SBI  0x1A,1
0020e2 98d8      	CBI  0x1B,0
0020e3 9ad9      	SBI  0x1B,1
                 ;    5685     	  }
                 ;    5686 	    }
                 ;    5687 		return FALSE;		// идет передача
                 _0x436:
0020e4 e0e0      	LDI  R30,LOW(0)
                 _0x4C1:
0020e5 9623      	ADIW R28,3
0020e6 9508      	RET
                 ;    5688  }
                 ;    5689 
                 ;    5690 
                 ;    5691 //    разблокировка подч.портов
                 ;    5692 	void unlock_Pack (u8 TWI_targetSlaveAddress)
                 ;    5693 	{
                 _unlock_Pack:
                 ;    5694 		u8 temp = Start_point_of_Dann_TX_TWI;	
                 ;    5695 	
                 ;    5696 		// собираем все 
                 ;    5697 		txBuffer[temp++] = PACKHDR;				// заголовок
0020e7 930a      	ST   -Y,R16
                 ;	TWI_targetSlaveAddress -> Y+1
                 ;	temp -> R16
0020e8 e002      	LDI  R16,2
0020e9 2fe0      	MOV  R30,R16
0020ea 5f0f      	SUBI R16,-1
0020eb e0f0      	LDI  R31,0
0020ec 940e 2857 	CALL SUBOPT_0xA6
                 ;    5698 		txBuffer[temp++] = 4; 			           		// длина
0020ee 2fe0      	MOV  R30,R16
0020ef 5f0f      	SUBI R16,-1
0020f0 940e 28ce 	CALL SUBOPT_0xB8
0020f2 e0e4      	LDI  R30,LOW(4)
0020f3 93ec      	ST   X,R30
                 ;    5699 		txBuffer[temp++] = Internal_Packet;        	// адрес
0020f4 2fe0      	MOV  R30,R16
0020f5 5f0f      	SUBI R16,-1
0020f6 e0f0      	LDI  R31,0
0020f7 940e 285d 	CALL SUBOPT_0xA7
                 ;    5700 		txBuffer[temp++] = PT_PORT_UNLOCK; 	// тип
0020f9 2fe0      	MOV  R30,R16
0020fa 5f0f      	SUBI R16,-1
0020fb 940e 28ce 	CALL SUBOPT_0xB8
0020fd eaee      	LDI  R30,LOW(174)
0020fe 93ec      	ST   X,R30
                 ;    5701 		txBuffer[temp++] = TRUE;						// данные
0020ff 2fe0      	MOV  R30,R16
002100 5f0f      	SUBI R16,-1
002101 940e 28ce 	CALL SUBOPT_0xB8
002103 e0e1      	LDI  R30,LOW(1)
002104 93ec      	ST   X,R30
                 ;    5702 		txBuffer[temp++] = calc_CRC (&txBuffer[Start_point_of_Dann_TX_TWI+1]) + txBuffer[Start_point_of_Dann_TX_TWI];		//CRC
002105 2fe0      	MOV  R30,R16
002106 5f0f      	SUBI R16,-1
002107 e0f0      	LDI  R31,0
002108 58e0      	SUBI R30,LOW(-_txBuffer)
002109 4ffc      	SBCI R31,HIGH(-_txBuffer)
00210a 93ff      	PUSH R31
00210b 93ef      	PUSH R30
00210c e8e3
00210d e0f3      	__POINTW1MN _txBuffer,3
00210e 93fa      	ST   -Y,R31
00210f 93ea      	ST   -Y,R30
002110 940e 206f 	CALL _calc_CRC
002112 2fae      	MOV  R26,R30
002113 91e0 0382 	__GETB1MN _txBuffer,2
002115 0fea      	ADD  R30,R26
002116 91af      	POP  R26
002117 91bf      	POP  R27
002118 93ec      	ST   X,R30
                 ;    5703 
                 ;    5704 		// передаем
                 ;    5705 		TWI_operation = SEND_DATA; // Set next operation        
002119 e0e1      	LDI  R30,LOW(1)
00211a 93e0 0621 	STS  _TWI_operation,R30
                 ;    5706 		while (! RUN_TWI ( TWI_targetSlaveAddress, TWI_CMD_MASTER_WRITE, txBuffer[Start_point_of_Dann_TX_TWI+1] + 4 ) );
                 _0x43E:
00211c 81e9      	LDD  R30,Y+1
00211d 940e 286a 	CALL SUBOPT_0xA9
00211f 91e0 0383 	__GETB1MN _txBuffer,3
002121 940e 286e 	CALL SUBOPT_0xAA
002123 f3c1      	BREQ _0x43E
                 ;    5707 		
                 ;    5708 		#ifdef print
                 ;    5709 		printf ("Unlock PORT %d \r\n",TWI_targetSlaveAddress);
                 ;    5710 		#endif
                 ;    5711 
                 ;    5712      }
002124 8108      	LDD  R16,Y+0
002125 9622      	ADIW R28,2
002126 9508      	RET
                 ;    5713 
                 ;    5714 
                 ;    5715 // пингуем подчиненное для проверки информации. Если приняты данные без ошибок - 
                 ;    5716 // отправляем подтверждение приема.
                 ;    5717 // 
                 ;    5718 unsigned char pingPack (unsigned char TWI_targetSlaveAddress)
                 ;    5719 {
                 _pingPack:
                 ;    5720 		// пусть готовит данные
                 ;    5721 		TWI_operation = SEND_DATA; // Set next operation        
002127 e0e1      	LDI  R30,LOW(1)
002128 93e0 0621 	STS  _TWI_operation,R30
                 ;    5722 		while (! RUN_TWI ( TWI_targetSlaveAddress, TWI_CMD_MASTER_READ, 2 ) );
                 _0x441:
00212a 81e8      	LD   R30,Y
00212b 93ea      	ST   -Y,R30
00212c e2e0      	LDI  R30,LOW(32)
00212d 940e 28d3 	CALL SUBOPT_0xB9
00212f f3d1      	BREQ _0x441
                 ;    5723    
                 ;    5724 		// принимаю данные
                 ;    5725 		TWI_operation = REQUEST_DATA; // Set next operation        
002130 e0e2      	LDI  R30,LOW(2)
002131 93e0 0621 	STS  _TWI_operation,R30
                 ;    5726 		while (! RUN_TWI (TWI_targetSlaveAddress, 0, 1 ) );
                 _0x444:
002133 940e 28da 	CALL SUBOPT_0xBA
002135 93ea      	ST   -Y,R30
002136 e0e1      	LDI  R30,LOW(1)
002137 940e 28de 	CALL SUBOPT_0xBB
002139 f3c9      	BREQ _0x444
                 ;    5727 
                 ;    5728         TWI_operation = READ_DATA_FROM_BUFFER; // Set next operation        
00213a e0e3      	LDI  R30,LOW(3)
00213b 93e0 0621 	STS  _TWI_operation,R30
                 ;    5729 		while (! RUN_TWI (TWI_targetSlaveAddress, 0, 2) );
                 _0x447:
00213d 940e 28da 	CALL SUBOPT_0xBA
00213f 940e 28d3 	CALL SUBOPT_0xB9
002141 f3d9      	BREQ _0x447
                 ;    5730 		
                 ;    5731 		
                 ;    5732 		// Есть данные на передачу. Принимаем и
                 ;    5733 		// если данные  приняты без ошибок - высылаем подтверждение
                 ;    5734 		
                 ;    5735 		if ( rxBuffer [1] )		
002142 91e0 057f 	__GETB1MN _rxBuffer,1
002144 30e0      	CPI  R30,0
002145 f159      	BREQ _0x44A
                 ;    5736 		{
                 ;    5737 			// принимаю данные
                 ;    5738 			TWI_operation = REQUEST_DATA; // Set next operation        
002146 e0e2      	LDI  R30,LOW(2)
002147 93e0 0621 	STS  _TWI_operation,R30
                 ;    5739 			while (! RUN_TWI (TWI_targetSlaveAddress, 0, rxBuffer [1]+2 ) );
                 _0x44B:
002149 940e 28da 	CALL SUBOPT_0xBA
00214b 93ea      	ST   -Y,R30
00214c 91e0 057f 	__GETB1MN _rxBuffer,1
00214e 5fee      	SUBI R30,-LOW(2)
00214f 940e 28de 	CALL SUBOPT_0xBB
002151 f3b9      	BREQ _0x44B
                 ;    5740 
                 ;    5741 	        TWI_operation = READ_DATA_FROM_BUFFER; // Set next operation        
002152 e0e3      	LDI  R30,LOW(3)
002153 93e0 0621 	STS  _TWI_operation,R30
                 ;    5742 			while (! RUN_TWI (TWI_targetSlaveAddress, 0, rxBuffer [1] +2) );
                 _0x44E:
002155 940e 28da 	CALL SUBOPT_0xBA
002157 93ea      	ST   -Y,R30
002158 91e0 057f 	__GETB1MN _rxBuffer,1
00215a 5fee      	SUBI R30,-LOW(2)
00215b 940e 28de 	CALL SUBOPT_0xBB
00215d f3b9      	BREQ _0x44E
                 ;    5743 
                 ;    5744 			// проверяем КС
                 ;    5745 			if ( check_RX_CRC_TWI ( &rxBuffer[1] ) )
00215e e7ef
00215f e0f5      	__POINTW1MN _rxBuffer,1
002160 93fa      	ST   -Y,R31
002161 93ea      	ST   -Y,R30
002162 940e 207f 	CALL _check_RX_CRC_TWI
002164 30e0      	CPI  R30,0
002165 f059      	BREQ _0x451
                 ;    5746 			{//  подтверждение приема
                 ;    5747 				TWI_operation = SEND_DATA; // Set next operation        
002166 e0e1      	LDI  R30,LOW(1)
002167 93e0 0621 	STS  _TWI_operation,R30
                 ;    5748 				while (! RUN_TWI (TWI_targetSlaveAddress, TWI_CMD_MASTER_RECIVE_PACK_OK, 2 ) );
                 _0x452:
002169 81e8      	LD   R30,Y
00216a 93ea      	ST   -Y,R30
00216b e2e1      	LDI  R30,LOW(33)
00216c 940e 28d3 	CALL SUBOPT_0xB9
00216e f3d1      	BREQ _0x452
                 ;    5749 				
                 ;    5750 				return TRUE;
00216f e0e1      	LDI  R30,LOW(1)
002170 c001      	RJMP _0x4C0
                 ;    5751 			}
                 ;    5752 		                      
                 ;    5753 		}	
                 _0x451:
                 ;    5754 		return FALSE;
                 _0x44A:
002171 e0e0      	LDI  R30,LOW(0)
                 _0x4C0:
002172 9621      	ADIW R28,1
002173 9508      	RET
                 ;    5755 }	
                 ;    5756  
                 ;    5757  
                 ;    5758 
                 ;    5759 void	Relay_pack_from_UART_to_TWI (u8 TWI_targetSlaveAddress)
                 ;    5760 {    
                 _Relay_pack_from_UART_to_TWI:
                 ;    5761 		u8 a, b=0, CRC=0, temp = Start_point_of_Dann_TX_TWI;	
                 ;    5762 		
                 ;    5763 //		temp = Start_point_of_Dann_TX_TWI;	
                 ;    5764 	
                 ;    5765 		// собираем все 
                 ;    5766 		txBuffer[temp++] = PACKHDR;				// заголовок
002174 940e 2abe 	CALL __SAVELOCR4
                 ;	TWI_targetSlaveAddress -> Y+4
                 ;	a -> R16
                 ;	b -> R17
                 ;	CRC -> R18
                 ;	temp -> R19
002176 e010      	LDI  R17,0
002177 e020      	LDI  R18,0
002178 e032      	LDI  R19,2
002179 2fe3      	MOV  R30,R19
00217a 5f3f      	SUBI R19,-1
00217b e0f0      	LDI  R31,0
00217c 940e 2857 	CALL SUBOPT_0xA6
                 ;    5767 		txBuffer[temp++] = rx0len+3;            		// длина (+3 - тк. вычлось при приеме)
00217e 2fe3      	MOV  R30,R19
00217f 5f3f      	SUBI R19,-1
002180 940e 28ce 	CALL SUBOPT_0xB8
002182 91e0 0625 	LDS  R30,_rx0len
002184 5fed      	SUBI R30,-LOW(3)
002185 93ec      	ST   X,R30
                 ;    5768 		txBuffer[temp++] = rx0addr;                 	// адрес
002186 2fe3      	MOV  R30,R19
002187 5f3f      	SUBI R19,-1
002188 e0f0      	LDI  R31,0
002189 58e0      	SUBI R30,LOW(-_txBuffer)
00218a 4ffc      	SBCI R31,HIGH(-_txBuffer)
00218b 01df      	MOVW R26,R30
00218c 91e0 0626 	LDS  R30,_rx0addr
00218e 93ec      	ST   X,R30
                 ;    5769 		txBuffer[temp++] = rx0type;					// тип
00218f 2fe3      	MOV  R30,R19
002190 5f3f      	SUBI R19,-1
002191 e0f0      	LDI  R31,0
002192 58e0      	SUBI R30,LOW(-_txBuffer)
002193 4ffc      	SBCI R31,HIGH(-_txBuffer)
002194 01df      	MOVW R26,R30
002195 91e0 0627 	LDS  R30,_rx0type
002197 93ec      	ST   X,R30
                 ;    5770 
                 ;    5771 		for (a=0; a<=rx0len;  a++)
002198 e000      	LDI  R16,LOW(0)
                 _0x456:
002199 91e0 0625 	LDS  R30,_rx0len
00219b 17e0      	CP   R30,R16
00219c f058      	BRLO _0x457
                 ;    5772 		{
                 ;    5773 			txBuffer[temp++] = rx0buf 	[b++];				
00219d 2fe3      	MOV  R30,R19
00219e 5f3f      	SUBI R19,-1
00219f 940e 28ce 	CALL SUBOPT_0xB8
0021a1 2fe1      	MOV  R30,R17
0021a2 5f1f      	SUBI R17,-1
0021a3 940e 2393 	CALL SUBOPT_0x18
0021a5 93ec      	ST   X,R30
                 ;    5774 		}                   
0021a6 5f0f      	SUBI R16,-1
0021a7 cff1      	RJMP _0x456
                 _0x457:
                 ;    5775 
                 ;    5776 		// передаем
                 ;    5777 		TWI_operation = SEND_DATA; // Set next operation        
0021a8 e0e1      	LDI  R30,LOW(1)
0021a9 93e0 0621 	STS  _TWI_operation,R30
                 ;    5778 		while (! RUN_TWI ( TWI_targetSlaveAddress, TWI_CMD_MASTER_WRITE, txBuffer[Start_point_of_Dann_TX_TWI+1] + 4 ) );
                 _0x458:
0021ab 81ec      	LDD  R30,Y+4
0021ac 940e 286a 	CALL SUBOPT_0xA9
0021ae 91e0 0383 	__GETB1MN _txBuffer,3
0021b0 940e 286e 	CALL SUBOPT_0xAA
0021b2 f3c1      	BREQ _0x458
                 ;    5779 
                 ;    5780 }
0021b3 c061      	RJMP _0x4BF
                 ;    5781 
                 ;    5782 // Ретрансляция пакета подчиненному процессору
                 ;    5783 // Глобальная передача всем подчиненным
                 ;    5784 //u8	Relay_pack_from_UART_to_TWI_Internal (void)
                 ;    5785 u8	Relay_pack_from_UART_to_TWI_Internal (u8 Target_Reciver_Addr)
                 ;    5786 {    
                 _Relay_pack_from_UART_to_TWI_Internal:
                 ;    5787 		u8 a, b=1, temp=Start_point_of_Dann_TX_TWI, CRC;
                 ;    5788 //									 Target_Reciver_Addr;
                 ;    5789 
                 ;    5790 //		Target_Reciver_Addr = rx0buf [0]+offset;			// адрес приемника
                 ;    5791 
                 ;    5792 		// пакет ВСЕМ
                 ;    5793 		if ( ( Target_Reciver_Addr == 255 ) || ( Target_Reciver_Addr == 254 )  )
0021b4 940e 2abe 	CALL __SAVELOCR4
                 ;	Target_Reciver_Addr -> Y+4
                 ;	a -> R16
                 ;	b -> R17
                 ;	temp -> R18
                 ;	CRC -> R19
0021b6 e011      	LDI  R17,1
0021b7 e022      	LDI  R18,2
0021b8 81ac      	LDD  R26,Y+4
0021b9 3faf      	CPI  R26,LOW(0xFF)
0021ba f011      	BREQ _0x45C
0021bb 3fae      	CPI  R26,LOW(0xFE)
0021bc f411      	BRNE _0x45B
                 _0x45C:
                 ;    5794 													  	Target_Reciver_Addr = TWI_GEN_CALL;
0021bd e0e0      	LDI  R30,LOW(0)
0021be 83ec      	STD  Y+4,R30
                 ;    5795 
                 ;    5796 		// адрес выходит за диапазон рабочих адресов?
                 ;    5797 //	 	if (  Target_Reciver_Addr > int_Devices+offset )  		return FALSE;		
                 ;    5798 	 	if (  Target_Reciver_Addr > int_Devices )  		return FALSE;		
                 _0x45B:
0021bf ebe4      	LDI  R30,LOW(_int_Devices*2)
0021c0 e0f0      	LDI  R31,HIGH(_int_Devices*2)
0021c1 91e4      	LPM  R30,Z
0021c2 81ac      	LDD  R26,Y+4
0021c3 17ea      	CP   R30,R26
0021c4 f410      	BRSH _0x45E
0021c5 e0e0      	LDI  R30,LOW(0)
0021c6 c04e      	RJMP _0x4BF
                 ;    5799 
                 ;    5800 		// собираем все 
                 ;    5801 
                 ;    5802 		txBuffer[temp++] = PACKHDR;				// заголовок
                 _0x45E:
0021c7 2fe2      	MOV  R30,R18
0021c8 5f2f      	SUBI R18,-1
0021c9 e0f0      	LDI  R31,0
0021ca 940e 2857 	CALL SUBOPT_0xA6
                 ;    5803 		CRC =  txBuffer[temp - 1];
0021cc 940e 28e3 	CALL SUBOPT_0xBC
0021ce 8130      	LD   R19,Z
                 ;    5804 		
                 ;    5805 		txBuffer[temp++] = rx0len+1;            		// длина 
0021cf 2fe2      	MOV  R30,R18
0021d0 5f2f      	SUBI R18,-1
0021d1 940e 28ce 	CALL SUBOPT_0xB8
0021d3 91e0 0625 	LDS  R30,_rx0len
0021d5 5fef      	SUBI R30,-LOW(1)
0021d6 93ec      	ST   X,R30
                 ;    5806         CRC+=  txBuffer[temp - 1];
0021d7 940e 28e3 	CALL SUBOPT_0xBC
0021d9 81e0      	LD   R30,Z
0021da 0f3e      	ADD  R19,R30
                 ;    5807         
                 ;    5808 		if ( ! Target_Reciver_Addr )
0021db 81ec      	LDD  R30,Y+4
0021dc 30e0      	CPI  R30,0
0021dd f431      	BRNE _0x45F
                 ;    5809 		{
                 ;    5810 		 	txBuffer[temp++] = Global_Packet;			// подменяем адрес на глобальный (255).
0021de 2fe2      	MOV  R30,R18
0021df 5f2f      	SUBI R18,-1
0021e0 940e 28ce 	CALL SUBOPT_0xB8
0021e2 efef      	LDI  R30,LOW(255)
0021e3 c005      	RJMP _0x4F4
                 ;    5811 		}
                 ;    5812 		else 	txBuffer[temp++] = Internal_Packet;			// подменяем адрес на внутренний. (0).
                 _0x45F:
0021e4 2fe2      	MOV  R30,R18
0021e5 5f2f      	SUBI R18,-1
0021e6 940e 28ce 	CALL SUBOPT_0xB8
0021e8 e0e0      	LDI  R30,LOW(0)
                 _0x4F4:
0021e9 93ec      	ST   X,R30
                 ;    5813         CRC+=  txBuffer[temp - 1];
0021ea 940e 28e3 	CALL SUBOPT_0xBC
0021ec 81e0      	LD   R30,Z
0021ed 0f3e      	ADD  R19,R30
                 ;    5814 
                 ;    5815 		
                 ;    5816 		for (a=0; a<rx0len-1;  a++)
0021ee e000      	LDI  R16,LOW(0)
                 _0x462:
0021ef 91e0 0625 	LDS  R30,_rx0len
0021f1 50e1      	SUBI R30,LOW(1)
0021f2 170e      	CP   R16,R30
0021f3 f478      	BRSH _0x463
                 ;    5817 		{
                 ;    5818 	        CRC+= rx0buf [b];
0021f4 2fe1      	MOV  R30,R17
0021f5 940e 2393 	CALL SUBOPT_0x18
0021f7 0f3e      	ADD  R19,R30
                 ;    5819 			txBuffer[temp++] = rx0buf 	[b++];				
0021f8 2fe2      	MOV  R30,R18
0021f9 5f2f      	SUBI R18,-1
0021fa 940e 28ce 	CALL SUBOPT_0xB8
0021fc 2fe1      	MOV  R30,R17
0021fd 5f1f      	SUBI R17,-1
0021fe 940e 2393 	CALL SUBOPT_0x18
002200 93ec      	ST   X,R30
                 ;    5820 		}   
002201 5f0f      	SUBI R16,-1
002202 cfec      	RJMP _0x462
                 _0x463:
                 ;    5821 		
                 ;    5822 		txBuffer[temp++] = CRC;
002203 2fe2      	MOV  R30,R18
002204 5f2f      	SUBI R18,-1
002205 e0f0      	LDI  R31,0
002206 58e0      	SUBI R30,LOW(-_txBuffer)
002207 4ffc      	SBCI R31,HIGH(-_txBuffer)
002208 8330      	ST   Z,R19
                 ;    5823 
                 ;    5824 		// передаем по адресу ретранслируемого пакета. В самом пакете подменяем адрес на 0-
                 ;    5825 		// признак внутреннего пакета  
                 ;    5826 		TWI_operation = SEND_DATA; // Set next operation        
002209 e0e1      	LDI  R30,LOW(1)
00220a 93e0 0621 	STS  _TWI_operation,R30
                 ;    5827 		while (! RUN_TWI ( Target_Reciver_Addr, TWI_CMD_MASTER_WRITE,
                 _0x464:
                 ;    5828 								 txBuffer[Start_point_of_Dann_TX_TWI+1] +4 ) );
00220c 81ec      	LDD  R30,Y+4
00220d 940e 286a 	CALL SUBOPT_0xA9
00220f 91e0 0383 	__GETB1MN _txBuffer,3
002211 940e 286e 	CALL SUBOPT_0xAA
002213 f3c1      	BREQ _0x464
                 ;    5829 		return TRUE;					 
002214 e0e1      	LDI  R30,LOW(1)
                 _0x4BF:
002215 940e 2ac5 	CALL __LOADLOCR4
002217 9625      	ADIW R28,5
002218 9508      	RET
                 ;    5830 }
                 ;    5831 
                 ;    5832  // поиск порта  и передача пакета в порт
                 ;    5833 u8 Searching_Port_for_Relay (void)
                 ;    5834 {
                 _Searching_Port_for_Relay:
                 ;    5835 		u8 a;
                 ;    5836 		
                 ;    5837 		for (a=1; a<= int_Devices; a++)				// ищем порт по адресу
002219 930a      	ST   -Y,R16
                 ;	a -> R16
00221a e001      	LDI  R16,LOW(1)
                 _0x468:
00221b ebe4      	LDI  R30,LOW(_int_Devices*2)
00221c e0f0      	LDI  R31,HIGH(_int_Devices*2)
00221d 91e4      	LPM  R30,Z
00221e 17e0      	CP   R30,R16
00221f f088      	BRLO _0x469
                 ;    5838 		{
                 ;    5839 				#ifdef print
                 ;    5840 				printf ("Found PORT-%x, Device-%x\r\n", a, lAddrDevice [a]);
                 ;    5841 				#endif
                 ;    5842 
                 ;    5843 		 	if (lAddrDevice [a]	== rx0addr)
002220 940e 237c 	CALL SUBOPT_0x14
002222 91a0 0626 	LDS  R26,_rx0addr
002224 17ea      	CP   R30,R26
002225 f449      	BRNE _0x46A
                 ;    5844 		 	{
                 ;    5845 				LedRed();
002226 9ad0      	SBI  0x1A,0
002227 9ad1      	SBI  0x1A,1
002228 98d8      	CBI  0x1B,0
002229 9ad9      	SBI  0x1B,1
                 ;    5846 				Relay_pack_from_UART_to_TWI ( a );
00222a 930a      	ST   -Y,R16
00222b 940e 2174 	CALL _Relay_pack_from_UART_to_TWI
                 ;    5847 				return TRUE;
00222d e0e1      	LDI  R30,LOW(1)
00222e c003      	RJMP _0x4BE
                 ;    5848 		 	}
                 ;    5849 		}
                 _0x46A:
00222f 5f0f      	SUBI R16,-1
002230 cfea      	RJMP _0x468
                 _0x469:
                 ;    5850 
                 ;    5851 		return FALSE;
002231 e0e0      	LDI  R30,LOW(0)
                 _0x4BE:
002232 9109      	LD   R16,Y+
002233 9508      	RET
                 ;    5852 }
                 
                 _getchar:
002234 9b5f           sbis usr,rxc
002235 cffe           rjmp _getchar
002236 b1ec           in   r30,udr
002237 9508      	RET
                 _putchar:
002238 9b5d           sbis usr,udre
002239 cffe           rjmp _putchar
00223a 81e8           ld   r30,y
00223b b9ec           out  udr,r30
00223c 9621      	ADIW R28,1
00223d 9508      	RET
                 _allocate_block_GD:
00223e 9722      	SBIW R28,2
00223f 940e 2abc 	CALL __SAVELOCR6
002241 e500
002242 e01c      	__GETWRN 16,17,3152
002243 01d8      	MOVW R26,R16
002244 e0e0      	LDI  R30,LOW(0)
002245 e0f0      	LDI  R31,HIGH(0)
002246 93ed      	ST   X+,R30
002247 93fc      	ST   X,R31
                 _0x4AA:
002248 2e00      	MOV  R0,R16
002249 2a01      	OR   R0,R17
00224a f191      	BREQ _0x4AC
00224b 01d8      	MOVW R26,R16
00224c 940e 2a4a 	CALL __GETW1P
00224e 0fe0      	ADD  R30,R16
00224f 1ff1      	ADC  R31,R17
002250 9634      	ADIW R30,4
002251 01af      	MOVW R20,R30
002252 d696      	RCALL SUBOPT_0xBD
002253 9730      	SBIW R30,0
002254 f019      	BREQ _0x4AD
002255 832e
002256 833f      	__PUTWSR 18,19,6
002257 c004      	RJMP _0x4AE
                 _0x4AD:
002258 e0e0      	LDI  R30,LOW(4352)
002259 e1f1      	LDI  R31,HIGH(4352)
00225a 83ee      	STD  Y+6,R30
00225b 83ff      	STD  Y+6+1,R31
                 _0x4AE:
00225c 81ee      	LDD  R30,Y+6
00225d 81ff      	LDD  R31,Y+6+1
00225e 1be4      	SUB  R30,R20
00225f 0bf5      	SBC  R31,R21
002260 01df      	MOVW R26,R30
002261 85e8      	LDD  R30,Y+8
002262 85f9      	LDD  R31,Y+8+1
002263 9634      	ADIW R30,4
002264 17ae      	CP   R26,R30
002265 07bf      	CPC  R27,R31
002266 f098      	BRLO _0x4AF
002267 01fa      	MOVW R30,R20
002268 01d8
002269 9612
00226a 93ed
00226b 93fc      	__PUTW1RNS 16,2
00226c 01f9      	MOVW R30,R18
00226d 01da
00226e 9612
00226f 93ed
002270 93fc      	__PUTW1RNS 20,2
002271 85e8      	LDD  R30,Y+8
002272 85f9      	LDD  R31,Y+8+1
002273 01da      	MOVW R26,R20
002274 93ed      	ST   X+,R30
002275 93fc      	ST   X,R31
002276 5f4c
002277 4f5f      	__ADDWRN 20,21,4
002278 01fa      	MOVW R30,R20
002279 c005      	RJMP _0x4BD
                 _0x4AF:
00227a 2f02
00227b 2f13      	__MOVEWRR 16,17,18,19
00227c cfcb      	RJMP _0x4AA
                 _0x4AC:
00227d e0e0      	LDI  R30,LOW(0)
00227e e0f0      	LDI  R31,HIGH(0)
                 _0x4BD:
00227f 940e 2ac3 	CALL __LOADLOCR6
002281 962a      	ADIW R28,10
002282 9508      	RET
                 _find_prev_block_GD:
002283 940e 2abe 	CALL __SAVELOCR4
002285 e500
002286 e01c      	__GETWRN 16,17,3152
                 _0x4B0:
002287 2e00      	MOV  R0,R16
002288 2a01      	OR   R0,R17
002289 f061      	BREQ _0x4B2
00228a d65e      	RCALL SUBOPT_0xBD
00228b 01df      	MOVW R26,R30
00228c 81ec      	LDD  R30,Y+4
00228d 81fd      	LDD  R31,Y+4+1
00228e 17ea      	CP   R30,R26
00228f 07fb      	CPC  R31,R27
002290 f411      	BRNE _0x4B3
002291 01f8      	MOVW R30,R16
002292 c005      	RJMP _0x4BC
                 _0x4B3:
002293 2f02
002294 2f13      	__MOVEWRR 16,17,18,19
002295 cff1      	RJMP _0x4B0
                 _0x4B2:
002296 e0e0      	LDI  R30,LOW(0)
002297 e0f0      	LDI  R31,HIGH(0)
                 _0x4BC:
002298 940e 2ac5 	CALL __LOADLOCR4
00229a 9626      	ADIW R28,6
00229b 9508      	RET
                 _realloc:
00229c 9722      	SBIW R28,2
00229d 940e 2abc 	CALL __SAVELOCR6
00229f 85ea      	LDD  R30,Y+10
0022a0 85fb      	LDD  R31,Y+10+1
0022a1 9730      	SBIW R30,0
0022a2 f411      	BRNE PC+3
0022a3 940c 22e1 	JMP _0x4B4
0022a5 9734      	SBIW R30,4
0022a6 018f      	MOVW R16,R30
0022a7 931a      	ST   -Y,R17
0022a8 930a      	ST   -Y,R16
0022a9 dfd9      	RCALL _find_prev_block_GD
0022aa 019f      	MOVW R18,R30
0022ab 9730      	SBIW R30,0
0022ac f1a1      	BREQ _0x4B5
0022ad 01d8      	MOVW R26,R16
0022ae 9612      	ADIW R26,2
0022af 940e 2a4a 	CALL __GETW1P
0022b1 01d9
0022b2 9612
0022b3 93ed
0022b4 93fc      	__PUTW1RNS 18,2
0022b5 85e8      	LDD  R30,Y+8
0022b6 85f9      	LDD  R31,Y+8+1
0022b7 9730      	SBIW R30,0
0022b8 f141      	BREQ _0x4B6
0022b9 93fa      	ST   -Y,R31
0022ba 93ea      	ST   -Y,R30
0022bb df82      	RCALL _allocate_block_GD
0022bc 01af      	MOVW R20,R30
0022bd 9730      	SBIW R30,0
0022be f0e9      	BREQ _0x4B7
0022bf 01d8      	MOVW R26,R16
0022c0 940e 2a4a 	CALL __GETW1P
0022c2 83ee      	STD  Y+6,R30
0022c3 83ff      	STD  Y+6+1,R31
0022c4 01df      	MOVW R26,R30
0022c5 85e8      	LDD  R30,Y+8
0022c6 85f9      	LDD  R31,Y+8+1
0022c7 17ae      	CP   R26,R30
0022c8 07bf      	CPC  R27,R31
0022c9 f420      	BRSH _0x4B8
0022ca 81ee      	LDD  R30,Y+6
0022cb 81ff      	LDD  R31,Y+6+1
0022cc 87e8      	STD  Y+8,R30
0022cd 87f9      	STD  Y+8+1,R31
                 _0x4B8:
0022ce 935a      	ST   -Y,R21
0022cf 934a      	ST   -Y,R20
0022d0 85ec      	LDD  R30,Y+12
0022d1 85fd      	LDD  R31,Y+12+1
0022d2 93fa      	ST   -Y,R31
0022d3 93ea      	ST   -Y,R30
0022d4 85ec      	LDD  R30,Y+12
0022d5 85fd      	LDD  R31,Y+12+1
0022d6 93fa      	ST   -Y,R31
0022d7 93ea      	ST   -Y,R30
0022d8 940e 28ef 	CALL _memmove
0022da 01fa      	MOVW R30,R20
0022db c007      	RJMP _0x4BB
                 _0x4B7:
0022dc 01f8      	MOVW R30,R16
0022dd 01d9
0022de 9612
0022df 93ed
0022e0 93fc      	__PUTW1RNS 18,2
                 _0x4B6:
                 _0x4B5:
                 _0x4B4:
0022e1 e0e0      	LDI  R30,LOW(0)
0022e2 e0f0      	LDI  R31,HIGH(0)
                 _0x4BB:
0022e3 940e 2ac3 	CALL __LOADLOCR6
0022e5 962c      	ADIW R28,12
0022e6 9508      	RET
                 _malloc:
0022e7 931a      	ST   -Y,R17
0022e8 930a      	ST   -Y,R16
0022e9 e000
0022ea e010      	__GETWRN 16,17,0
0022eb 81ea      	LDD  R30,Y+2
0022ec 81fb      	LDD  R31,Y+2+1
0022ed 9730      	SBIW R30,0
0022ee f081      	BREQ _0x4B9
0022ef 93fa      	ST   -Y,R31
0022f0 93ea      	ST   -Y,R30
0022f1 df4c      	RCALL _allocate_block_GD
0022f2 018f      	MOVW R16,R30
0022f3 9730      	SBIW R30,0
0022f4 f051      	BREQ _0x4BA
0022f5 931a      	ST   -Y,R17
0022f6 930a      	ST   -Y,R16
0022f7 e0e0      	LDI  R30,LOW(0)
0022f8 93ea      	ST   -Y,R30
0022f9 81ed      	LDD  R30,Y+5
0022fa 81fe      	LDD  R31,Y+5+1
0022fb 93fa      	ST   -Y,R31
0022fc 93ea      	ST   -Y,R30
0022fd 940e 290c 	CALL _memset
                 _0x4BA:
                 _0x4B9:
0022ff 01f8      	MOVW R30,R16
002300 8119      	LDD  R17,Y+1
002301 8108      	LDD  R16,Y+0
002302 9624      	ADIW R28,4
002303 9508      	RET
                 _free:
002304 81e8      	LD   R30,Y
002305 81f9      	LDD  R31,Y+1
002306 93fa      	ST   -Y,R31
002307 93ea      	ST   -Y,R30
002308 e0e0      	LDI  R30,LOW(0)
002309 e0f0      	LDI  R31,HIGH(0)
00230a 93fa      	ST   -Y,R31
00230b 93ea      	ST   -Y,R30
00230c df8f      	RCALL _realloc
00230d 9622      	ADIW R28,2
00230e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x0:
00230f 93ea      	ST   -Y,R30
002310 940e 0330 	CALL _putchar0
002312 e0e0      	LDI  R30,LOW(0)
002313 93ea      	ST   -Y,R30
002314 940c 0330 	JMP  _putchar0
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x1:
002316 0fae      	ADD  R26,R30
002317 1fbf      	ADC  R27,R31
002318 91ec      	LD   R30,X
002319 93ea      	ST   -Y,R30
00231a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x2:
00231b efef      	LDI  R30,LOW(255)
00231c 93ea      	ST   -Y,R30
00231d 940e 0330 	CALL _putchar0
00231f 940c 0344 	JMP  _EndReply
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x3:
002321 e0e0      	LDI  R30,LOW(0)
002322 93ea      	ST   -Y,R30
002323 940c 0330 	JMP  _putchar0
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x4:
002325 5fef      	SUBI R30,-LOW(1)
002326 93ea      	ST   -Y,R30
002327 940c 0330 	JMP  _putchar0
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0x5:
002329 e0e1      	LDI  R30,LOW(1)
00232a 93ea      	ST   -Y,R30
00232b 940c 033a 	JMP  _StartReply
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x6:
00232d e0e1      	LDI  R30,LOW(1)
00232e 93ea      	ST   -Y,R30
00232f 940e 0330 	CALL _putchar0
002331 940c 0344 	JMP  _EndReply
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x7:
002333 93fa      	ST   -Y,R31
002334 93ea      	ST   -Y,R30
002335 e0e2      	LDI  R30,LOW(2)
002336 93ea      	ST   -Y,R30
002337 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0x8:
002338 e0e0      	LDI  R30,LOW(0)
002339 93ea      	ST   -Y,R30
00233a 940c 059e 	JMP  _open_user_bin
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x9:
00233c 70e1      	ANDI R30,LOW(0x1)
00233d 2fae      	MOV  R26,R30
00233e 2fe1      	MOV  R30,R17
00233f 50e1      	SUBI R30,LOW(1)
002340 940e 297e 	CALL __LSLB12
002342 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xA:
002343 2fe1      	MOV  R30,R17
002344 50e1      	SUBI R30,LOW(1)
002345 e0a1      	LDI  R26,LOW(1)
002346 940e 297e 	CALL __LSLB12
002348 efaf      	LDI  R26,LOW(255)
002349 27ea      	EOR  R30,R26
00234a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
                 SUBOPT_0xB:
00234b e0e0      	LDI  R30,LOW(0)
00234c 93ea      	ST   -Y,R30
00234d 940c 034d 	JMP  _Reply
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xC:
00234f e0e0      	LDI  R30,LOW(0)
002350 93ea      	ST   -Y,R30
002351 940e 2174 	CALL _Relay_pack_from_UART_to_TWI
002353 2477      	CLR  R7
002354 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xD:
002355 81e8      	LD   R30,Y
002356 93ea      	ST   -Y,R30
002357 940c 0330 	JMP  _putchar0
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xE:
002359 91e0 0727 	LDS  R30,_rx0ptr
00235b 5fef      	SUBI R30,-LOW(1)
00235c 93e0 0727 	STS  _rx0ptr,R30
00235e 50e1      	SUBI R30,LOW(1)
00235f e0f0      	LDI  R31,0
002360 5de8      	SUBI R30,LOW(-_rx0buf)
002361 4ff9      	SBCI R31,HIGH(-_rx0buf)
002362 8300      	ST   Z,R16
002363 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xF:
002364 b7e7      	IN   R30,0x37
002365 7eef      	ANDI R30,0xEF
002366 bfe7      	OUT  0x37,R30
002367 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x10:
002368 93ea      	ST   -Y,R30
002369 b7ef      	IN   R30,SREG
00236a 93ea      	ST   -Y,R30
00236b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x11:
00236c 91e9      	LD   R30,Y+
00236d bfef      	OUT  SREG,R30
00236e 91e9      	LD   R30,Y+
00236f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x12:
002370 27ea      	EOR  R30,R26
002371 bfe7      	OUT  0x37,R30
002372 91e0 007d 	LDS  R30,125
002374 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x13:
002375 e0e0      	LDI  R30,LOW(0)
002376 93e0 008b 	STS  139,R30
002378 e0e5      	LDI  R30,LOW(5)
002379 93e0 008a 	STS  138,R30
00237b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x14:
00237c 2fe0      	MOV  R30,R16
00237d e0f0      	LDI  R31,0
00237e 50e3      	SUBI R30,LOW(-_lAddrDevice)
00237f 4ffa      	SBCI R31,HIGH(-_lAddrDevice)
002380 81e0      	LD   R30,Z
002381 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x15:
002382 81a8      	LD   R26,Y
002383 e0b0      	LDI  R27,0
002384 50a3      	SUBI R26,LOW(-_lAddrDevice)
002385 4fba      	SBCI R27,HIGH(-_lAddrDevice)
002386 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x16:
002387 81e8      	LD   R30,Y
002388 50e1      	SUBI R30,LOW(1)
002389 e0a1      	LDI  R26,LOW(1)
00238a 940e 297e 	CALL __LSLB12
00238c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x17:
00238d 01f2      	MOVW R30,R4
00238e 9631      	ADIW R30,1
00238f 012f      	MOVW R4,R30
002390 9731      	SBIW R30,1
002391 01df      	MOVW R26,R30
002392 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0x18:
002393 e0f0      	LDI  R31,0
002394 5de8      	SUBI R30,LOW(-_rx0buf)
002395 4ff9      	SBCI R31,HIGH(-_rx0buf)
002396 81e0      	LD   R30,Z
002397 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x19:
002398 81ac      	LDD  R26,Y+4
002399 81bd      	LDD  R27,Y+4+1
00239a 91ed      	LD   R30,X+
00239b 83ac      	STD  Y+4,R26
00239c 83bd      	STD  Y+4+1,R27
00239d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES
                 SUBOPT_0x1A:
00239e 93ea      	ST   -Y,R30
00239f 91e0 0729 	LDS  R30,_fu_user
0023a1 91f0 072a 	LDS  R31,_fu_user+1
0023a3 93fa      	ST   -Y,R31
0023a4 93ea      	ST   -Y,R30
0023a5 940e 1760 	CALL _fputc
0023a7 3fef      	CPI  R30,LOW(0xFFFF)
0023a8 efaf      	LDI  R26,HIGH(0xFFFF)
0023a9 07fa      	CPC  R31,R26
0023aa 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x1B:
0023ab 91e0 0729 	LDS  R30,_fu_user
0023ad 91f0 072a 	LDS  R31,_fu_user+1
0023af 93fa      	ST   -Y,R31
0023b0 93ea      	ST   -Y,R30
0023b1 e0e0
0023b2 e0f0
0023b3 e060
0023b4 e070      	__GETD1N 0x0
0023b5 940e 2a63 	CALL __PUTPARD1
0023b7 e0e2      	LDI  R30,LOW(2)
0023b8 93ea      	ST   -Y,R30
0023b9 940e 1918 	CALL _fseek
0023bb 3fef      	CPI  R30,LOW(0xFFFF)
0023bc efaf      	LDI  R26,HIGH(0xFFFF)
0023bd 07fa      	CPC  R31,R26
0023be 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x1C:
0023bf 50e1
0023c0 40f0
0023c1 4060
0023c2 4070      	__SUBD1N 1
0023c3 e8a4
0023c4 e0b0
0023c5 e080
0023c6 e090      	__GETD2N 0x84
0023c7 940e 29cd 	CALL __MULD12U
0023c9 5fec
0023ca 4fff
0023cb 4f6f
0023cc 4f7f      	__ADDD1N 4
0023cd 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x1D:
0023ce 91e0 0729 	LDS  R30,_fu_user
0023d0 91f0 072a 	LDS  R31,_fu_user+1
0023d2 93fa      	ST   -Y,R31
0023d3 93ea      	ST   -Y,R30
0023d4 940c 1a7d 	JMP  _ftell
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x1E:
0023d6 93ea      	ST   -Y,R30
0023d7 91e0 0729 	LDS  R30,_fu_user
0023d9 91f0 072a 	LDS  R31,_fu_user+1
0023db 93fa      	ST   -Y,R31
0023dc 93ea      	ST   -Y,R30
0023dd 940c 1760 	JMP  _fputc
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x1F:
0023df 940e 2a63 	CALL __PUTPARD1
0023e1 e0e2      	LDI  R30,LOW(2)
0023e2 93ea      	ST   -Y,R30
0023e3 940e 1918 	CALL _fseek
0023e5 3fef      	CPI  R30,LOW(0xFFFF)
0023e6 efaf      	LDI  R26,HIGH(0xFFFF)
0023e7 07fa      	CPC  R31,R26
0023e8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x20:
0023e9 93fa      	ST   -Y,R31
0023ea 93ea      	ST   -Y,R30
0023eb e0e1      	LDI  R30,LOW(1)
0023ec 93ea      	ST   -Y,R30
0023ed 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x21:
0023ee 940e 134b 	CALL _fopenc
0023f0 93e0 0729 	STS  _fu_user,R30
0023f2 93f0 072a 	STS  _fu_user+1,R31
0023f4 9730      	SBIW R30,0
0023f5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x22:
0023f6 93fa      	ST   -Y,R31
0023f7 93ea      	ST   -Y,R30
0023f8 e0e0      	LDI  R30,LOW(0)
0023f9 93ea      	ST   -Y,R30
0023fa 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES
                 SUBOPT_0x23:
0023fb 91e0 0729 	LDS  R30,_fu_user
0023fd 91f0 072a 	LDS  R31,_fu_user+1
0023ff 93fa      	ST   -Y,R31
002400 93ea      	ST   -Y,R30
002401 940c 165a 	JMP  _fgetc
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x24:
002403 2ffe      	MOV  R31,R30
002404 e0e0      	LDI  R30,0
002405 81ac
002406 81bd
002407 818e
002408 819f      	__GETD2S 4
002409 940e 29bb 	CALL __CWD1
00240b 940e 2970 	CALL __ORD12
00240d 83ec
00240e 83fd
00240f 836e
002410 837f      	__PUTD1S 4
002411 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x25:
002412 93ea      	ST   -Y,R30
002413 940e 0330 	CALL _putchar0
002415 81ac
002416 81bd
002417 818e
002418 819f      	__GETD2S 4
002419 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x26:
00241a 940e 2992 	CALL __LSRD12
00241c 93ea      	ST   -Y,R30
00241d 940c 0330 	JMP  _putchar0
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x27:
00241f 91e0 0729 	LDS  R30,_fu_user
002421 91f0 072a 	LDS  R31,_fu_user+1
002423 93fa      	ST   -Y,R31
002424 93ea      	ST   -Y,R30
002425 940e 1a89 	CALL _feof
002427 9730      	SBIW R30,0
002428 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x28:
002429 e0e8      	LDI  R30,LOW(8)
00242a e0f0      	LDI  R31,HIGH(8)
00242b 940e 29c5 	CALL __MULW12U
00242d 0fe6      	ADD  R30,R22
00242e 1ff7      	ADC  R31,R23
00242f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x29:
002430 940e 06ff 	CALL __FF_spi
002432 85ae      	LDD  R26,Y+14
002433 27bb      	CLR  R27
002434 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x2A:
002435 940e 2992 	CALL __LSRD12
002437 2f0e      	MOV  R16,R30
002438 930a      	ST   -Y,R16
002439 940e 06ff 	CALL __FF_spi
00243b 85ea
00243c 85fb
00243d 856c
00243e 857d      	__GETD1S 10
00243f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x2B:
002440 2f0e      	MOV  R16,R30
002441 930a      	ST   -Y,R16
002442 940c 06ff 	JMP  __FF_spi
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES
                 SUBOPT_0x2C:
002444 940e 06ff 	CALL __FF_spi
002446 efef      	LDI  R30,LOW(255)
002447 93ea      	ST   -Y,R30
002448 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 20 TIMES
                 SUBOPT_0x2D:
002449 efef      	LDI  R30,LOW(255)
00244a 93ea      	ST   -Y,R30
00244b 940c 06ff 	JMP  __FF_spi
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x2E:
00244d 27ff      	CLR  R31
00244e 2766      	CLR  R22
00244f 2777      	CLR  R23
002450 83ee
002451 83ff
002452 8768
002453 8779      	__PUTD1S 6
002454 81ae
002455 81bf
002456 8588
002457 8599      	__GETD2S 6
002458 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x2F:
002459 27ff      	CLR  R31
00245a 2766      	CLR  R22
00245b 2777      	CLR  R23
00245c 83ee
00245d 83ff
00245e 8768
00245f 8779      	__PUTD1S 6
002460 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x30:
002461 91a0 072b 	LDS  R26,_OCR_REG
002463 91b0 072c 	LDS  R27,_OCR_REG+1
002465 9180 072d 	LDS  R24,_OCR_REG+2
002467 9190 072e 	LDS  R25,_OCR_REG+3
002469 940e 2970 	CALL __ORD12
00246b 93e0 072b 	STS  _OCR_REG,R30
00246d 93f0 072c 	STS  _OCR_REG+1,R31
00246f 9360 072d 	STS  _OCR_REG+2,R22
002471 9370 072e 	STS  _OCR_REG+3,R23
002473 cfd5      	RJMP SUBOPT_0x2D
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x31:
002474 efef      	LDI  R30,LOW(255)
002475 93ea      	ST   -Y,R30
002476 cfcd      	RJMP SUBOPT_0x2C
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x32:
002477 e5e0      	LDI  R30,LOW(80)
002478 b9ed      	OUT  0xD,R30
002479 e0e0      	LDI  R30,LOW(0)
00247a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
                 SUBOPT_0x33:
00247b 81e9
00247c 81fa
00247d 816b
00247e 817c      	__GETD1S 1
00247f 5fef
002480 4fff
002481 4f6f
002482 4f7f      	__SUBD1N -1
002483 83e9
002484 83fa
002485 836b
002486 837c      	__PUTD1S 1
002487 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES
                 SUBOPT_0x34:
002488 940e 2a63 	CALL __PUTPARD1
00248a 940e 0b3d 	CALL __FF_read
00248c 30e0      	CPI  R30,0
00248d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x35:
00248e e0e1      	LDI  R30,LOW(1)
00248f 93e0 0972 	STS  __FF_error,R30
002491 e0e0      	LDI  R30,LOW(0)
002492 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x36:
002493 2766      	CLR  R22
002494 2777      	CLR  R23
002495 01df      	MOVW R26,R30
002496 01cb      	MOVW R24,R22
002497 91e0 0935 	LDS  R30,_BPB_BytsPerSec
002499 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
00249b 2766      	CLR  R22
00249c 2777      	CLR  R23
00249d 940e 29ed 	CALL __MULD12
00249f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x37:
0024a0 e0f0      	LDI  R31,0
0024a1 2bea      	OR   R30,R26
0024a2 2bfb      	OR   R31,R27
0024a3 2766      	CLR  R22
0024a4 2777      	CLR  R23
0024a5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x38:
0024a6 27ff      	CLR  R31
0024a7 2766      	CLR  R22
0024a8 2777      	CLR  R23
0024a9 01df      	MOVW R26,R30
0024aa 01cb      	MOVW R24,R22
0024ab e1e8      	LDI  R30,LOW(24)
0024ac 940e 2986 	CALL __LSLD12
0024ae 01df      	MOVW R26,R30
0024af 01cb      	MOVW R24,R22
0024b0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x39:
0024b1 27ff      	CLR  R31
0024b2 2766      	CLR  R22
0024b3 2777      	CLR  R23
0024b4 940e 29b6 	CALL __LSLD16
0024b6 940e 2970 	CALL __ORD12
0024b8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x3A:
0024b9 27ff      	CLR  R31
0024ba 2766      	CLR  R22
0024bb 2777      	CLR  R23
0024bc 01df      	MOVW R26,R30
0024bd 01cb      	MOVW R24,R22
0024be e0e8      	LDI  R30,LOW(8)
0024bf 940e 2986 	CALL __LSLD12
0024c1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x3B:
0024c2 93ea      	ST   -Y,R30
0024c3 e0e0
0024c4 e0f0
0024c5 e060
0024c6 e070      	__GETD1N 0x0
0024c7 940e 2a63 	CALL __PUTPARD1
0024c9 940e 0705 	CALL _send_cmd
0024cb 2f0e      	MOV  R16,R30
0024cc 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x3C:
0024cd e5e0      	LDI  R30,LOW(80)
0024ce b9ed      	OUT  0xD,R30
0024cf e0e1      	LDI  R30,LOW(1)
0024d0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x3D:
0024d1 91e0 0935 	LDS  R30,_BPB_BytsPerSec
0024d3 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
0024d5 81ad
0024d6 81be
0024d7 818f
0024d8 8598      	__GETD2S 5
0024d9 2766      	CLR  R22
0024da 2777      	CLR  R23
0024db 940e 2a33 	CALL __MODD21U
0024dd 940e 2aa4 	CALL __CPD10
0024df 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x3E:
0024e0 e0e4      	LDI  R30,LOW(4)
0024e1 93e0 0972 	STS  __FF_error,R30
0024e3 e0e0      	LDI  R30,LOW(0)
0024e4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x3F:
0024e5 93ea      	ST   -Y,R30
0024e6 81ee
0024e7 81ff
0024e8 8568
0024e9 8579      	__GETD1S 6
0024ea 940e 2a63 	CALL __PUTPARD1
0024ec 940e 0705 	CALL _send_cmd
0024ee 2f0e      	MOV  R16,R30
0024ef 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x40:
0024f0 e0e3      	LDI  R30,LOW(3)
0024f1 93e0 0972 	STS  __FF_error,R30
0024f3 e0e0      	LDI  R30,LOW(0)
0024f4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x41:
0024f5 91ec      	LD   R30,X
0024f6 93ea      	ST   -Y,R30
0024f7 940e 0c16 	CALL _valid_file_char
0024f9 9730      	SBIW R30,0
0024fa 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x42:
0024fb 8def      	LDD  R30,Y+31
0024fc a1f8      	LDD  R31,Y+31+1
0024fd 9631      	ADIW R30,1
0024fe 8fef      	STD  Y+31,R30
0024ff a3f8      	STD  Y+31+1,R31
002500 9731      	SBIW R30,1
002501 01de      	MOVW R26,R28
002502 9616      	ADIW R26,6
002503 0fae      	ADD  R26,R30
002504 1fbf      	ADC  R27,R31
002505 e2e0      	LDI  R30,LOW(32)
002506 93ec      	ST   X,R30
002507 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x43:
002508 a1ab      	LDD  R26,Y+35
002509 a1bc      	LDD  R27,Y+35+1
00250a e0e0
00250b e0f0
00250c e060
00250d e070      	__GETD1N 0x0
00250e 940e 2a54 	CALL __PUTDP1
002510 efef      	LDI  R30,LOW(65535)
002511 efff      	LDI  R31,HIGH(65535)
002512 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x44:
002513 8def      	LDD  R30,Y+31
002514 a1f8      	LDD  R31,Y+31+1
002515 9631      	ADIW R30,1
002516 8fef      	STD  Y+31,R30
002517 a3f8      	STD  Y+31+1,R31
002518 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x45:
002519 91e0 0935 	LDS  R30,_BPB_BytsPerSec
00251b 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
00251d 2766      	CLR  R22
00251e 2777      	CLR  R23
00251f 01df      	MOVW R26,R30
002520 01cb      	MOVW R24,R22
002521 91e0 0937 	LDS  R30,_BPB_SecPerClus
002523 27ff      	CLR  R31
002524 2766      	CLR  R22
002525 2777      	CLR  R23
002526 940e 29ed 	CALL __MULD12
002528 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
                 SUBOPT_0x46:
002529 8def      	LDD  R30,Y+31
00252a a1f8      	LDD  R31,Y+31+1
00252b 2766      	CLR  R22
00252c 2777      	CLR  R23
00252d 01df      	MOVW R26,R30
00252e 01cb      	MOVW R24,R22
00252f 91e0 0935 	LDS  R30,_BPB_BytsPerSec
002531 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
002533 2766      	CLR  R22
002534 2777      	CLR  R23
002535 940e 29ed 	CALL __MULD12
002537 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
                 SUBOPT_0x47:
002538 01fa      	MOVW R30,R20
002539 0fee      	LSL  R30
00253a 1fff      	ROL  R31
00253b 940e 299e 	CALL __LSLW4
00253d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0x48:
00253e 2766      	CLR  R22
00253f 2777      	CLR  R23
002540 940e 295c 	CALL __ADDD12
002542 8fe9
002543 8ffa
002544 8f6b
002545 8f7c      	__PUTD1S 25
002546 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x49:
002547 8de9
002548 8dfa
002549 8d6b
00254a 8d7c      	__GETD1S 25
00254b a1ab      	LDD  R26,Y+35
00254c a1bc      	LDD  R27,Y+35+1
00254d 940e 2a54 	CALL __PUTDP1
00254f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x4A:
002550 89ed      	LDD  R30,Y+21
002551 89fe      	LDD  R31,Y+21+1
002552 93fa      	ST   -Y,R31
002553 93ea      	ST   -Y,R30
002554 8de9      	LDD  R30,Y+25
002555 8dfa      	LDD  R31,Y+25+1
002556 93fa      	ST   -Y,R31
002557 93ea      	ST   -Y,R30
002558 e0eb      	LDI  R30,LOW(11)
002559 93ea      	ST   -Y,R30
00255a 940e 2924 	CALL _strncmp
00255c 30e0      	CPI  R30,0
00255d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x4B:
00255e 940e 29ed 	CALL __MULD12
002560 91a0 0954 	LDS  R26,__FF_PART_ADDR
002562 91b0 0955 	LDS  R27,__FF_PART_ADDR+1
002564 9180 0956 	LDS  R24,__FF_PART_ADDR+2
002566 9190 0957 	LDS  R25,__FF_PART_ADDR+3
002568 940e 295c 	CALL __ADDD12
00256a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x4C:
00256b 91e0 0935 	LDS  R30,_BPB_BytsPerSec
00256d 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
00256f 95f6      	LSR  R31
002570 95e7      	ROR  R30
002571 85ad      	LDD  R26,Y+13
002572 85be      	LDD  R27,Y+13+1
002573 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x4D:
002574 940e 29f2 	CALL __DIVW21U
002576 91a0 0938 	LDS  R26,_BPB_RsvdSecCnt
002578 91b0 0939 	LDS  R27,_BPB_RsvdSecCnt+1
00257a 0fea      	ADD  R30,R26
00257b 1ffb      	ADC  R31,R27
00257c 018f      	MOVW R16,R30
00257d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x4E:
00257e 940e 2a30 	CALL __MODW21U
002580 0fee      	LSL  R30
002581 1fff      	ROL  R31
002582 019f      	MOVW R18,R30
002583 01f8      	MOVW R30,R16
002584 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x4F:
002585 91e0 0964 	LDS  R30,__FF_FAT2_ADDR
002587 91f0 0965 	LDS  R31,__FF_FAT2_ADDR+1
002589 9160 0966 	LDS  R22,__FF_FAT2_ADDR+2
00258b 9170 0967 	LDS  R23,__FF_FAT2_ADDR+3
00258d 91a0 0973 	LDS  R26,__FF_buff_addr
00258f 91b0 0974 	LDS  R27,__FF_buff_addr+1
002591 9180 0975 	LDS  R24,__FF_buff_addr+2
002593 9190 0976 	LDS  R25,__FF_buff_addr+3
002595 940e 2ab7 	CALL __CPD21
002597 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x50:
002598 91a0 0960 	LDS  R26,__FF_FAT1_ADDR
00259a 91b0 0961 	LDS  R27,__FF_FAT1_ADDR+1
00259c 9180 0962 	LDS  R24,__FF_FAT1_ADDR+2
00259e 9190 0963 	LDS  R25,__FF_FAT1_ADDR+3
0025a0 91e0 0964 	LDS  R30,__FF_FAT2_ADDR
0025a2 91f0 0965 	LDS  R31,__FF_FAT2_ADDR+1
0025a4 9160 0966 	LDS  R22,__FF_FAT2_ADDR+2
0025a6 9170 0967 	LDS  R23,__FF_FAT2_ADDR+3
0025a8 940e 2966 	CALL __SUBD12
0025aa 91a0 0973 	LDS  R26,__FF_buff_addr
0025ac 91b0 0974 	LDS  R27,__FF_buff_addr+1
0025ae 9180 0975 	LDS  R24,__FF_buff_addr+2
0025b0 9190 0976 	LDS  R25,__FF_buff_addr+3
0025b2 940e 295c 	CALL __ADDD12
0025b4 940e 2a63 	CALL __PUTPARD1
0025b6 940e 0bab 	CALL __FF_write
0025b8 30e0      	CPI  R30,0
0025b9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x51:
0025ba 91e0 0973 	LDS  R30,__FF_buff_addr
0025bc 91f0 0974 	LDS  R31,__FF_buff_addr+1
0025be 9160 0975 	LDS  R22,__FF_buff_addr+2
0025c0 9170 0976 	LDS  R23,__FF_buff_addr+3
0025c2 940e 2a63 	CALL __PUTPARD1
0025c4 940e 0bab 	CALL __FF_write
0025c6 30e0      	CPI  R30,0
0025c7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x52:
0025c8 2fe0      	MOV  R30,R16
0025c9 81aa      	LDD  R26,Y+2
0025ca 81bb      	LDD  R27,Y+2+1
0025cb e0f0      	LDI  R31,0
0025cc cd49      	RJMP SUBOPT_0x1
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0x53:
0025cd 2fe0      	MOV  R30,R16
0025ce 81aa      	LDD  R26,Y+2
0025cf 81bb      	LDD  R27,Y+2+1
0025d0 e0f0      	LDI  R31,0
0025d1 0fae      	ADD  R26,R30
0025d2 1fbf      	ADC  R27,R31
0025d3 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x54:
0025d4 e0f0      	LDI  R31,0
0025d5 51e0      	SUBI R30,LOW(-_FILENAME)
0025d6 4ff6      	SBCI R31,HIGH(-_FILENAME)
0025d7 01df      	MOVW R26,R30
0025d8 e2e0      	LDI  R30,LOW(32)
0025d9 93ec      	ST   X,R30
0025da 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x55:
0025db 81f0      	LD   R31,Z
0025dc e0e0      	LDI  R30,LOW(0)
0025dd 01df      	MOVW R26,R30
0025de 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x56:
0025df e0ed      	LDI  R30,LOW(13)
0025e0 93e0 0972 	STS  __FF_error,R30
0025e2 e0e0      	LDI  R30,LOW(0)
0025e3 e0f0      	LDI  R31,HIGH(0)
0025e4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x57:
0025e5 91e0 0935 	LDS  R30,_BPB_BytsPerSec
0025e7 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
0025e9 95f6      	LSR  R31
0025ea 95e7      	ROR  R30
0025eb 89aa      	LDD  R26,Y+18
0025ec 89bb      	LDD  R27,Y+18+1
0025ed 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x58:
0025ee 940e 295c 	CALL __ADDD12
0025f0 940e 2a63 	CALL __PUTPARD1
0025f2 940e 0bab 	CALL __FF_write
0025f4 30e0      	CPI  R30,0
0025f5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
                 SUBOPT_0x59:
0025f6 940e 2a63 	CALL __PUTPARD1
0025f8 940e 0bab 	CALL __FF_write
0025fa 30e0      	CPI  R30,0
0025fb 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x5A:
0025fc 85eb      	LDD  R30,Y+11
0025fd 85fc      	LDD  R31,Y+11+1
0025fe 89a6
0025ff 89b7
002600 8d80
002601 8d91      	__GETD2Z 22
002602 940e 2a68 	CALL __PUTPARD2
002604 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x5B:
002605 85ab      	LDD  R26,Y+11
002606 85bc      	LDD  R27,Y+11+1
002607 965a      	ADIW R26,26
002608 940e 2a4a 	CALL __GETW1P
00260a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x5C:
00260b 85ab      	LDD  R26,Y+11
00260c 85bc      	LDD  R27,Y+11+1
00260d 961c      	ADIW R26,12
00260e 940e 2a4a 	CALL __GETW1P
002610 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x5D:
002611 81ef
002612 85f8
002613 8569
002614 857a      	__GETD1S 7
002615 7fef
002616 70f0
002617 7060
002618 7070      	__ANDD1N 0xFF
002619 2fa1
00261a 2fb2      	__GETW2R 17,18
00261b 93ec      	ST   X,R30
00261c 81af
00261d 85b8
00261e 8589
00261f 859a      	__GETD2S 7
002620 e0e8      	LDI  R30,LOW(8)
002621 940e 2992 	CALL __LSRD12
002623 83ef
002624 87f8
002625 8769
002626 877a      	__PUTD1S 7
002627 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x5E:
002628 933a      	ST   -Y,R19
002629 932a      	ST   -Y,R18
00262a e0e0      	LDI  R30,LOW(0)
00262b 93ea      	ST   -Y,R30
00262c 940c 0e5c 	JMP  _next_cluster
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x5F:
00262e 01d9      	MOVW R26,R18
00262f 91ac      	LD   R26,X
002630 35ac      	CPI  R26,LOW(0x5C)
002631 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x60:
002632 91ec      	LD   R30,X
002633 93ea      	ST   -Y,R30
002634 940c 2949 	JMP  _toupper
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x61:
002636 01d8      	MOVW R26,R16
002637 e0e0      	LDI  R30,LOW(0)
002638 93ec      	ST   X,R30
002639 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x62:
00263a 0fee      	LSL  R30
00263b 1fff      	ROL  R31
00263c 2ffe      	MOV  R31,R30
00263d e0e0      	LDI  R30,0
00263e 91a0 095c 	LDS  R26,__FF_DIR_ADDR
002640 91b0 095d 	LDS  R27,__FF_DIR_ADDR+1
002642 9180 095e 	LDS  R24,__FF_DIR_ADDR+2
002644 9190 095f 	LDS  R25,__FF_DIR_ADDR+3
002646 2766      	CLR  R22
002647 2777      	CLR  R23
002648 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x63:
002649 81e0      	LD   R30,Z
00264a e0f0      	LDI  R31,0
00264b 2bea      	OR   R30,R26
00264c 2bfb      	OR   R31,R27
00264d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x64:
00264e 0fea      	ADD  R30,R26
00264f 1ffb      	ADC  R31,R27
002650 010f      	MOVW R0,R30
002651 2fe0      	MOV  R30,R16
002652 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x65:
002653 0fea      	ADD  R30,R26
002654 1ffb      	ADC  R31,R27
002655 91e4      	LPM  R30,Z
002656 01d0      	MOVW R26,R0
002657 93ec      	ST   X,R30
002658 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x66:
002659 976c      	SBIW R28,28
00265a 940e 2abc 	CALL __SAVELOCR6
00265c e0e0
00265d 87ec
00265e 87ed
00265f 87ee
002660 87ef      	__CLRD1S 12
002661 a1eb      	LDD  R30,Y+35
002662 a1fc      	LDD  R31,Y+35+1
002663 93fa      	ST   -Y,R31
002664 93ea      	ST   -Y,R30
002665 01fe      	MOVW R30,R28
002666 963e      	ADIW R30,14
002667 93fa      	ST   -Y,R31
002668 93ea      	ST   -Y,R30
002669 01fe      	MOVW R30,R28
00266a 9678      	ADIW R30,24
00266b 93fa      	ST   -Y,R31
00266c 93ea      	ST   -Y,R30
00266d 940e 11cb 	CALL __FF_checkdir
00266f 9730      	SBIW R30,0
002670 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 18 TIMES
                 SUBOPT_0x67:
002671 85ec
002672 85fd
002673 856e
002674 857f      	__GETD1S 12
002675 93e0 095c 	STS  __FF_DIR_ADDR,R30
002677 93f0 095d 	STS  __FF_DIR_ADDR+1,R31
002679 9360 095e 	STS  __FF_DIR_ADDR+2,R22
00267b 9370 095f 	STS  __FF_DIR_ADDR+3,R23
00267d e0e0      	LDI  R30,LOW(0)
00267e e0f0      	LDI  R31,HIGH(0)
00267f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x68:
002680 91e0 095c 	LDS  R30,__FF_DIR_ADDR
002682 91f0 095d 	LDS  R31,__FF_DIR_ADDR+1
002684 9160 095e 	LDS  R22,__FF_DIR_ADDR+2
002686 9170 095f 	LDS  R23,__FF_DIR_ADDR+3
002688 87e8
002689 87f9
00268a 876a
00268b 877b      	__PUTD1S 8
00268c 01fe      	MOVW R30,R28
00268d 9638      	ADIW R30,8
00268e 93fa      	ST   -Y,R31
00268f 93ea      	ST   -Y,R30
002690 01fe      	MOVW R30,R28
002691 9676      	ADIW R30,22
002692 93fa      	ST   -Y,R31
002693 93ea      	ST   -Y,R30
002694 940e 0c3e 	CALL _scan_directory
002696 019f      	MOVW R18,R30
002697 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x69:
002698 83ee      	STD  Y+6,R30
002699 83ff      	STD  Y+6+1,R31
00269a 9730      	SBIW R30,0
00269b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x6A:
00269c 91e0 0935 	LDS  R30,_BPB_BytsPerSec
00269e 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
0026a0 85a8
0026a1 85b9
0026a2 858a
0026a3 859b      	__GETD2S 8
0026a4 2766      	CLR  R22
0026a5 2777      	CLR  R23
0026a6 940e 2a33 	CALL __MODD21U
0026a8 01af      	MOVW R20,R30
0026a9 01fa      	MOVW R30,R20
0026aa 85a8
0026ab 85b9
0026ac 858a
0026ad 859b      	__GETD2S 8
0026ae 2766      	CLR  R22
0026af 2777      	CLR  R23
0026b0 940e 296b 	CALL __SUBD21
0026b2 87a8
0026b3 87b9
0026b4 878a
0026b5 879b      	__PUTD2S 8
0026b6 85e8
0026b7 85f9
0026b8 856a
0026b9 857b      	__GETD1S 8
0026ba cdcd      	RJMP SUBOPT_0x34
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x6B:
0026bb 01fe      	MOVW R30,R28
0026bc 9674      	ADIW R30,20
0026bd 93fa      	ST   -Y,R31
0026be 93ea      	ST   -Y,R30
0026bf 940e 0edd 	CALL _file_name_conversion
0026c1 8be8      	STD  Y+16,R30
0026c2 8bf9      	STD  Y+16+1,R31
0026c3 9730      	SBIW R30,0
0026c4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES
                 SUBOPT_0x6C:
0026c5 81ee      	LDD  R30,Y+6
0026c6 81ff      	LDD  R31,Y+6+1
0026c7 93fa      	ST   -Y,R31
0026c8 93ea      	ST   -Y,R30
0026c9 dc3a      	RCALL _free
0026ca cfa6      	RJMP SUBOPT_0x67
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x6D:
0026cb 01fa      	MOVW R30,R20
0026cc 5de1      	SUBI R30,LOW(-__FF_buff)
0026cd 4ff8      	SBCI R31,HIGH(-__FF_buff)
0026ce 8bea      	STD  Y+18,R30
0026cf 8bfb      	STD  Y+18+1,R31
0026d0 2e02      	MOV  R0,R18
0026d1 2a03      	OR   R0,R19
0026d2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x6E:
0026d3 e0eb      	LDI  R30,LOW(11)
0026d4 93e0 0972 	STS  __FF_error,R30
0026d6 cfee      	RJMP SUBOPT_0x6C
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
                 SUBOPT_0x6F:
0026d7 0fa0      	ADD  R26,R16
0026d8 1fb1      	ADC  R27,R17
0026d9 91ec      	LD   R30,X
0026da 01d0      	MOVW R26,R0
0026db 93ec      	ST   X,R30
0026dc 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x70:
0026dd 81ae      	LDD  R26,Y+6
0026de 81bf      	LDD  R27,Y+6+1
0026df 961c      	ADIW R26,12
0026e0 940e 2a4a 	CALL __GETW1P
0026e2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x71:
0026e3 9652      	ADIW R26,18
0026e4 e0e0      	LDI  R30,LOW(0)
0026e5 e0f0      	LDI  R31,HIGH(0)
0026e6 93ed      	ST   X+,R30
0026e7 93fc      	ST   X,R31
0026e8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x72:
0026e9 81ae      	LDD  R26,Y+6
0026ea 81bf      	LDD  R27,Y+6+1
0026eb 5ea4      	SUBI R26,LOW(-540)
0026ec 4fbd      	SBCI R27,HIGH(-540)
0026ed e0e0
0026ee e0f0
0026ef e060
0026f0 e070      	__GETD1N 0x0
0026f1 940e 2a54 	CALL __PUTDP1
0026f3 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x73:
0026f4 01fa      	MOVW R30,R20
0026f5 5de1      	SUBI R30,LOW(-__FF_buff)
0026f6 4ff8      	SBCI R31,HIGH(-__FF_buff)
0026f7 967f      	ADIW R30,31
0026f8 8bea      	STD  Y+18,R30
0026f9 8bfb      	STD  Y+18+1,R31
0026fa 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x74:
0026fb 89aa      	LDD  R26,Y+18
0026fc 89bb      	LDD  R27,Y+18+1
0026fd 9711      	SBIW R26,1
0026fe 8baa      	STD  Y+18,R26
0026ff 8bbb      	STD  Y+18+1,R27
002700 9611      	ADIW R26,1
002701 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x75:
002702 81ae      	LDD  R26,Y+6
002703 81bf      	LDD  R27,Y+6+1
002704 5ea4      	SUBI R26,LOW(-540)
002705 4fbd      	SBCI R27,HIGH(-540)
002706 940e 2a4e 	CALL __GETD1P
002708 940e 2aa4 	CALL __CPD10
00270a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x76:
00270b 81ee      	LDD  R30,Y+6
00270c 81ff      	LDD  R31,Y+6+1
00270d 85a4      	LDD  R26,Z+12
00270e 85b5      	LDD  R27,Z+13
00270f 93ba      	ST   -Y,R27
002710 93aa      	ST   -Y,R26
002711 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES
                 SUBOPT_0x77:
002712 81ee      	LDD  R30,Y+6
002713 81ff      	LDD  R31,Y+6+1
002714 85a6      	LDD  R26,Z+14
002715 85b7      	LDD  R27,Z+15
002716 93ba      	ST   -Y,R27
002717 93aa      	ST   -Y,R26
002718 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0x78:
002719 e0e1      	LDI  R30,LOW(1)
00271a 93ea      	ST   -Y,R30
00271b 940c 0e5c 	JMP  _next_cluster
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x79:
00271d 81ae      	LDD  R26,Y+6
00271e 81bf      	LDD  R27,Y+6+1
00271f 9654      	ADIW R26,20
002720 e0e1      	LDI  R30,LOW(1)
002721 e0f0      	LDI  R31,HIGH(1)
002722 93ed      	ST   X+,R30
002723 93fc      	ST   X,R31
002724 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0x7A:
002725 81ee      	LDD  R30,Y+6
002726 81ff      	LDD  R31,Y+6+1
002727 967c      	ADIW R30,28
002728 0fe0      	ADD  R30,R16
002729 1ff1      	ADC  R31,R17
00272a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x7B:
00272b 010f      	MOVW R0,R30
00272c e2af      	LDI  R26,LOW(__FF_buff)
00272d e0b7      	LDI  R27,HIGH(__FF_buff)
00272e cfa8      	RJMP SUBOPT_0x6F
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x7C:
00272f 0fea      	ADD  R30,R26
002730 1ffb      	ADC  R31,R27
002731 010f      	MOVW R0,R30
002732 01f8      	MOVW R30,R16
002733 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x7D:
002734 e0e5      	LDI  R30,LOW(5)
002735 93e0 0972 	STS  __FF_error,R30
002737 cf39      	RJMP SUBOPT_0x67
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x7E:
002738 89ea      	LDD  R30,Y+18
002739 89fb      	LDD  R31,Y+18+1
00273a 9631      	ADIW R30,1
00273b 8bea      	STD  Y+18,R30
00273c 8bfb      	STD  Y+18+1,R31
00273d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES
                 SUBOPT_0x7F:
00273e 89aa      	LDD  R26,Y+18
00273f 89bb      	LDD  R27,Y+18+1
002740 9611      	ADIW R26,1
002741 8baa      	STD  Y+18,R26
002742 8bbb      	STD  Y+18+1,R27
002743 9711      	SBIW R26,1
002744 e0e0      	LDI  R30,LOW(0)
002745 93ec      	ST   X,R30
002746 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x80:
002747 9724      	SBIW R28,4
002748 931a      	ST   -Y,R17
002749 930a      	ST   -Y,R16
00274a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0x81:
00274b 81ae      	LDD  R26,Y+6
00274c 81bf      	LDD  R27,Y+6+1
00274d 5dac      	SUBI R26,LOW(-548)
00274e 4fbd      	SBCI R27,HIGH(-548)
00274f 91ac      	LD   R26,X
002750 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x82:
002751 81ae      	LDD  R26,Y+6
002752 81bf      	LDD  R27,Y+6+1
002753 9654      	ADIW R26,20
002754 940e 2a4a 	CALL __GETW1P
002756 9731      	SBIW R30,1
002757 91a0 0935 	LDS  R26,_BPB_BytsPerSec
002759 91b0 0936 	LDS  R27,_BPB_BytsPerSec+1
00275b 940e 29c5 	CALL __MULW12U
00275d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x83:
00275e 2766      	CLR  R22
00275f 2777      	CLR  R23
002760 940e 295c 	CALL __ADDD12
002762 83ea
002763 83fb
002764 836c
002765 837d      	__PUTD1S 2
002766 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x84:
002767 01d8      	MOVW R26,R16
002768 5da1      	SUBI R26,LOW(-__FF_buff)
002769 4fb8      	SBCI R27,HIGH(-__FF_buff)
00276a cfba      	RJMP SUBOPT_0x7A
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x85:
00276b 81ee      	LDD  R30,Y+6
00276c 81ff      	LDD  R31,Y+6+1
00276d 93fa      	ST   -Y,R31
00276e 93ea      	ST   -Y,R30
00276f 940e 10ec 	CALL _append_toc
002771 30e0      	CPI  R30,0
002772 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x86:
002773 5dac      	SUBI R26,LOW(-548)
002774 4fbd      	SBCI R27,HIGH(-548)
002775 91ac      	LD   R26,X
002776 30a1      	CPI  R26,LOW(0x1)
002777 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x87:
002778 81af      	LDD  R26,Y+7
002779 85b8      	LDD  R27,Y+7+1
00277a 5ea0      	SUBI R26,LOW(-544)
00277b 4fbd      	SBCI R27,HIGH(-544)
00277c 940e 2a4e 	CALL __GETD1P
00277e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x88:
00277f 5dab      	SUBI R26,LOW(-549)
002780 4fbd      	SBCI R27,HIGH(-549)
002781 e0ea      	LDI  R30,LOW(10)
002782 93ec      	ST   X,R30
002783 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x89:
002784 81af      	LDD  R26,Y+7
002785 85b8      	LDD  R27,Y+7+1
002786 5da9      	SUBI R26,LOW(-551)
002787 4fbd      	SBCI R27,HIGH(-551)
002788 940e 2a4a 	CALL __GETW1P
00278a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x8A:
00278b 965c      	ADIW R26,28
00278c 91e0 0935 	LDS  R30,_BPB_BytsPerSec
00278e 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
002790 9731      	SBIW R30,1
002791 0fea      	ADD  R30,R26
002792 1ffb      	ADC  R31,R27
002793 15e0      	CP   R30,R0
002794 05f1      	CPC  R31,R1
002795 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x8B:
002796 81af      	LDD  R26,Y+7
002797 85b8      	LDD  R27,Y+7+1
002798 5dac      	SUBI R26,LOW(-548)
002799 4fbd      	SBCI R27,HIGH(-548)
00279a 91ac      	LD   R26,X
00279b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x8C:
00279c 81ef      	LDD  R30,Y+7
00279d 85f8      	LDD  R31,Y+7+1
00279e 967c      	ADIW R30,28
00279f 0fe1      	ADD  R30,R17
0027a0 1ff2      	ADC  R31,R18
0027a1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x8D:
0027a2 81ef      	LDD  R30,Y+7
0027a3 85f8      	LDD  R31,Y+7+1
0027a4 85a6      	LDD  R26,Z+14
0027a5 85b7      	LDD  R27,Z+15
0027a6 93ba      	ST   -Y,R27
0027a7 93aa      	ST   -Y,R26
0027a8 940c 0da9 	JMP  _clust_to_addr
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x8E:
0027aa 81af      	LDD  R26,Y+7
0027ab 85b8      	LDD  R27,Y+7+1
0027ac 9654      	ADIW R26,20
0027ad 940e 2a4a 	CALL __GETW1P
0027af 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x8F:
0027b0 2766      	CLR  R22
0027b1 2777      	CLR  R23
0027b2 940e 295c 	CALL __ADDD12
0027b4 83eb
0027b5 83fc
0027b6 836d
0027b7 837e      	__PUTD1S 3
0027b8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x90:
0027b9 89a4      	LDD  R26,Z+20
0027ba 89b5      	LDD  R27,Z+21
0027bb 91e0 0937 	LDS  R30,_BPB_SecPerClus
0027bd e0f0      	LDI  R31,0
0027be 17ae      	CP   R26,R30
0027bf 07bf      	CPC  R27,R31
0027c0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x91:
0027c1 5daa      	SUBI R26,LOW(-550)
0027c2 4fbd      	SBCI R27,HIGH(-550)
0027c3 e0e1      	LDI  R30,LOW(1)
0027c4 93ec      	ST   X,R30
0027c5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x92:
0027c6 5fef
0027c7 4fff
0027c8 4f6f
0027c9 4f7f      	__SUBD1N -1
0027ca 940e 2a54 	CALL __PUTDP1
0027cc 2fe0      	MOV  R30,R16
0027cd e0f0      	LDI  R31,0
0027ce 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x93:
0027cf 9654      	ADIW R26,20
0027d0 e0e1      	LDI  R30,LOW(1)
0027d1 e0f0      	LDI  R31,HIGH(1)
0027d2 93ed      	ST   X+,R30
0027d3 93fc      	ST   X,R31
0027d4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x94:
0027d5 91ec      	LD   R30,X
0027d6 01d0      	MOVW R26,R0
0027d7 93ec      	ST   X,R30
0027d8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x95:
0027d9 e0e0      	LDI  R30,LOW(0)
0027da e0f0      	LDI  R31,HIGH(0)
0027db 93fa      	ST   -Y,R31
0027dc 93ea      	ST   -Y,R30
0027dd 940c 0f28 	JMP  _prev_cluster
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x96:
0027df 81ae      	LDD  R26,Y+6
0027e0 81bf      	LDD  R27,Y+6+1
0027e1 9650      	ADIW R26,16
0027e2 efef      	LDI  R30,LOW(65535)
0027e3 efff      	LDI  R31,HIGH(65535)
0027e4 93ed      	ST   X+,R30
0027e5 93fc      	ST   X,R31
0027e6 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x97:
0027e7 85e8      	LDD  R30,Y+8
0027e8 85f9      	LDD  R31,Y+8+1
0027e9 89a0      	LDD  R26,Z+16
0027ea 89b1      	LDD  R27,Z+17
0027eb 93ba      	ST   -Y,R27
0027ec 93aa      	ST   -Y,R26
0027ed 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0x98:
0027ee 93ea      	ST   -Y,R30
0027ef 940e 1054 	CALL _write_clus_table
0027f1 30e0      	CPI  R30,0
0027f2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES
                 SUBOPT_0x99:
0027f3 81ae      	LDD  R26,Y+6
0027f4 81bf      	LDD  R27,Y+6+1
0027f5 5ea0      	SUBI R26,LOW(-544)
0027f6 4fbd      	SBCI R27,HIGH(-544)
0027f7 940e 2a4e 	CALL __GETD1P
0027f9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES
                 SUBOPT_0x9A:
0027fa 81ae      	LDD  R26,Y+6
0027fb 81bf      	LDD  R27,Y+6+1
0027fc 5ea4      	SUBI R26,LOW(-540)
0027fd 4fbd      	SBCI R27,HIGH(-540)
0027fe 940e 2a4e 	CALL __GETD1P
002800 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x9B:
002801 81ae      	LDD  R26,Y+6
002802 81bf      	LDD  R27,Y+6+1
002803 5daa      	SUBI R26,LOW(-550)
002804 4fbd      	SBCI R27,HIGH(-550)
002805 91ec      	LD   R30,X
002806 30e0      	CPI  R30,0
002807 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x9C:
002808 81ae      	LDD  R26,Y+6
002809 81bf      	LDD  R27,Y+6+1
00280a 961e      	ADIW R26,14
00280b 940e 2a4a 	CALL __GETW1P
00280d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x9D:
00280e 5daa      	SUBI R26,LOW(-550)
00280f 4fbd      	SBCI R27,HIGH(-550)
002810 e0e0      	LDI  R30,LOW(0)
002811 93ec      	ST   X,R30
002812 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x9E:
002813 81ae      	LDD  R26,Y+6
002814 81bf      	LDD  R27,Y+6+1
002815 5da9      	SUBI R26,LOW(-551)
002816 4fbd      	SBCI R27,HIGH(-551)
002817 940e 2a4a 	CALL __GETW1P
002819 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0x9F:
00281a 81ae      	LDD  R26,Y+6
00281b 81bf      	LDD  R27,Y+6+1
00281c 9654      	ADIW R26,20
00281d 940e 2a4a 	CALL __GETW1P
00281f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xA0:
002820 89a9      	LDD  R26,Y+17
002821 89ba      	LDD  R27,Y+17+1
002822 5ea4      	SUBI R26,LOW(-540)
002823 4fbd      	SBCI R27,HIGH(-540)
002824 940e 2a4e 	CALL __GETD1P
002826 85ad
002827 85be
002828 858f
002829 8998      	__GETD2S 13
00282a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xA1:
00282b e0ea      	LDI  R30,LOW(10)
00282c 93e0 0972 	STS  __FF_error,R30
00282e efef      	LDI  R30,LOW(65535)
00282f efff      	LDI  R31,HIGH(65535)
002830 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xA2:
002831 91e0 0935 	LDS  R30,_BPB_BytsPerSec
002833 91f0 0936 	LDS  R31,_BPB_BytsPerSec+1
002835 85a8
002836 85b9
002837 858a
002838 859b      	__GETD2S 8
002839 2766      	CLR  R22
00283a 2777      	CLR  R23
00283b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xA3:
00283c 81a8      	LD   R26,Y
00283d 81b9      	LDD  R27,Y+1
00283e 5ea0      	SUBI R26,LOW(-544)
00283f 4fbd      	SBCI R27,HIGH(-544)
002840 940e 2a4e 	CALL __GETD1P
002842 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xA4:
002843 2ffe      	MOV  R31,R30
002844 e0e0      	LDI  R30,0
002845 91a0 0a2c 	LDS  R26,_kolvo_abonentov
002847 91b0 0a2d 	LDS  R27,_kolvo_abonentov+1
002849 2bea      	OR   R30,R26
00284a 2bfb      	OR   R31,R27
00284b 93e0 0a2c 	STS  _kolvo_abonentov,R30
00284d 93f0 0a2d 	STS  _kolvo_abonentov+1,R31
00284f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
                 SUBOPT_0xA5:
002850 91e0 0a20 	LDS  R30,_gshch7
002852 91f0 0a21 	LDS  R31,_gshch7+1
002854 93ec      	ST   X,R30
002855 940c 1d09 	JMP  _gshum7
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0xA6:
002857 58e0      	SUBI R30,LOW(-_txBuffer)
002858 4ffc      	SBCI R31,HIGH(-_txBuffer)
002859 01df      	MOVW R26,R30
00285a e7e1      	LDI  R30,LOW(113)
00285b 93ec      	ST   X,R30
00285c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xA7:
00285d 58e0      	SUBI R30,LOW(-_txBuffer)
00285e 4ffc      	SBCI R31,HIGH(-_txBuffer)
00285f 01df      	MOVW R26,R30
002860 e0e0      	LDI  R30,LOW(0)
002861 93ec      	ST   X,R30
002862 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xA8:
002863 81e0      	LD   R30,Z
002864 01d9      	MOVW R26,R18
002865 e0f0      	LDI  R31,0
002866 0fea      	ADD  R30,R26
002867 1ffb      	ADC  R31,R27
002868 019f      	MOVW R18,R30
002869 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0xA9:
00286a 93ea      	ST   -Y,R30
00286b e1e0      	LDI  R30,LOW(16)
00286c 93ea      	ST   -Y,R30
00286d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0xAA:
00286e 5fec      	SUBI R30,-LOW(4)
00286f 93ea      	ST   -Y,R30
002870 940e 20a7 	CALL _RUN_TWI
002872 30e0      	CPI  R30,0
002873 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xAB:
002874 91e0 0a1c 	LDS  R30,_gshch5
002876 91f0 0a1d 	LDS  R31,_gshch5+1
002878 70f0      	ANDI R31,HIGH(0xFF)
002879 93ec      	ST   X,R30
00287a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xAC:
00287b 2fae      	MOV  R26,R30
00287c 91e0 0a18 	LDS  R30,_gshch3
00287e 91f0 0a19 	LDS  R31,_gshch3+1
002880 27ea      	EOR  R30,R26
002881 01d0      	MOVW R26,R0
002882 93ec      	ST   X,R30
002883 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xAD:
002884 01d9      	MOVW R26,R18
002885 e0f0      	LDI  R31,0
002886 0fea      	ADD  R30,R26
002887 1ffb      	ADC  R31,R27
002888 019f      	MOVW R18,R30
002889 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xAE:
00288a efef      	LDI  R30,LOW(65535)
00288b efff      	LDI  R31,HIGH(65535)
00288c 1be2      	SUB  R30,R18
00288d 0bf3      	SBC  R31,R19
00288e 019f      	MOVW R18,R30
00288f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0xAF:
002890 2fe0      	MOV  R30,R16
002891 e0f0      	LDI  R31,0
002892 0fae      	ADD  R26,R30
002893 1fbf      	ADC  R27,R31
002894 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0xB0:
002895 93ea      	ST   -Y,R30
002896 940e 1ee3 	CALL _zakrutbuf
002898 940c 1e1d 	JMP  _g_tx_kazakovu
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xB1:
00289a 931a      	ST   -Y,R17
00289b 930a      	ST   -Y,R16
00289c e2e6      	LDI  R30,LOW(38)
00289d 93e0 0a2a 	STS  _komu,R30
00289f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xB2:
0028a0 2fe0      	MOV  R30,R16
0028a1 e0f0      	LDI  R31,0
0028a2 5ce4      	SUBI R30,LOW(-_TWI_buf_GA)
0028a3 4ff5      	SBCI R31,HIGH(-_TWI_buf_GA)
0028a4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xB3:
0028a5 e0e0      	LDI  R30,LOW(0)
0028a6 93e0 0620 	STS  _TWI_statusReg,R30
0028a8 efe8      	LDI  R30,LOW(248)
0028a9 93e0 0b3c 	STS  _TWI_state_GA,R30
0028ab eae5      	LDI  R30,LOW(165)
0028ac 93e0 0074 	STS  116,R30
0028ae 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xB4:
0028af 91e0 0b3d 	LDS  R30,_TWI_bufPtr_S80
0028b1 5fef      	SUBI R30,-LOW(1)
0028b2 93e0 0b3d 	STS  _TWI_bufPtr_S80,R30
0028b4 50e1      	SUBI R30,LOW(1)
0028b5 e0f0      	LDI  R31,0
0028b6 5ce4      	SUBI R30,LOW(-_TWI_buf_GA)
0028b7 4ff5      	SBCI R31,HIGH(-_TWI_buf_GA)
0028b8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xB5:
0028b9 91e0 0620 	LDS  R30,_TWI_statusReg
0028bb 60e1      	ORI  R30,1
0028bc 93e0 0620 	STS  _TWI_statusReg,R30
0028be e9e4      	LDI  R30,LOW(148)
0028bf 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xB6:
0028c0 81aa      	LDD  R26,Y+2
0028c1 81bb      	LDD  R27,Y+2+1
0028c2 91ed      	LD   R30,X+
0028c3 83aa      	STD  Y+2,R26
0028c4 83bb      	STD  Y+2+1,R27
0028c5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xB7:
0028c6 e8e0      	LDI  R30,LOW(_txBuffer)
0028c7 e0f3      	LDI  R31,HIGH(_txBuffer)
0028c8 93fa      	ST   -Y,R31
0028c9 93ea      	ST   -Y,R30
0028ca 81ea      	LDD  R30,Y+2
0028cb 93ea      	ST   -Y,R30
0028cc 940c 1fc6 	JMP  _TWI_Start_Transceiver_With_Data
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES
                 SUBOPT_0xB8:
0028ce e0f0      	LDI  R31,0
0028cf 58e0      	SUBI R30,LOW(-_txBuffer)
0028d0 4ffc      	SBCI R31,HIGH(-_txBuffer)
0028d1 01df      	MOVW R26,R30
0028d2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0xB9:
0028d3 93ea      	ST   -Y,R30
0028d4 e0e2      	LDI  R30,LOW(2)
0028d5 93ea      	ST   -Y,R30
0028d6 940e 20a7 	CALL _RUN_TWI
0028d8 30e0      	CPI  R30,0
0028d9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
                 SUBOPT_0xBA:
0028da 81e8      	LD   R30,Y
0028db 93ea      	ST   -Y,R30
0028dc e0e0      	LDI  R30,LOW(0)
0028dd 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0xBB:
0028de 93ea      	ST   -Y,R30
0028df 940e 20a7 	CALL _RUN_TWI
0028e1 30e0      	CPI  R30,0
0028e2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
                 SUBOPT_0xBC:
0028e3 2fe2      	MOV  R30,R18
0028e4 50e1      	SUBI R30,LOW(1)
0028e5 e0f0      	LDI  R31,0
0028e6 58e0      	SUBI R30,LOW(-_txBuffer)
0028e7 4ffc      	SBCI R31,HIGH(-_txBuffer)
0028e8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
                 SUBOPT_0xBD:
0028e9 01d8      	MOVW R26,R16
0028ea 9612      	ADIW R26,2
0028eb 940e 2a4a 	CALL __GETW1P
0028ed 019f      	MOVW R18,R30
0028ee 9508      	RET
                 
                 _memmove:
0028ef 8199      	ldd  r25,y+1
0028f0 8188      	ld   r24,y
0028f1 9600      	adiw r24,0
0028f2 f0a9      	breq __memmove3
0028f3 81bd      	ldd  r27,y+5
0028f4 81ac      	ldd  r26,y+4
0028f5 81fb      	ldd  r31,y+3
0028f6 81ea      	ldd  r30,y+2
0028f7 17ea      	cp   r30,r26
0028f8 07fb      	cpc  r31,r27
0028f9 f071      	breq __memmove3
0028fa f02c      	brlt __memmove1
                 __memmove0:
0028fb 9161      	ld   r22,z+
0028fc 936d      	st   x+,r22
0028fd 9701      	sbiw r24,1
0028fe f7e1      	brne __memmove0
0028ff c008      	rjmp __memmove3
                 __memmove1:
002900 0fa8      	add  r26,r24
002901 1fb9      	adc  r27,r25
002902 0fe8      	add  r30,r24
002903 1ff9      	adc  r31,r25
                 __memmove2:
002904 9162      	ld   r22,-z
002905 936e      	st   -x,r22
002906 9701      	sbiw r24,1
002907 f7e1      	brne __memmove2
                 __memmove3:
002908 81fd      	ldd  r31,y+5
002909 81ec      	ldd  r30,y+4
00290a 9626      	adiw r28,6
00290b 9508      	ret
                 
                 _memset:
00290c 81b9      	ldd  r27,y+1
00290d 81a8      	ld   r26,y
00290e 9610      	adiw r26,0
00290f f031      	breq __memset1
002910 81fc      	ldd  r31,y+4
002911 81eb      	ldd  r30,y+3
002912 816a      	ldd  r22,y+2
                 __memset0:
002913 9361      	st   z+,r22
002914 9711      	sbiw r26,1
002915 f7e9      	brne __memset0
                 __memset1:
002916 81eb      	ldd  r30,y+3
002917 81fc      	ldd  r31,y+4
002918 9625      	adiw r28,5
002919 9508      	ret
                 
                 _strlen:
00291a 91a9      	ld   r26,y+
00291b 91b9      	ld   r27,y+
00291c 27ee      	clr  r30
00291d 27ff      	clr  r31
                 __strlen0:
00291e 916d      	ld   r22,x+
00291f 2366      	tst  r22
002920 f011      	breq __strlen1
002921 9631      	adiw r30,1
002922 cffb      	rjmp __strlen0
                 __strlen1:
002923 9508      	ret
                 
                 _strncmp:
002924 2766      	clr  r22
002925 2777      	clr  r23
002926 9189      	ld   r24,y+
002927 91e9      	ld   r30,y+
002928 91f9      	ld   r31,y+
002929 91a9      	ld   r26,y+
00292a 91b9      	ld   r27,y+
                 __strncmp0:
00292b 2388      	tst  r24
00292c f049      	breq __strncmp1
00292d 958a      	dec  r24
00292e 916d      	ld   r22,x+
00292f 9171      	ld   r23,z+
002930 1767      	cp   r22,r23
002931 f421      	brne __strncmp1
002932 2366      	tst  r22
002933 f7b9      	brne __strncmp0
                 __strncmp3:
002934 27ee      	clr  r30
002935 9508      	ret
                 __strncmp1:
002936 1b67      	sub  r22,r23
002937 f3e1      	breq __strncmp3
002938 e0e1      	ldi  r30,1
002939 f408      	brcc __strncmp2
00293a 50e2      	subi r30,2
                 __strncmp2:
00293b 9508      	ret
                 
                 _strrpos:
00293c 9169      	ld   r22,y+
00293d 91a9      	ld   r26,y+
00293e 91b9      	ld   r27,y+
00293f efef      	ldi  r30,-1
002940 27ff      	clr  r31
                 __strrpos0:
002941 917d      	ld   r23,x+
002942 1767      	cp   r22,r23
002943 f409      	brne __strrpos1
002944 2fef      	mov  r30,r31
                 __strrpos1:
002945 95f3      	inc  r31
002946 2377      	tst  r23
002947 f7c9      	brne __strrpos0
002948 9508      	ret
                 
                 _toupper:
002949 91e9      	ld   r30,y+
00294a 36e1      	cpi  r30,'a'
00294b f018      	brlo __toupper0
00294c 37eb      	cpi  r30,'z'+1
00294d f408      	brcc __toupper0
00294e 52e0      	subi r30,32
                 __toupper0:
00294f 9508      	ret
                 
                 _delay_ms:
002950 91e9      	ld   r30,y+
002951 91f9      	ld   r31,y+
002952 9630      	adiw r30,0
002953 f039      	breq __delay_ms1
                 __delay_ms0:
002954 ed80
002955 e097
002956 9701
002957 f7f1      	__DELAY_USW 0x7D0
002958 95a8      	wdr
002959 9731      	sbiw r30,1
00295a f7c9      	brne __delay_ms0
                 __delay_ms1:
00295b 9508      	ret
                 
                 __ADDD12:
00295c 0fea      	ADD  R30,R26
00295d 1ffb      	ADC  R31,R27
00295e 1f68      	ADC  R22,R24
00295f 1f79      	ADC  R23,R25
002960 9508      	RET
                 
                 __ADDD21:
002961 0fae      	ADD  R26,R30
002962 1fbf      	ADC  R27,R31
002963 1f86      	ADC  R24,R22
002964 1f97      	ADC  R25,R23
002965 9508      	RET
                 
                 __SUBD12:
002966 1bea      	SUB  R30,R26
002967 0bfb      	SBC  R31,R27
002968 0b68      	SBC  R22,R24
002969 0b79      	SBC  R23,R25
00296a 9508      	RET
                 
                 __SUBD21:
00296b 1bae      	SUB  R26,R30
00296c 0bbf      	SBC  R27,R31
00296d 0b86      	SBC  R24,R22
00296e 0b97      	SBC  R25,R23
00296f 9508      	RET
                 
                 __ORD12:
002970 2bea      	OR   R30,R26
002971 2bfb      	OR   R31,R27
002972 2b68      	OR   R22,R24
002973 2b79      	OR   R23,R25
002974 9508      	RET
                 
                 __ANEGD1:
002975 95e0      	COM  R30
002976 95f0      	COM  R31
002977 9560      	COM  R22
002978 9570      	COM  R23
002979 5fef      	SUBI R30,-1
00297a 4fff      	SBCI R31,-1
00297b 4f6f      	SBCI R22,-1
00297c 4f7f      	SBCI R23,-1
00297d 9508      	RET
                 
                 __LSLB12:
00297e 23ee      	TST  R30
00297f 2e0e      	MOV  R0,R30
002980 2fea      	MOV  R30,R26
002981 f019      	BREQ __LSLB12R
                 __LSLB12L:
002982 0fee      	LSL  R30
002983 940a      	DEC  R0
002984 f7e9      	BRNE __LSLB12L
                 __LSLB12R:
002985 9508      	RET
                 
                 __LSLD12:
002986 23ee      	TST  R30
002987 2e0e      	MOV  R0,R30
002988 01fd      	MOVW R30,R26
002989 01bc      	MOVW R22,R24
00298a f031      	BREQ __LSLD12R
                 __LSLD12L:
00298b 0fee      	LSL  R30
00298c 1fff      	ROL  R31
00298d 1f66      	ROL  R22
00298e 1f77      	ROL  R23
00298f 940a      	DEC  R0
002990 f7d1      	BRNE __LSLD12L
                 __LSLD12R:
002991 9508      	RET
                 
                 __LSRD12:
002992 23ee      	TST  R30
002993 2e0e      	MOV  R0,R30
002994 01fd      	MOVW R30,R26
002995 01bc      	MOVW R22,R24
002996 f031      	BREQ __LSRD12R
                 __LSRD12L:
002997 9576      	LSR  R23
002998 9567      	ROR  R22
002999 95f7      	ROR  R31
00299a 95e7      	ROR  R30
00299b 940a      	DEC  R0
00299c f7d1      	BRNE __LSRD12L
                 __LSRD12R:
00299d 9508      	RET
                 
                 __LSLW4:
00299e 0fee      	LSL  R30
00299f 1fff      	ROL  R31
                 __LSLW3:
0029a0 0fee      	LSL  R30
0029a1 1fff      	ROL  R31
                 __LSLW2:
0029a2 0fee      	LSL  R30
0029a3 1fff      	ROL  R31
0029a4 0fee      	LSL  R30
0029a5 1fff      	ROL  R31
0029a6 9508      	RET
                 
                 __LSRD1:
0029a7 9576      	LSR  R23
0029a8 9567      	ROR  R22
0029a9 95f7      	ROR  R31
0029aa 95e7      	ROR  R30
0029ab 9508      	RET
                 
                 __LSLD1:
0029ac 0fee      	LSL  R30
0029ad 1fff      	ROL  R31
0029ae 1f66      	ROL  R22
0029af 1f77      	ROL  R23
0029b0 9508      	RET
                 
                 __LSRD16:
0029b1 2fe6      	MOV  R30,R22
0029b2 2ff7      	MOV  R31,R23
0029b3 e060      	LDI  R22,0
0029b4 e070      	LDI  R23,0
0029b5 9508      	RET
                 
                 __LSLD16:
0029b6 2f6e      	MOV  R22,R30
0029b7 2f7f      	MOV  R23,R31
0029b8 e0e0      	LDI  R30,0
0029b9 e0f0      	LDI  R31,0
0029ba 9508      	RET
                 
                 __CWD1:
0029bb 2f6f      	MOV  R22,R31
0029bc 0f66      	ADD  R22,R22
0029bd 0b66      	SBC  R22,R22
0029be 2f76      	MOV  R23,R22
0029bf 9508      	RET
                 
                 __EQB12:
0029c0 17ea      	CP   R30,R26
0029c1 e0e1      	LDI  R30,1
0029c2 f009      	BREQ __EQB12T
0029c3 27ee      	CLR  R30
                 __EQB12T:
0029c4 9508      	RET
                 
                 __MULW12U:
0029c5 9ffa      	MUL  R31,R26
0029c6 2df0      	MOV  R31,R0
0029c7 9feb      	MUL  R30,R27
0029c8 0df0      	ADD  R31,R0
0029c9 9fea      	MUL  R30,R26
0029ca 2de0      	MOV  R30,R0
0029cb 0df1      	ADD  R31,R1
0029cc 9508      	RET
                 
                 __MULD12U:
0029cd 9f7a      	MUL  R23,R26
0029ce 2d70      	MOV  R23,R0
0029cf 9f6b      	MUL  R22,R27
0029d0 0d70      	ADD  R23,R0
0029d1 9ff8      	MUL  R31,R24
0029d2 0d70      	ADD  R23,R0
0029d3 9fe9      	MUL  R30,R25
0029d4 0d70      	ADD  R23,R0
0029d5 9f6a      	MUL  R22,R26
0029d6 2d60      	MOV  R22,R0
0029d7 0d71      	ADD  R23,R1
0029d8 9ffb      	MUL  R31,R27
0029d9 0d60      	ADD  R22,R0
0029da 1d71      	ADC  R23,R1
0029db 9fe8      	MUL  R30,R24
0029dc 0d60      	ADD  R22,R0
0029dd 1d71      	ADC  R23,R1
0029de 2788      	CLR  R24
0029df 9ffa      	MUL  R31,R26
0029e0 2df0      	MOV  R31,R0
0029e1 0d61      	ADD  R22,R1
0029e2 1f78      	ADC  R23,R24
0029e3 9feb      	MUL  R30,R27
0029e4 0df0      	ADD  R31,R0
0029e5 1d61      	ADC  R22,R1
0029e6 1f78      	ADC  R23,R24
0029e7 9fea      	MUL  R30,R26
0029e8 2de0      	MOV  R30,R0
0029e9 0df1      	ADD  R31,R1
0029ea 1f68      	ADC  R22,R24
0029eb 1f78      	ADC  R23,R24
0029ec 9508      	RET
                 
                 __MULD12:
0029ed d049      	RCALL __CHKSIGND
0029ee dfde      	RCALL __MULD12U
0029ef f40e      	BRTC __MULD121
0029f0 df84      	RCALL __ANEGD1
                 __MULD121:
0029f1 9508      	RET
                 
                 __DIVW21U:
0029f2 2400      	CLR  R0
0029f3 2411      	CLR  R1
0029f4 e190      	LDI  R25,16
                 __DIVW21U1:
0029f5 0faa      	LSL  R26
0029f6 1fbb      	ROL  R27
0029f7 1c00      	ROL  R0
0029f8 1c11      	ROL  R1
0029f9 1a0e      	SUB  R0,R30
0029fa 0a1f      	SBC  R1,R31
0029fb f418      	BRCC __DIVW21U2
0029fc 0e0e      	ADD  R0,R30
0029fd 1e1f      	ADC  R1,R31
0029fe c001      	RJMP __DIVW21U3
                 __DIVW21U2:
0029ff 60a1      	SBR  R26,1
                 __DIVW21U3:
002a00 959a      	DEC  R25
002a01 f799      	BRNE __DIVW21U1
002a02 01fd      	MOVW R30,R26
002a03 01d0      	MOVW R26,R0
002a04 9508      	RET
                 
                 __DIVD21U:
002a05 933f      	PUSH R19
002a06 934f      	PUSH R20
002a07 935f      	PUSH R21
002a08 2400      	CLR  R0
002a09 2411      	CLR  R1
002a0a 2733      	CLR  R19
002a0b 2744      	CLR  R20
002a0c e250      	LDI  R21,32
                 __DIVD21U1:
002a0d 0faa      	LSL  R26
002a0e 1fbb      	ROL  R27
002a0f 1f88      	ROL  R24
002a10 1f99      	ROL  R25
002a11 1c00      	ROL  R0
002a12 1c11      	ROL  R1
002a13 1f33      	ROL  R19
002a14 1f44      	ROL  R20
002a15 1a0e      	SUB  R0,R30
002a16 0a1f      	SBC  R1,R31
002a17 0b36      	SBC  R19,R22
002a18 0b47      	SBC  R20,R23
002a19 f428      	BRCC __DIVD21U2
002a1a 0e0e      	ADD  R0,R30
002a1b 1e1f      	ADC  R1,R31
002a1c 1f36      	ADC  R19,R22
002a1d 1f47      	ADC  R20,R23
002a1e c001      	RJMP __DIVD21U3
                 __DIVD21U2:
002a1f 60a1      	SBR  R26,1
                 __DIVD21U3:
002a20 955a      	DEC  R21
002a21 f759      	BRNE __DIVD21U1
002a22 01fd      	MOVW R30,R26
002a23 01bc      	MOVW R22,R24
002a24 01d0      	MOVW R26,R0
002a25 2f83      	MOV  R24,R19
002a26 2f94      	MOV  R25,R20
002a27 915f      	POP  R21
002a28 914f      	POP  R20
002a29 913f      	POP  R19
002a2a 9508      	RET
                 
                 __DIVD21:
002a2b d00b      	RCALL __CHKSIGND
002a2c dfd8      	RCALL __DIVD21U
002a2d f40e      	BRTC __DIVD211
002a2e df46      	RCALL __ANEGD1
                 __DIVD211:
002a2f 9508      	RET
                 
                 __MODW21U:
002a30 dfc1      	RCALL __DIVW21U
002a31 01fd      	MOVW R30,R26
002a32 9508      	RET
                 
                 __MODD21U:
002a33 dfd1      	RCALL __DIVD21U
002a34 01fd      	MOVW R30,R26
002a35 01bc      	MOVW R22,R24
002a36 9508      	RET
                 
                 __CHKSIGND:
002a37 94e8      	CLT
002a38 ff77      	SBRS R23,7
002a39 c002      	RJMP __CHKSD1
002a3a df3a      	RCALL __ANEGD1
002a3b 9468      	SET
                 __CHKSD1:
002a3c ff97      	SBRS R25,7
002a3d c00b      	RJMP __CHKSD2
002a3e 2400      	CLR  R0
002a3f 95a0      	COM  R26
002a40 95b0      	COM  R27
002a41 9580      	COM  R24
002a42 9590      	COM  R25
002a43 9611      	ADIW R26,1
002a44 1d80      	ADC  R24,R0
002a45 1d90      	ADC  R25,R0
002a46 f800      	BLD  R0,0
002a47 9403      	INC  R0
002a48 fa00      	BST  R0,0
                 __CHKSD2:
002a49 9508      	RET
                 
                 __GETW1P:
002a4a 91ed      	LD   R30,X+
002a4b 91fc      	LD   R31,X
002a4c 9711      	SBIW R26,1
002a4d 9508      	RET
                 
                 __GETD1P:
002a4e 91ed      	LD   R30,X+
002a4f 91fd      	LD   R31,X+
002a50 916d      	LD   R22,X+
002a51 917c      	LD   R23,X
002a52 9713      	SBIW R26,3
002a53 9508      	RET
                 
                 __PUTDP1:
002a54 93ed      	ST   X+,R30
002a55 93fd      	ST   X+,R31
002a56 936d      	ST   X+,R22
002a57 937c      	ST   X,R23
002a58 9508      	RET
                 
                 __GETW1PF:
002a59 9005      	LPM  R0,Z+
002a5a 91f4      	LPM  R31,Z
002a5b 2de0      	MOV  R30,R0
002a5c 9508      	RET
                 
                 __GETD1PF:
002a5d 9005      	LPM  R0,Z+
002a5e 9015      	LPM  R1,Z+
002a5f 9165      	LPM  R22,Z+
002a60 9174      	LPM  R23,Z
002a61 01f0      	MOVW R30,R0
002a62 9508      	RET
                 
                 __PUTPARD1:
002a63 937a      	ST   -Y,R23
002a64 936a      	ST   -Y,R22
002a65 93fa      	ST   -Y,R31
002a66 93ea      	ST   -Y,R30
002a67 9508      	RET
                 
                 __PUTPARD2:
002a68 939a      	ST   -Y,R25
002a69 938a      	ST   -Y,R24
002a6a 93ba      	ST   -Y,R27
002a6b 93aa      	ST   -Y,R26
002a6c 9508      	RET
                 
                 __EEPROMRDD:
002a6d 9612      	ADIW R26,2
002a6e d003      	RCALL __EEPROMRDW
002a6f 2f7f      	MOV  R23,R31
002a70 2f6e      	MOV  R22,R30
002a71 9712      	SBIW R26,2
                 
                 __EEPROMRDW:
002a72 9611      	ADIW R26,1
002a73 d002      	RCALL __EEPROMRDB
002a74 2ffe      	MOV  R31,R30
002a75 9711      	SBIW R26,1
                 
                 __EEPROMRDB:
002a76 99e1      	SBIC EECR,EEWE
002a77 cffe      	RJMP __EEPROMRDB
002a78 93ff      	PUSH R31
002a79 b7ff      	IN   R31,SREG
002a7a 94f8      	CLI
002a7b bbae      	OUT  EEARL,R26
002a7c bbbf      	OUT  EEARH,R27
002a7d 9ae0      	SBI  EECR,EERE
002a7e b3ed      	IN   R30,EEDR
002a7f bfff      	OUT  SREG,R31
002a80 91ff      	POP  R31
002a81 9508      	RET
                 
                 __EEPROMWRD:
002a82 d00a      	RCALL __EEPROMWRW
002a83 9612      	ADIW R26,2
002a84 2e0e      	MOV  R0,R30
002a85 2e1f      	MOV  R1,R31
002a86 2fe6      	MOV  R30,R22
002a87 2ff7      	MOV  R31,R23
002a88 d004      	RCALL __EEPROMWRW
002a89 2de0      	MOV  R30,R0
002a8a 2df1      	MOV  R31,R1
002a8b 9712      	SBIW R26,2
002a8c 9508      	RET
                 
                 __EEPROMWRW:
002a8d d007      	RCALL __EEPROMWRB
002a8e 9611      	ADIW R26,1
002a8f 93ef      	PUSH R30
002a90 2fef      	MOV  R30,R31
002a91 d003      	RCALL __EEPROMWRB
002a92 91ef      	POP  R30
002a93 9711      	SBIW R26,1
002a94 9508      	RET
                 
                 __EEPROMWRB:
002a95 99e1      	SBIC EECR,EEWE
002a96 cffe      	RJMP __EEPROMWRB
002a97 b79f      	IN   R25,SREG
002a98 94f8      	CLI
002a99 bbae      	OUT  EEARL,R26
002a9a bbbf      	OUT  EEARH,R27
002a9b 9ae0      	SBI  EECR,EERE
002a9c b38d      	IN   R24,EEDR
002a9d 17e8      	CP   R30,R24
002a9e f019      	BREQ __EEPROMWRB0
002a9f bbed      	OUT  EEDR,R30
002aa0 9ae2      	SBI  EECR,EEMWE
002aa1 9ae1      	SBI  EECR,EEWE
                 __EEPROMWRB0:
002aa2 bf9f      	OUT  SREG,R25
002aa3 9508      	RET
                 
                 __CPD10:
002aa4 9730      	SBIW R30,0
002aa5 4060      	SBCI R22,0
002aa6 4070      	SBCI R23,0
002aa7 9508      	RET
                 
                 __CPW02:
002aa8 2400      	CLR  R0
002aa9 160a      	CP   R0,R26
002aaa 060b      	CPC  R0,R27
002aab 9508      	RET
                 
                 __CPD02:
002aac 2400      	CLR  R0
002aad 160a      	CP   R0,R26
002aae 060b      	CPC  R0,R27
002aaf 0608      	CPC  R0,R24
002ab0 0609      	CPC  R0,R25
002ab1 9508      	RET
                 
                 __CPD12:
002ab2 17ea      	CP   R30,R26
002ab3 07fb      	CPC  R31,R27
002ab4 0768      	CPC  R22,R24
002ab5 0779      	CPC  R23,R25
002ab6 9508      	RET
                 
                 __CPD21:
002ab7 17ae      	CP   R26,R30
002ab8 07bf      	CPC  R27,R31
002ab9 0786      	CPC  R24,R22
002aba 0797      	CPC  R25,R23
002abb 9508      	RET
                 
                 __SAVELOCR6:
002abc 935a      	ST   -Y,R21
                 __SAVELOCR5:
002abd 934a      	ST   -Y,R20
                 __SAVELOCR4:
002abe 933a      	ST   -Y,R19
                 __SAVELOCR3:
002abf 932a      	ST   -Y,R18
                 __SAVELOCR2:
002ac0 931a      	ST   -Y,R17
002ac1 930a      	ST   -Y,R16
002ac2 9508      	RET
                 
                 __LOADLOCR6:
002ac3 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
002ac4 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
002ac5 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
002ac6 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
002ac7 8119      	LDD  R17,Y+1
002ac8 8108      	LD   R16,Y
002ac9 9508      	RET
                 
                 __INITLOCB:
                 __INITLOCW:
002aca 0fac      	ADD R26,R28
002acb 1fbd      	ADC R27,R29
                 __INITLOC0:
002acc 9005      	LPM  R0,Z+
002acd 920d      	ST   X+,R0
002ace 958a      	DEC  R24
002acf f7e1      	BRNE __INITLOC0
002ad0 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega128 register use summary:
r0 : 104 r1 :  22 r2 :  10 r3 :   0 r4 :   4 r5 :   0 r6 :   0 r7 :   6 
r8 :   8 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16: 345 r17: 220 r18: 154 r19:  94 r20:  82 r21:  38 r22: 344 r23: 310 
r24: 174 r25: 131 r26: 890 r27: 502 r28:  91 r29:   2 r30:2656 r31:1004 
x  : 223 y  :1627 z  :  94 
Registers used: 25 out of 35 (71.4%)

ATmega128 instruction use summary:
adc   :  62 add   :  67 adiw  : 157 and   :   7 andi  :  74 asr   :   6 
bclr  :   0 bld   :   8 brbc  :   0 brbs  :   0 brcc  :   4 brcs  :   0 
break :   0 breq  : 135 brge  :   9 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :  32 brlt  :   1 brmi  :   0 brne  : 247 brpl  :   0 
brsh  :  78 brtc  :   2 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   2 call  : 956 cbi   :  11 cbr   :   0 clc   :   0 clh   :   0 
cli   :   3 cln   :   0 clr   : 153 cls   :   0 clt   :   4 clv   :   0 
clz   :   0 com   :   8 cp    :  52 cpc   : 109 cpi   : 272 cpse  :   0 
dec   :   8 elpm  :   0 eor   :  33 fmul  :   0 fmuls :   0 fmulsu:   0 
icall :   0 ijmp  :   0 in    :  23 inc   :   2 jmp   :  82 ld    : 162 
ldd   : 953 ldi   :1078 lds   : 530 lpm   :  24 lsl   :  25 lsr   :   5 
mov   : 165 movw  : 224 mul   :  14 muls  :   0 mulsu :   0 neg   :   0 
nop   :   0 or    :  49 ori   :  10 out   :  52 pop   : 117 push  : 117 
rcall :  73 ret   : 299 reti  :   6 rjmp  : 391 rol   :  34 ror   :  15 
sbc   :  14 sbci  : 217 sbi   :  37 sbic  :   2 sbis  :   5 sbiw  :  92 
sbr   :   2 sbrc  :   2 sbrs  :   4 sec   :   0 seh   :   0 sei   :   1 
sen   :   0 ser   :   0 ses   :   0 set   :   5 sev   :   0 sez   :   0 
sleep :   0 spm   :   0 st    : 460 std   : 345 sts   : 368 sub   :   9 
subi  : 248 swap  :   0 tst   :   8 wdr   :   2 
Instructions used: 69 out of 112 (61.6%)

ATmega128 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0055a2  21414    508  21922  131072  16.7%
[.dseg] 0x000100 0x000b3e      0   1982   1982    4096  48.4%
[.eseg] 0x000000 0x000081      0    129    129    4096   3.1%

Assembly complete, 0 errors, 14 warnings
