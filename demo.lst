
AVRASM ver. 1.52  demo.asm Wed Feb 22 15:21:42 2006


         ;CodeVisionAVR C Compiler V1.24.5 Standard
         ;(C) Copyright 1998-2005 Pavel Haiduc, HP InfoTech s.r.l.
         ;http://www.hpinfotech.com
         ;e-mail:office@hpinfotech.com
         
         ;Chip type              : ATmega128
         ;Program type           : Application
         ;Clock frequency        : 14,745600 MHz
         ;Memory model           : Small
         ;Optimize for           : Size
         ;(s)printf features     : long, width
         ;(s)scanf features      : long, width
         ;External SRAM size     : 0
         ;Data Stack size        : 1024 byte(s)
         ;Heap size              : 2268 byte(s)
         ;Promote char to int    : No
         ;char is unsigned       : Yes
         ;8 bit enums            : Yes
         ;Word align FLASH struct: Yes
         ;Enhanced core instructions    : On
         ;Automatic register allocation : On
         
          	.EQU UDRE=0x5
          	.EQU RXC=0x7
          	.EQU USR=0xB
          	.EQU UDR=0xC
          	.EQU SPSR=0xE
          	.EQU SPDR=0xF
          	.EQU EERE=0x0
          	.EQU EEWE=0x1
          	.EQU EEMWE=0x2
          	.EQU EECR=0x1C
          	.EQU EEDR=0x1D
          	.EQU EEARL=0x1E
          	.EQU EEARH=0x1F
          	.EQU WDTCR=0x21
          	.EQU MCUCR=0x35
          	.EQU RAMPZ=0x3B
          	.EQU SPL=0x3D
          	.EQU SPH=0x3E
          	.EQU SREG=0x3F
          	.EQU XMCRA=0x6D
          	.EQU XMCRB=0x6C
         
          	.DEF R0X0=R0
          	.DEF R0X1=R1
          	.DEF R0X2=R2
          	.DEF R0X3=R3
          	.DEF R0X4=R4
          	.DEF R0X5=R5
          	.DEF R0X6=R6
          	.DEF R0X7=R7
          	.DEF R0X8=R8
          	.DEF R0X9=R9
          	.DEF R0XA=R10
          	.DEF R0XB=R11
          	.DEF R0XC=R12
          	.DEF R0XD=R13
          	.DEF R0XE=R14
          	.DEF R0XF=R15
          	.DEF R0X10=R16
          	.DEF R0X11=R17
          	.DEF R0X12=R18
          	.DEF R0X13=R19
          	.DEF R0X14=R20
          	.DEF R0X15=R21
          	.DEF R0X16=R22
          	.DEF R0X17=R23
          	.DEF R0X18=R24
          	.DEF R0X19=R25
          	.DEF R0X1A=R26
          	.DEF R0X1B=R27
          	.DEF R0X1C=R28
          	.DEF R0X1D=R29
          	.DEF R0X1E=R30
          	.DEF R0X1F=R31
         
          	.EQU __se_bit=0x20
          	.EQU __sm_mask=0x1C
          	.EQU __sm_adc_noise_red=0x08
          	.EQU __sm_powerdown=0x10
          	.EQU __sm_powersave=0x18
          	.EQU __sm_standby=0x14
          	.EQU __sm_ext_standby=0x1C
         
          	.MACRO __CPD1N
          	CPI  R30,LOW(@0)
          	LDI  R26,HIGH(@0)
          	CPC  R31,R26
          	LDI  R26,BYTE3(@0)
          	CPC  R22,R26
          	LDI  R26,BYTE4(@0)
          	CPC  R23,R26
          	.ENDM
         
          	.MACRO __CPD2N
          	CPI  R26,LOW(@0)
          	LDI  R30,HIGH(@0)
          	CPC  R27,R30
          	LDI  R30,BYTE3(@0)
          	CPC  R24,R30
          	LDI  R30,BYTE4(@0)
          	CPC  R25,R30
          	.ENDM
         
          	.MACRO __CPWRR
          	CP   R@0,R@2
          	CPC  R@1,R@3
          	.ENDM
         
          	.MACRO __CPWRN
          	CPI  R@0,LOW(@2)
          	LDI  R30,HIGH(@2)
          	CPC  R@1,R30
          	.ENDM
         
          	.MACRO __ADDD1N
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	SBCI R22,BYTE3(-@0)
          	SBCI R23,BYTE4(-@0)
          	.ENDM
         
          	.MACRO __ADDD2N
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	SBCI R24,BYTE3(-@0)
          	SBCI R25,BYTE4(-@0)
          	.ENDM
         
          	.MACRO __SUBD1N
          	SUBI R30,LOW(@0)
          	SBCI R31,HIGH(@0)
          	SBCI R22,BYTE3(@0)
          	SBCI R23,BYTE4(@0)
          	.ENDM
         
          	.MACRO __SUBD2N
          	SUBI R26,LOW(@0)
          	SBCI R27,HIGH(@0)
          	SBCI R24,BYTE3(@0)
          	SBCI R25,BYTE4(@0)
          	.ENDM
         
          	.MACRO __ANDD1N
          	ANDI R30,LOW(@0)
          	ANDI R31,HIGH(@0)
          	ANDI R22,BYTE3(@0)
          	ANDI R23,BYTE4(@0)
          	.ENDM
         
          	.MACRO __ORD1N
          	ORI  R30,LOW(@0)
          	ORI  R31,HIGH(@0)
          	ORI  R22,BYTE3(@0)
          	ORI  R23,BYTE4(@0)
          	.ENDM
         
          	.MACRO __DELAY_USB
          	LDI  R24,LOW(@0)
          __DELAY_USB_LOOP:
          	DEC  R24
          	BRNE __DELAY_USB_LOOP
          	.ENDM
         
          	.MACRO __DELAY_USW
          	LDI  R24,LOW(@0)
          	LDI  R25,HIGH(@0)
          __DELAY_USW_LOOP:
          	SBIW R24,1
          	BRNE __DELAY_USW_LOOP
          	.ENDM
         
          	.MACRO __CLRD1S
          	LDI  R30,0
          	STD  Y+@0,R30
          	STD  Y+@0+1,R30
          	STD  Y+@0+2,R30
          	STD  Y+@0+3,R30
          	.ENDM
         
          	.MACRO __GETD1S
          	LDD  R30,Y+@0
          	LDD  R31,Y+@0+1
          	LDD  R22,Y+@0+2
          	LDD  R23,Y+@0+3
          	.ENDM
         
          	.MACRO __PUTD1S
          	STD  Y+@0,R30
          	STD  Y+@0+1,R31
          	STD  Y+@0+2,R22
          	STD  Y+@0+3,R23
          	.ENDM
         
          	.MACRO __POINTB1MN
          	LDI  R30,LOW(@0+@1)
          	.ENDM
         
          	.MACRO __POINTW1MN
          	LDI  R30,LOW(@0+@1)
          	LDI  R31,HIGH(@0+@1)
          	.ENDM
         
          	.MACRO __POINTW1FN
          	LDI  R30,LOW(2*@0+@1)
          	LDI  R31,HIGH(2*@0+@1)
          	.ENDM
         
          	.MACRO __POINTB2MN
          	LDI  R26,LOW(@0+@1)
          	.ENDM
         
          	.MACRO __POINTW2MN
          	LDI  R26,LOW(@0+@1)
          	LDI  R27,HIGH(@0+@1)
          	.ENDM
         
          	.MACRO __POINTBRM
          	LDI  R@0,LOW(@1)
          	.ENDM
         
          	.MACRO __POINTWRM
          	LDI  R@0,LOW(@2)
          	LDI  R@1,HIGH(@2)
          	.ENDM
         
          	.MACRO __POINTBRMN
          	LDI  R@0,LOW(@1+@2)
          	.ENDM
         
          	.MACRO __POINTWRMN
          	LDI  R@0,LOW(@2+@3)
          	LDI  R@1,HIGH(@2+@3)
          	.ENDM
         
          	.MACRO __GETD1N
          	LDI  R30,LOW(@0)
          	LDI  R31,HIGH(@0)
          	LDI  R22,BYTE3(@0)
          	LDI  R23,BYTE4(@0)
          	.ENDM
         
          	.MACRO __GETD2N
          	LDI  R26,LOW(@0)
          	LDI  R27,HIGH(@0)
          	LDI  R24,BYTE3(@0)
          	LDI  R25,BYTE4(@0)
          	.ENDM
         
          	.MACRO __GETD2S
          	LDD  R26,Y+@0
          	LDD  R27,Y+@0+1
          	LDD  R24,Y+@0+2
          	LDD  R25,Y+@0+3
          	.ENDM
         
          	.MACRO __GETB1MN
          	LDS  R30,@0+@1
          	.ENDM
         
          	.MACRO __GETW1MN
          	LDS  R30,@0+@1
          	LDS  R31,@0+@1+1
          	.ENDM
         
          	.MACRO __GETD1MN
          	LDS  R30,@0+@1
          	LDS  R31,@0+@1+1
          	LDS  R22,@0+@1+2
          	LDS  R23,@0+@1+3
          	.ENDM
         
          	.MACRO __GETBRMN
          	LDS  R@2,@0+@1
          	.ENDM
         
          	.MACRO __GETWRMN
          	LDS  R@2,@0+@1
          	LDS  R@3,@0+@1+1
          	.ENDM
         
          	.MACRO __GETWRZ
          	LDD  R@0,Z+@2
          	LDD  R@1,Z+@2+1
          	.ENDM
         
          	.MACRO __GETD2Z
          	LDD  R26,Z+@0
          	LDD  R27,Z+@0+1
          	LDD  R24,Z+@0+2
          	LDD  R25,Z+@0+3
          	.ENDM
         
          	.MACRO __GETB2MN
          	LDS  R26,@0+@1
          	.ENDM
         
          	.MACRO __GETW2MN
          	LDS  R26,@0+@1
          	LDS  R27,@0+@1+1
          	.ENDM
         
          	.MACRO __GETD2MN
          	LDS  R26,@0+@1
          	LDS  R27,@0+@1+1
          	LDS  R24,@0+@1+2
          	LDS  R25,@0+@1+3
          	.ENDM
         
          	.MACRO __PUTB1MN
          	STS  @0+@1,R30
          	.ENDM
         
          	.MACRO __PUTW1MN
          	STS  @0+@1,R30
          	STS  @0+@1+1,R31
          	.ENDM
         
          	.MACRO __PUTD1MN
          	STS  @0+@1,R30
          	STS  @0+@1+1,R31
          	STS  @0+@1+2,R22
          	STS  @0+@1+3,R23
          	.ENDM
         
          	.MACRO __PUTDZ2
          	STD  Z+@0,R26
          	STD  Z+@0+1,R27
          	STD  Z+@0+2,R24
          	STD  Z+@0+3,R25
          	.ENDM
         
          	.MACRO __PUTBMRN
          	STS  @0+@1,R@2
          	.ENDM
         
          	.MACRO __PUTWMRN
          	STS  @0+@1,R@2
          	STS  @0+@1+1,R@3
          	.ENDM
         
          	.MACRO __PUTBZR
          	STD  Z+@1,R@0
          	.ENDM
         
          	.MACRO __PUTWZR
          	STD  Z+@2,R@0
          	STD  Z+@2+1,R@1
          	.ENDM
         
          	.MACRO __GETW1R
          	MOV  R30,R@0
          	MOV  R31,R@1
          	.ENDM
         
          	.MACRO __GETW2R
          	MOV  R26,R@0
          	MOV  R27,R@1
          	.ENDM
         
          	.MACRO __GETWRN
          	LDI  R@0,LOW(@2)
          	LDI  R@1,HIGH(@2)
          	.ENDM
         
          	.MACRO __PUTW1R
          	MOV  R@0,R30
          	MOV  R@1,R31
          	.ENDM
         
          	.MACRO __PUTW2R
          	MOV  R@0,R26
          	MOV  R@1,R27
          	.ENDM
         
          	.MACRO __ADDWRN
          	SUBI R@0,LOW(-@2)
          	SBCI R@1,HIGH(-@2)
          	.ENDM
         
          	.MACRO __ADDWRR
          	ADD  R@0,R@2
          	ADC  R@1,R@3
          	.ENDM
         
          	.MACRO __SUBWRN
          	SUBI R@0,LOW(@2)
          	SBCI R@1,HIGH(@2)
          	.ENDM
         
          	.MACRO __SUBWRR
          	SUB  R@0,R@2
          	SBC  R@1,R@3
          	.ENDM
         
          	.MACRO __ANDWRN
          	ANDI R@0,LOW(@2)
          	ANDI R@1,HIGH(@2)
          	.ENDM
         
          	.MACRO __ANDWRR
          	AND  R@0,R@2
          	AND  R@1,R@3
          	.ENDM
         
          	.MACRO __ORWRN
          	ORI  R@0,LOW(@2)
          	ORI  R@1,HIGH(@2)
          	.ENDM
         
          	.MACRO __ORWRR
          	OR   R@0,R@2
          	OR   R@1,R@3
          	.ENDM
         
          	.MACRO __EORWRR
          	EOR  R@0,R@2
          	EOR  R@1,R@3
          	.ENDM
         
          	.MACRO __GETWRS
          	LDD  R@0,Y+@2
          	LDD  R@1,Y+@2+1
          	.ENDM
         
          	.MACRO __PUTWSR
          	STD  Y+@2,R@0
          	STD  Y+@2+1,R@1
          	.ENDM
         
          	.MACRO __MOVEWRR
          	MOV  R@0,R@2
          	MOV  R@1,R@3
          	.ENDM
         
          	.MACRO __INWR
          	IN   R@0,@2
          	IN   R@1,@2+1
          	.ENDM
         
          	.MACRO __OUTWR
          	OUT  @2+1,R@1
          	OUT  @2,R@0
          	.ENDM
         
          	.MACRO __CALL1MN
          	LDS  R30,@0+@1
          	LDS  R31,@0+@1+1
          	ICALL
          	.ENDM
         
         
          	.MACRO __CALL1FN
          	LDI  R30,LOW(2*@0+@1)
          	LDI  R31,HIGH(2*@0+@1)
          	CALL __GETW1PF
          	ICALL
          	.ENDM
         
         
          	.MACRO __CALL2EN
          	LDI  R26,LOW(@0+@1)
          	LDI  R27,HIGH(@0+@1)
          	CALL __EEPROMRDW
          	ICALL
          	.ENDM
         
         
          	.MACRO __GETW1STACK
          	IN   R26,SPL
          	IN   R27,SPH
          	ADIW R26,@0+1
          	LD   R30,X+
          	LD   R31,X
          	.ENDM
         
          	.MACRO __NBST
          	BST  R@0,@1
          	IN   R30,SREG
          	LDI  R31,0x40
          	EOR  R30,R31
          	OUT  SREG,R30
          	.ENDM
         
         
          	.MACRO __PUTB1SN
          	LDD  R26,Y+@0
          	LDD  R27,Y+@0+1
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1SN
          	LDD  R26,Y+@0
          	LDD  R27,Y+@0+1
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1SN
          	LDD  R26,Y+@0
          	LDD  R27,Y+@0+1
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	CALL __PUTDP1
          	.ENDM
         
          	.MACRO __PUTB1SNS
          	LDD  R26,Y+@0
          	LDD  R27,Y+@0+1
          	ADIW R26,@1
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1SNS
          	LDD  R26,Y+@0
          	LDD  R27,Y+@0+1
          	ADIW R26,@1
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1SNS
          	LDD  R26,Y+@0
          	LDD  R27,Y+@0+1
          	ADIW R26,@1
          	CALL __PUTDP1
          	.ENDM
         
          	.MACRO __PUTB1PMN
          	LDS  R26,@0
          	LDS  R27,@0+1
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1PMN
          	LDS  R26,@0
          	LDS  R27,@0+1
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1PMN
          	LDS  R26,@0
          	LDS  R27,@0+1
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	CALL __PUTDP1
          	.ENDM
         
          	.MACRO __PUTB1PMNS
          	LDS  R26,@0
          	LDS  R27,@0+1
          	ADIW R26,@1
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1PMNS
          	LDS  R26,@0
          	LDS  R27,@0+1
          	ADIW R26,@1
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1PMNS
          	LDS  R26,@0
          	LDS  R27,@0+1
          	ADIW R26,@1
          	CALL __PUTDP1
          	.ENDM
         
          	.MACRO __PUTB1RN
          	MOVW R26,R@0
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1RN
          	MOVW R26,R@0
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1RN
          	MOVW R26,R@0
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	CALL __PUTDP1
          	.ENDM
         
          	.MACRO __PUTB1RNS
          	MOVW R26,R@0
          	ADIW R26,@1
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1RNS
          	MOVW R26,R@0
          	ADIW R26,@1
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1RNS
          	MOVW R26,R@0
          	ADIW R26,@1
          	CALL __PUTDP1
          	.ENDM
         
          	.MACRO __PUTB1RON
          	MOV  R26,R@0
          	MOV  R27,R@1
          	SUBI R26,LOW(-@2)
          	SBCI R27,HIGH(-@2)
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1RON
          	MOV  R26,R@0
          	MOV  R27,R@1
          	SUBI R26,LOW(-@2)
          	SBCI R27,HIGH(-@2)
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1RON
          	MOV  R26,R@0
          	MOV  R27,R@1
          	SUBI R26,LOW(-@2)
          	SBCI R27,HIGH(-@2)
          	CALL __PUTDP1
          	.ENDM
         
          	.MACRO __PUTB1RONS
          	MOV  R26,R@0
          	MOV  R27,R@1
          	ADIW R26,@2
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1RONS
          	MOV  R26,R@0
          	MOV  R27,R@1
          	ADIW R26,@2
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1RONS
          	MOV  R26,R@0
          	MOV  R27,R@1
          	ADIW R26,@2
          	CALL __PUTDP1
          	.ENDM
         
         
          	.MACRO __GETB1SX
          	MOVW R30,R28
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	LD   R30,Z
          	.ENDM
         
          	.MACRO __GETW1SX
          	MOVW R30,R28
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	LD   R0,Z+
          	LD   R31,Z
          	MOV  R30,R0
          	.ENDM
         
          	.MACRO __GETD1SX
          	MOVW R30,R28
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	LD   R0,Z+
          	LD   R1,Z+
          	LD   R22,Z+
          	LD   R23,Z
          	MOVW R30,R0
          	.ENDM
         
          	.MACRO __GETB2SX
          	MOVW R26,R28
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	LD   R26,X
          	.ENDM
         
          	.MACRO __GETW2SX
          	MOVW R26,R28
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	LD   R0,X+
          	LD   R27,X
          	MOV  R26,R0
          	.ENDM
         
          	.MACRO __GETD2SX
          	MOVW R26,R28
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	LD   R0,X+
          	LD   R1,X+
          	LD   R24,X+
          	LD   R25,X
          	MOVW R26,R0
          	.ENDM
         
          	.MACRO __GETBRSX
          	MOVW R30,R28
          	SUBI R30,LOW(-@1)
          	SBCI R31,HIGH(-@1)
          	LD   R@0,Z
          	.ENDM
         
          	.MACRO __GETWRSX
          	MOVW R30,R28
          	SUBI R30,LOW(-@2)
          	SBCI R31,HIGH(-@2)
          	LD   R@0,Z+
          	LD   R@1,Z
          	.ENDM
         
          	.MACRO __LSLW8SX
          	MOVW R30,R28
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	LD   R31,Z
          	CLR  R30
          	.ENDM
         
          	.MACRO __PUTB1SX
          	MOVW R26,R28
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1SX
          	MOVW R26,R28
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1SX
          	MOVW R26,R28
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	ST   X+,R30
          	ST   X+,R31
          	ST   X+,R22
          	ST   X,R23
          	.ENDM
         
          	.MACRO __CLRW1SX
          	MOVW R30,R28
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	CLR  R0
          	ST   Z+,R0
          	ST   Z,R0
          	.ENDM
         
          	.MACRO __CLRD1SX
          	MOVW R30,R28
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	CLR  R0
          	ST   Z+,R0
          	ST   Z+,R0
          	ST   Z+,R0
          	ST   Z,R0
          	.ENDM
         
          	.MACRO __PUTB2SX
          	MOVW R30,R28
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	ST   Z,R26
          	.ENDM
         
          	.MACRO __PUTW2SX
          	MOVW R30,R28
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	ST   Z+,R26
          	ST   Z,R27
          	.ENDM
         
          	.MACRO __PUTBSRX
          	MOVW R30,R28
          	SUBI R30,LOW(-@0)
          	SBCI R31,HIGH(-@0)
          	ST   Z,R@1
          	.ENDM
         
          	.MACRO __PUTWSRX
          	MOVW R30,R28
          	SUBI R30,LOW(-@2)
          	SBCI R31,HIGH(-@2)
          	ST   Z+,R@0
          	ST   Z,R@1
          	.ENDM
         
          	.MACRO __PUTB1SNX
          	MOVW R26,R28
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	LD   R0,X+
          	LD   R27,X
          	MOV  R26,R0
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	ST   X,R30
          	.ENDM
         
          	.MACRO __PUTW1SNX
          	MOVW R26,R28
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	LD   R0,X+
          	LD   R27,X
          	MOV  R26,R0
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	ST   X+,R30
          	ST   X,R31
          	.ENDM
         
          	.MACRO __PUTD1SNX
          	MOVW R26,R28
          	SUBI R26,LOW(-@0)
          	SBCI R27,HIGH(-@0)
          	LD   R0,X+
          	LD   R27,X
          	MOV  R26,R0
          	SUBI R26,LOW(-@1)
          	SBCI R27,HIGH(-@1)
          	ST   X+,R30
          	ST   X+,R31
          	ST   X+,R22
          	ST   X,R23
          	.ENDM
         
          	.MACRO __MULBRR
          	MULS R@0,R@1
          	MOV  R30,R0
          	.ENDM
         
          	.MACRO __MULBRRU
          	MUL  R@0,R@1
          	MOV  R30,R0
          	.ENDM
         
          	.CSEG
          	.ORG 0
         
          	.INCLUDE "demo.vec"
         
         ;INTERRUPT VECTORS
000000 940c 0232 	JMP  __RESET
000002 940c 0000 	JMP  0x00
000004 940c 0000 	JMP  0x00
000006 940c 0000 	JMP  0x00
000008 940c 0000 	JMP  0x00
00000a 940c 0000 	JMP  0x00
00000c 940c 0000 	JMP  0x00
00000e 940c 0000 	JMP  0x00
000010 940c 0000 	JMP  0x00
000012 940c 0000 	JMP  0x00
000014 940c 0000 	JMP  0x00
000016 940c 0000 	JMP  0x00
000018 940c 0000 	JMP  0x00
00001a 940c 0000 	JMP  0x00
00001c 940c 0000 	JMP  0x00
00001e 940c 0000 	JMP  0x00
000020 940c 0000 	JMP  0x00
000022 940c 0000 	JMP  0x00
000024 940c 0000 	JMP  0x00
000026 940c 0000 	JMP  0x00
000028 940c 0000 	JMP  0x00
00002a 940c 0000 	JMP  0x00
00002c 940c 0000 	JMP  0x00
00002e 940c 0000 	JMP  0x00
000030 940c 0000 	JMP  0x00
000032 940c 0000 	JMP  0x00
000034 940c 0000 	JMP  0x00
000036 940c 0000 	JMP  0x00
000038 940c 0000 	JMP  0x00
00003a 940c 0000 	JMP  0x00
00003c 940c 0000 	JMP  0x00
00003e 940c 0000 	JMP  0x00
000040 940c 0000 	JMP  0x00
000042 940c 0000 	JMP  0x00
000044 940c 0000 	JMP  0x00
         
          	.INCLUDE "demo.inc"
          	.DEF _PT_SecStart=R4
          	.DEF _BPB_BytsPerSec=R6
          	.DEF _BPB_SecPerClus=R8
          	.DEF _BPB_RsvdSecCnt=R9
          	.DEF _BPB_NumFATs=R11
          	.DEF _BPB_RootEntCnt=R12
          	.DEF _BPB_FATType=R14
          _sd_cmd:
          	.DB  0x0,0x0
000046 0000
          	.DB  0x40,0x0
000047 0040
          	.DB  0x0,0x0
000048 0000
          	.DB  0x0,0x0
000049 0000
          	.DB  0x1,0x0
00004a 0001
          	.DB  0x41,0x0
00004b 0041
          	.DB  0x0,0x0
00004c 0000
          	.DB  0x0,0x0
00004d 0000
          	.DB  0x2,0x0
00004e 0002
          	.DB  0x49,0x0
00004f 0049
          	.DB  0x0,0x0
000050 0000
          	.DB  0x0,0x0
000051 0000
          	.DB  0x3,0x0
000052 0003
          	.DB  0x4A,0x0
000053 004a
          	.DB  0x0,0x0
000054 0000
          	.DB  0x0,0x0
000055 0000
          	.DB  0x4,0x0
000056 0004
          	.DB  0x4C,0x0
000057 004c
          	.DB  0x0,0x0
000058 0000
          	.DB  0x0,0x0
000059 0000
          	.DB  0x5,0x0
00005a 0005
          	.DB  0x4D,0x0
00005b 004d
          	.DB  0x0,0x0
00005c 0000
          	.DB  0x2,0x0
00005d 0002
          	.DB  0x6,0x0
00005e 0006
          	.DB  0x50,0x0
00005f 0050
          	.DB  0x1,0x0
000060 0001
          	.DB  0x0,0x0
000061 0000
          	.DB  0x7,0x0
000062 0007
          	.DB  0x51,0x0
000063 0051
          	.DB  0x2,0x0
000064 0002
          	.DB  0x0,0x0
000065 0000
          	.DB  0x8,0x0
000066 0008
          	.DB  0x52,0x0
000067 0052
          	.DB  0x2,0x0
000068 0002
          	.DB  0x0,0x0
000069 0000
          	.DB  0x9,0x0
00006a 0009
          	.DB  0x58,0x0
00006b 0058
          	.DB  0x2,0x0
00006c 0002
          	.DB  0x0,0x0
00006d 0000
          	.DB  0xA,0x0
00006e 000a
          	.DB  0x59,0x0
00006f 0059
          	.DB  0x2,0x0
000070 0002
          	.DB  0x0,0x0
000071 0000
          	.DB  0xB,0x0
000072 000b
          	.DB  0x5B,0x0
000073 005b
          	.DB  0x0,0x0
000074 0000
          	.DB  0x0,0x0
000075 0000
          	.DB  0xC,0x0
000076 000c
          	.DB  0x5C,0x0
000077 005c
          	.DB  0x2,0x0
000078 0002
          	.DB  0x1,0x0
000079 0001
          	.DB  0xD,0x0
00007a 000d
          	.DB  0x5D,0x0
00007b 005d
          	.DB  0x2,0x0
00007c 0002
          	.DB  0x1,0x0
00007d 0001
          	.DB  0xE,0x0
00007e 000e
          	.DB  0x5E,0x0
00007f 005e
          	.DB  0x2,0x0
000080 0002
          	.DB  0x0,0x0
000081 0000
          	.DB  0xF,0x0
000082 000f
          	.DB  0x60,0x0
000083 0060
          	.DB  0x2,0x0
000084 0002
          	.DB  0x0,0x0
000085 0000
          	.DB  0x10,0x0
000086 0010
          	.DB  0x61,0x0
000087 0061
          	.DB  0x2,0x0
000088 0002
          	.DB  0x0,0x0
000089 0000
          	.DB  0x11,0x0
00008a 0011
          	.DB  0x62,0x0
00008b 0062
          	.DB  0x2,0x0
00008c 0002
          	.DB  0x0,0x0
00008d 0000
          	.DB  0x12,0x0
00008e 0012
          	.DB  0x63,0x0
00008f 0063
          	.DB  0x2,0x0
000090 0002
          	.DB  0x0,0x0
000091 0000
          	.DB  0x13,0x0
000092 0013
          	.DB  0x64,0x0
000093 0064
          	.DB  0x2,0x0
000094 0002
          	.DB  0x0,0x0
000095 0000
          	.DB  0x14,0x0
000096 0014
          	.DB  0x65,0x0
000097 0065
          	.DB  0x2,0x0
000098 0002
          	.DB  0x0,0x0
000099 0000
          	.DB  0x15,0x0
00009a 0015
          	.DB  0x66,0x0
00009b 0066
          	.DB  0x3,0x0
00009c 0003
          	.DB  0x1,0x0
00009d 0001
          	.DB  0x16,0x0
00009e 0016
          	.DB  0x6A,0x0
00009f 006a
          	.DB  0x3,0x0
0000a0 0003
          	.DB  0x1,0x0
0000a1 0001
          	.DB  0x17,0x0
0000a2 0017
          	.DB  0x7A,0x0
0000a3 007a
          	.DB  0x0,0x0
0000a4 0000
          	.DB  0x3,0x0
0000a5 0003
          	.DB  0x18,0x0
0000a6 0018
          	.DB  0x7B,0x0
0000a7 007b
          	.DB  0x3,0x0
0000a8 0003
          	.DB  0x0,0x0
0000a9 0000
          	.DB  0x19,0x0
0000aa 0019
          	.DB  0x69,0x0
0000ab 0069
          	.DB  0x0,0x0
0000ac 0000
          	.DB  0x0,0x0
0000ad 0000
          _0:
          	.DB  0xA,0xD,0x52,0x45,0x41,0x44,0x5F,0x45
0000ae 0d0a
0000af 4552
0000b0 4441
0000b1 455f
          	.DB  0x52,0x52,0x0,0xA,0xD,0x42,0x6F,0x6F
0000b2 5252
0000b3 0a00
0000b4 420d
0000b5 6f6f
          	.DB  0x74,0x5F,0x53,0x65,0x63,0x3A,0x20,0x5B
0000b6 5f74
0000b7 6553
0000b8 3a63
0000b9 5b20
          	.DB  0x30,0x78,0x25,0x58,0x20,0x25,0x58,0x20
0000ba 7830
0000bb 5825
0000bc 2520
0000bd 2058
          	.DB  0x25,0x58,0x5D,0x20,0x5B,0x30,0x78,0x25
0000be 5825
0000bf 205d
0000c0 305b
0000c1 2578
          	.DB  0x58,0x5D,0x20,0x5B,0x30,0x78,0x25,0x58
0000c2 5d58
0000c3 5b20
0000c4 7830
0000c5 5825
          	.DB  0x5D,0x0,0xA,0xD,0x50,0x61,0x72,0x74
0000c6 005d
0000c7 0d0a
0000c8 6150
0000c9 7472
          	.DB  0x20,0x41,0x64,0x64,0x72,0x65,0x73,0x73
0000ca 4120
0000cb 6464
0000cc 6572
0000cd 7373
          	.DB  0x3A,0x20,0x20,0x25,0x6C,0x58,0x0,0xA
0000ce 203a
0000cf 2520
0000d0 586c
0000d1 0a00
          	.DB  0xD,0x42,0x53,0x5F,0x6A,0x6D,0x70,0x42
0000d2 420d
0000d3 5f53
0000d4 6d6a
0000d5 4270
          	.DB  0x6F,0x6F,0x74,0x3A,0x20,0x20,0x25,0x6C
0000d6 6f6f
0000d7 3a74
0000d8 2020
0000d9 6c25
          	.DB  0x58,0x0,0xA,0xD,0x42,0x50,0x42,0x5F
0000da 0058
0000db 0d0a
0000dc 5042
0000dd 5f42
          	.DB  0x42,0x79,0x74,0x73,0x50,0x65,0x72,0x53
0000de 7942
0000df 7374
0000e0 6550
0000e1 5372
          	.DB  0x65,0x63,0x3A,0x20,0x20,0x25,0x58,0x0
0000e2 6365
0000e3 203a
0000e4 2520
0000e5 0058
          	.DB  0xA,0xD,0x42,0x50,0x42,0x5F,0x53,0x65
0000e6 0d0a
0000e7 5042
0000e8 5f42
0000e9 6553
          	.DB  0x63,0x50,0x65,0x72,0x43,0x6C,0x75,0x73
0000ea 5063
0000eb 7265
0000ec 6c43
0000ed 7375
          	.DB  0x3A,0x20,0x20,0x25,0x58,0x0,0xA,0xD
0000ee 203a
0000ef 2520
0000f0 0058
0000f1 0d0a
          	.DB  0x42,0x50,0x42,0x5F,0x52,0x73,0x76,0x64
0000f2 5042
0000f3 5f42
0000f4 7352
0000f5 6476
          	.DB  0x53,0x65,0x63,0x43,0x6E,0x74,0x3A,0x20
0000f6 6553
0000f7 4363
0000f8 746e
0000f9 203a
          	.DB  0x20,0x25,0x58,0x0,0xA,0xD,0x42,0x50
0000fa 2520
0000fb 0058
0000fc 0d0a
0000fd 5042
          	.DB  0x42,0x5F,0x4E,0x75,0x6D,0x46,0x41,0x54
0000fe 5f42
0000ff 754e
000100 466d
000101 5441
          	.DB  0x73,0x3A,0x20,0x20,0x25,0x58,0x0,0xA
000102 3a73
000103 2020
000104 5825
000105 0a00
          	.DB  0xD,0x42,0x50,0x42,0x5F,0x52,0x6F,0x6F
000106 420d
000107 4250
000108 525f
000109 6f6f
          	.DB  0x74,0x45,0x6E,0x74,0x43,0x6E,0x74,0x3A
00010a 4574
00010b 746e
00010c 6e43
00010d 3a74
          	.DB  0x20,0x20,0x25,0x58,0x0,0xA,0xD,0x42
00010e 2020
00010f 5825
000110 0a00
000111 420d
          	.DB  0x50,0x42,0x5F,0x46,0x41,0x54,0x53,0x7A
000112 4250
000113 465f
000114 5441
000115 7a53
          	.DB  0x31,0x36,0x3A,0x20,0x20,0x25,0x58,0x0
000116 3631
000117 203a
000118 2520
000119 0058
          	.DB  0xA,0xD,0x42,0x50,0x42,0x5F,0x54,0x6F
00011a 0d0a
00011b 5042
00011c 5f42
00011d 6f54
          	.DB  0x74,0x53,0x65,0x63,0x31,0x36,0x3A,0x20
00011e 5374
00011f 6365
000120 3631
000121 203a
          	.DB  0x20,0x25,0x6C,0x58,0x0,0xA,0xD,0x42
000122 2520
000123 586c
000124 0a00
000125 420d
          	.DB  0x50,0x42,0x5F,0x46,0x41,0x54,0x54,0x79
000126 4250
000127 465f
000128 5441
000129 7954
          	.DB  0x70,0x65,0x3A,0x20,0x20,0x46,0x41,0x54
00012a 6570
00012b 203a
00012c 4620
00012d 5441
          	.DB  0x31,0x32,0x0,0xA,0xD,0x42,0x50,0x42
00012e 3231
00012f 0a00
000130 420d
000131 4250
          	.DB  0x5F,0x46,0x41,0x54,0x54,0x79,0x70,0x65
000132 465f
000133 5441
000134 7954
000135 6570
          	.DB  0x3A,0x20,0x20,0x46,0x41,0x54,0x31,0x36
000136 203a
000137 4620
000138 5441
000139 3631
          	.DB  0x0,0xA,0xD,0x42,0x50,0x42,0x5F,0x46
00013a 0a00
00013b 420d
00013c 4250
00013d 465f
          	.DB  0x41,0x54,0x54,0x79,0x70,0x65,0x3A,0x20
00013e 5441
00013f 7954
000140 6570
000141 203a
          	.DB  0x20,0x46,0x41,0x54,0x20,0x45,0x52,0x52
000142 4620
000143 5441
000144 4520
000145 5252
          	.DB  0x4F,0x52,0x21,0x21,0x0,0xA,0xD,0x43
000146 524f
000147 2121
000148 0a00
000149 430d
          	.DB  0x6C,0x75,0x73,0x74,0x65,0x72,0x43,0x6E
00014a 756c
00014b 7473
00014c 7265
00014d 6e43
          	.DB  0x74,0x3A,0x20,0x20,0x25,0x6C,0x58,0x0
00014e 3a74
00014f 2020
000150 6c25
000151 0058
          	.DB  0xA,0xD,0x52,0x4F,0x4F,0x54,0x5F,0x41
000152 0d0a
000153 4f52
000154 544f
000155 415f
          	.DB  0x44,0x44,0x52,0x3A,0x20,0x20,0x25,0x6C
000156 4444
000157 3a52
000158 2020
000159 6c25
          	.DB  0x58,0x0,0xA,0xD,0x46,0x41,0x54,0x32
00015a 0058
00015b 0d0a
00015c 4146
00015d 3254
          	.DB  0x5F,0x41,0x44,0x44,0x52,0x3A,0x20,0x20
00015e 415f
00015f 4444
000160 3a52
000161 2020
          	.DB  0x25,0x6C,0x58,0x0,0xA,0xD,0x52,0x6F
000162 6c25
000163 0058
000164 0d0a
000165 6f52
          	.DB  0x6F,0x74,0x44,0x69,0x72,0x53,0x65,0x63
000166 746f
000167 6944
000168 5372
000169 6365
          	.DB  0x74,0x6F,0x72,0x73,0x3A,0x20,0x20,0x25
00016a 6f74
00016b 7372
00016c 203a
00016d 2520
          	.DB  0x58,0x0,0xA,0xD,0x46,0x69,0x72,0x73
00016e 0058
00016f 0d0a
000170 6946
000171 7372
          	.DB  0x74,0x44,0x61,0x74,0x61,0x53,0x65,0x63
000172 4474
000173 7461
000174 5361
000175 6365
          	.DB  0x74,0x6F,0x72,0x3A,0x20,0x20,0x25,0x58
000176 6f74
000177 3a72
000178 2020
000179 5825
          	.DB  0x0,0xA,0xD,0x52,0x65,0x73,0x65,0x74
00017a 0a00
00017b 520d
00017c 7365
00017d 7465
          	.DB  0x20,0x43,0x4D,0x44,0x3A,0x20,0x20,0x0
00017e 4320
00017f 444d
000180 203a
000181 0020
          	.DB  0x4F,0x4B,0x21,0x21,0x21,0x0,0x45,0x52
000182 4b4f
000183 2121
000184 0021
000185 5245
          	.DB  0x52,0x4F,0x52,0x21,0x21,0x21,0x0,0xD
000186 4f52
000187 2152
000188 2121
000189 0d00
          	.DB  0xA,0x49,0x6E,0x69,0x74,0x69,0x61,0x6C
00018a 490a
00018b 696e
00018c 6974
00018d 6c61
          	.DB  0x69,0x7A,0x61,0x74,0x69,0x6F,0x6E,0x3A
00018e 7a69
00018f 7461
000190 6f69
000191 3a6e
          	.DB  0x20,0x20,0x0,0x4F,0x4B,0x21,0x0,0x45
000192 2020
000193 4f00
000194 214b
000195 4500
          	.DB  0x52,0x52,0x4F,0x52,0x2D,0x25,0x78,0x20
000196 5252
000197 524f
000198 252d
000199 2078
          	.DB  0x20,0x0,0xA,0xD,0x0,0x25,0x58,0x20
00019a 0020
00019b 0d0a
00019c 2500
00019d 2058
          	.DB  0x0,0xD,0xA,0x46,0x69,0x6C,0x65,0x20
00019e 0d00
00019f 460a
0001a0 6c69
0001a1 2065
          	.DB  0x4C,0x69,0x73,0x74,0x69,0x6E,0x67,0x20
0001a2 694c
0001a3 7473
0001a4 6e69
0001a5 2067
          	.DB  0x66,0x6F,0x72,0x3A,0x20,0x20,0x52,0x4F
0001a6 6f66
0001a7 3a72
0001a8 2020
0001a9 4f52
          	.DB  0x4F,0x54,0x5C,0x0,0x20,0x20,0x5B,0x0
0001aa 544f
0001ab 005c
0001ac 2020
0001ad 005b
          	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
0001ae 2020
0001af 2020
0001b0 2020
0001b1 2020
          	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
0001b2 2020
0001b3 2020
0001b4 2020
0001b5 2020
          	.DB  0x5B,0x25,0x6C,0x64,0x5D,0x20,0x62,0x79
0001b6 255b
0001b7 646c
0001b8 205d
0001b9 7962
          	.DB  0x74,0x65,0x73,0x20,0x20,0x20,0x20,0x20
0001ba 6574
0001bb 2073
0001bc 2020
0001bd 2020
          	.DB  0x20,0x28,0x25,0x58,0x29,0xD,0x20,0x20
0001be 2820
0001bf 5825
0001c0 0d29
0001c1 2020
          	.DB  0x0,0x5D,0x20,0x20,0x20,0x20,0x20,0x20
0001c2 5d00
0001c3 2020
0001c4 2020
0001c5 2020
          	.DB  0x28,0x25,0x58,0x29,0x0,0xD,0xA,0x20
0001c6 2528
0001c7 2958
0001c8 0d00
0001c9 200a
          	.DB  0x20,0x56,0x6F,0x6C,0x75,0x6D,0x65,0x20
0001ca 5620
0001cb 6c6f
0001cc 6d75
0001cd 2065
          	.DB  0x53,0x65,0x72,0x69,0x61,0x6C,0x3A,0x20
0001ce 6553
0001cf 6972
0001d0 6c61
0001d1 203a
          	.DB  0x20,0x5B,0x30,0x78,0x25,0x6C,0x58,0x5D
0001d2 5b20
0001d3 7830
0001d4 6c25
0001d5 5d58
          	.DB  0x0,0xD,0xA,0x20,0x20,0x56,0x6F,0x6C
0001d6 0d00
0001d7 200a
0001d8 5620
0001d9 6c6f
          	.DB  0x75,0x6D,0x65,0x20,0x4C,0x61,0x62,0x65
0001da 6d75
0001db 2065
0001dc 614c
0001dd 6562
          	.DB  0x6C,0x3A,0x20,0x20,0x5B,0x25,0x73,0x5D
0001de 3a6c
0001df 2020
0001e0 255b
0001e1 5d73
          	.DB  0xD,0xA,0x0,0x25,0x30,0x32,0x58,0x20
0001e2 0a0d
0001e3 2500
0001e4 3230
0001e5 2058
          	.DB  0x0,0x64,0x65,0x6D,0x6F,0x2E,0x64,0x61
0001e6 6400
0001e7 6d65
0001e8 2e6f
0001e9 6164
          	.DB  0x74,0x0,0x43,0x6F,0x6C,0x75,0x6D,0x6E
0001ea 0074
0001eb 6f43
0001ec 756c
0001ed 6e6d
          	.DB  0x20,0x25,0x64,0x2C,0x20,0x43,0x6F,0x6C
0001ee 2520
0001ef 2c64
0001f0 4320
0001f1 6c6f
          	.DB  0x75,0x6D,0x6E,0x20,0x25,0x64,0x2C,0x20
0001f2 6d75
0001f3 206e
0001f4 6425
0001f5 202c
          	.DB  0x43,0x6F,0x6C,0x75,0x6D,0x6E,0x20,0x25
0001f6 6f43
0001f7 756c
0001f8 6e6d
0001f9 2520
          	.DB  0x64,0x2C,0x20,0x43,0x6F,0x6C,0x75,0x6D
0001fa 2c64
0001fb 4320
0001fc 6c6f
0001fd 6d75
          	.DB  0x6E,0x20,0x25,0x64,0x2C,0x20,0x43,0x6F
0001fe 206e
0001ff 6425
000200 202c
000201 6f43
          	.DB  0x6C,0x75,0x6D,0x6E,0x20,0x25,0x64,0x2C
000202 756c
000203 6e6d
000204 2520
000205 2c64
          	.DB  0x20,0x43,0x6F,0x6C,0x75,0x6D,0x6E,0x20
000206 4320
000207 6c6f
000208 6d75
000209 206e
          	.DB  0x25,0x64,0x2C,0x20,0x43,0x6F,0x6C,0x75
00020a 6425
00020b 202c
00020c 6f43
00020d 756c
          	.DB  0x6D,0x6E,0x20,0x25,0x64,0x2C,0x20,0x43
00020e 6e6d
00020f 2520
000210 2c64
000211 4320
          	.DB  0x6F,0x6C,0x75,0x6D,0x6E,0x20,0x25,0x64
000212 6c6f
000213 6d75
000214 206e
000215 6425
          	.DB  0x2C,0x20,0x43,0x6F,0x6C,0x75,0x6D,0x6E
000216 202c
000217 6f43
000218 756c
000219 6e6d
          	.DB  0x20,0x25,0x64,0x2C,0x20,0x43,0x6F,0x6C
00021a 2520
00021b 2c64
00021c 4320
00021d 6c6f
          	.DB  0x75,0x6D,0x6E,0x20,0x25,0x64,0x2C,0xD
00021e 6d75
00021f 206e
000220 6425
000221 0d2c
          	.DB  0xA,0x0,0x25,0x6C,0x64,0x2C,0x20,0x0
000222 000a
000223 6c25
000224 2c64
000225 0020
          	.DB  0xD,0xA,0xD,0xA,0x44,0x4F,0x4E,0x45
000226 0a0d
000227 0a0d
000228 4f44
000229 454e
          	.DB  0x21,0x21,0x21,0x0
00022a 2121
00022b 0021
         
         ;HEAP START MARKER INITIALIZATION
          __HEAP_START_MARKER:
          	.DW  0,0
00022c 0000
00022d 0000
         
          __GLOBAL_INI_TBL:
          	.DW  0x04
00022e 0004
          	.DW  0x824
00022f 0824
          	.DW  __HEAP_START_MARKER*2
000230 0458
         
          	.DW  0
000231 0000
         
          __RESET:
000232 94f8      	CLI
000233 27ee      	CLR  R30
000234 bbec      	OUT  EECR,R30
         
         ;INTERRUPT VECTORS ARE PLACED
         ;AT THE START OF FLASH
000235 e0f1      	LDI  R31,1
000236 bff5      	OUT  MCUCR,R31
000237 bfe5      	OUT  MCUCR,R30
000238 93e0 006c 	STS  XMCRB,R30
00023a bfeb      	OUT  RAMPZ,R30
         
         ;DISABLE WATCHDOG
00023b e1f8      	LDI  R31,0x18
00023c bdf1      	OUT  WDTCR,R31
00023d bde1      	OUT  WDTCR,R30
         
         ;CLEAR R2-R14
00023e e08d      	LDI  R24,13
00023f e0a2      	LDI  R26,2
000240 27bb      	CLR  R27
          __CLEAR_REG:
000241 93ed      	ST   X+,R30
000242 958a      	DEC  R24
000243 f7e9      	BRNE __CLEAR_REG
         
         ;CLEAR SRAM
000244 e284      	LDI  R24,LOW(0x724)
000245 e097      	LDI  R25,HIGH(0x724)
000246 e0a0      	LDI  R26,LOW(0x100)
000247 e0b1      	LDI  R27,HIGH(0x100)
          __CLEAR_SRAM:
000248 93ed      	ST   X+,R30
000249 9701      	SBIW R24,1
00024a f7e9      	BRNE __CLEAR_SRAM
         
         ;GLOBAL VARIABLES INITIALIZATION
00024b e5ec      	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
00024c e0f4      	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
          __GLOBAL_INI_NEXT:
00024d 9185      	LPM  R24,Z+
00024e 9195      	LPM  R25,Z+
00024f 9700      	SBIW R24,0
000250 f061      	BREQ __GLOBAL_INI_END
000251 91a5      	LPM  R26,Z+
000252 91b5      	LPM  R27,Z+
000253 9005      	LPM  R0,Z+
000254 9015      	LPM  R1,Z+
000255 01bf      	MOVW R22,R30
000256 01f0      	MOVW R30,R0
          __GLOBAL_INI_LOOP:
000257 9005      	LPM  R0,Z+
000258 920d      	ST   X+,R0
000259 9701      	SBIW R24,1
00025a f7e1      	BRNE __GLOBAL_INI_LOOP
00025b 01fb      	MOVW R30,R22
00025c cff0      	RJMP __GLOBAL_INI_NEXT
          __GLOBAL_INI_END:
         
         ;STACK POINTER INITIALIZATION
00025d e2e3      	LDI  R30,LOW(0x823)
00025e bfed      	OUT  SPL,R30
00025f e0e8      	LDI  R30,HIGH(0x823)
000260 bfee      	OUT  SPH,R30
         
         ;DATA STACK POINTER INITIALIZATION
000261 e0c0      	LDI  R28,LOW(0x500)
000262 e0d5      	LDI  R29,HIGH(0x500)
         
000263 940c 18c3 	JMP  _main
         
          	.ESEG
          	.ORG 0
         
          	.DSEG
          	.ORG 0x500
         ;       1 /*********************************************
         ;       2 Project : FlashFileSD Example
         ;       3 Version : 
         ;       4 Date    : 12/23/2003
         ;       5 Author  : Erick M Higa    
         ;       6 Company : Progressive Resources LLC       
         ;       7 Comments: 
         ;       8 This is a simple example program for the FlashFileSD
         ;       9 
         ;      10 
         ;      11 Chip type           : ATmega128
         ;      12 Program type        : Application
         ;      13 Clock frequency     : 14.745600 MHz
         ;      14 Memory model        : Small
         ;      15 External SRAM size  : 0
         ;      16 Data Stack size     : 1024
         ;      17 *********************************************/
         ;      18 
         ;      19 
         ;      20 #include "options.h"
         ;      21 /*
         ;      22 	Progressive Resources LLC
         ;      23                                     
         ;      24 			FlashFile
         ;      25 	
         ;      26 	Version : 	1.32
         ;      27 	Date: 		12/31/2003
         ;      28 	Author: 	Erick M. Higa
         ;      29                                            
         ;      30 	Software License
         ;      31 	The use of Progressive Resources LLC FlashFile Source Package indicates 
         ;      32 	your understanding and acceptance of the following terms and conditions. 
         ;      33 	This license shall supersede any verbal or prior verbal or written, statement 
         ;      34 	or agreement to the contrary. If you do not understand or accept these terms, 
         ;      35 	or your local regulations prohibit "after sale" license agreements or limited 
         ;      36 	disclaimers, you must cease and desist using this product immediately.
         ;      37 	This product is © Copyright 2003 by Progressive Resources LLC, all rights 
         ;      38 	reserved. International copyright laws, international treaties and all other 
         ;      39 	applicable national or international laws protect this product. This software 
         ;      40 	product and documentation may not, in whole or in part, be copied, photocopied, 
         ;      41 	translated, or reduced to any electronic medium or machine readable form, without 
         ;      42 	prior consent in writing, from Progressive Resources LLC and according to all 
         ;      43 	applicable laws. The sole owner of this product is Progressive Resources LLC.
         ;      44 
         ;      45 	Operating License
         ;      46 	You have the non-exclusive right to use any enclosed product but have no right 
         ;      47 	to distribute it as a source code product without the express written permission 
         ;      48 	of Progressive Resources LLC. Use over a "local area network" (within the same 
         ;      49 	locale) is permitted provided that only a single person, on a single computer 
         ;      50 	uses the product at a time. Use over a "wide area network" (outside the same 
         ;      51 	locale) is strictly prohibited under any and all circumstances.
         ;      52                                            
         ;      53 	Liability Disclaimer
         ;      54 	This product and/or license is provided as is, without any representation or 
         ;      55 	warranty of any kind, either express or implied, including without limitation 
         ;      56 	any representations or endorsements regarding the use of, the results of, or 
         ;      57 	performance of the product, Its appropriateness, accuracy, reliability, or 
         ;      58 	correctness. The user and/or licensee assume the entire risk as to the use of 
         ;      59 	this product. Progressive Resources LLC does not assume liability for the use 
         ;      60 	of this product beyond the original purchase price of the software. In no event 
         ;      61 	will Progressive Resources LLC be liable for additional direct or indirect 
         ;      62 	damages including any lost profits, lost savings, or other incidental or 
         ;      63 	consequential damages arising from any defects, or the use or inability to 
         ;      64 	use these products, even if Progressive Resources LLC have been advised of 
         ;      65 	the possibility of such damages.
         ;      66 */                                 
         ;      67 
         ;      68 /*
         ;      69 #include _AVR_LIB_
         ;      70 #include <stdio.h>
         ;      71 
         ;      72 #ifndef _file_sys_h_
         ;      73 	#include "..\flash\file_sys.h"
         ;      74 #endif
         ;      75 */
         ;      76 
         ;      77 unsigned long OCR_REG;
          _OCR_REG:
000500      	.BYTE 0x4
         ;      78 unsigned char _FF_buff[512];
          __FF_buff:
000504      	.BYTE 0x200
         ;      79 unsigned int PT_SecStart;
         ;      80 unsigned long BS_jmpBoot;
          _BS_jmpBoot:
000704      	.BYTE 0x4
         ;      81 unsigned int BPB_BytsPerSec;
         ;      82 unsigned char BPB_SecPerClus;
         ;      83 unsigned int BPB_RsvdSecCnt;
         ;      84 unsigned char BPB_NumFATs;
         ;      85 unsigned int BPB_RootEntCnt;
         ;      86 unsigned int BPB_FATSz16;
          _BPB_FATSz16:
000708      	.BYTE 0x2
         ;      87 unsigned char BPB_FATType;
         ;      88 unsigned long BPB_TotSec;
          _BPB_TotSec:
00070a      	.BYTE 0x4
         ;      89 unsigned long BS_VolSerial;
          _BS_VolSerial:
00070e      	.BYTE 0x4
         ;      90 unsigned char BS_VolLab[12];
          _BS_VolLab:
000712      	.BYTE 0xC
         ;      91 unsigned long _FF_PART_ADDR, _FF_ROOT_ADDR, _FF_DIR_ADDR;
          __FF_PART_ADDR:
00071e      	.BYTE 0x4
          __FF_ROOT_ADDR:
000722      	.BYTE 0x4
          __FF_DIR_ADDR:
000726      	.BYTE 0x4
         ;      92 unsigned long _FF_FAT1_ADDR, _FF_FAT2_ADDR;
          __FF_FAT1_ADDR:
00072a      	.BYTE 0x4
          __FF_FAT2_ADDR:
00072e      	.BYTE 0x4
         ;      93 unsigned long _FF_RootDirSectors;
          __FF_RootDirSectors:
000732      	.BYTE 0x4
         ;      94 unsigned int FirstDataSector;
          _FirstDataSector:
000736      	.BYTE 0x2
         ;      95 unsigned long FirstSectorofCluster;
          _FirstSectorofCluster:
000738      	.BYTE 0x4
         ;      96 unsigned char _FF_error;
          __FF_error:
00073c      	.BYTE 0x1
         ;      97 unsigned long _FF_buff_addr;
          __FF_buff_addr:
00073d      	.BYTE 0x4
         ;      98 extern unsigned long clus_0_addr, _FF_n_temp;
         ;      99 extern unsigned int c_counter;
         ;     100 extern unsigned char _FF_FULL_PATH[_FF_PATH_LENGTH];
         ;     101 
         ;     102 unsigned long DataClusTot;
          _DataClusTot:
000741      	.BYTE 0x4
         ;     103 
         ;     104 flash struct CMD
         ;     105 {
         ;     106 	unsigned int index;
         ;     107 	unsigned int tx_data;
         ;     108 	unsigned int arg;
         ;     109 	unsigned int resp;
         ;     110 };
         ;     111 
         ;     112 flash struct CMD sd_cmd[CMD_TOT] =
         
          	.CSEG
         ;     113 {
         ;     114 	{CMD0,	0x40,	NO_ARG,		RESP_1},		// GO_IDLE_STATE
         ;     115 	{CMD1,	0x41,	NO_ARG,		RESP_1},		// SEND_OP_COND (ACMD41 = 0x69)
         ;     116 	{CMD9,	0x49,	NO_ARG,		RESP_1},		// SEND_CSD
         ;     117 	{CMD10,	0x4A,	NO_ARG,		RESP_1},		// SEND_CID
         ;     118 	{CMD12,	0x4C,	NO_ARG,		RESP_1},		// STOP_TRANSMISSION
         ;     119 	{CMD13,	0x4D,	NO_ARG,		RESP_2},		// SEND_STATUS
         ;     120 	{CMD16,	0x50,	BLOCK_LEN,	RESP_1},		// SET_BLOCKLEN
         ;     121 	{CMD17, 0x51,	DATA_ADDR,	RESP_1},		// READ_SINGLE_BLOCK
         ;     122 	{CMD18, 0x52,	DATA_ADDR,	RESP_1},		// READ_MULTIPLE_BLOCK
         ;     123 	{CMD24, 0x58,	DATA_ADDR,	RESP_1},		// WRITE_BLOCK
         ;     124 	{CMD25, 0x59,	DATA_ADDR,	RESP_1},		// WRITE_MULTIPLE_BLOCK
         ;     125 	{CMD27,	0x5B,	NO_ARG,		RESP_1},		// PROGRAM_CSD
         ;     126 	{CMD28, 0x5C,	DATA_ADDR,	RESP_1b},		// SET_WRITE_PROT
         ;     127 	{CMD29, 0x5D,	DATA_ADDR,	RESP_1b},		// CLR_WRITE_PROT
         ;     128 	{CMD30, 0x5E,	DATA_ADDR,	RESP_1},		// SEND_WRITE_PROT
         ;     129 	{CMD32,	0x60,	DATA_ADDR,	RESP_1},		// TAG_SECTOR_START
         ;     130 	{CMD33,	0x61,	DATA_ADDR,	RESP_1},		// TAG_SECTOR_END
         ;     131 	{CMD34,	0x62,	DATA_ADDR,	RESP_1},		// UNTAG_SECTOR
         ;     132 	{CMD35,	0x63,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP_START
         ;     133 	{CMD36,	0x64,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP_END
         ;     134 	{CMD37,	0x65,	DATA_ADDR,	RESP_1},		// TAG_ERASE_GROUP
         ;     135 	{CMD38,	0x66,	STUFF_BITS,	RESP_1b},		// ERASE
         ;     136 	{CMD42,	0x6A,	STUFF_BITS,	RESP_1b},		// LOCK_UNLOCK
         ;     137 	{CMD58,	0x7A,	NO_ARG,		RESP_3},		// READ_OCR
         ;     138 	{CMD59,	0x7B,	STUFF_BITS,	RESP_1},		// CRC_ON_OFF
         ;     139 	{ACMD41, 0x69,	NO_ARG,		RESP_1}
         ;     140 };
         ;     141 
         ;     142 unsigned char _FF_spi(unsigned char mydata)
         ;     143 {
          __FF_spi:
         ;     144     SPDR = mydata;          //byte 1
000265 81e8      	LD   R30,Y
000266 b9ef      	OUT  0xF,R30
         ;     145     while ((SPSR&0x80) == 0); 
          _0x3:
000267 9b77      	SBIS 0xE,7
000268 cffe      	RJMP _0x3
         ;     146     return SPDR;
000269 b1ef      	IN   R30,0xF
00026a 9621      	ADIW R28,1
00026b 9508      	RET
         ;     147 }
         ;     148 	
         ;     149 unsigned int send_cmd(unsigned char command, unsigned long argument)
         ;     150 {
          _send_cmd:
         ;     151 	unsigned char spi_data_out;
         ;     152 	unsigned char response_1;
         ;     153 	unsigned long response_2;
         ;     154 	unsigned int c, i;
         ;     155 	
         ;     156 	SD_CS_ON();			// select chip
00026c 9724      	SBIW R28,4
00026d 940e 2304 	CALL __SAVELOCR6
         ;	command -> Y+14
         ;	argument -> Y+10
         ;	spi_data_out -> R16
         ;	response_1 -> R17
         ;	response_2 -> Y+6
         ;	c -> R18,R19
         ;	i -> R20,R21
00026f 98c4      	CBI  0x18,4
         ;     157 	
         ;     158 	spi_data_out = sd_cmd[command].tx_data;
000270 85ae      	LDD  R26,Y+14
000271 27bb      	CLR  R27
000272   +  	__POINTW1FN _sd_cmd,2
000274 93ff      	PUSH R31
000275 93ef      	PUSH R30
000276 e0e8      	LDI  R30,LOW(8)
000277 e0f0      	LDI  R31,HIGH(8)
000278 940e 2239 	CALL __MULW12U
00027a 91af      	POP  R26
00027b 91bf      	POP  R27
00027c 0fea      	ADD  R30,R26
00027d 1ffb      	ADC  R31,R27
00027e 9104      	LPM  R16,Z
         ;     159 	_FF_spi(spi_data_out);
00027f 930a      	ST   -Y,R16
000280 940e 1c4f 	CALL SUBOPT_0x0
         ;     160 	
         ;     161 	c = sd_cmd[command].arg;
000282   +  	__POINTW1FN _sd_cmd,4
000284 93ff      	PUSH R31
000285 93ef      	PUSH R30
000286 e0e8      	LDI  R30,LOW(8)
000287 e0f0      	LDI  R31,HIGH(8)
000288 940e 2239 	CALL __MULW12U
00028a 91af      	POP  R26
00028b 91bf      	POP  R27
00028c 940e 1c54 	CALL SUBOPT_0x1
         ;     162 	if (c == NO_ARG)
00028e 2e02      	MOV  R0,R18
00028f 2a03      	OR   R0,R19
000290 f471      	BRNE _0x6
         ;     163 		for (i=0; i<4; i++)
000291   +  	__GETWRN 20,21,0
          _0x8:
000293   +  	__CPWRN 20,21,4
000296 f438      	BRSH _0x9
         ;     164 			_FF_spi(0);
000297 e0e0      	LDI  R30,LOW(0)
000298 93ea      	ST   -Y,R30
000299 940e 0265 	CALL __FF_spi
         ;     165 	else
00029b   +  	__ADDWRN 20,21,1
00029d cff5      	RJMP _0x8
          _0x9:
00029e c028      	RJMP _0xA
          _0x6:
         ;     166 	{
         ;     167 		spi_data_out = (argument & 0xFF000000) >> 24;
00029f   +  	__GETD1S 10
0002a3   +  	__ANDD1N 0xFF000000
0002a7 01df      	MOVW R26,R30
0002a8 01cb      	MOVW R24,R22
0002a9 e1e8      	LDI  R30,LOW(24)
0002aa 940e 1c5b 	CALL SUBOPT_0x2
         ;     168 		_FF_spi(spi_data_out);
         ;     169 		spi_data_out = (argument & 0x00FF0000) >> 16;
0002ac   +  	__ANDD1N 0xFF0000
0002b0 940e 222a 	CALL __LSRD16
0002b2 940e 1c66 	CALL SUBOPT_0x3
         ;     170 		_FF_spi(spi_data_out);
         ;     171 		spi_data_out = (argument & 0x0000FF00) >> 8;
0002b4   +  	__GETD1S 10
0002b8   +  	__ANDD1N 0xFF00
0002bc 01df      	MOVW R26,R30
0002bd 01cb      	MOVW R24,R22
0002be e0e8      	LDI  R30,LOW(8)
0002bf 940e 1c5b 	CALL SUBOPT_0x2
         ;     172 		_FF_spi(spi_data_out);
         ;     173 		spi_data_out = (argument & 0x000000FF);
0002c1   +  	__ANDD1N 0xFF
0002c5 940e 1c66 	CALL SUBOPT_0x3
         ;     174 		_FF_spi(spi_data_out);
         ;     175 	}
          _0xA:
         ;     176 	if (command == CMD0)
0002c7 85ee      	LDD  R30,Y+14
0002c8 30e0      	CPI  R30,0
0002c9 f411      	BRNE _0xB
         ;     177 		spi_data_out = 0x95;		// CRC byte, don't care except for first signal=0x95
0002ca e905      	LDI  R16,LOW(149)
         ;     178 	else
0002cb c001      	RJMP _0xC
          _0xB:
         ;     179 		spi_data_out = 0xFF;
0002cc ef0f      	LDI  R16,LOW(255)
         ;     180 	_FF_spi(spi_data_out);
          _0xC:
0002cd 930a      	ST   -Y,R16
0002ce 940e 1c6a 	CALL SUBOPT_0x4
         ;     181 	_FF_spi(0xff);	
0002d0 940e 1c4f 	CALL SUBOPT_0x0
         ;     182 	c = sd_cmd[command].resp;
0002d2   +  	__POINTW1FN _sd_cmd,6
0002d4 93ff      	PUSH R31
0002d5 93ef      	PUSH R30
0002d6 e0e8      	LDI  R30,LOW(8)
0002d7 e0f0      	LDI  R31,HIGH(8)
0002d8 940e 2239 	CALL __MULW12U
0002da 91af      	POP  R26
0002db 91bf      	POP  R27
0002dc 940e 1c54 	CALL SUBOPT_0x1
         ;     183 	switch(c)
0002de   +  	__GETW1R 18,19
         ;     184 	{
         ;     185 		case RESP_1:
0002e0 9730      	SBIW R30,0
0002e1 f421      	BRNE _0x10
         ;     186 			return (_FF_spi(0xFF));
0002e2 940e 1c6f 	CALL SUBOPT_0x5
0002e4 e0f0      	LDI  R31,0
0002e5 c088      	RJMP _0x3F0
         ;     187 			break;
         ;     188 		case RESP_1b:
          _0x10:
0002e6 30e1      	CPI  R30,LOW(0x1)
0002e7 e0a0      	LDI  R26,HIGH(0x1)
0002e8 07fa      	CPC  R31,R26
0002e9 f4e1      	BRNE _0x11
         ;     189 			response_1 = _FF_spi(0xFF);
0002ea 940e 1c6f 	CALL SUBOPT_0x5
0002ec 2f1e      	MOV  R17,R30
         ;     190 			response_2 = 0;
0002ed   +  	__CLRD1S 6
         ;     191 			while (response_2 == 0)
          _0x12:
0002f2   +  	__GETD1S 6
0002f6 940e 22e8 	CALL __CPD10
0002f8 f451      	BRNE _0x14
         ;     192 				response_2 = _FF_spi(0xFF);
0002f9 940e 1c6f 	CALL SUBOPT_0x5
0002fb 27ff      	CLR  R31
0002fc 2766      	CLR  R22
0002fd 2777      	CLR  R23
0002fe   +  	__PUTD1S 6
         ;     193 			return (response_1);
000302 cfef      	RJMP _0x12
          _0x14:
000303 2fe1      	MOV  R30,R17
000304 e0f0      	LDI  R31,0
000305 c068      	RJMP _0x3F0
         ;     194 			break;
         ;     195 		case RESP_2:
          _0x11:
000306 30e2      	CPI  R30,LOW(0x2)
000307 e0a0      	LDI  R26,HIGH(0x2)
000308 07fa      	CPC  R31,R26
000309 f4d9      	BRNE _0x15
         ;     196 			response_2 = _FF_spi(0xFF);
00030a 940e 1c6f 	CALL SUBOPT_0x5
00030c 940e 1c73 	CALL SUBOPT_0x6
         ;     197 			response_2 = (response_2 << 8) | _FF_spi(0xFF);
00030e e0e8      	LDI  R30,LOW(8)
00030f 940e 21fb 	CALL __LSLD12
000311 937f      	PUSH R23
000312 936f      	PUSH R22
000313 93ff      	PUSH R31
000314 93ef      	PUSH R30
000315 940e 1c6f 	CALL SUBOPT_0x5
000317 91af      	POP  R26
000318 91bf      	POP  R27
000319 918f      	POP  R24
00031a 919f      	POP  R25
00031b 27ff      	CLR  R31
00031c 2766      	CLR  R22
00031d 2777      	CLR  R23
00031e 940e 21ed 	CALL __ORD12
000320   +  	__PUTD1S 6
         ;     198 			return (response_2);
000324 c049      	RJMP _0x3F0
         ;     199 			break;
         ;     200 		case RESP_3:
          _0x15:
000325 30e3      	CPI  R30,LOW(0x3)
000326 e0a0      	LDI  R26,HIGH(0x3)
000327 07fa      	CPC  R31,R26
000328 f011      	BREQ PC+3
000329 940c 036c 	JMP _0xF
         ;     201 			response_1 = _FF_spi(0xFF);
00032b 940e 1c6f 	CALL SUBOPT_0x5
00032d 2f1e      	MOV  R17,R30
         ;     202 			OCR_REG = 0;
00032e e0e0      	LDI  R30,0
00032f 93e0 0500 	STS  _OCR_REG,R30
000331 93e0 0501 	STS  _OCR_REG+1,R30
000333 93e0 0502 	STS  _OCR_REG+2,R30
000335 93e0 0503 	STS  _OCR_REG+3,R30
         ;     203 			response_2 = _FF_spi(0xFF);
000337 940e 1c6f 	CALL SUBOPT_0x5
000339 940e 1c73 	CALL SUBOPT_0x6
         ;     204 			OCR_REG = response_2 << 24;
00033b e1e8      	LDI  R30,LOW(24)
00033c 940e 21fb 	CALL __LSLD12
00033e 93e0 0500 	STS  _OCR_REG,R30
000340 93f0 0501 	STS  _OCR_REG+1,R31
000342 9360 0502 	STS  _OCR_REG+2,R22
000344 9370 0503 	STS  _OCR_REG+3,R23
         ;     205 			response_2 = _FF_spi(0xFF);
000346 940e 1c6f 	CALL SUBOPT_0x5
000348 940e 1c7f 	CALL SUBOPT_0x7
         ;     206 			OCR_REG |= (response_2 << 16);
00034a 940e 222f 	CALL __LSLD16
00034c 940e 1c87 	CALL SUBOPT_0x8
         ;     207 			response_2 = _FF_spi(0xFF);
00034e 940e 1c73 	CALL SUBOPT_0x6
         ;     208 			OCR_REG |= (response_2 << 8);
000350 e0e8      	LDI  R30,LOW(8)
000351 940e 21fb 	CALL __LSLD12
000353 940e 1c87 	CALL SUBOPT_0x8
         ;     209 			response_2 = _FF_spi(0xFF);
000355 940e 1c7f 	CALL SUBOPT_0x7
         ;     210 			OCR_REG |= (response_2);
000357 91a0 0500 	LDS  R26,_OCR_REG
000359 91b0 0501 	LDS  R27,_OCR_REG+1
00035b 9180 0502 	LDS  R24,_OCR_REG+2
00035d 9190 0503 	LDS  R25,_OCR_REG+3
00035f 940e 21ed 	CALL __ORD12
000361 93e0 0500 	STS  _OCR_REG,R30
000363 93f0 0501 	STS  _OCR_REG+1,R31
000365 9360 0502 	STS  _OCR_REG+2,R22
000367 9370 0503 	STS  _OCR_REG+3,R23
         ;     211 			return (response_1);
000369 2fe1      	MOV  R30,R17
00036a e0f0      	LDI  R31,0
00036b c002      	RJMP _0x3F0
         ;     212 			break;
         ;     213 	}
          _0xF:
         ;     214 	return (0);
00036c e0e0      	LDI  R30,LOW(0)
00036d e0f0      	LDI  R31,HIGH(0)
          _0x3F0:
00036e 940e 230b 	CALL __LOADLOCR6
000370 962f      	ADIW R28,15
000371 9508      	RET
         ;     215 }
         ;     216 
         ;     217 void clear_sd_buff(void)
         ;     218 {
          _clear_sd_buff:
         ;     219 	SD_CS_OFF();
000372 9ac4      	SBI  0x18,4
         ;     220 	_FF_spi(0xFF);
000373 940e 1c9a 	CALL SUBOPT_0x9
         ;     221 	_FF_spi(0xFF);
000375 940e 0265 	CALL __FF_spi
         ;     222 }	
000377 9508      	RET
         ;     223 
         ;     224 unsigned char initialize_media(void)
         ;     225 {
          _initialize_media:
         ;     226 	unsigned char data_temp;
         ;     227 	unsigned long n;
         ;     228 	
         ;     229 	// SPI BUS SETUP
         ;     230 	// SPI initialization
         ;     231 	// SPI Type: Master
         ;     232 	// SPI Clock Rate: 921.600 kHz
         ;     233 	// SPI Clock Phase: Cycle Half
         ;     234 	// SPI Clock Polarity: Low
         ;     235 	// SPI Data Order: MSB First
         ;     236 	DDRB |= 0x07;		// Set SS, SCK, and MOSI to Output (If not output, processor will be a slave)
000378 9724      	SBIW R28,4
000379 930a      	ST   -Y,R16
         ;	data_temp -> R16
         ;	n -> Y+1
00037a b3e7      	IN   R30,0x17
00037b 60e7      	ORI  R30,LOW(0x7)
00037c bbe7      	OUT  0x17,R30
         ;     237 	DDRB &= 0xF7;		// Set MISO to Input
00037d 98bb      	CBI  0x17,3
         ;     238 	CS_DDR_SET();		// Set CS to Output
00037e 9abc      	SBI  0x17,4
         ;     239 	SPCR=0x50;
00037f 940e 1c9d 	CALL SUBOPT_0xA
         ;     240 	SPSR=0x00;
000381 b9ee      	OUT  0xE,R30
         ;     241 		
         ;     242 	BPB_BytsPerSec = 512;	// Initialize sector size to 512 (all SD cards have a 512 sector size)
000382 e0e0      	LDI  R30,LOW(512)
000383 e0f2      	LDI  R31,HIGH(512)
000384   +  	__PUTW1R 6,7
         ;     243     _FF_n_temp = 0;
000386 e0e0      	LDI  R30,0
000387 93e0 0750 	STS  __FF_n_temp,R30
000389 93e0 0751 	STS  __FF_n_temp+1,R30
00038b 93e0 0752 	STS  __FF_n_temp+2,R30
00038d 93e0 0753 	STS  __FF_n_temp+3,R30
         ;     244 	if (reset_sd()==0)
00038f d3d4      	RCALL _reset_sd
000390 30e0      	CPI  R30,0
000391 f411      	BRNE _0x17
         ;     245 		return (0);
000392 e0e0      	LDI  R30,LOW(0)
000393 c3b6      	RJMP _0x3EF
         ;     246 	// delay_ms(50);
         ;     247 	for (n=0; ((n<100)||(data_temp==0)) ; n++)
          _0x17:
000394   +  	__CLRD1S 1
          _0x19:
000399   +  	__GETD2S 1
00039d   +  	__CPD2N 0x64
0003a4 f010      	BRLO _0x1B
0003a5 3000      	CPI  R16,0
0003a6 f441      	BRNE _0x1A
          _0x1B:
         ;     248 	{
         ;     249 		SD_CS_ON();
0003a7 98c4      	CBI  0x18,4
         ;     250 		data_temp = _FF_spi(0xFF);
0003a8 940e 1c6f 	CALL SUBOPT_0x5
0003aa 2f0e      	MOV  R16,R30
         ;     251 		SD_CS_OFF();
0003ab 9ac4      	SBI  0x18,4
         ;     252 	}
0003ac 940e 1ca1 	CALL SUBOPT_0xB
0003ae cfea      	RJMP _0x19
          _0x1A:
         ;     253 	// delay_ms(50);
         ;     254 	for (n=0; n<100; n++)
0003af   +  	__CLRD1S 1
          _0x1E:
0003b4   +  	__GETD2S 1
0003b8   +  	__CPD2N 0x64
0003bf f4a0      	BRSH _0x1F
         ;     255 	{
         ;     256 		if (init_sd())		// Initialization Succeeded
0003c0 d3e4      	RCALL _init_sd
0003c1 30e0      	CPI  R30,0
0003c2 f489      	BRNE _0x1F
         ;     257 			break;
         ;     258 		if (n==99)
0003c3   +  	__GETD2S 1
0003c7   +  	__CPD2N 0x63
0003ce f411      	BRNE _0x21
         ;     259 			return (0);
0003cf e0e0      	LDI  R30,LOW(0)
0003d0 c379      	RJMP _0x3EF
         ;     260 	}
          _0x21:
0003d1 940e 1ca1 	CALL SUBOPT_0xB
0003d3 cfe0      	RJMP _0x1E
          _0x1F:
         ;     261 
         ;     262 	if (_FF_read(0x0)==0)
0003d4   +  	__GETD1N 0x0
0003d8 940e 1cae 	CALL SUBOPT_0xC
0003da f441      	BRNE _0x22
         ;     263 	{
         ;     264 		#ifdef _DEBUG_ON_
         ;     265 			printf("\n\rREAD_ERR"); 		
0003db   +  	__POINTW1FN _0,0
0003dd 93fa      	ST   -Y,R31
0003de 93ea      	ST   -Y,R30
0003df e080      	LDI  R24,0
0003e0 940e 1cb4 	CALL SUBOPT_0xD
         ;     266 		#endif
         ;     267 		_FF_error = INIT_ERR;
         ;     268 		return (0);
0003e2 c367      	RJMP _0x3EF
         ;     269 	}
         ;     270 	PT_SecStart = ((int) _FF_buff[0x1c7] << 8) | (int) _FF_buff[0x1c6];
          _0x22:
0003e3   +  	__GETBRMN __FF_buff,455,27
0003e5 e0a0      	LDI  R26,LOW(0)
0003e6   +  	__GETB1MN __FF_buff,454
0003e8 e0f0      	LDI  R31,0
0003e9 2bea      	OR   R30,R26
0003ea 2bfb      	OR   R31,R27
0003eb   +  	__PUTW1R 4,5
         ;     271 	
         ;     272 	if ((((_FF_buff[0]==0xEB)&&(_FF_buff[2]==0x90))||(_FF_buff[0]==0xE9)) && ((_FF_buff[510]==0x55)&&(_FF_buff[511]==0xAA)))
0003ed 91a0 0504 	LDS  R26,__FF_buff
0003ef 3eab      	CPI  R26,LOW(0xEB)
0003f0 f421      	BRNE _0x24
0003f1   +  	__GETB1MN __FF_buff,2
0003f3 39e0      	CPI  R30,LOW(0x90)
0003f4 f021      	BREQ _0x26
          _0x24:
0003f5 91a0 0504 	LDS  R26,__FF_buff
0003f7 3ea9      	CPI  R26,LOW(0xE9)
0003f8 f451      	BRNE _0x28
          _0x26:
0003f9   +  	__GETB1MN __FF_buff,510
0003fb 35e5      	CPI  R30,LOW(0x55)
0003fc f421      	BRNE _0x29
0003fd   +  	__GETB1MN __FF_buff,511
0003ff 3aea      	CPI  R30,LOW(0xAA)
000400 f009      	BREQ _0x2A
          _0x29:
000401 c001      	RJMP _0x28
          _0x2A:
000402 c001      	RJMP _0x2B
          _0x28:
000403 c002      	RJMP _0x23
          _0x2B:
         ;     273     	PT_SecStart = 0;
000404 2444      	CLR  R4
000405 2455      	CLR  R5
         ;     274  
         ;     275 	_FF_PART_ADDR = (long) PT_SecStart * (long) BPB_BytsPerSec;
          _0x23:
000406   +  	__GETW1R 4,5
000408 940e 1cbb 	CALL SUBOPT_0xE
00040a 93e0 071e 	STS  __FF_PART_ADDR,R30
00040c 93f0 071f 	STS  __FF_PART_ADDR+1,R31
00040e 9360 0720 	STS  __FF_PART_ADDR+2,R22
000410 9370 0721 	STS  __FF_PART_ADDR+3,R23
         ;     276 
         ;     277 	if (PT_SecStart)
000412 2c04      	MOV  R0,R4
000413 2805      	OR   R0,R5
000414 f059      	BREQ _0x2C
         ;     278 	{
         ;     279 		if (_FF_read(_FF_PART_ADDR)==0)
000415 940e 1cae 	CALL SUBOPT_0xC
000417 f441      	BRNE _0x2D
         ;     280 		{
         ;     281 		   	#ifdef _DEBUG_ON_
         ;     282 				printf("\n\rREAD_ERR");
000418   +  	__POINTW1FN _0,0
00041a 93fa      	ST   -Y,R31
00041b 93ea      	ST   -Y,R30
00041c e080      	LDI  R24,0
00041d 940e 1cb4 	CALL SUBOPT_0xD
         ;     283 			#endif
         ;     284 			_FF_error = INIT_ERR;
         ;     285 			return (0);
00041f c32a      	RJMP _0x3EF
         ;     286 		}
         ;     287 	}
          _0x2D:
         ;     288 
         ;     289  	#ifdef _DEBUG_ON_
         ;     290 		printf("\n\rBoot_Sec: [0x%X %X %X] [0x%X] [0x%X]", _FF_buff[0],_FF_buff[1],_FF_buff[2],_FF_buff[510],_FF_buff[511]); 		
          _0x2C:
000420   +  	__POINTW1FN _0,11
000422 93fa      	ST   -Y,R31
000423 93ea      	ST   -Y,R30
000424 91e0 0504 	LDS  R30,__FF_buff
000426 27ff      	CLR  R31
000427 2766      	CLR  R22
000428 2777      	CLR  R23
000429 940e 22d1 	CALL __PUTPARD1
00042b   +  	__GETB1MN __FF_buff,1
00042d 27ff      	CLR  R31
00042e 2766      	CLR  R22
00042f 2777      	CLR  R23
000430 940e 22d1 	CALL __PUTPARD1
000432   +  	__GETB1MN __FF_buff,2
000434 27ff      	CLR  R31
000435 2766      	CLR  R22
000436 2777      	CLR  R23
000437 940e 22d1 	CALL __PUTPARD1
000439   +  	__GETB1MN __FF_buff,510
00043b 27ff      	CLR  R31
00043c 2766      	CLR  R22
00043d 2777      	CLR  R23
00043e 940e 22d1 	CALL __PUTPARD1
000440   +  	__GETB1MN __FF_buff,511
000442 27ff      	CLR  R31
000443 2766      	CLR  R22
000444 2777      	CLR  R23
000445 940e 22d1 	CALL __PUTPARD1
000447 e184      	LDI  R24,20
000448 940e 1b51 	CALL _printf
00044a 9666      	ADIW R28,22
         ;     291 	#endif
         ;     292    	
         ;     293     BS_jmpBoot = (((long) _FF_buff[0] << 16) | ((int) _FF_buff[1] << 8) | (int) _FF_buff[2]);    		
00044b 91e0 0504 	LDS  R30,__FF_buff
00044d 27ff      	CLR  R31
00044e 2766      	CLR  R22
00044f 2777      	CLR  R23
000450 940e 222f 	CALL __LSLD16
000452 01df      	MOVW R26,R30
000453 01cb      	MOVW R24,R22
000454   +  	__GETBRMN __FF_buff,1,31
000456 e0e0      	LDI  R30,LOW(0)
000457 940e 2234 	CALL __CWD1
000459 940e 21ed 	CALL __ORD12
00045b 01df      	MOVW R26,R30
00045c 01cb      	MOVW R24,R22
00045d   +  	__GETB1MN __FF_buff,2
00045f e0f0      	LDI  R31,0
000460 940e 2234 	CALL __CWD1
000462 940e 21ed 	CALL __ORD12
000464 93e0 0704 	STS  _BS_jmpBoot,R30
000466 93f0 0705 	STS  _BS_jmpBoot+1,R31
000468 9360 0706 	STS  _BS_jmpBoot+2,R22
00046a 9370 0707 	STS  _BS_jmpBoot+3,R23
         ;     294 	BPB_BytsPerSec = ((int) _FF_buff[0xC] << 8) | (int) _FF_buff[0xB];
00046c   +  	__GETBRMN __FF_buff,12,27
00046e e0a0      	LDI  R26,LOW(0)
00046f   +  	__GETB1MN __FF_buff,11
000471 e0f0      	LDI  R31,0
000472 2bea      	OR   R30,R26
000473 2bfb      	OR   R31,R27
000474   +  	__PUTW1R 6,7
         ;     295     BPB_SecPerClus = _FF_buff[0xD];
000476   +  	__POINTW1MN __FF_buff,13
000478 8080      	LD   R8,Z
         ;     296 	BPB_RsvdSecCnt = ((int) _FF_buff[0xF] << 8) | (int) _FF_buff[0xE];	
000479   +  	__GETBRMN __FF_buff,15,27
00047b   +  	__GETB1MN __FF_buff,14
00047d e0f0      	LDI  R31,0
00047e 2bea      	OR   R30,R26
00047f 2bfb      	OR   R31,R27
000480   +  	__PUTW1R 9,10
         ;     297 	BPB_NumFATs = _FF_buff[0x10];
000482   +  	__POINTW1MN __FF_buff,16
000484 80b0      	LD   R11,Z
         ;     298 	BPB_RootEntCnt = ((int) _FF_buff[0x12] << 8) | (int) _FF_buff[0x11];	
000485   +  	__GETBRMN __FF_buff,18,27
000487   +  	__GETB1MN __FF_buff,17
000489 e0f0      	LDI  R31,0
00048a 2bea      	OR   R30,R26
00048b 2bfb      	OR   R31,R27
00048c   +  	__PUTW1R 12,13
         ;     299 	BPB_FATSz16 = ((int) _FF_buff[0x17] << 8) | (int) _FF_buff[0x16];
00048e   +  	__GETBRMN __FF_buff,23,27
000490   +  	__GETB1MN __FF_buff,22
000492 e0f0      	LDI  R31,0
000493 2bea      	OR   R30,R26
000494 2bfb      	OR   R31,R27
000495 93e0 0708 	STS  _BPB_FATSz16,R30
000497 93f0 0709 	STS  _BPB_FATSz16+1,R31
         ;     300 	BPB_TotSec = ((unsigned int) _FF_buff[0x14] << 8) | (unsigned int) _FF_buff[0x13];
000499   +  	__GETBRMN __FF_buff,20,27
00049b   +  	__GETB1MN __FF_buff,19
00049d 940e 1cc6 	CALL SUBOPT_0xF
00049f 93e0 070a 	STS  _BPB_TotSec,R30
0004a1 93f0 070b 	STS  _BPB_TotSec+1,R31
0004a3 9360 070c 	STS  _BPB_TotSec+2,R22
0004a5 9370 070d 	STS  _BPB_TotSec+3,R23
         ;     301 	if (BPB_TotSec==0)
0004a7 940e 22e8 	CALL __CPD10
0004a9 f539      	BRNE _0x2E
         ;     302 		BPB_TotSec = ((unsigned long) _FF_buff[0x23] << 24) | ((unsigned long) _FF_buff[0x22] << 16)
         ;     303 					| ((unsigned long) _FF_buff[0x21] << 8) | ((unsigned long) _FF_buff[0x20]);
0004aa   +  	__GETB1MN __FF_buff,35
0004ac 940e 1ccc 	CALL SUBOPT_0x10
0004ae   +  	__GETB1MN __FF_buff,34
0004b0 940e 1cd7 	CALL SUBOPT_0x11
0004b2 937f      	PUSH R23
0004b3 936f      	PUSH R22
0004b4 93ff      	PUSH R31
0004b5 93ef      	PUSH R30
0004b6   +  	__GETB1MN __FF_buff,33
0004b8 940e 1cdf 	CALL SUBOPT_0x12
0004ba 91af      	POP  R26
0004bb 91bf      	POP  R27
0004bc 918f      	POP  R24
0004bd 919f      	POP  R25
0004be 940e 21ed 	CALL __ORD12
0004c0 01df      	MOVW R26,R30
0004c1 01cb      	MOVW R24,R22
0004c2   +  	__GETB1MN __FF_buff,32
0004c4 27ff      	CLR  R31
0004c5 2766      	CLR  R22
0004c6 2777      	CLR  R23
0004c7 940e 21ed 	CALL __ORD12
0004c9 93e0 070a 	STS  _BPB_TotSec,R30
0004cb 93f0 070b 	STS  _BPB_TotSec+1,R31
0004cd 9360 070c 	STS  _BPB_TotSec+2,R22
0004cf 9370 070d 	STS  _BPB_TotSec+3,R23
         ;     304 	BS_VolSerial = ((unsigned long) _FF_buff[0x2A] << 24) | ((unsigned long) _FF_buff[0x29] << 16)
          _0x2E:
         ;     305 				| ((unsigned long) _FF_buff[0x28] << 8) | ((unsigned long) _FF_buff[0x27]);
0004d1   +  	__GETB1MN __FF_buff,42
0004d3 940e 1ccc 	CALL SUBOPT_0x10
0004d5   +  	__GETB1MN __FF_buff,41
0004d7 940e 1cd7 	CALL SUBOPT_0x11
0004d9 937f      	PUSH R23
0004da 936f      	PUSH R22
0004db 93ff      	PUSH R31
0004dc 93ef      	PUSH R30
0004dd   +  	__GETB1MN __FF_buff,40
0004df 940e 1cdf 	CALL SUBOPT_0x12
0004e1 91af      	POP  R26
0004e2 91bf      	POP  R27
0004e3 918f      	POP  R24
0004e4 919f      	POP  R25
0004e5 940e 21ed 	CALL __ORD12
0004e7 01df      	MOVW R26,R30
0004e8 01cb      	MOVW R24,R22
0004e9   +  	__GETB1MN __FF_buff,39
0004eb 27ff      	CLR  R31
0004ec 2766      	CLR  R22
0004ed 2777      	CLR  R23
0004ee 940e 21ed 	CALL __ORD12
0004f0 93e0 070e 	STS  _BS_VolSerial,R30
0004f2 93f0 070f 	STS  _BS_VolSerial+1,R31
0004f4 9360 0710 	STS  _BS_VolSerial+2,R22
0004f6 9370 0711 	STS  _BS_VolSerial+3,R23
         ;     306 	for (n=0; n<11; n++)
0004f8   +  	__CLRD1S 1
          _0x30:
0004fd   +  	__GETD2S 1
000501   +  	__CPD2N 0xB
000508 f4b0      	BRSH _0x31
         ;     307 		BS_VolLab[n] = _FF_buff[0x2B+n];
000509   +  	__GETD1S 1
00050d 5eee      	SUBI R30,LOW(-_BS_VolLab)
00050e 4ff8      	SBCI R31,HIGH(-_BS_VolLab)
00050f 01df      	MOVW R26,R30
000510   +  	__GETD1S 1
000514   +  	__ADDD1N 43
000518 5fec      	SUBI R30,LOW(-__FF_buff)
000519 4ffa      	SBCI R31,HIGH(-__FF_buff)
00051a 81e0      	LD   R30,Z
00051b 93ec      	ST   X,R30
         ;     308 	BS_VolLab[11] = 0;		// Terminate the string
00051c 940e 1ca1 	CALL SUBOPT_0xB
00051e cfde      	RJMP _0x30
          _0x31:
00051f e0e0      	LDI  R30,LOW(0)
000520   +  	__PUTB1MN _BS_VolLab,11
         ;     309 	_FF_FAT1_ADDR = _FF_PART_ADDR + ((long) BPB_RsvdSecCnt * (long) BPB_BytsPerSec); 
000522   +  	__GETW1R 9,10
000524 940e 1cbb 	CALL SUBOPT_0xE
000526 91a0 071e 	LDS  R26,__FF_PART_ADDR
000528 91b0 071f 	LDS  R27,__FF_PART_ADDR+1
00052a 9180 0720 	LDS  R24,__FF_PART_ADDR+2
00052c 9190 0721 	LDS  R25,__FF_PART_ADDR+3
00052e 940e 21de 	CALL __ADDD12
000530 93e0 072a 	STS  __FF_FAT1_ADDR,R30
000532 93f0 072b 	STS  __FF_FAT1_ADDR+1,R31
000534 9360 072c 	STS  __FF_FAT1_ADDR+2,R22
000536 9370 072d 	STS  __FF_FAT1_ADDR+3,R23
         ;     310 	_FF_FAT2_ADDR = _FF_FAT1_ADDR + ((long) BPB_FATSz16 * (long) BPB_BytsPerSec);
000538 91e0 0708 	LDS  R30,_BPB_FATSz16
00053a 91f0 0709 	LDS  R31,_BPB_FATSz16+1
00053c 940e 1cbb 	CALL SUBOPT_0xE
00053e 91a0 072a 	LDS  R26,__FF_FAT1_ADDR
000540 91b0 072b 	LDS  R27,__FF_FAT1_ADDR+1
000542 9180 072c 	LDS  R24,__FF_FAT1_ADDR+2
000544 9190 072d 	LDS  R25,__FF_FAT1_ADDR+3
000546 940e 21de 	CALL __ADDD12
000548 93e0 072e 	STS  __FF_FAT2_ADDR,R30
00054a 93f0 072f 	STS  __FF_FAT2_ADDR+1,R31
00054c 9360 0730 	STS  __FF_FAT2_ADDR+2,R22
00054e 9370 0731 	STS  __FF_FAT2_ADDR+3,R23
         ;     311 	_FF_ROOT_ADDR = ((long) BPB_NumFATs * (long) BPB_FATSz16) + (long) BPB_RsvdSecCnt;
000550 2deb      	MOV  R30,R11
000551 27ff      	CLR  R31
000552 2766      	CLR  R22
000553 2777      	CLR  R23
000554 01df      	MOVW R26,R30
000555 01cb      	MOVW R24,R22
000556 91e0 0708 	LDS  R30,_BPB_FATSz16
000558 91f0 0709 	LDS  R31,_BPB_FATSz16+1
00055a 2766      	CLR  R22
00055b 2777      	CLR  R23
00055c 940e 2261 	CALL __MULD12
00055e 01df      	MOVW R26,R30
00055f 01cb      	MOVW R24,R22
000560   +  	__GETW1R 9,10
000562 2766      	CLR  R22
000563 2777      	CLR  R23
000564 940e 21de 	CALL __ADDD12
000566 93e0 0722 	STS  __FF_ROOT_ADDR,R30
000568 93f0 0723 	STS  __FF_ROOT_ADDR+1,R31
00056a 9360 0724 	STS  __FF_ROOT_ADDR+2,R22
00056c 9370 0725 	STS  __FF_ROOT_ADDR+3,R23
         ;     312 	_FF_ROOT_ADDR *= BPB_BytsPerSec;
00056e   +  	__GETW1R 6,7
000570 91a0 0722 	LDS  R26,__FF_ROOT_ADDR
000572 91b0 0723 	LDS  R27,__FF_ROOT_ADDR+1
000574 9180 0724 	LDS  R24,__FF_ROOT_ADDR+2
000576 9190 0725 	LDS  R25,__FF_ROOT_ADDR+3
000578 2766      	CLR  R22
000579 2777      	CLR  R23
00057a 940e 2241 	CALL __MULD12U
00057c 93e0 0722 	STS  __FF_ROOT_ADDR,R30
00057e 93f0 0723 	STS  __FF_ROOT_ADDR+1,R31
000580 9360 0724 	STS  __FF_ROOT_ADDR+2,R22
000582 9370 0725 	STS  __FF_ROOT_ADDR+3,R23
         ;     313 	_FF_ROOT_ADDR += _FF_PART_ADDR;
000584 91e0 071e 	LDS  R30,__FF_PART_ADDR
000586 91f0 071f 	LDS  R31,__FF_PART_ADDR+1
000588 9160 0720 	LDS  R22,__FF_PART_ADDR+2
00058a 9170 0721 	LDS  R23,__FF_PART_ADDR+3
00058c 91a0 0722 	LDS  R26,__FF_ROOT_ADDR
00058e 91b0 0723 	LDS  R27,__FF_ROOT_ADDR+1
000590 9180 0724 	LDS  R24,__FF_ROOT_ADDR+2
000592 9190 0725 	LDS  R25,__FF_ROOT_ADDR+3
000594 940e 21de 	CALL __ADDD12
000596 93e0 0722 	STS  __FF_ROOT_ADDR,R30
000598 93f0 0723 	STS  __FF_ROOT_ADDR+1,R31
00059a 9360 0724 	STS  __FF_ROOT_ADDR+2,R22
00059c 9370 0725 	STS  __FF_ROOT_ADDR+3,R23
         ;     314 	
         ;     315 	_FF_RootDirSectors = ((BPB_RootEntCnt * 32) + BPB_BytsPerSec - 1) / BPB_BytsPerSec;
00059e   +  	__GETW1R 12,13
0005a0 0fee      	LSL  R30
0005a1 1fff      	ROL  R31
0005a2 940e 2213 	CALL __LSLW4
0005a4 0de6      	ADD  R30,R6
0005a5 1df7      	ADC  R31,R7
0005a6 940e 1ce8 	CALL SUBOPT_0x13
0005a8 940e 2266 	CALL __DIVW21U
0005aa 2766      	CLR  R22
0005ab 2777      	CLR  R23
0005ac 93e0 0732 	STS  __FF_RootDirSectors,R30
0005ae 93f0 0733 	STS  __FF_RootDirSectors+1,R31
0005b0 9360 0734 	STS  __FF_RootDirSectors+2,R22
0005b2 9370 0735 	STS  __FF_RootDirSectors+3,R23
         ;     316 	FirstDataSector = (BPB_NumFATs * BPB_FATSz16) + BPB_RsvdSecCnt + _FF_RootDirSectors; 
0005b4 91e0 0708 	LDS  R30,_BPB_FATSz16
0005b6 91f0 0709 	LDS  R31,_BPB_FATSz16+1
0005b8 2dab      	MOV  R26,R11
0005b9 e0b0      	LDI  R27,0
0005ba 940e 2239 	CALL __MULW12U
0005bc 0de9      	ADD  R30,R9
0005bd 1dfa      	ADC  R31,R10
0005be 01df      	MOVW R26,R30
0005bf 91e0 0732 	LDS  R30,__FF_RootDirSectors
0005c1 91f0 0733 	LDS  R31,__FF_RootDirSectors+1
0005c3 9160 0734 	LDS  R22,__FF_RootDirSectors+2
0005c5 9170 0735 	LDS  R23,__FF_RootDirSectors+3
0005c7 2788      	CLR  R24
0005c8 2799      	CLR  R25
0005c9 940e 21de 	CALL __ADDD12
0005cb 93e0 0736 	STS  _FirstDataSector,R30
0005cd 93f0 0737 	STS  _FirstDataSector+1,R31
         ;     317 	
         ;     318 	DataClusTot = BPB_TotSec - FirstDataSector;
0005cf 91a0 070a 	LDS  R26,_BPB_TotSec
0005d1 91b0 070b 	LDS  R27,_BPB_TotSec+1
0005d3 9180 070c 	LDS  R24,_BPB_TotSec+2
0005d5 9190 070d 	LDS  R25,_BPB_TotSec+3
0005d7 940e 1ced 	CALL SUBOPT_0x14
0005d9 93e0 0741 	STS  _DataClusTot,R30
0005db 93f0 0742 	STS  _DataClusTot+1,R31
0005dd 9360 0743 	STS  _DataClusTot+2,R22
0005df 9370 0744 	STS  _DataClusTot+3,R23
         ;     319 	DataClusTot /= BPB_SecPerClus;
0005e1 2de8      	MOV  R30,R8
0005e2 91a0 0741 	LDS  R26,_DataClusTot
0005e4 91b0 0742 	LDS  R27,_DataClusTot+1
0005e6 9180 0743 	LDS  R24,_DataClusTot+2
0005e8 9190 0744 	LDS  R25,_DataClusTot+3
0005ea 27ff      	CLR  R31
0005eb 2766      	CLR  R22
0005ec 2777      	CLR  R23
0005ed 940e 2279 	CALL __DIVD21U
0005ef 93e0 0741 	STS  _DataClusTot,R30
0005f1 93f0 0742 	STS  _DataClusTot+1,R31
0005f3 9360 0743 	STS  _DataClusTot+2,R22
0005f5 9370 0744 	STS  _DataClusTot+3,R23
         ;     320 	clus_0_addr = 0;		// Reset Empty Cluster table location
0005f7 e0e0      	LDI  R30,0
0005f8 93e0 074c 	STS  _clus_0_addr,R30
0005fa 93e0 074d 	STS  _clus_0_addr+1,R30
0005fc 93e0 074e 	STS  _clus_0_addr+2,R30
0005fe 93e0 074f 	STS  _clus_0_addr+3,R30
         ;     321 	c_counter = 1;
000600 e0e1      	LDI  R30,LOW(1)
000601 e0f0      	LDI  R31,HIGH(1)
000602 93e0 0754 	STS  _c_counter,R30
000604 93f0 0755 	STS  _c_counter+1,R31
         ;     322 	
         ;     323 	if (DataClusTot < 4085)				// FAT12
000606 91a0 0741 	LDS  R26,_DataClusTot
000608 91b0 0742 	LDS  R27,_DataClusTot+1
00060a 9180 0743 	LDS  R24,_DataClusTot+2
00060c 9190 0744 	LDS  R25,_DataClusTot+3
00060e   +  	__CPD2N 0xFF5
000615 f418      	BRSH _0x32
         ;     324 		BPB_FATType = 0x32;
000616 e3e2      	LDI  R30,LOW(50)
000617 2eee      	MOV  R14,R30
         ;     325 	else if (DataClusTot < 65525)		// FAT16
000618 c019      	RJMP _0x33
          _0x32:
000619 91a0 0741 	LDS  R26,_DataClusTot
00061b 91b0 0742 	LDS  R27,_DataClusTot+1
00061d 9180 0743 	LDS  R24,_DataClusTot+2
00061f 9190 0744 	LDS  R25,_DataClusTot+3
000621   +  	__CPD2N 0xFFF5
000628 f418      	BRSH _0x34
         ;     326 		BPB_FATType = 0x36;
000629 e3e6      	LDI  R30,LOW(54)
00062a 2eee      	MOV  R14,R30
         ;     327 	else
00062b c006      	RJMP _0x35
          _0x34:
         ;     328 	{
         ;     329 		BPB_FATType = 0;
00062c 24ee      	CLR  R14
         ;     330 		_FF_error = FAT_ERR;
00062d e0ec      	LDI  R30,LOW(12)
00062e 93e0 073c 	STS  __FF_error,R30
         ;     331 		return (0);
000630 e0e0      	LDI  R30,LOW(0)
000631 c118      	RJMP _0x3EF
         ;     332 	}
          _0x35:
          _0x33:
         ;     333     
         ;     334 	_FF_DIR_ADDR = _FF_ROOT_ADDR;		// Set current directory to root address
000632 91e0 0722 	LDS  R30,__FF_ROOT_ADDR
000634 91f0 0723 	LDS  R31,__FF_ROOT_ADDR+1
000636 9160 0724 	LDS  R22,__FF_ROOT_ADDR+2
000638 9170 0725 	LDS  R23,__FF_ROOT_ADDR+3
00063a 93e0 0726 	STS  __FF_DIR_ADDR,R30
00063c 93f0 0727 	STS  __FF_DIR_ADDR+1,R31
00063e 9360 0728 	STS  __FF_DIR_ADDR+2,R22
000640 9370 0729 	STS  __FF_DIR_ADDR+3,R23
         ;     335 
         ;     336 	_FF_FULL_PATH[0] = 0x5C;	// a '\'
000642 e5ec      	LDI  R30,LOW(92)
000643 93e0 0756 	STS  __FF_FULL_PATH,R30
         ;     337 	_FF_FULL_PATH[1] = 0;
000645 e0e0      	LDI  R30,LOW(0)
000646   +  	__PUTB1MN __FF_FULL_PATH,1
         ;     338 	
         ;     339 	#ifdef _DEBUG_ON_
         ;     340 		printf("\n\rPart Address:  %lX", _FF_PART_ADDR);
000648   +  	__POINTW1FN _0,50
00064a 93fa      	ST   -Y,R31
00064b 93ea      	ST   -Y,R30
00064c 91e0 071e 	LDS  R30,__FF_PART_ADDR
00064e 91f0 071f 	LDS  R31,__FF_PART_ADDR+1
000650 9160 0720 	LDS  R22,__FF_PART_ADDR+2
000652 9170 0721 	LDS  R23,__FF_PART_ADDR+3
000654 940e 22d1 	CALL __PUTPARD1
000656 e084      	LDI  R24,4
000657 940e 1b51 	CALL _printf
000659 9626      	ADIW R28,6
         ;     341 		printf("\n\rBS_jmpBoot:  %lX", BS_jmpBoot);
00065a   +  	__POINTW1FN _0,71
00065c 93fa      	ST   -Y,R31
00065d 93ea      	ST   -Y,R30
00065e 91e0 0704 	LDS  R30,_BS_jmpBoot
000660 91f0 0705 	LDS  R31,_BS_jmpBoot+1
000662 9160 0706 	LDS  R22,_BS_jmpBoot+2
000664 9170 0707 	LDS  R23,_BS_jmpBoot+3
000666 940e 22d1 	CALL __PUTPARD1
000668 e084      	LDI  R24,4
000669 940e 1b51 	CALL _printf
00066b 9626      	ADIW R28,6
         ;     342 		printf("\n\rBPB_BytsPerSec:  %X", BPB_BytsPerSec);
00066c   +  	__POINTW1FN _0,90
00066e 93fa      	ST   -Y,R31
00066f 93ea      	ST   -Y,R30
000670   +  	__GETW1R 6,7
000672 2766      	CLR  R22
000673 2777      	CLR  R23
000674 940e 22d1 	CALL __PUTPARD1
000676 e084      	LDI  R24,4
000677 940e 1b51 	CALL _printf
000679 9626      	ADIW R28,6
         ;     343 		printf("\n\rBPB_SecPerClus:  %X", BPB_SecPerClus);
00067a   +  	__POINTW1FN _0,112
00067c 93fa      	ST   -Y,R31
00067d 93ea      	ST   -Y,R30
00067e 2de8      	MOV  R30,R8
00067f 27ff      	CLR  R31
000680 2766      	CLR  R22
000681 2777      	CLR  R23
000682 940e 22d1 	CALL __PUTPARD1
000684 e084      	LDI  R24,4
000685 940e 1b51 	CALL _printf
000687 9626      	ADIW R28,6
         ;     344 		printf("\n\rBPB_RsvdSecCnt:  %X", BPB_RsvdSecCnt);
000688   +  	__POINTW1FN _0,134
00068a 93fa      	ST   -Y,R31
00068b 93ea      	ST   -Y,R30
00068c   +  	__GETW1R 9,10
00068e 2766      	CLR  R22
00068f 2777      	CLR  R23
000690 940e 22d1 	CALL __PUTPARD1
000692 e084      	LDI  R24,4
000693 940e 1b51 	CALL _printf
000695 9626      	ADIW R28,6
         ;     345 		printf("\n\rBPB_NumFATs:  %X", BPB_NumFATs);
000696   +  	__POINTW1FN _0,156
000698 93fa      	ST   -Y,R31
000699 93ea      	ST   -Y,R30
00069a 2deb      	MOV  R30,R11
00069b 27ff      	CLR  R31
00069c 2766      	CLR  R22
00069d 2777      	CLR  R23
00069e 940e 22d1 	CALL __PUTPARD1
0006a0 e084      	LDI  R24,4
0006a1 940e 1b51 	CALL _printf
0006a3 9626      	ADIW R28,6
         ;     346 		printf("\n\rBPB_RootEntCnt:  %X", BPB_RootEntCnt);
0006a4   +  	__POINTW1FN _0,175
0006a6 93fa      	ST   -Y,R31
0006a7 93ea      	ST   -Y,R30
0006a8   +  	__GETW1R 12,13
0006aa 2766      	CLR  R22
0006ab 2777      	CLR  R23
0006ac 940e 22d1 	CALL __PUTPARD1
0006ae e084      	LDI  R24,4
0006af 940e 1b51 	CALL _printf
0006b1 9626      	ADIW R28,6
         ;     347 		printf("\n\rBPB_FATSz16:  %X", BPB_FATSz16);
0006b2   +  	__POINTW1FN _0,197
0006b4 93fa      	ST   -Y,R31
0006b5 93ea      	ST   -Y,R30
0006b6 91e0 0708 	LDS  R30,_BPB_FATSz16
0006b8 91f0 0709 	LDS  R31,_BPB_FATSz16+1
0006ba 2766      	CLR  R22
0006bb 2777      	CLR  R23
0006bc 940e 22d1 	CALL __PUTPARD1
0006be e084      	LDI  R24,4
0006bf 940e 1b51 	CALL _printf
0006c1 9626      	ADIW R28,6
         ;     348 		printf("\n\rBPB_TotSec16:  %lX", BPB_TotSec);
0006c2   +  	__POINTW1FN _0,216
0006c4 93fa      	ST   -Y,R31
0006c5 93ea      	ST   -Y,R30
0006c6 91e0 070a 	LDS  R30,_BPB_TotSec
0006c8 91f0 070b 	LDS  R31,_BPB_TotSec+1
0006ca 9160 070c 	LDS  R22,_BPB_TotSec+2
0006cc 9170 070d 	LDS  R23,_BPB_TotSec+3
0006ce 940e 22d1 	CALL __PUTPARD1
0006d0 e084      	LDI  R24,4
0006d1 940e 1b51 	CALL _printf
0006d3 9626      	ADIW R28,6
         ;     349 		if (BPB_FATType == 0x32)
0006d4 e3e2      	LDI  R30,LOW(50)
0006d5 15ee      	CP   R30,R14
0006d6 f449      	BRNE _0x36
         ;     350 			printf("\n\rBPB_FATType:  FAT12");
0006d7   +  	__POINTW1FN _0,237
0006d9 93fa      	ST   -Y,R31
0006da 93ea      	ST   -Y,R30
0006db e080      	LDI  R24,0
0006dc 940e 1b51 	CALL _printf
0006de 9622      	ADIW R28,2
         ;     351 		else if (BPB_FATType == 0x36)
0006df c011      	RJMP _0x37
          _0x36:
0006e0 e3e6      	LDI  R30,LOW(54)
0006e1 15ee      	CP   R30,R14
0006e2 f431      	BRNE _0x38
         ;     352 			printf("\n\rBPB_FATType:  FAT16");
0006e3   +  	__POINTW1FN _0,259
0006e5 93fa      	ST   -Y,R31
0006e6 93ea      	ST   -Y,R30
0006e7 e080      	LDI  R24,0
0006e8 c005      	RJMP _0x3F1
         ;     353 		else
          _0x38:
         ;     354 			printf("\n\rBPB_FATType:  FAT ERROR!!");
0006e9   +  	__POINTW1FN _0,281
0006eb 93fa      	ST   -Y,R31
0006ec 93ea      	ST   -Y,R30
0006ed e080      	LDI  R24,0
          _0x3F1:
0006ee 940e 1b51 	CALL _printf
0006f0 9622      	ADIW R28,2
         ;     355 		printf("\n\rClusterCnt:  %lX", DataClusTot);
          _0x37:
0006f1   +  	__POINTW1FN _0,309
0006f3 93fa      	ST   -Y,R31
0006f4 93ea      	ST   -Y,R30
0006f5 91e0 0741 	LDS  R30,_DataClusTot
0006f7 91f0 0742 	LDS  R31,_DataClusTot+1
0006f9 9160 0743 	LDS  R22,_DataClusTot+2
0006fb 9170 0744 	LDS  R23,_DataClusTot+3
0006fd 940e 22d1 	CALL __PUTPARD1
0006ff e084      	LDI  R24,4
000700 940e 1b51 	CALL _printf
000702 9626      	ADIW R28,6
         ;     356 		printf("\n\rROOT_ADDR:  %lX", _FF_ROOT_ADDR);
000703   +  	__POINTW1FN _0,328
000705 93fa      	ST   -Y,R31
000706 93ea      	ST   -Y,R30
000707 91e0 0722 	LDS  R30,__FF_ROOT_ADDR
000709 91f0 0723 	LDS  R31,__FF_ROOT_ADDR+1
00070b 9160 0724 	LDS  R22,__FF_ROOT_ADDR+2
00070d 9170 0725 	LDS  R23,__FF_ROOT_ADDR+3
00070f 940e 22d1 	CALL __PUTPARD1
000711 e084      	LDI  R24,4
000712 940e 1b51 	CALL _printf
000714 9626      	ADIW R28,6
         ;     357 		printf("\n\rFAT2_ADDR:  %lX", _FF_FAT2_ADDR);
000715   +  	__POINTW1FN _0,346
000717 93fa      	ST   -Y,R31
000718 93ea      	ST   -Y,R30
000719 91e0 072e 	LDS  R30,__FF_FAT2_ADDR
00071b 91f0 072f 	LDS  R31,__FF_FAT2_ADDR+1
00071d 9160 0730 	LDS  R22,__FF_FAT2_ADDR+2
00071f 9170 0731 	LDS  R23,__FF_FAT2_ADDR+3
000721 940e 22d1 	CALL __PUTPARD1
000723 e084      	LDI  R24,4
000724 940e 1b51 	CALL _printf
000726 9626      	ADIW R28,6
         ;     358 		printf("\n\rRootDirSectors:  %X", _FF_RootDirSectors);
000727   +  	__POINTW1FN _0,364
000729 93fa      	ST   -Y,R31
00072a 93ea      	ST   -Y,R30
00072b 91e0 0732 	LDS  R30,__FF_RootDirSectors
00072d 91f0 0733 	LDS  R31,__FF_RootDirSectors+1
00072f 9160 0734 	LDS  R22,__FF_RootDirSectors+2
000731 9170 0735 	LDS  R23,__FF_RootDirSectors+3
000733 940e 22d1 	CALL __PUTPARD1
000735 e084      	LDI  R24,4
000736 940e 1b51 	CALL _printf
000738 9626      	ADIW R28,6
         ;     359 		printf("\n\rFirstDataSector:  %X", FirstDataSector);
000739   +  	__POINTW1FN _0,386
00073b 93fa      	ST   -Y,R31
00073c 93ea      	ST   -Y,R30
00073d 91e0 0736 	LDS  R30,_FirstDataSector
00073f 91f0 0737 	LDS  R31,_FirstDataSector+1
000741 2766      	CLR  R22
000742 2777      	CLR  R23
000743 940e 22d1 	CALL __PUTPARD1
000745 e084      	LDI  R24,4
000746 940e 1b51 	CALL _printf
000748 9626      	ADIW R28,6
         ;     360 	#endif
         ;     361 	
         ;     362 	return (1);	
000749 e0e1      	LDI  R30,LOW(1)
          _0x3EF:
00074a 8108      	LDD  R16,Y+0
00074b 9625      	ADIW R28,5
00074c 9508      	RET
         ;     363 }
         ;     364 
         ;     365 unsigned char spi_speedset(void)
         ;     366 {
          _spi_speedset:
         ;     367 	if (SPCR == 0x50)
00074d b1ed      	IN   R30,0xD
00074e 35e0      	CPI  R30,LOW(0x50)
00074f f419      	BRNE _0x3A
         ;     368 		SPCR = 0x51;
000750 e5e1      	LDI  R30,LOW(81)
000751 b9ed      	OUT  0xD,R30
         ;     369 	else if (SPCR == 0x51)
000752 c00f      	RJMP _0x3B
          _0x3A:
000753 b1ed      	IN   R30,0xD
000754 35e1      	CPI  R30,LOW(0x51)
000755 f419      	BRNE _0x3C
         ;     370 		SPCR = 0x52;
000756 e5e2      	LDI  R30,LOW(82)
000757 b9ed      	OUT  0xD,R30
         ;     371 	else if (SPCR == 0x52)
000758 c009      	RJMP _0x3D
          _0x3C:
000759 b1ed      	IN   R30,0xD
00075a 35e2      	CPI  R30,LOW(0x52)
00075b f419      	BRNE _0x3E
         ;     372 		SPCR = 0x53;
00075c e5e3      	LDI  R30,LOW(83)
00075d b9ed      	OUT  0xD,R30
         ;     373 	else
00075e c003      	RJMP _0x3F
          _0x3E:
         ;     374 	{
         ;     375 		SPCR = 0x50;
00075f 940e 1c9d 	CALL SUBOPT_0xA
         ;     376 		return (0);
000761 9508      	RET
         ;     377 	}
          _0x3F:
          _0x3D:
          _0x3B:
         ;     378 	return (1);
000762 e0e1      	LDI  R30,LOW(1)
000763 9508      	RET
         ;     379 }
         ;     380 
         ;     381 unsigned char reset_sd(void)
         ;     382 {
          _reset_sd:
         ;     383 	unsigned char resp, n, c;
         ;     384 
         ;     385 	#ifdef _DEBUG_ON_
         ;     386 		printf("\n\rReset CMD:  ");	
000764 940e 2307 	CALL __SAVELOCR3
         ;	resp -> R16
         ;	n -> R17
         ;	c -> R18
000766   +  	__POINTW1FN _0,409
000768 93fa      	ST   -Y,R31
000769 93ea      	ST   -Y,R30
00076a e080      	LDI  R24,0
00076b 940e 1b51 	CALL _printf
00076d 9622      	ADIW R28,2
         ;     387 	#endif
         ;     388 	
         ;     389 	for (c=0; c<4; c++)		// try reset command 3 times if needed
00076e e020      	LDI  R18,LOW(0)
          _0x41:
00076f 3024      	CPI  R18,4
000770 f590      	BRSH _0x42
         ;     390 	{
         ;     391 		SD_CS_OFF();
000771 9ac4      	SBI  0x18,4
         ;     392 		for (n=0; n<10; n++)	// initialize clk signal to sync card
000772 e010      	LDI  R17,LOW(0)
          _0x44:
000773 301a      	CPI  R17,10
000774 f420      	BRSH _0x45
         ;     393 			_FF_spi(0xFF);
000775 940e 1c6f 	CALL SUBOPT_0x5
         ;     394 		resp = send_cmd(CMD0,0);
000777 5f1f      	SUBI R17,-1
000778 cffa      	RJMP _0x44
          _0x45:
000779 e0e0      	LDI  R30,LOW(0)
00077a 940e 1cf4 	CALL SUBOPT_0x15
         ;     395 		for (n=0; n<200; n++)
00077c e010      	LDI  R17,LOW(0)
          _0x47:
00077d 3c18      	CPI  R17,200
00077e f498      	BRSH _0x48
         ;     396 		{
         ;     397 			if (resp == 0x1)
00077f 3001      	CPI  R16,1
000780 f461      	BRNE _0x49
         ;     398 			{
         ;     399 				SD_CS_OFF();
000781 9ac4      	SBI  0x18,4
         ;     400     			#ifdef _DEBUG_ON_
         ;     401 					printf("OK!!!");
000782   +  	__POINTW1FN _0,424
000784 93fa      	ST   -Y,R31
000785 93ea      	ST   -Y,R30
000786 e080      	LDI  R24,0
000787 940e 1b51 	CALL _printf
000789 9622      	ADIW R28,2
         ;     402 				#endif
         ;     403 				SPCR = 0x50;
00078a 940e 1cff 	CALL SUBOPT_0x16
         ;     404 				return(1);
00078c c057      	RJMP _0x3EE
         ;     405 			}
         ;     406 	      	resp = _FF_spi(0xFF);
          _0x49:
00078d 940e 1c6f 	CALL SUBOPT_0x5
00078f 2f0e      	MOV  R16,R30
         ;     407 		}
000790 5f1f      	SUBI R17,-1
000791 cfeb      	RJMP _0x47
          _0x48:
         ;     408 		#ifdef _DEBUG_ON_
         ;     409 			printf("ERROR!!!");
000792   +  	__POINTW1FN _0,430
000794 93fa      	ST   -Y,R31
000795 93ea      	ST   -Y,R30
000796 e080      	LDI  R24,0
000797 940e 1b51 	CALL _printf
000799 9622      	ADIW R28,2
         ;     410 		#endif
         ;     411  		if (spi_speedset()==0)
00079a 940e 074d 	CALL _spi_speedset
00079c 30e0      	CPI  R30,0
00079d f419      	BRNE _0x4A
         ;     412  		{
         ;     413 		    SD_CS_OFF();
00079e 9ac4      	SBI  0x18,4
         ;     414  			return (0);
00079f e0e0      	LDI  R30,LOW(0)
0007a0 c043      	RJMP _0x3EE
         ;     415  		}
         ;     416 	}
          _0x4A:
0007a1 5f2f      	SUBI R18,-1
0007a2 cfcc      	RJMP _0x41
          _0x42:
         ;     417 	return (0);
0007a3 e0e0      	LDI  R30,LOW(0)
0007a4 c03f      	RJMP _0x3EE
         ;     418 }
         ;     419 
         ;     420 unsigned char init_sd(void)
         ;     421 {
          _init_sd:
         ;     422 	unsigned char resp;
         ;     423 	unsigned int c;
         ;     424 	
         ;     425 	clear_sd_buff();
0007a5 940e 2307 	CALL __SAVELOCR3
         ;	resp -> R16
         ;	c -> R17,R18
0007a7 940e 0372 	CALL _clear_sd_buff
         ;     426 
         ;     427     #ifdef _DEBUG_ON_
         ;     428 		printf("\r\nInitialization:  ");
0007a9   +  	__POINTW1FN _0,439
0007ab 93fa      	ST   -Y,R31
0007ac 93ea      	ST   -Y,R30
0007ad e080      	LDI  R24,0
0007ae 940e 1b51 	CALL _printf
0007b0 9622      	ADIW R28,2
         ;     429 	#endif
         ;     430     for (c=0; c<1000; c++)
0007b1   +  	__GETWRN 17,18,0
          _0x4C:
0007b3   +  	__CPWRN 17,18,1000
0007b6 f490      	BRSH _0x4D
         ;     431     {
         ;     432     	resp = send_cmd(CMD1, 0);
0007b7 e0e1      	LDI  R30,LOW(1)
0007b8 940e 1cf4 	CALL SUBOPT_0x15
         ;     433     	if (resp == 0)
0007ba 3000      	CPI  R16,0
0007bb f069      	BREQ _0x4D
         ;     434     		break;
         ;     435    		resp = _FF_spi(0xFF);
0007bc 940e 1c6f 	CALL SUBOPT_0x5
0007be 2f0e      	MOV  R16,R30
         ;     436    		if (resp == 0)
0007bf 3000      	CPI  R16,0
0007c0 f041      	BREQ _0x4D
         ;     437    			break;
         ;     438    		resp = _FF_spi(0xFF);
0007c1 940e 1c6f 	CALL SUBOPT_0x5
0007c3 2f0e      	MOV  R16,R30
         ;     439    		if (resp == 0)
0007c4 3000      	CPI  R16,0
0007c5 f019      	BREQ _0x4D
         ;     440    			break;
         ;     441 	}
0007c6   +  	__ADDWRN 17,18,1
0007c8 cfea      	RJMP _0x4C
          _0x4D:
         ;     442    	if (resp == 0)
0007c9 3000      	CPI  R16,0
0007ca f451      	BRNE _0x51
         ;     443 	{
         ;     444 		#ifdef _DEBUG_ON_
         ;     445    			printf("OK!");
0007cb   +  	__POINTW1FN _0,459
0007cd 93fa      	ST   -Y,R31
0007ce 93ea      	ST   -Y,R30
0007cf e080      	LDI  R24,0
0007d0 940e 1b51 	CALL _printf
0007d2 9622      	ADIW R28,2
         ;     446 	   	#endif
         ;     447 		return (1);
0007d3 e0e1      	LDI  R30,LOW(1)
0007d4 c00f      	RJMP _0x3EE
         ;     448 	}
         ;     449 	else
          _0x51:
         ;     450 	{
         ;     451 		#ifdef _DEBUG_ON_
         ;     452    			printf("ERROR-%x  ", resp);
0007d5   +  	__POINTW1FN _0,463
0007d7 93fa      	ST   -Y,R31
0007d8 93ea      	ST   -Y,R30
0007d9 2fe0      	MOV  R30,R16
0007da 27ff      	CLR  R31
0007db 2766      	CLR  R22
0007dc 2777      	CLR  R23
0007dd 940e 22d1 	CALL __PUTPARD1
0007df e084      	LDI  R24,4
0007e0 940e 1b51 	CALL _printf
0007e2 9626      	ADIW R28,6
         ;     453 	   	#endif
         ;     454 		return (0);
0007e3 e0e0      	LDI  R30,LOW(0)
         ;     455  	}        		
         ;     456 }
          _0x3EE:
0007e4 940e 230e 	CALL __LOADLOCR3
0007e6 9623      	ADIW R28,3
0007e7 9508      	RET
         ;     457 
         ;     458 unsigned char _FF_read_disp(unsigned long sd_addr)
         ;     459 {
         ;     460 	unsigned char resp;
         ;     461 	unsigned long n, remainder;
         ;     462 	
         ;     463 	if (sd_addr % 0x200)
         ;	sd_addr -> Y+9
         ;	resp -> R16
         ;	n -> Y+5
         ;	remainder -> Y+1
         ;     464 	{	// Not a valid read address, return 0
         ;     465 		_FF_error = READ_ERR;
         ;     466 		return (0);
         ;     467 	}
         ;     468 
         ;     469 	clear_sd_buff();
         ;     470 	resp = send_cmd(CMD17, sd_addr);		// Send read request
         ;     471 	
         ;     472 	while(resp!=0xFE)
         ;     473 		resp = _FF_spi(0xFF);
         ;     474 	for (n=0; n<512; n++)
         ;     475 	{
         ;     476 		remainder = n % 0x10;
         ;     477 		if (remainder == 0)
         ;     478 			printf("\n\r");
         ;     479 		_FF_buff[n] = _FF_spi(0xFF);
         ;     480 		if (_FF_buff[n]<0x10)
         ;     481 			putchar(0x30);
         ;     482 		printf("%X ", _FF_buff[n]);
         ;     483 	}
         ;     484 	_FF_spi(0xFF);
         ;     485 	_FF_spi(0xFF);
         ;     486 	_FF_spi(0xFF);
         ;     487 	SD_CS_OFF();
         ;     488 	return (1);
         ;     489 }
         ;     490 
         ;     491 // Read data from a SD card @ address
         ;     492 unsigned char _FF_read(unsigned long sd_addr)
         ;     493 {
          __FF_read:
         ;     494 	unsigned char resp;
         ;     495 	unsigned long n;
         ;     496 //printf("\r\nReadin ADDR [0x%lX]", sd_addr);
         ;     497 	
         ;     498 	if (sd_addr % BPB_BytsPerSec)
0007e8 9724      	SBIW R28,4
0007e9 930a      	ST   -Y,R16
         ;	sd_addr -> Y+5
         ;	resp -> R16
         ;	n -> Y+1
0007ea 940e 1d03 	CALL SUBOPT_0x17
0007ec f019      	BREQ _0x5C
         ;     499 	{	// Not a valid read address, return 0
         ;     500 		_FF_error = READ_ERR;
0007ed 940e 1d10 	CALL SUBOPT_0x18
         ;     501 		return (0);
0007ef c061      	RJMP _0x3ED
         ;     502 	}
         ;     503 		
         ;     504 	for (;;)
          _0x5C:
          _0x5E:
         ;     505 	{
         ;     506 		clear_sd_buff();
0007f0 940e 0372 	CALL _clear_sd_buff
         ;     507 		resp = send_cmd(CMD17, sd_addr);	// read block command
0007f2 e0e7      	LDI  R30,LOW(7)
0007f3 940e 1d15 	CALL SUBOPT_0x19
         ;     508 		for (n=0; n<1000; n++)
0007f5   +  	__CLRD1S 1
          _0x61:
0007fa   +  	__GETD2S 1
0007fe   +  	__CPD2N 0x3E8
000805 f440      	BRSH _0x62
         ;     509 		{
         ;     510 			if (resp==0xFE)
000806 3f0e      	CPI  R16,254
000807 f031      	BREQ _0x62
         ;     511 			{	// waiting for start byte
         ;     512 				break;
         ;     513 			}
         ;     514 			resp = _FF_spi(0xFF);
000808 940e 1c6f 	CALL SUBOPT_0x5
00080a 2f0e      	MOV  R16,R30
         ;     515 		}
00080b 940e 1ca1 	CALL SUBOPT_0xB
00080d cfec      	RJMP _0x61
          _0x62:
         ;     516 		if (resp==0xFE)
00080e 3f0e      	CPI  R16,254
00080f f5c9      	BRNE _0x64
         ;     517 		{	// if it is a valid start byte => start reading SD Card
         ;     518 			for (n=0; n<BPB_BytsPerSec; n++)
000810   +  	__CLRD1S 1
          _0x66:
000815   +  	__GETW1R 6,7
000817   +  	__GETD2S 1
00081b 2766      	CLR  R22
00081c 2777      	CLR  R23
00081d 940e 22ff 	CALL __CPD21
00081f f480      	BRSH _0x67
         ;     519 				_FF_buff[n] = _FF_spi(0xFF);
000820   +  	__GETD1S 1
000824 5fec      	SUBI R30,LOW(-__FF_buff)
000825 4ffa      	SBCI R31,HIGH(-__FF_buff)
000826 93ff      	PUSH R31
000827 93ef      	PUSH R30
000828 940e 1c6f 	CALL SUBOPT_0x5
00082a 91af      	POP  R26
00082b 91bf      	POP  R27
00082c 93ec      	ST   X,R30
         ;     520 			_FF_spi(0xFF);
00082d 940e 1ca1 	CALL SUBOPT_0xB
00082f cfe5      	RJMP _0x66
          _0x67:
000830 940e 1c9a 	CALL SUBOPT_0x9
         ;     521 			_FF_spi(0xFF);
000832 940e 1c6a 	CALL SUBOPT_0x4
         ;     522 			_FF_spi(0xFF);
000834 940e 0265 	CALL __FF_spi
         ;     523 			SD_CS_OFF();
000836 9ac4      	SBI  0x18,4
         ;     524 			_FF_error = NO_ERR;
000837 e0e0      	LDI  R30,LOW(0)
000838 93e0 073c 	STS  __FF_error,R30
         ;     525 			_FF_buff_addr = sd_addr;
00083a   +  	__GETD1S 5
00083e 93e0 073d 	STS  __FF_buff_addr,R30
000840 93f0 073e 	STS  __FF_buff_addr+1,R31
000842 9360 073f 	STS  __FF_buff_addr+2,R22
000844 9370 0740 	STS  __FF_buff_addr+3,R23
         ;     526 			SPCR = 0x50;
000846 940e 1cff 	CALL SUBOPT_0x16
         ;     527 			return (1);
000848 c008      	RJMP _0x3ED
         ;     528 		}
         ;     529 
         ;     530 		SD_CS_OFF();
          _0x64:
000849 9ac4      	SBI  0x18,4
         ;     531 
         ;     532 		if (spi_speedset()==0)
00084a 940e 074d 	CALL _spi_speedset
00084c 30e0      	CPI  R30,0
00084d f009      	BREQ _0x5F
         ;     533 			break;
         ;     534 	}	
00084e cfa1      	RJMP _0x5E
          _0x5F:
         ;     535 	_FF_error = READ_ERR;    
00084f 940e 1d10 	CALL SUBOPT_0x18
         ;     536 	return(0);
          _0x3ED:
000851 8108      	LDD  R16,Y+0
000852 9629      	ADIW R28,9
000853 9508      	RET
         ;     537 }
         ;     538 
         ;     539 
         ;     540 #ifndef _READ_ONLY_
         ;     541 unsigned char _FF_write(unsigned long sd_addr)
         ;     542 {
          __FF_write:
         ;     543 	unsigned char resp, calc, valid_flag;
         ;     544 	unsigned int n;
         ;     545 	
         ;     546 	if ((sd_addr%BPB_BytsPerSec) || (sd_addr <= _FF_PART_ADDR))
000854 940e 2305 	CALL __SAVELOCR5
         ;	sd_addr -> Y+5
         ;	resp -> R16
         ;	calc -> R17
         ;	valid_flag -> R18
         ;	n -> R19,R20
000856 940e 1d03 	CALL SUBOPT_0x17
000858 f479      	BRNE _0x6A
000859 91e0 071e 	LDS  R30,__FF_PART_ADDR
00085b 91f0 071f 	LDS  R31,__FF_PART_ADDR+1
00085d 9160 0720 	LDS  R22,__FF_PART_ADDR+2
00085f 9170 0721 	LDS  R23,__FF_PART_ADDR+3
000861   +  	__GETD2S 5
000865 940e 22fa 	CALL __CPD12
000867 f018      	BRLO _0x69
          _0x6A:
         ;     547 	{	// Not a valid write address, return 0
         ;     548 		_FF_error = WRITE_ERR;
000868 940e 1d20 	CALL SUBOPT_0x1A
         ;     549 		return (0);
00086a c04c      	RJMP _0x3EC
         ;     550 	}
         ;     551 
         ;     552 //printf("\r\nWriting to address:  %lX", sd_addr);
         ;     553 	for (;;)
          _0x69:
          _0x6D:
         ;     554 	{
         ;     555 		clear_sd_buff();
00086b 940e 0372 	CALL _clear_sd_buff
         ;     556 		resp = send_cmd(CMD24, sd_addr);
00086d e0e9      	LDI  R30,LOW(9)
00086e 940e 1d15 	CALL SUBOPT_0x19
         ;     557 		valid_flag = 0;
000870 e020      	LDI  R18,LOW(0)
         ;     558 		for (n=0; n<1000; n++)
000871   +  	__GETWRN 19,20,0
          _0x70:
000873   +  	__CPWRN 19,20,1000
000876 f450      	BRSH _0x71
         ;     559 		{
         ;     560 			if (resp == 0x00)
000877 3000      	CPI  R16,0
000878 f411      	BRNE _0x72
         ;     561 			{
         ;     562 				valid_flag = 1;
000879 e021      	LDI  R18,LOW(1)
         ;     563 				break;
00087a c006      	RJMP _0x71
         ;     564 			}
         ;     565 			resp = _FF_spi(0xFF);
          _0x72:
00087b 940e 1c6f 	CALL SUBOPT_0x5
00087d 2f0e      	MOV  R16,R30
         ;     566 		}
00087e   +  	__ADDWRN 19,20,1
000880 cff2      	RJMP _0x70
          _0x71:
         ;     567 	
         ;     568 		if (valid_flag)
000881 3020      	CPI  R18,0
000882 f161      	BREQ _0x73
         ;     569 		{
         ;     570 			_FF_spi(0xFF);
000883 940e 1c6f 	CALL SUBOPT_0x5
         ;     571 			_FF_spi(0xFE);					// Start Block Token
000885 efee      	LDI  R30,LOW(254)
000886 93ea      	ST   -Y,R30
000887 940e 0265 	CALL __FF_spi
         ;     572 			for (n=0; n<BPB_BytsPerSec; n++)		// Write Data in buffer to card
000889   +  	__GETWRN 19,20,0
          _0x75:
00088b   +  	__CPWRR 19,20,6,7
00088d f458      	BRSH _0x76
         ;     573 				_FF_spi(_FF_buff[n]);
00088e e0a4      	LDI  R26,LOW(__FF_buff)
00088f e0b5      	LDI  R27,HIGH(__FF_buff)
000890 0fa3      	ADD  R26,R19
000891 1fb4      	ADC  R27,R20
000892 91ec      	LD   R30,X
000893 93ea      	ST   -Y,R30
000894 940e 0265 	CALL __FF_spi
         ;     574 			_FF_spi(0xFF);					// Send 2 blank CRC bytes
000896   +  	__ADDWRN 19,20,1
000898 cff2      	RJMP _0x75
          _0x76:
000899 940e 1c9a 	CALL SUBOPT_0x9
         ;     575 			_FF_spi(0xFF);
00089b 940e 1c6a 	CALL SUBOPT_0x4
         ;     576 			resp = _FF_spi(0xFF);			// Response should be 0bXXX00101
00089d 940e 0265 	CALL __FF_spi
00089f 2f0e      	MOV  R16,R30
         ;     577 			calc = resp | 0xE0;
0008a0 2fe0      	MOV  R30,R16
0008a1 6ee0      	ORI  R30,LOW(0xE0)
0008a2 2f1e      	MOV  R17,R30
         ;     578 			if (calc==0xE5)
0008a3 3e15      	CPI  R17,229
0008a4 f451      	BRNE _0x77
         ;     579 			{
         ;     580 				while(_FF_spi(0xFF)==0)
          _0x78:
0008a5 940e 1c6f 	CALL SUBOPT_0x5
0008a7 30e0      	CPI  R30,0
0008a8 f3e1      	BREQ _0x78
         ;     581 					;	// Clear Buffer before returning 'OK'
         ;     582 				SD_CS_OFF();
0008a9 9ac4      	SBI  0x18,4
         ;     583 //				SPCR = 0x50;			// Reset SPI bus Speed
         ;     584 				_FF_error = NO_ERR;
0008aa e0e0      	LDI  R30,LOW(0)
0008ab 93e0 073c 	STS  __FF_error,R30
         ;     585 				return(1);
0008ad e0e1      	LDI  R30,LOW(1)
0008ae c008      	RJMP _0x3EC
         ;     586 			}
         ;     587 		}
          _0x77:
         ;     588 		SD_CS_OFF(); 
          _0x73:
0008af 9ac4      	SBI  0x18,4
         ;     589 
         ;     590 		if (spi_speedset()==0)
0008b0 940e 074d 	CALL _spi_speedset
0008b2 30e0      	CPI  R30,0
0008b3 f009      	BREQ _0x6E
         ;     591 			break;
         ;     592 		// delay_ms(100);		
         ;     593 	}
0008b4 cfb6      	RJMP _0x6D
          _0x6E:
         ;     594 	_FF_error = WRITE_ERR;
0008b5 940e 1d20 	CALL SUBOPT_0x1A
         ;     595 	return(0x0);
          _0x3EC:
0008b7 940e 230c 	CALL __LOADLOCR5
0008b9 9629      	ADIW R28,9
0008ba 9508      	RET
         ;     596 }
         ;     597 #endif
         ;     598 /*
         ;     599 	Progressive Resources LLC
         ;     600                                     
         ;     601 			FlashFile
         ;     602 	
         ;     603 	Version : 	1.32
         ;     604 	Date: 		12/31/2003
         ;     605 	Author: 	Erick M. Higa
         ;     606 	
         ;     607 	Revision History:
         ;     608 	12/31/2003 - EMH - v1.00 
         ;     609 			   	 	 - Initial Release
         ;     610 	01/19/2004 - EMH - v1.10
         ;     611 			   	 	 - fixed FAT access errors by allowing both FAT tables to be updated
         ;     612 					 - fixed erase_cluster chain to stop if chain goes to '0'
         ;     613 					 - fixed #include's so other non m128 processors could be used
         ;     614 					 - fixed fcreate to match 'C' standard for function "creat"
         ;     615 					 - fixed fseek so it would not error when in "READ" mode
         ;     616 					 - modified SPI interface to use _FF_spi() so it is more universal
         ;     617 					   (see the "sd_cmd.c" file for the function used)
         ;     618 					 - redifined global variables and #defines for more unique names
         ;     619 					 - added string functions fputs, fputsc, & fgets
         ;     620 					 - added functions fquickformat, fgetfileinfo, & GetVolID()
         ;     621 					 - added directory support
         ;     622 					 - modified delays in "sd_cmd.c" to increase transfer speed to max
         ;     623 					 - updated "options.h" to include additions, and to make #defines 
         ;     624 					   more universal to multiple platforms
         ;     625 	01/21/2004 - EMH - v1.20
         ;     626 			   	 	 - Added ICC Support to the FlashFileSD
         ;     627 					 - fixed card initialization error for MMC/SD's that have only a boot 
         ;     628 			   	 	   sector and no partition table
         ;     629 					 - Fixed intermittant error on fcreate when creating existing file
         ;     630 					 - changed "options.h" to #include all required files
         ;     631 	02/19/2004 - EMH - v1.21
         ;     632 					 - Replaced all "const" refrances to "flash" to support CodeVision 1.24.1b
         ;     633 	03/02/2004 - EMH - v1.22 (unofficial release)
         ;     634 					 - Changed Directory Functions to allow for multi-cluster directory entries
         ;     635 					 - Added function addr_to_clust() to support long directories
         ;     636 					 - Fixed FAT table address calculation to support multiple reserved sectors
         ;     637 					   (previously) assumed one reserved sector, if XP formats card sometimes 
         ;     638 					   multiple reserved sectors - thanks YW
         ;     639 	03/10/2004 - EMH - v1.30
         ;     640 					 - Added support for a Compact Flash package
         ;     641 					 - Renamed read and write to flash function names for multiple media support	
         ;     642 	03/26/2004 - EMH - v1.31
         ;     643 					 - Added define for easy MEGA128Dev board setup
         ;     644 					 - Changed demo projects so "option.h" is in the project directory	
         ;     645 	04/01/2004 - EMH - v1.32
         ;     646 					 - Fixed bug in "prev_cluster()" that didn't use updated FAT table address
         ;     647 					   calculations.  (effects XP formatted cards see v1.22 notes)
         ;     648                                            
         ;     649 	Software License
         ;     650 	The use of Progressive Resources LLC FlashFile Source Package indicates 
         ;     651 	your understanding and acceptance of the following terms and conditions. 
         ;     652 	This license shall supersede any verbal or prior verbal or written, statement 
         ;     653 	or agreement to the contrary. If you do not understand or accept these terms, 
         ;     654 	or your local regulations prohibit "after sale" license agreements or limited 
         ;     655 	disclaimers, you must cease and desist using this product immediately.
         ;     656 	This product is © Copyright 2003 by Progressive Resources LLC, all rights 
         ;     657 	reserved. International copyright laws, international treaties and all other 
         ;     658 	applicable national or international laws protect this product. This software 
         ;     659 	product and documentation may not, in whole or in part, be copied, photocopied, 
         ;     660 	translated, or reduced to any electronic medium or machine readable form, without 
         ;     661 	prior consent in writing, from Progressive Resources LLC and according to all 
         ;     662 	applicable laws. The sole owner of this product is Progressive Resources LLC.
         ;     663 
         ;     664 	Operating License
         ;     665 	You have the non-exclusive right to use any enclosed product but have no right 
         ;     666 	to distribute it as a source code product without the express written permission 
         ;     667 	of Progressive Resources LLC. Use over a "local area network" (within the same 
         ;     668 	locale) is permitted provided that only a single person, on a single computer 
         ;     669 	uses the product at a time. Use over a "wide area network" (outside the same 
         ;     670 	locale) is strictly prohibited under any and all circumstances.
         ;     671                                            
         ;     672 	Liability Disclaimer
         ;     673 	This product and/or license is provided as is, without any representation or 
         ;     674 	warranty of any kind, either express or implied, including without limitation 
         ;     675 	any representations or endorsements regarding the use of, the results of, or 
         ;     676 	performance of the product, Its appropriateness, accuracy, reliability, or 
         ;     677 	correctness. The user and/or licensee assume the entire risk as to the use of 
         ;     678 	this product. Progressive Resources LLC does not assume liability for the use 
         ;     679 	of this product beyond the original purchase price of the software. In no event 
         ;     680 	will Progressive Resources LLC be liable for additional direct or indirect 
         ;     681 	damages including any lost profits, lost savings, or other incidental or 
         ;     682 	consequential damages arising from any defects, or the use or inability to 
         ;     683 	use these products, even if Progressive Resources LLC have been advised of 
         ;     684 	the possibility of such damages.
         ;     685 */                                 
         ;     686 
         ;     687 extern unsigned long OCR_REG;
         ;     688 extern unsigned char _FF_buff[512];
         ;     689 extern unsigned int PT_SecStart;
         ;     690 extern unsigned long BS_jmpBoot;
         ;     691 extern unsigned int BPB_BytsPerSec;
         ;     692 extern unsigned char BPB_SecPerClus;
         ;     693 extern unsigned int BPB_RsvdSecCnt;
         ;     694 extern unsigned char BPB_NumFATs;
         ;     695 extern unsigned int BPB_RootEntCnt;
         ;     696 extern unsigned int BPB_FATSz16;
         ;     697 extern unsigned char BPB_FATType;
         ;     698 extern unsigned long BPB_TotSec;
         ;     699 extern unsigned long BS_VolSerial;
         ;     700 extern unsigned char BS_VolLab[12];
         ;     701 extern unsigned long _FF_PART_ADDR, _FF_ROOT_ADDR, _FF_DIR_ADDR;
         ;     702 extern unsigned long _FF_FAT1_ADDR, _FF_FAT2_ADDR;
         ;     703 extern unsigned int FirstDataSector;
         ;     704 extern unsigned long FirstSectorofCluster;
         ;     705 extern unsigned char _FF_error;
         ;     706 extern unsigned long _FF_buff_addr;
         ;     707 extern unsigned long DataClusTot;
         ;     708 unsigned char rtc_hour, rtc_min, rtc_sec;
         
          	.DSEG
          _rtc_hour:
000745      	.BYTE 0x1
          _rtc_min:
000746      	.BYTE 0x1
          _rtc_sec:
000747      	.BYTE 0x1
         ;     709 unsigned char rtc_date, rtc_month;
          _rtc_date:
000748      	.BYTE 0x1
          _rtc_month:
000749      	.BYTE 0x1
         ;     710 unsigned int rtc_year;
          _rtc_year:
00074a      	.BYTE 0x2
         ;     711 unsigned long clus_0_addr, _FF_n_temp;
          _clus_0_addr:
00074c      	.BYTE 0x4
          __FF_n_temp:
000750      	.BYTE 0x4
         ;     712 unsigned int c_counter;
          _c_counter:
000754      	.BYTE 0x2
         ;     713 unsigned char _FF_FULL_PATH[_FF_PATH_LENGTH];
          __FF_FULL_PATH:
000756      	.BYTE 0x64
         ;     714 unsigned char FILENAME[12];
          _FILENAME:
0007ba      	.BYTE 0xC
         ;     715 
         ;     716 // Conversion file to change an ASCII valued character into the calculated value
         ;     717 unsigned char ascii_to_char(unsigned char ascii_char)
         ;     718 {
         
          	.CSEG
         ;     719 	unsigned char temp_char;
         ;     720 	
         ;     721 	if (ascii_char < 0x30)		// invalid, return error
         ;	ascii_char -> Y+1
         ;	temp_char -> R16
         ;     722 		return (0xFF);
         ;     723 	else if (ascii_char < 0x3A)
         ;     724 	{	//number, subtract 0x30, retrun value
         ;     725 		temp_char = ascii_char - 0x30;
         ;     726 		return (temp_char);
         ;     727 	}
         ;     728 	else if (ascii_char < 0x41)	// invalid, return error
         ;     729 		return (0xFF);
         ;     730 	else if (ascii_char < 0x47)
         ;     731 	{	// lower case a-f, subtract 0x37, return value
         ;     732 		temp_char = ascii_char - 0x37;
         ;     733 		return (temp_char);
         ;     734 	}
         ;     735 	else if (ascii_char < 0x61)	// invalid, return error
         ;     736 		return (0xFF);
         ;     737 	else if (ascii_char < 0x67)
         ;     738 	{	// upper case A-F, subtract 0x57, return value
         ;     739 		temp_char = ascii_char - 0x57;
         ;     740 		return (temp_char);
         ;     741 	}
         ;     742 	else	// invalid, return error
         ;     743 		return (0xFF);
         ;     744 }
         ;     745 
         ;     746 // Function to see if the character is a valid FILENAME character
         ;     747 int valid_file_char(unsigned char file_char)
         ;     748 {
          _valid_file_char:
         ;     749 	if (file_char < 0x20)
0008bb 81a8      	LD   R26,Y
0008bc 32a0      	CPI  R26,LOW(0x20)
0008bd f418      	BRSH _0x88
         ;     750 		return (EOF);
0008be efef      	LDI  R30,LOW(65535)
0008bf efff      	LDI  R31,HIGH(65535)
0008c0 c022      	RJMP _0x3EB
         ;     751 	else if ((file_char==0x22) || (file_char==0x2A) || (file_char==0x2B) || (file_char==0x2C) ||
          _0x88:
         ;     752 			(file_char==0x2E) || (file_char==0x2F) || ((file_char>=0x3A)&&(file_char<=0x3F)) ||
         ;     753 			((file_char>=0x5B)&&(file_char<=0x5D)) || (file_char==0x7C) || (file_char==0xE5))
0008c1 81a8      	LD   R26,Y
0008c2 32a2      	CPI  R26,LOW(0x22)
0008c3 f0d1      	BREQ _0x8B
0008c4 32aa      	CPI  R26,LOW(0x2A)
0008c5 f0c1      	BREQ _0x8B
0008c6 32ab      	CPI  R26,LOW(0x2B)
0008c7 f0b1      	BREQ _0x8B
0008c8 32ac      	CPI  R26,LOW(0x2C)
0008c9 f0a1      	BREQ _0x8B
0008ca 32ae      	CPI  R26,LOW(0x2E)
0008cb f091      	BREQ _0x8B
0008cc 32af      	CPI  R26,LOW(0x2F)
0008cd f081      	BREQ _0x8B
0008ce 33aa      	CPI  R26,LOW(0x3A)
0008cf f018      	BRLO _0x8C
0008d0 e3ef      	LDI  R30,LOW(63)
0008d1 17ea      	CP   R30,R26
0008d2 f458      	BRSH _0x8B
          _0x8C:
0008d3 81a8      	LD   R26,Y
0008d4 35ab      	CPI  R26,LOW(0x5B)
0008d5 f018      	BRLO _0x8E
0008d6 e5ed      	LDI  R30,LOW(93)
0008d7 17ea      	CP   R30,R26
0008d8 f428      	BRSH _0x8B
          _0x8E:
0008d9 81a8      	LD   R26,Y
0008da 37ac      	CPI  R26,LOW(0x7C)
0008db f011      	BREQ _0x8B
0008dc 3ea5      	CPI  R26,LOW(0xE5)
0008dd f419      	BRNE _0x8A
          _0x8B:
         ;     754 		return (EOF);
0008de efef      	LDI  R30,LOW(65535)
0008df efff      	LDI  R31,HIGH(65535)
0008e0 c002      	RJMP _0x3EB
         ;     755 	else
          _0x8A:
         ;     756 		return (0);
0008e1 e0e0      	LDI  R30,LOW(0)
0008e2 e0f0      	LDI  R31,HIGH(0)
         ;     757 }
          _0x3EB:
0008e3 9621      	ADIW R28,1
0008e4 9508      	RET
         ;     758 
         ;     759 // Function will scan the directory @VALID_ADDR and return a
         ;     760 // '0' if successful (w/ VALID_ADDR changing to location of entry avaliable),
         ;     761 // and a '-1' if file or folder exists (w/ VALID_ADDR changing to location of
         ;     762 // entry of exisiting file/folder) or if no more entry space (VALID_ADDR would
         ;     763 // change to 0).
         ;     764 int scan_directory(unsigned long *VALID_ADDR, unsigned char *NAME)
         ;     765 {
          _scan_directory:
         ;     766 	unsigned int ent_cntr, ent_max, n, c, dir_clus;
         ;     767 	unsigned long temp_addr;
         ;     768 	unsigned char *sp, *qp, aval_flag, name_store[14];
         ;     769 	
         ;     770 	aval_flag = 0;
0008e5 976b      	SBIW R28,27
0008e6 940e 2304 	CALL __SAVELOCR6
         ;	*VALID_ADDR -> Y+35
         ;	*NAME -> Y+33
         ;	ent_cntr -> R16,R17
         ;	ent_max -> R18,R19
         ;	n -> R20,R21
         ;	c -> Y+31
         ;	dir_clus -> Y+29
         ;	temp_addr -> Y+25
         ;	*sp -> Y+23
         ;	*qp -> Y+21
         ;	aval_flag -> Y+20
         ;	name_store -> Y+6
0008e8 e0e0      	LDI  R30,LOW(0)
0008e9 8bec      	STD  Y+20,R30
         ;     771 	ent_cntr = 0;	// set to 0
0008ea   +  	__GETWRN 16,17,0
         ;     772 	
         ;     773 	qp = NAME;
0008ec a1e9      	LDD  R30,Y+33
0008ed a1fa      	LDD  R31,Y+33+1
0008ee 8bed      	STD  Y+21,R30
0008ef 8bfe      	STD  Y+21+1,R31
         ;     774 	for (c=0; c<11; c++)
0008f0 e0e0      	LDI  R30,0
0008f1 8fef      	STD  Y+31,R30
0008f2 a3e8      	STD  Y+31+1,R30
          _0x93:
0008f3 8daf      	LDD  R26,Y+31
0008f4 a1b8      	LDD  R27,Y+31+1
0008f5 30ab      	CPI  R26,LOW(0xB)
0008f6 e0e0      	LDI  R30,HIGH(0xB)
0008f7 07be      	CPC  R27,R30
0008f8 f010      	BRLO PC+3
0008f9 940c 0942 	JMP _0x94
         ;     775 	{
         ;     776 		if (valid_file_char(*qp)==0)
0008fb 89ad      	LDD  R26,Y+21
0008fc 89be      	LDD  R27,Y+21+1
0008fd 940e 1d25 	CALL SUBOPT_0x1B
0008ff f4a1      	BRNE _0x95
         ;     777 			name_store[c] = toupper(*qp++);
000900 8def      	LDD  R30,Y+31
000901 a1f8      	LDD  R31,Y+31+1
000902 01de      	MOVW R26,R28
000903 9616      	ADIW R26,6
000904 0fea      	ADD  R30,R26
000905 1ffb      	ADC  R31,R27
000906 93ff      	PUSH R31
000907 93ef      	PUSH R30
000908 89ad      	LDD  R26,Y+21
000909 89be      	LDD  R27,Y+21+1
00090a 91ed      	LD   R30,X+
00090b 8bad      	STD  Y+21,R26
00090c 8bbe      	STD  Y+21+1,R27
00090d 93ea      	ST   -Y,R30
00090e 940e 21d3 	CALL _toupper
000910 91af      	POP  R26
000911 91bf      	POP  R27
000912 93ec      	ST   X,R30
         ;     778 		else if (*qp == '.')
000913 c02b      	RJMP _0x96
          _0x95:
000914 89ad      	LDD  R26,Y+21
000915 89be      	LDD  R27,Y+21+1
000916 91ac      	LD   R26,X
000917 32ae      	CPI  R26,LOW(0x2E)
000918 f4a1      	BRNE _0x97
         ;     779 		{
         ;     780 			while (c<8)
          _0x98:
000919 8daf      	LDD  R26,Y+31
00091a a1b8      	LDD  R27,Y+31+1
00091b 30a8      	CPI  R26,LOW(0x8)
00091c e0e0      	LDI  R30,HIGH(0x8)
00091d 07be      	CPC  R27,R30
00091e f418      	BRSH _0x9A
         ;     781 				name_store[c++] = 0x20;
00091f 940e 1d2b 	CALL SUBOPT_0x1C
         ;     782 			c--;
000921 cff7      	RJMP _0x98
          _0x9A:
000922 8def      	LDD  R30,Y+31
000923 a1f8      	LDD  R31,Y+31+1
000924 9731      	SBIW R30,1
000925 8fef      	STD  Y+31,R30
000926 a3f8      	STD  Y+31+1,R31
         ;     783 			
         ;     784 			qp++;
000927 940e 1d38 	CALL SUBOPT_0x1D
         ;     785 			aval_flag |= 1;
000929 89ec      	LDD  R30,Y+20
00092a 60e1      	ORI  R30,1
00092b 8bec      	STD  Y+20,R30
         ;     786 		}
         ;     787 		else if (*qp == 0)
00092c c012      	RJMP _0x9B
          _0x97:
00092d 89ad      	LDD  R26,Y+21
00092e 89be      	LDD  R27,Y+21+1
00092f 91ec      	LD   R30,X
000930 30e0      	CPI  R30,0
000931 f451      	BRNE _0x9C
         ;     788 		{
         ;     789 			while (c<11)
          _0x9D:
000932 8daf      	LDD  R26,Y+31
000933 a1b8      	LDD  R27,Y+31+1
000934 30ab      	CPI  R26,LOW(0xB)
000935 e0e0      	LDI  R30,HIGH(0xB)
000936 07be      	CPC  R27,R30
000937 f418      	BRSH _0x9F
         ;     790 				name_store[c++] = 0x20;
000938 940e 1d2b 	CALL SUBOPT_0x1C
         ;     791 		}
00093a cff7      	RJMP _0x9D
          _0x9F:
         ;     792 		else
00093b c003      	RJMP _0xA0
          _0x9C:
         ;     793 		{
         ;     794 			*VALID_ADDR = 0;
00093c 940e 1d3e 	CALL SUBOPT_0x1E
         ;     795 			return (EOF);
00093e c110      	RJMP _0x3EA
         ;     796 		}
          _0xA0:
          _0x9B:
          _0x96:
         ;     797 	}
00093f 940e 1d49 	CALL SUBOPT_0x1F
000941 cfb1      	RJMP _0x93
          _0x94:
         ;     798 	name_store[11] = 0;
000942 e0e0      	LDI  R30,LOW(0)
000943 8be9      	STD  Y+17,R30
         ;     799 	
         ;     800 	if (*VALID_ADDR == _FF_ROOT_ADDR)
000944 a1ab      	LDD  R26,Y+35
000945 a1bc      	LDD  R27,Y+35+1
000946 940e 22c2 	CALL __GETD1P
000948 91a0 0722 	LDS  R26,__FF_ROOT_ADDR
00094a 91b0 0723 	LDS  R27,__FF_ROOT_ADDR+1
00094c 9180 0724 	LDS  R24,__FF_ROOT_ADDR+2
00094e 9190 0725 	LDS  R25,__FF_ROOT_ADDR+3
000950 940e 22fa 	CALL __CPD12
000952 f419      	BRNE _0xA1
         ;     801 		ent_max = BPB_RootEntCnt;
000953   +  	__MOVEWRR 18,19,12,13
         ;     802 	else
000955 c01a      	RJMP _0xA2
          _0xA1:
         ;     803 	{
         ;     804 		dir_clus = addr_to_clust(*VALID_ADDR);
000956 a1ab      	LDD  R26,Y+35
000957 a1bc      	LDD  R27,Y+35+1
000958 940e 22c2 	CALL __GETD1P
00095a 940e 22d1 	CALL __PUTPARD1
00095c d128      	RCALL _addr_to_clust
00095d 8fed      	STD  Y+29,R30
00095e 8ffe      	STD  Y+29+1,R31
         ;     805 		if (dir_clus != 0)
00095f 9730      	SBIW R30,0
000960 f019      	BREQ _0xA3
         ;     806 			aval_flag |= 0x80;
000961 89ec      	LDD  R30,Y+20
000962 68e0      	ORI  R30,0x80
000963 8bec      	STD  Y+20,R30
         ;     807 		ent_max = ((long) BPB_BytsPerSec * (long) BPB_SecPerClus) / 0x20;
          _0xA3:
000964 940e 1d4f 	CALL SUBOPT_0x20
000966 01df      	MOVW R26,R30
000967 01cb      	MOVW R24,R22
000968   +  	__GETD1N 0x20
00096c 940e 229f 	CALL __DIVD21
00096e   +  	__PUTW1R 18,19
         ;     808     }
          _0xA2:
         ;     809 	c = 0;
000970 e0e0      	LDI  R30,0
000971 8fef      	STD  Y+31,R30
000972 a3e8      	STD  Y+31+1,R30
         ;     810 	while (ent_cntr < ent_max)	
          _0xA4:
000973   +  	__CPWRR 16,17,18,19
000975 f010      	BRLO PC+3
000976 940c 0a4d 	JMP _0xA6
         ;     811 	{
         ;     812 		if (_FF_read(*VALID_ADDR+((long)c*BPB_BytsPerSec))==0)
000978 a1ab      	LDD  R26,Y+35
000979 a1bc      	LDD  R27,Y+35+1
00097a 940e 22c2 	CALL __GETD1P
00097c 937f      	PUSH R23
00097d 936f      	PUSH R22
00097e 93ff      	PUSH R31
00097f 93ef      	PUSH R30
000980 940e 1d5c 	CALL SUBOPT_0x21
000982 91af      	POP  R26
000983 91bf      	POP  R27
000984 918f      	POP  R24
000985 919f      	POP  R25
000986 940e 21de 	CALL __ADDD12
000988 940e 1cae 	CALL SUBOPT_0xC
00098a f409      	BRNE _0xA7
         ;     813 			break;
00098b c0c1      	RJMP _0xA6
         ;     814 		for (n=0; n<16; n++)
          _0xA7:
00098c   +  	__GETWRN 20,21,0
          _0xA9:
00098e   +  	__CPWRN 20,21,16
000991 f010      	BRLO PC+3
000992 940c 0a24 	JMP _0xAA
         ;     815 		{
         ;     816 			sp = &_FF_buff[n*0x20];
000994 940e 1d69 	CALL SUBOPT_0x22
000996 5fec      	SUBI R30,LOW(-__FF_buff)
000997 4ffa      	SBCI R31,HIGH(-__FF_buff)
000998 8bef      	STD  Y+23,R30
000999 8ff8      	STD  Y+23+1,R31
         ;     817 			qp = name_store;
00099a 01fe      	MOVW R30,R28
00099b 9636      	ADIW R30,6
00099c 8bed      	STD  Y+21,R30
00099d 8bfe      	STD  Y+21+1,R31
         ;     818 			if (*sp==0)
00099e 89af      	LDD  R26,Y+23
00099f 8db8      	LDD  R27,Y+23+1
0009a0 91ec      	LD   R30,X
0009a1 30e0      	CPI  R30,0
0009a2 f4e1      	BRNE _0xAB
         ;     819 			{
         ;     820 				if ((aval_flag&0x10)==0)
0009a3 89ec      	LDD  R30,Y+20
0009a4 71e0      	ANDI R30,LOW(0x10)
0009a5 f4a1      	BRNE _0xAC
         ;     821 					temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
0009a6 a1ab      	LDD  R26,Y+35
0009a7 a1bc      	LDD  R27,Y+35+1
0009a8 940e 22c2 	CALL __GETD1P
0009aa 937f      	PUSH R23
0009ab 936f      	PUSH R22
0009ac 93ff      	PUSH R31
0009ad 93ef      	PUSH R30
0009ae 940e 1d5c 	CALL SUBOPT_0x21
0009b0 91af      	POP  R26
0009b1 91bf      	POP  R27
0009b2 918f      	POP  R24
0009b3 919f      	POP  R25
0009b4 940e 21e3 	CALL __ADDD21
0009b6 940e 1d69 	CALL SUBOPT_0x22
0009b8 940e 1d70 	CALL SUBOPT_0x23
         ;     822 				*VALID_ADDR = temp_addr;
          _0xAC:
0009ba 940e 1d79 	CALL SUBOPT_0x24
         ;     823 				return (0);
0009bc e0e0      	LDI  R30,LOW(0)
0009bd e0f0      	LDI  R31,HIGH(0)
0009be c090      	RJMP _0x3EA
         ;     824 			}
         ;     825 			else if (*sp==0xE5)
          _0xAB:
0009bf 89af      	LDD  R26,Y+23
0009c0 8db8      	LDD  R27,Y+23+1
0009c1 91ac      	LD   R26,X
0009c2 3ea5      	CPI  R26,LOW(0xE5)
0009c3 f4c1      	BRNE _0xAE
         ;     826 			{
         ;     827 				temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
0009c4 a1ab      	LDD  R26,Y+35
0009c5 a1bc      	LDD  R27,Y+35+1
0009c6 940e 22c2 	CALL __GETD1P
0009c8 937f      	PUSH R23
0009c9 936f      	PUSH R22
0009ca 93ff      	PUSH R31
0009cb 93ef      	PUSH R30
0009cc 940e 1d5c 	CALL SUBOPT_0x21
0009ce 91af      	POP  R26
0009cf 91bf      	POP  R27
0009d0 918f      	POP  R24
0009d1 919f      	POP  R25
0009d2 940e 21e3 	CALL __ADDD21
0009d4 940e 1d69 	CALL SUBOPT_0x22
0009d6 940e 1d70 	CALL SUBOPT_0x23
         ;     828 				aval_flag |= 0x10;
0009d8 89ec      	LDD  R30,Y+20
0009d9 61e0      	ORI  R30,0x10
0009da 8bec      	STD  Y+20,R30
         ;     829 			}
         ;     830 			else
0009db c043      	RJMP _0xAF
          _0xAE:
         ;     831 			{
         ;     832 				if (aval_flag & 0x01)	// file
0009dc 89ec      	LDD  R30,Y+20
0009dd 70e1      	ANDI R30,LOW(0x1)
0009de f0e9      	BREQ _0xB0
         ;     833 				{
         ;     834 					if (strncmp(qp, sp, 11)==0)
0009df 940e 1d82 	CALL SUBOPT_0x25
0009e1 f4c9      	BRNE _0xB1
         ;     835 					{
         ;     836 						temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
0009e2 a1ab      	LDD  R26,Y+35
0009e3 a1bc      	LDD  R27,Y+35+1
0009e4 940e 22c2 	CALL __GETD1P
0009e6 937f      	PUSH R23
0009e7 936f      	PUSH R22
0009e8 93ff      	PUSH R31
0009e9 93ef      	PUSH R30
0009ea 940e 1d5c 	CALL SUBOPT_0x21
0009ec 91af      	POP  R26
0009ed 91bf      	POP  R27
0009ee 918f      	POP  R24
0009ef 919f      	POP  R25
0009f0 940e 21e3 	CALL __ADDD21
0009f2 940e 1d69 	CALL SUBOPT_0x22
0009f4 940e 1d70 	CALL SUBOPT_0x23
         ;     837 						*VALID_ADDR = temp_addr;
0009f6 940e 1d79 	CALL SUBOPT_0x24
         ;     838 						return (EOF);	// file exists @ temp_addr
0009f8 efef      	LDI  R30,LOW(65535)
0009f9 efff      	LDI  R31,HIGH(65535)
0009fa c054      	RJMP _0x3EA
         ;     839 					}
         ;     840 				}
          _0xB1:
         ;     841 				else					// folder
0009fb c023      	RJMP _0xB2
          _0xB0:
         ;     842 				{
         ;     843 					if ((strncmp(qp, sp, 11)==0)&&(*(sp+11)&0x10))
0009fc 940e 1d82 	CALL SUBOPT_0x25
0009fe f431      	BRNE _0xB4
0009ff 89af      	LDD  R26,Y+23
000a00 8db8      	LDD  R27,Y+23+1
000a01 961b      	ADIW R26,11
000a02 91ec      	LD   R30,X
000a03 71e0      	ANDI R30,LOW(0x10)
000a04 f409      	BRNE _0xB5
          _0xB4:
000a05 c019      	RJMP _0xB3
          _0xB5:
         ;     844 					{
         ;     845 						temp_addr = *VALID_ADDR + ((long) c * BPB_BytsPerSec) + (n * 0x20);
000a06 a1ab      	LDD  R26,Y+35
000a07 a1bc      	LDD  R27,Y+35+1
000a08 940e 22c2 	CALL __GETD1P
000a0a 937f      	PUSH R23
000a0b 936f      	PUSH R22
000a0c 93ff      	PUSH R31
000a0d 93ef      	PUSH R30
000a0e 940e 1d5c 	CALL SUBOPT_0x21
000a10 91af      	POP  R26
000a11 91bf      	POP  R27
000a12 918f      	POP  R24
000a13 919f      	POP  R25
000a14 940e 21e3 	CALL __ADDD21
000a16 940e 1d69 	CALL SUBOPT_0x22
000a18 940e 1d70 	CALL SUBOPT_0x23
         ;     846 						*VALID_ADDR = temp_addr;
000a1a 940e 1d79 	CALL SUBOPT_0x24
         ;     847 						return (EOF);	// file exists @ temp_addr
000a1c efef      	LDI  R30,LOW(65535)
000a1d efff      	LDI  R31,HIGH(65535)
000a1e c030      	RJMP _0x3EA
         ;     848 					}
         ;     849 				}
          _0xB3:
          _0xB2:
         ;     850 			}
          _0xAF:
         ;     851 			ent_cntr++;
000a1f   +  	__ADDWRN 16,17,1
         ;     852 		}
000a21   +  	__ADDWRN 20,21,1
000a23 cf6a      	RJMP _0xA9
          _0xAA:
         ;     853 		c++;
000a24 940e 1d49 	CALL SUBOPT_0x1F
         ;     854 		if (ent_cntr == ent_max)
000a26   +  	__CPWRR 18,19,16,17
000a28 f519      	BRNE _0xB6
         ;     855 		{
         ;     856 			if (aval_flag & 0x80)		// a folder @ a valid cluster
000a29 89ec      	LDD  R30,Y+20
000a2a 78e0      	ANDI R30,LOW(0x80)
000a2b f101      	BREQ _0xB7
         ;     857 			{
         ;     858 				c = next_cluster(dir_clus, SINGLE);
000a2c 8ded      	LDD  R30,Y+29
000a2d 8dfe      	LDD  R31,Y+29+1
000a2e 93fa      	ST   -Y,R31
000a2f 93ea      	ST   -Y,R30
000a30 940e 1d90 	CALL SUBOPT_0x26
000a32 8fef      	STD  Y+31,R30
000a33 a3f8      	STD  Y+31+1,R31
         ;     859 				if (c != EOF)
000a34 8daf      	LDD  R26,Y+31
000a35 a1b8      	LDD  R27,Y+31+1
000a36 3faf      	CPI  R26,LOW(0xFFFF)
000a37 efef      	LDI  R30,HIGH(0xFFFF)
000a38 07be      	CPC  R27,R30
000a39 f091      	BREQ _0xB8
         ;     860 				{	// another dir cluster exists
         ;     861 					*VALID_ADDR = clust_to_addr(c);
000a3a 8def      	LDD  R30,Y+31
000a3b a1f8      	LDD  R31,Y+31+1
000a3c 93fa      	ST   -Y,R31
000a3d 93ea      	ST   -Y,R30
000a3e d014      	RCALL _clust_to_addr
000a3f a1ab      	LDD  R26,Y+35
000a40 a1bc      	LDD  R27,Y+35+1
000a41 940e 22c8 	CALL __PUTDP1
         ;     862 					dir_clus = c;
000a43 8def      	LDD  R30,Y+31
000a44 a1f8      	LDD  R31,Y+31+1
000a45 8fed      	STD  Y+29,R30
000a46 8ffe      	STD  Y+29+1,R31
         ;     863 					ent_cntr = 0;
000a47   +  	__GETWRN 16,17,0
         ;     864 					c = 0;
000a49 e0e0      	LDI  R30,0
000a4a 8fef      	STD  Y+31,R30
000a4b a3e8      	STD  Y+31+1,R30
         ;     865 				}
         ;     866 			}
          _0xB8:
         ;     867 		}
          _0xB7:
         ;     868 	}
          _0xB6:
000a4c cf26      	RJMP _0xA4
          _0xA6:
         ;     869 	*VALID_ADDR = 0;
000a4d 940e 1d3e 	CALL SUBOPT_0x1E
         ;     870 	return (EOF);	
          _0x3EA:
000a4f 940e 230b 	CALL __LOADLOCR6
000a51 96a5      	ADIW R28,37
000a52 9508      	RET
         ;     871 }
         ;     872 
         ;     873 #ifdef _DEBUG_ON_
         ;     874 // Function to display all files and folders in the root directory, 
         ;     875 // with the size of the file in bytes within the [brakets]
         ;     876 void read_directory(void)
         ;     877 {
         ;     878 	unsigned char valid_flag, attribute_temp;
         ;     879 	unsigned int c, n, d, m, dir_clus;
         ;     880 	unsigned long calc, calc_clus, dir_addr;
         ;     881 	
         ;     882 	if (_FF_DIR_ADDR != _FF_ROOT_ADDR)
         ;	valid_flag -> R16
         ;	attribute_temp -> R17
         ;	c -> R18,R19
         ;	n -> R20,R21
         ;	d -> Y+22
         ;	m -> Y+20
         ;	dir_clus -> Y+18
         ;	calc -> Y+14
         ;	calc_clus -> Y+10
         ;	dir_addr -> Y+6
         ;     883 	{
         ;     884 		dir_clus = addr_to_clust(_FF_DIR_ADDR);
         ;     885 		if (dir_clus == 0)
         ;     886 			return;
         ;     887 	}
         ;     888 
         ;     889 	printf("\r\nFile Listing for:  ROOT\\");
         ;     890 	for (d=0; d<_FF_PATH_LENGTH; d++)
         ;     891 	{
         ;     892 		if (_FF_FULL_PATH[d])
         ;     893 			putchar(_FF_FULL_PATH[d]);
         ;     894 		else
         ;     895 			break;
         ;     896 	}
         ;     897 	
         ;     898     
         ;     899     dir_addr = _FF_DIR_ADDR;
         ;     900 	d = 0;
         ;     901 	m = 0;
         ;     902 	while (d<BPB_RootEntCnt)
         ;     903 	{
         ;     904     	if (_FF_read(dir_addr+(m*0x200))==0)
         ;     905     		break;
         ;     906 		for (n=0; n<16; n++)
         ;     907 		{
         ;     908 			for (c=0; c<11; c++)
         ;     909 			{
         ;     910 				if (_FF_buff[(n*0x20)]==0)
         ;     911 				{
         ;     912 					n=16;
         ;     913 					d=BPB_RootEntCnt;
         ;     914 					valid_flag = 0;
         ;     915 					break;
         ;     916 				}
         ;     917 				valid_flag = 1;
         ;     918 				if (valid_file_char(_FF_buff[(n*0x20)+c]))
         ;     919 				{
         ;     920 					valid_flag = 0;
         ;     921 					break;
         ;     922 				}
         ;     923 		    }   
         ;     924 		    if (valid_flag)
         ;     925 	  		{
         ;     926 		  		calc = (n * 0x20) + 0xB;
         ;     927 		  		attribute_temp = _FF_buff[calc];
         ;     928 		  		putchar('\n');
         ;     929 				putchar('\r');
         ;     930 				c = (n * 0x20);
         ;     931 			  	calc = ((long) _FF_buff[c+0x1F] << 24) | ((long) _FF_buff[c+0x1E] << 16) |
         ;     932 			  			((long) _FF_buff[c+0x1D] << 8) | ((long) _FF_buff[c+0x1C]);
         ;     933 			  	calc_clus = ((int) _FF_buff[c+0x1B] << 8) | (int) _FF_buff[c+0x1A];
         ;     934 				if (attribute_temp & 0x10)
         ;     935 					printf("  [");
         ;     936 				else
         ;     937 			  		printf("                [%ld] bytes      (%X)\r  ", calc, calc_clus);		  		
         ;     938 				for (c=0; c<8; c++)
         ;     939 				{
         ;     940 					calc = (n * 0x20) + c;
         ;     941 					if (_FF_buff[calc]==0x20)
         ;     942 						break;
         ;     943 					putchar(_FF_buff[calc]);
         ;     944 				}
         ;     945 				if (attribute_temp & 0x10)
         ;     946 				{
         ;     947 					printf("]      (%X)", calc_clus);
         ;     948 				}
         ;     949 				else
         ;     950 				{
         ;     951 					putchar('.');
         ;     952 					for (c=8; c<11; c++)
         ;     953 					{
         ;     954 						calc = (n * 0x20) + c;
         ;     955 						if (_FF_buff[calc]==0x20)
         ;     956 							break;
         ;     957 						putchar(_FF_buff[calc]);
         ;     958 					}
         ;     959 				}
         ;     960 		  	}
         ;     961 		  	d++;		  		
         ;     962 		}
         ;     963 		m++;
         ;     964 		if (_FF_ROOT_ADDR!=_FF_DIR_ADDR)
         ;     965 		{
         ;     966 		   	if (m==BPB_SecPerClus)
         ;     967 		   	{
         ;     968 
         ;     969 				m = next_cluster(dir_clus, SINGLE);
         ;     970 				if (m != EOF)
         ;     971 				{	// another dir cluster exists
         ;     972 					dir_addr = clust_to_addr(m);
         ;     973 					dir_clus = m;
         ;     974 					d = 0;
         ;     975 					m = 0;
         ;     976 				}
         ;     977 				else
         ;     978 					break;
         ;     979 		   		
         ;     980 		   	}
         ;     981 		}
         ;     982 	}
         ;     983 	putchar('\n');
         ;     984 	putchar('\r');	
         ;     985 } 
         ;     986 
         ;     987 void GetVolID(void)
         ;     988 {
         ;     989 	printf("\r\n  Volume Serial:  [0x%lX]", BS_VolSerial);
         ;     990 	printf("\r\n  Volume Label:  [%s]\r\n", BS_VolLab);
         ;     991 }
         ;     992 #endif
         ;     993 
         ;     994 // Convert a cluster number into a read address
         ;     995 unsigned long clust_to_addr(unsigned int clust_no)
         ;     996 {
          _clust_to_addr:
         ;     997 	unsigned long clust_addr;
         ;     998 	
         ;     999 	FirstSectorofCluster = ((clust_no - 2) * (long) BPB_SecPerClus) + (long) FirstDataSector;
000a53 9724      	SBIW R28,4
         ;	clust_no -> Y+4
         ;	clust_addr -> Y+0
000a54 81ac      	LDD  R26,Y+4
000a55 81bd      	LDD  R27,Y+4+1
000a56 9712      	SBIW R26,2
000a57 2de8      	MOV  R30,R8
000a58 27ff      	CLR  R31
000a59 2766      	CLR  R22
000a5a 2777      	CLR  R23
000a5b 2788      	CLR  R24
000a5c 2799      	CLR  R25
000a5d 940e 2241 	CALL __MULD12U
000a5f 01df      	MOVW R26,R30
000a60 01cb      	MOVW R24,R22
000a61 91e0 0736 	LDS  R30,_FirstDataSector
000a63 91f0 0737 	LDS  R31,_FirstDataSector+1
000a65 2766      	CLR  R22
000a66 2777      	CLR  R23
000a67 940e 21de 	CALL __ADDD12
000a69 93e0 0738 	STS  _FirstSectorofCluster,R30
000a6b 93f0 0739 	STS  _FirstSectorofCluster+1,R31
000a6d 9360 073a 	STS  _FirstSectorofCluster+2,R22
000a6f 9370 073b 	STS  _FirstSectorofCluster+3,R23
         ;    1000 	clust_addr = (long) FirstSectorofCluster * (long) BPB_BytsPerSec + _FF_PART_ADDR;
000a71   +  	__GETW1R 6,7
000a73 2766      	CLR  R22
000a74 2777      	CLR  R23
000a75 91a0 0738 	LDS  R26,_FirstSectorofCluster
000a77 91b0 0739 	LDS  R27,_FirstSectorofCluster+1
000a79 9180 073a 	LDS  R24,_FirstSectorofCluster+2
000a7b 9190 073b 	LDS  R25,_FirstSectorofCluster+3
000a7d 940e 1d94 	CALL SUBOPT_0x27
000a7f   +  	__PUTD1S 0
         ;    1001 
         ;    1002 	return (clust_addr);
000a83 9626      	ADIW R28,6
000a84 9508      	RET
         ;    1003 }
         ;    1004 
         ;    1005 // Converts an address into a cluster number
         ;    1006 unsigned int addr_to_clust(unsigned long clus_addr)
         ;    1007 {
          _addr_to_clust:
         ;    1008 	if (clus_addr <= _FF_PART_ADDR)
000a85 91e0 071e 	LDS  R30,__FF_PART_ADDR
000a87 91f0 071f 	LDS  R31,__FF_PART_ADDR+1
000a89 9160 0720 	LDS  R22,__FF_PART_ADDR+2
000a8b 9170 0721 	LDS  R23,__FF_PART_ADDR+3
000a8d   +  	__GETD2S 0
000a91 940e 22fa 	CALL __CPD12
000a93 f018      	BRLO _0xDD
         ;    1009 		return (0);
000a94 e0e0      	LDI  R30,LOW(0)
000a95 e0f0      	LDI  R31,HIGH(0)
000a96 c064      	RJMP _0x3E9
         ;    1010 	clus_addr -= _FF_PART_ADDR;
          _0xDD:
000a97 91a0 071e 	LDS  R26,__FF_PART_ADDR
000a99 91b0 071f 	LDS  R27,__FF_PART_ADDR+1
000a9b 9180 0720 	LDS  R24,__FF_PART_ADDR+2
000a9d 9190 0721 	LDS  R25,__FF_PART_ADDR+3
000a9f   +  	__GETD1S 0
000aa3 940e 21e8 	CALL __SUBD12
000aa5   +  	__PUTD1S 0
         ;    1011 	clus_addr /= BPB_BytsPerSec;
000aa9   +  	__GETW1R 6,7
000aab   +  	__GETD2S 0
000aaf 2766      	CLR  R22
000ab0 2777      	CLR  R23
000ab1 940e 2279 	CALL __DIVD21U
000ab3   +  	__PUTD1S 0
         ;    1012 	if (clus_addr <= (unsigned long) FirstDataSector)
000ab7 91e0 0736 	LDS  R30,_FirstDataSector
000ab9 91f0 0737 	LDS  R31,_FirstDataSector+1
000abb 2766      	CLR  R22
000abc 2777      	CLR  R23
000abd   +  	__GETD2S 0
000ac1 940e 22fa 	CALL __CPD12
000ac3 f018      	BRLO _0xDE
         ;    1013 		return (0);
000ac4 e0e0      	LDI  R30,LOW(0)
000ac5 e0f0      	LDI  R31,HIGH(0)
000ac6 c034      	RJMP _0x3E9
         ;    1014 	clus_addr -= FirstDataSector;
          _0xDE:
000ac7 91e0 0736 	LDS  R30,_FirstDataSector
000ac9 91f0 0737 	LDS  R31,_FirstDataSector+1
000acb   +  	__GETD2S 0
000acf 940e 1ced 	CALL SUBOPT_0x14
000ad1   +  	__PUTD1S 0
         ;    1015 	clus_addr /= BPB_SecPerClus;
000ad5 2de8      	MOV  R30,R8
000ad6   +  	__GETD2S 0
000ada 27ff      	CLR  R31
000adb 2766      	CLR  R22
000adc 2777      	CLR  R23
000add 940e 2279 	CALL __DIVD21U
000adf   +  	__PUTD1S 0
         ;    1016 	clus_addr += 2;
000ae3   +  	__ADDD1N 2
000ae7   +  	__PUTD1S 0
         ;    1017 	if (clus_addr > 0xFFFF)
000aeb   +  	__GETD2S 0
000aef   +  	__GETD1N 0xFFFF
000af3 940e 22fa 	CALL __CPD12
000af5 f418      	BRSH _0xDF
         ;    1018 		return (0);
000af6 e0e0      	LDI  R30,LOW(0)
000af7 e0f0      	LDI  R31,HIGH(0)
000af8 c002      	RJMP _0x3E9
         ;    1019 	
         ;    1020 	return ((int) clus_addr);	
          _0xDF:
000af9 81e8      	LD   R30,Y
000afa 81f9      	LDD  R31,Y+1
          _0x3E9:
000afb 9624      	ADIW R28,4
000afc 9508      	RET
         ;    1021 }
         ;    1022 
         ;    1023 // Find the cluster that the current cluster is pointing to
         ;    1024 unsigned int next_cluster(unsigned int current_cluster, unsigned char mode)
         ;    1025 {
          _next_cluster:
         ;    1026 	unsigned int calc_sec, calc_offset, calc_remainder, next_clust;
         ;    1027 	unsigned long addr_temp;
         ;    1028 	
         ;    1029 	if (current_cluster<=1)		// If cluster is 0 or 1, its the wrong cluster
000afd 9726      	SBIW R28,6
000afe 940e 2304 	CALL __SAVELOCR6
         ;	current_cluster -> Y+13
         ;	mode -> Y+12
         ;	calc_sec -> R16,R17
         ;	calc_offset -> R18,R19
         ;	calc_remainder -> R20,R21
         ;	next_clust -> Y+10
         ;	addr_temp -> Y+6
000b00 85ad      	LDD  R26,Y+13
000b01 85be      	LDD  R27,Y+13+1
000b02 e0e1      	LDI  R30,LOW(1)
000b03 e0f0      	LDI  R31,HIGH(1)
000b04 17ea      	CP   R30,R26
000b05 07fb      	CPC  R31,R27
000b06 f018      	BRLO _0xE0
         ;    1030 		return (EOF);
000b07 efef      	LDI  R30,LOW(65535)
000b08 efff      	LDI  R31,HIGH(65535)
000b09 c117      	RJMP _0x3E8
         ;    1031 		
         ;    1032 	if (BPB_FATType == 0x36)		// if FAT16
          _0xE0:
000b0a e3e6      	LDI  R30,LOW(54)
000b0b 15ee      	CP   R30,R14
000b0c f011      	BREQ PC+3
000b0d 940c 0b61 	JMP _0xE1
         ;    1033 	{
         ;    1034 		// FAT16 table address calculations
         ;    1035 		calc_sec = current_cluster / (BPB_BytsPerSec / 2) + BPB_RsvdSecCnt;
000b0f 940e 1da1 	CALL SUBOPT_0x28
000b11 940e 1da8 	CALL SUBOPT_0x29
         ;    1036 		calc_offset = 2 * (current_cluster % (BPB_BytsPerSec / 2));
000b13 940e 1da1 	CALL SUBOPT_0x28
000b15 940e 1daf 	CALL SUBOPT_0x2A
         ;    1037 	    
         ;    1038 	 	addr_temp = _FF_PART_ADDR+(calc_sec*0x200);
000b17 940e 1db8 	CALL SUBOPT_0x2B
         ;    1039 		if (mode==SINGLE)
000b19 30a1      	CPI  R26,LOW(0x1)
000b1a f459      	BRNE _0xE2
         ;    1040 		{	// This is a single cluster lookup
         ;    1041 			if (_FF_read(addr_temp)==0)
000b1b   +  	__GETD1S 6
000b1f 940e 1cae 	CALL SUBOPT_0xC
000b21 f419      	BRNE _0xE3
         ;    1042 				return(EOF);
000b22 efef      	LDI  R30,LOW(65535)
000b23 efff      	LDI  R31,HIGH(65535)
000b24 c0fc      	RJMP _0x3E8
         ;    1043 		}
          _0xE3:
         ;    1044 		else if ((mode==CHAIN) || (mode==END_CHAIN))
000b25 c02c      	RJMP _0xE4
          _0xE2:
000b26 85ac      	LDD  R26,Y+12
000b27 30a0      	CPI  R26,LOW(0x0)
000b28 f011      	BREQ _0xE6
000b29 30a2      	CPI  R26,LOW(0x2)
000b2a f539      	BRNE _0xE5
          _0xE6:
         ;    1045 		{	// Mupltiple clusters to lookup
         ;    1046 			if (addr_temp!=_FF_buff_addr)
000b2b 940e 1dce 	CALL SUBOPT_0x2C
000b2d f121      	BREQ _0xE8
         ;    1047 			{	// Is the address of lookup is different then the current buffere address
         ;    1048 				#ifndef _READ_ONLY_
         ;    1049 				if (_FF_buff_addr)	// if the buffer address is 0, don't write
000b2e 91e0 073d 	LDS  R30,__FF_buff_addr
000b30 91f0 073e 	LDS  R31,__FF_buff_addr+1
000b32 9160 073f 	LDS  R22,__FF_buff_addr+2
000b34 9170 0740 	LDS  R23,__FF_buff_addr+3
000b36 940e 22e8 	CALL __CPD10
000b38 f079      	BREQ _0xE9
         ;    1050 				{
         ;    1051 					#ifdef _SECOND_FAT_ON_
         ;    1052 						if (_FF_buff_addr < _FF_FAT2_ADDR)
000b39 940e 1ddd 	CALL SUBOPT_0x2D
000b3b f430      	BRSH _0xEA
         ;    1053 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000b3c 940e 1df0 	CALL SUBOPT_0x2E
000b3e f419      	BRNE _0xEB
         ;    1054 								return(EOF);
000b3f efef      	LDI  R30,LOW(65535)
000b40 efff      	LDI  R31,HIGH(65535)
000b41 c0df      	RJMP _0x3E8
         ;    1055 					#endif
         ;    1056 					if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
          _0xEB:
          _0xEA:
000b42 940e 1e12 	CALL SUBOPT_0x2F
000b44 f419      	BRNE _0xEC
         ;    1057 						return(EOF);
000b45 efef      	LDI  R30,LOW(65535)
000b46 efff      	LDI  R31,HIGH(65535)
000b47 c0d9      	RJMP _0x3E8
         ;    1058 				}
          _0xEC:
         ;    1059 				#endif
         ;    1060 				if (_FF_read(addr_temp)==0)	// Read new table info
          _0xE9:
000b48   +  	__GETD1S 6
000b4c 940e 1cae 	CALL SUBOPT_0xC
000b4e f419      	BRNE _0xED
         ;    1061 					return(EOF);
000b4f efef      	LDI  R30,LOW(65535)
000b50 efff      	LDI  R31,HIGH(65535)
000b51 c0cf      	RJMP _0x3E8
         ;    1062 			}
          _0xED:
         ;    1063 		}
          _0xE8:
         ;    1064 		next_clust = ((int) _FF_buff[calc_offset+1] << 8) | _FF_buff[calc_offset];
          _0xE5:
          _0xE4:
000b52 940e 1e20 	CALL SUBOPT_0x30
000b54 e0e0      	LDI  R30,LOW(0)
000b55 93ff      	PUSH R31
000b56 93ef      	PUSH R30
000b57 940e 1e27 	CALL SUBOPT_0x31
000b59 91af      	POP  R26
000b5a 91bf      	POP  R27
000b5b e0f0      	LDI  R31,0
000b5c 2bea      	OR   R30,R26
000b5d 2bfb      	OR   R31,R27
000b5e 87ea      	STD  Y+10,R30
000b5f 87fb      	STD  Y+10+1,R31
         ;    1065 	}
         ;    1066 	#ifdef _FAT12_ON_
         ;    1067 	else if (BPB_FATType == 0x32)	// if FAT12
000b60 c0be      	RJMP _0xEE
          _0xE1:
000b61 e3e2      	LDI  R30,LOW(50)
000b62 15ee      	CP   R30,R14
000b63 f011      	BREQ PC+3
000b64 940c 0c1c 	JMP _0xEF
         ;    1068 	{
         ;    1069 		// FAT12 table address calculations
         ;    1070 		calc_offset = (current_cluster * 3) / 2;
000b66 940e 1e2d 	CALL SUBOPT_0x32
000b68 95f6      	LSR  R31
000b69 95e7      	ROR  R30
000b6a   +  	__PUTW1R 18,19
         ;    1071 		calc_remainder = (current_cluster * 3) % 2;
000b6c 940e 1e2d 	CALL SUBOPT_0x32
000b6e 70e1      	ANDI R30,LOW(0x1)
000b6f 70f0      	ANDI R31,HIGH(0x1)
000b70   +  	__PUTW1R 20,21
         ;    1072 		calc_sec = (calc_offset / BPB_BytsPerSec) + BPB_RsvdSecCnt;
000b72 940e 1e34 	CALL SUBOPT_0x33
         ;    1073 		calc_offset %= BPB_BytsPerSec;
000b74 940e 1e39 	CALL SUBOPT_0x34
         ;    1074 
         ;    1075 	 	addr_temp = _FF_PART_ADDR+(calc_sec*BPB_BytsPerSec);
000b76   +  	__GETW1R 6,7
000b78   +  	__GETW2R 16,17
000b7a 940e 2239 	CALL __MULW12U
000b7c 91a0 071e 	LDS  R26,__FF_PART_ADDR
000b7e 91b0 071f 	LDS  R27,__FF_PART_ADDR+1
000b80 9180 0720 	LDS  R24,__FF_PART_ADDR+2
000b82 9190 0721 	LDS  R25,__FF_PART_ADDR+3
000b84 2766      	CLR  R22
000b85 2777      	CLR  R23
000b86 940e 21de 	CALL __ADDD12
000b88   +  	__PUTD1S 6
         ;    1076 		if (mode==SINGLE)
000b8c 85ac      	LDD  R26,Y+12
000b8d 30a1      	CPI  R26,LOW(0x1)
000b8e f439      	BRNE _0xF0
         ;    1077 		{	// This is a single cluster lookup
         ;    1078 			if (_FF_read(addr_temp)==0)
000b8f 940e 1cae 	CALL SUBOPT_0xC
000b91 f419      	BRNE _0xF1
         ;    1079 				return(EOF);
000b92 efef      	LDI  R30,LOW(65535)
000b93 efff      	LDI  R31,HIGH(65535)
000b94 c08c      	RJMP _0x3E8
         ;    1080 		}
          _0xF1:
         ;    1081 		else if ((mode==CHAIN) || (mode==END_CHAIN))
000b95 c02c      	RJMP _0xF2
          _0xF0:
000b96 85ac      	LDD  R26,Y+12
000b97 30a0      	CPI  R26,LOW(0x0)
000b98 f011      	BREQ _0xF4
000b99 30a2      	CPI  R26,LOW(0x2)
000b9a f539      	BRNE _0xF3
          _0xF4:
         ;    1082 		{	// Mupltiple clusters to lookup
         ;    1083 			if (addr_temp!=_FF_buff_addr)
000b9b 940e 1dce 	CALL SUBOPT_0x2C
000b9d f121      	BREQ _0xF6
         ;    1084 			{	// Is the address of lookup is different then the current buffere address
         ;    1085 				#ifndef _READ_ONLY_
         ;    1086 				if (_FF_buff_addr)	// if the buffer address is 0, don't write
000b9e 91e0 073d 	LDS  R30,__FF_buff_addr
000ba0 91f0 073e 	LDS  R31,__FF_buff_addr+1
000ba2 9160 073f 	LDS  R22,__FF_buff_addr+2
000ba4 9170 0740 	LDS  R23,__FF_buff_addr+3
000ba6 940e 22e8 	CALL __CPD10
000ba8 f079      	BREQ _0xF7
         ;    1087 				{
         ;    1088 					#ifdef _SECOND_FAT_ON_
         ;    1089 						if (_FF_buff_addr < _FF_FAT2_ADDR)
000ba9 940e 1ddd 	CALL SUBOPT_0x2D
000bab f430      	BRSH _0xF8
         ;    1090 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000bac 940e 1df0 	CALL SUBOPT_0x2E
000bae f419      	BRNE _0xF9
         ;    1091 								return(EOF);
000baf efef      	LDI  R30,LOW(65535)
000bb0 efff      	LDI  R31,HIGH(65535)
000bb1 c06f      	RJMP _0x3E8
         ;    1092 					#endif
         ;    1093 					if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
          _0xF9:
          _0xF8:
000bb2 940e 1e12 	CALL SUBOPT_0x2F
000bb4 f419      	BRNE _0xFA
         ;    1094 						return(EOF);
000bb5 efef      	LDI  R30,LOW(65535)
000bb6 efff      	LDI  R31,HIGH(65535)
000bb7 c069      	RJMP _0x3E8
         ;    1095 				}
          _0xFA:
         ;    1096 				#endif
         ;    1097 				if (_FF_read(addr_temp)==0)	// Read new table info
          _0xF7:
000bb8   +  	__GETD1S 6
000bbc 940e 1cae 	CALL SUBOPT_0xC
000bbe f419      	BRNE _0xFB
         ;    1098 					return(EOF);
000bbf efef      	LDI  R30,LOW(65535)
000bc0 efff      	LDI  R31,HIGH(65535)
000bc1 c05f      	RJMP _0x3E8
         ;    1099 			}
          _0xFB:
         ;    1100 		}
          _0xF6:
         ;    1101 		next_clust = _FF_buff[calc_offset];
          _0xF3:
          _0xF2:
000bc2 940e 1e27 	CALL SUBOPT_0x31
000bc4 e0f0      	LDI  R31,0
000bc5 87ea      	STD  Y+10,R30
000bc6 87fb      	STD  Y+10+1,R31
         ;    1102 		if (calc_offset == (BPB_BytsPerSec-1))
000bc7 940e 1e42 	CALL SUBOPT_0x35
000bc9 f591      	BRNE _0xFC
         ;    1103 		{	// Is the FAT12 record accross more than one sector?
         ;    1104 			addr_temp = _FF_PART_ADDR+((calc_sec+1)*0x200);
000bca   +  	__GETW1R 16,17
000bcc 9631      	ADIW R30,1
000bcd 940e 1db8 	CALL SUBOPT_0x2B
         ;    1105 			if ((mode==CHAIN) || (mode==END_CHAIN))
000bcf 30a0      	CPI  R26,LOW(0x0)
000bd0 f019      	BREQ _0xFE
000bd1 85ac      	LDD  R26,Y+12
000bd2 30a2      	CPI  R26,LOW(0x2)
000bd3 f4d9      	BRNE _0xFD
          _0xFE:
         ;    1106 			{	// multiple chain lookup
         ;    1107 				#ifndef _READ_ONLY_
         ;    1108 					#ifdef _SECOND_FAT_ON_
         ;    1109 						if (_FF_buff_addr < _FF_FAT2_ADDR)
000bd4 940e 1ddd 	CALL SUBOPT_0x2D
000bd6 f430      	BRSH _0x100
         ;    1110 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000bd7 940e 1df0 	CALL SUBOPT_0x2E
000bd9 f419      	BRNE _0x101
         ;    1111 								return(EOF);
000bda efef      	LDI  R30,LOW(65535)
000bdb efff      	LDI  R31,HIGH(65535)
000bdc c044      	RJMP _0x3E8
         ;    1112 					#endif
         ;    1113 				if (_FF_write(_FF_buff_addr)==0)	// Save buffer data to card
          _0x101:
          _0x100:
000bdd 940e 1e12 	CALL SUBOPT_0x2F
000bdf f419      	BRNE _0x102
         ;    1114 					return(EOF);
000be0 efef      	LDI  R30,LOW(65535)
000be1 efff      	LDI  R31,HIGH(65535)
000be2 c03e      	RJMP _0x3E8
         ;    1115 				#endif
         ;    1116 				_FF_buff_addr = addr_temp;		// Save new buffer address
          _0x102:
000be3   +  	__GETD1S 6
000be7 93e0 073d 	STS  __FF_buff_addr,R30
000be9 93f0 073e 	STS  __FF_buff_addr+1,R31
000beb 9360 073f 	STS  __FF_buff_addr+2,R22
000bed 9370 0740 	STS  __FF_buff_addr+3,R23
         ;    1117 			}
         ;    1118 			if (_FF_read(addr_temp)==0)
          _0xFD:
000bef   +  	__GETD1S 6
000bf3 940e 1cae 	CALL SUBOPT_0xC
000bf5 f419      	BRNE _0x103
         ;    1119 				return(EOF);
000bf6 efef      	LDI  R30,LOW(65535)
000bf7 efff      	LDI  R31,HIGH(65535)
000bf8 c028      	RJMP _0x3E8
         ;    1120 			next_clust |= ((int) _FF_buff[0] << 8);
          _0x103:
000bf9 91f0 0504 	LDS  R31,__FF_buff
000bfb c002      	RJMP _0x3F2
         ;    1121 		}
         ;    1122 		else
          _0xFC:
         ;    1123 			next_clust |= ((int) _FF_buff[calc_offset+1] << 8);
000bfc 940e 1e20 	CALL SUBOPT_0x30
          _0x3F2:
000bfe e0e0      	LDI  R30,LOW(0)
000bff 85aa      	LDD  R26,Y+10
000c00 85bb      	LDD  R27,Y+10+1
000c01 2bea      	OR   R30,R26
000c02 2bfb      	OR   R31,R27
000c03 87ea      	STD  Y+10,R30
000c04 87fb      	STD  Y+10+1,R31
         ;    1124 
         ;    1125 		if (calc_remainder)
000c05 2e04      	MOV  R0,R20
000c06 2a05      	OR   R0,R21
000c07 f019      	BREQ _0x105
         ;    1126 			next_clust >>= 4;
000c08 940e 221c 	CALL __LSRW4
000c0a c003      	RJMP _0x3F3
         ;    1127 		else
          _0x105:
         ;    1128 			next_clust &= 0x0FFF;
000c0b 85ea      	LDD  R30,Y+10
000c0c 85fb      	LDD  R31,Y+10+1
000c0d 70ff      	ANDI R31,HIGH(0xFFF)
          _0x3F3:
000c0e 87ea      	STD  Y+10,R30
000c0f 87fb      	STD  Y+10+1,R31
         ;    1129 			
         ;    1130 		if (next_clust >= 0xFF8)
000c10 85aa      	LDD  R26,Y+10
000c11 85bb      	LDD  R27,Y+10+1
000c12 3fa8      	CPI  R26,LOW(0xFF8)
000c13 e0ef      	LDI  R30,HIGH(0xFF8)
000c14 07be      	CPC  R27,R30
000c15 f028      	BRLO _0x107
         ;    1131 			next_clust |= 0xF000;			
000c16 85ea      	LDD  R30,Y+10
000c17 85fb      	LDD  R31,Y+10+1
000c18 6ff0      	ORI  R31,HIGH(0xF000)
000c19 87ea      	STD  Y+10,R30
000c1a 87fb      	STD  Y+10+1,R31
         ;    1132 	}
          _0x107:
         ;    1133 	#endif
         ;    1134 	else		// not FAT12 or FAT16, return 0
000c1b c003      	RJMP _0x108
          _0xEF:
         ;    1135 		return (EOF);
000c1c efef      	LDI  R30,LOW(65535)
000c1d efff      	LDI  R31,HIGH(65535)
000c1e c002      	RJMP _0x3E8
         ;    1136 	return (next_clust);
          _0x108:
          _0xEE:
000c1f 85ea      	LDD  R30,Y+10
000c20 85fb      	LDD  R31,Y+10+1
          _0x3E8:
000c21 940e 230b 	CALL __LOADLOCR6
000c23 962f      	ADIW R28,15
000c24 9508      	RET
         ;    1137 }
         ;    1138 
         ;    1139 // Convert a constant string file name into the proper 8.3 FAT format
         ;    1140 unsigned char *file_name_conversion(unsigned char *current_file)
         ;    1141 {
          _file_name_conversion:
         ;    1142 	unsigned char n, c;
         ;    1143 		
         ;    1144 	c = 0;
000c25 931a      	ST   -Y,R17
000c26 930a      	ST   -Y,R16
         ;	*current_file -> Y+2
         ;	n -> R16
         ;	c -> R17
000c27 e010      	LDI  R17,LOW(0)
         ;    1145 	
         ;    1146 	for (n=0; n<14; n++)
000c28 e000      	LDI  R16,LOW(0)
          _0x10A:
000c29 300e      	CPI  R16,14
000c2a f5c0      	BRSH _0x10B
         ;    1147 	{
         ;    1148 		if (valid_file_char(current_file[n])==0)
000c2b 940e 1e48 	CALL SUBOPT_0x36
000c2d 940e 1d25 	CALL SUBOPT_0x1B
000c2f f479      	BRNE _0x10C
         ;    1149 			// If the character is valid, save in uppercase to file name buffer
         ;    1150 			FILENAME[c++] = toupper(current_file[n]);
000c30 2fe1      	MOV  R30,R17
000c31 5f1f      	SUBI R17,-1
000c32 e0f0      	LDI  R31,0
000c33 54e6      	SUBI R30,LOW(-_FILENAME)
000c34 4ff8      	SBCI R31,HIGH(-_FILENAME)
000c35 93ff      	PUSH R31
000c36 93ef      	PUSH R30
000c37 940e 1e48 	CALL SUBOPT_0x36
000c39 940e 1e4f 	CALL SUBOPT_0x37
000c3b 91af      	POP  R26
000c3c 91bf      	POP  R27
000c3d 93ec      	ST   X,R30
         ;    1151 		else if (current_file[n]=='.')
000c3e c020      	RJMP _0x10D
          _0x10C:
000c3f 940e 1e48 	CALL SUBOPT_0x36
000c41 91ac      	LD   R26,X
000c42 32ae      	CPI  R26,LOW(0x2E)
000c43 f441      	BRNE _0x10E
         ;    1152 			// If it is a period, back fill buffer with [spaces], till 8 characters deep
         ;    1153 			while (c<8)
          _0x10F:
000c44 3018      	CPI  R17,8
000c45 f428      	BRSH _0x111
         ;    1154 				FILENAME[c++] = 0x20;
000c46 2fe1      	MOV  R30,R17
000c47 5f1f      	SUBI R17,-1
000c48 940e 1e53 	CALL SUBOPT_0x38
         ;    1155 		else if (current_file[n]==0)
000c4a cff9      	RJMP _0x10F
          _0x111:
000c4b c013      	RJMP _0x112
          _0x10E:
000c4c 940e 1e48 	CALL SUBOPT_0x36
000c4e 91ec      	LD   R30,X
000c4f 30e0      	CPI  R30,0
000c50 f441      	BRNE _0x113
         ;    1156 		{	// If it is NULL, back fill buffer with [spaces], till 11 characters deep
         ;    1157 			while (c<11)
          _0x114:
000c51 301b      	CPI  R17,11
000c52 f428      	BRSH _0x116
         ;    1158 				FILENAME[c++] = 0x20;
000c53 2fe1      	MOV  R30,R17
000c54 5f1f      	SUBI R17,-1
000c55 940e 1e53 	CALL SUBOPT_0x38
         ;    1159 			break;
000c57 cff9      	RJMP _0x114
          _0x116:
000c58 c00a      	RJMP _0x10B
         ;    1160 		}
         ;    1161 		else
          _0x113:
         ;    1162 		{
         ;    1163 			_FF_error = NAME_ERR;
000c59 e0e5      	LDI  R30,LOW(5)
000c5a 93e0 073c 	STS  __FF_error,R30
         ;    1164 			return (0);
000c5c e0e0      	LDI  R30,LOW(0)
000c5d e0f0      	LDI  R31,HIGH(0)
000c5e c00c      	RJMP _0x3E7
         ;    1165 		}
          _0x112:
          _0x10D:
         ;    1166 		if (c>=11)
000c5f 301b      	CPI  R17,11
000c60 f410      	BRSH _0x10B
         ;    1167 			break;
         ;    1168 	}
000c61 5f0f      	SUBI R16,-1
000c62 cfc6      	RJMP _0x10A
          _0x10B:
         ;    1169 	FILENAME[c] = 0;
000c63 2fa1      	MOV  R26,R17
000c64 e0b0      	LDI  R27,0
000c65 54a6      	SUBI R26,LOW(-_FILENAME)
000c66 4fb8      	SBCI R27,HIGH(-_FILENAME)
000c67 e0e0      	LDI  R30,LOW(0)
000c68 93ec      	ST   X,R30
         ;    1170 	// Return the pointer of the filename
         ;    1171 	return (FILENAME);		
000c69 ebea      	LDI  R30,LOW(_FILENAME)
000c6a e0f7      	LDI  R31,HIGH(_FILENAME)
          _0x3E7:
000c6b 8119      	LDD  R17,Y+1
000c6c 8108      	LDD  R16,Y+0
000c6d 9624      	ADIW R28,4
000c6e 9508      	RET
         ;    1172 }
         ;    1173 
         ;    1174 // Find the first cluster that is pointing to clus_no
         ;    1175 unsigned int prev_cluster(unsigned int clus_no)
         ;    1176 {
          _prev_cluster:
         ;    1177 	unsigned char read_flag;
         ;    1178 	unsigned int calc_temp, n, c, n_temp;
         ;    1179 	unsigned long calc_clus, addr_temp;
         ;    1180 	
         ;    1181 	addr_temp = _FF_FAT1_ADDR;
000c6f 972c      	SBIW R28,12
000c70 940e 2305 	CALL __SAVELOCR5
         ;	clus_no -> Y+17
         ;	read_flag -> R16
         ;	calc_temp -> R17,R18
         ;	n -> R19,R20
         ;	c -> Y+15
         ;	n_temp -> Y+13
         ;	calc_clus -> Y+9
         ;	addr_temp -> Y+5
000c72 91e0 072a 	LDS  R30,__FF_FAT1_ADDR
000c74 91f0 072b 	LDS  R31,__FF_FAT1_ADDR+1
000c76 9160 072c 	LDS  R22,__FF_FAT1_ADDR+2
000c78 9170 072d 	LDS  R23,__FF_FAT1_ADDR+3
000c7a   +  	__PUTD1S 5
         ;    1182 	c = 1;
000c7e e0e1      	LDI  R30,LOW(1)
000c7f e0f0      	LDI  R31,HIGH(1)
000c80 87ef      	STD  Y+15,R30
000c81 8bf8      	STD  Y+15+1,R31
         ;    1183 	if ((clus_no==0) && (BPB_FATType==0x36))
000c82 89a9      	LDD  R26,Y+17
000c83 89ba      	LDD  R27,Y+17+1
000c84 940e 22ec 	CALL __CPW02
000c86 f419      	BRNE _0x11A
000c87 e3e6      	LDI  R30,LOW(54)
000c88 15ee      	CP   R30,R14
000c89 f009      	BREQ _0x11B
          _0x11A:
000c8a c021      	RJMP _0x119
          _0x11B:
         ;    1184 	{
         ;    1185 		if (clus_0_addr>addr_temp)
000c8b   +  	__GETD1S 5
000c8f 91a0 074c 	LDS  R26,_clus_0_addr
000c91 91b0 074d 	LDS  R27,_clus_0_addr+1
000c93 9180 074e 	LDS  R24,_clus_0_addr+2
000c95 9190 074f 	LDS  R25,_clus_0_addr+3
000c97 940e 22fa 	CALL __CPD12
000c99 f490      	BRSH _0x11C
         ;    1186 		{
         ;    1187 			addr_temp = clus_0_addr;
000c9a 91e0 074c 	LDS  R30,_clus_0_addr
000c9c 91f0 074d 	LDS  R31,_clus_0_addr+1
000c9e 9160 074e 	LDS  R22,_clus_0_addr+2
000ca0 9170 074f 	LDS  R23,_clus_0_addr+3
000ca2   +  	__PUTD1S 5
         ;    1188 			c = c_counter;
000ca6 91e0 0754 	LDS  R30,_c_counter
000ca8 91f0 0755 	LDS  R31,_c_counter+1
000caa 87ef      	STD  Y+15,R30
000cab 8bf8      	STD  Y+15+1,R31
         ;    1189 		}
         ;    1190 	}
          _0x11C:
         ;    1191 
         ;    1192 	read_flag = 1;
          _0x119:
000cac e001      	LDI  R16,LOW(1)
         ;    1193 	
         ;    1194 	while (addr_temp<_FF_FAT2_ADDR)
          _0x11D:
000cad 91e0 072e 	LDS  R30,__FF_FAT2_ADDR
000caf 91f0 072f 	LDS  R31,__FF_FAT2_ADDR+1
000cb1 9160 0730 	LDS  R22,__FF_FAT2_ADDR+2
000cb3 9170 0731 	LDS  R23,__FF_FAT2_ADDR+3
000cb5   +  	__GETD2S 5
000cb9 940e 22ff 	CALL __CPD21
000cbb f010      	BRLO PC+3
000cbc 940c 0e0d 	JMP _0x11F
         ;    1195 	{
         ;    1196 		if (BPB_FATType == 0x36)		// if FAT16
000cbe e3e6      	LDI  R30,LOW(54)
000cbf 15ee      	CP   R30,R14
000cc0 f011      	BREQ PC+3
000cc1 940c 0d76 	JMP _0x120
         ;    1197 		{
         ;    1198 			if (clus_no==0)
000cc3 89e9      	LDD  R30,Y+17
000cc4 89fa      	LDD  R31,Y+17+1
000cc5 9730      	SBIW R30,0
000cc6 f491      	BRNE _0x121
         ;    1199 			{
         ;    1200 				clus_0_addr = addr_temp;
000cc7   +  	__GETD1S 5
000ccb 93e0 074c 	STS  _clus_0_addr,R30
000ccd 93f0 074d 	STS  _clus_0_addr+1,R31
000ccf 9360 074e 	STS  _clus_0_addr+2,R22
000cd1 9370 074f 	STS  _clus_0_addr+3,R23
         ;    1201 				c_counter = c;
000cd3 85ef      	LDD  R30,Y+15
000cd4 89f8      	LDD  R31,Y+15+1
000cd5 93e0 0754 	STS  _c_counter,R30
000cd7 93f0 0755 	STS  _c_counter+1,R31
         ;    1202 			}
         ;    1203 			if (_FF_read(addr_temp)==0)		// Read error ==> break
          _0x121:
000cd9   +  	__GETD1S 5
000cdd 940e 1cae 	CALL SUBOPT_0xC
000cdf f419      	BRNE _0x122
         ;    1204 				return(0);
000ce0 e0e0      	LDI  R30,LOW(0)
000ce1 e0f0      	LDI  R31,HIGH(0)
000ce2 c12c      	RJMP _0x3E6
         ;    1205 			if (_FF_n_temp)
          _0x122:
000ce3 91e0 0750 	LDS  R30,__FF_n_temp
000ce5 91f0 0751 	LDS  R31,__FF_n_temp+1
000ce7 9160 0752 	LDS  R22,__FF_n_temp+2
000ce9 9170 0753 	LDS  R23,__FF_n_temp+3
000ceb 940e 22e8 	CALL __CPD10
000ced f081      	BREQ _0x123
         ;    1206 			{
         ;    1207 				n_temp = _FF_n_temp;
000cee 91e0 0750 	LDS  R30,__FF_n_temp
000cf0 91f0 0751 	LDS  R31,__FF_n_temp+1
000cf2 87ed      	STD  Y+13,R30
000cf3 87fe      	STD  Y+13+1,R31
         ;    1208 				_FF_n_temp = 0;
000cf4 e0e0      	LDI  R30,0
000cf5 93e0 0750 	STS  __FF_n_temp,R30
000cf7 93e0 0751 	STS  __FF_n_temp+1,R30
000cf9 93e0 0752 	STS  __FF_n_temp+2,R30
000cfb 93e0 0753 	STS  __FF_n_temp+3,R30
         ;    1209 			}
         ;    1210 			else
000cfd c003      	RJMP _0x124
          _0x123:
         ;    1211 				n_temp = 0;
000cfe e0e0      	LDI  R30,0
000cff 87ed      	STD  Y+13,R30
000d00 87ee      	STD  Y+13+1,R30
         ;    1212 			for (n=n_temp; n<(BPB_BytsPerSec/2); n++)
          _0x124:
000d01   +  	__GETWRS 19,20,13
          _0x126:
000d03   +  	__GETW1R 6,7
000d05 95f6      	LSR  R31
000d06 95e7      	ROR  R30
000d07 173e      	CP   R19,R30
000d08 074f      	CPC  R20,R31
000d09 f010      	BRLO PC+3
000d0a 940c 0d71 	JMP _0x127
         ;    1213 			{
         ;    1214 				calc_clus = ((unsigned int) _FF_buff[(n*2)+1] << 8) | ((unsigned int) _FF_buff[n*2]);
000d0c   +  	__GETW1R 19,20
000d0e 0fee      	LSL  R30
000d0f 1fff      	ROL  R31
000d10 9631      	ADIW R30,1
000d11 940e 1e5a 	CALL SUBOPT_0x39
000d13 01df      	MOVW R26,R30
000d14   +  	__GETW1R 19,20
000d16 0fee      	LSL  R30
000d17 1fff      	ROL  R31
000d18 5fec      	SUBI R30,LOW(-__FF_buff)
000d19 4ffa      	SBCI R31,HIGH(-__FF_buff)
000d1a 81e0      	LD   R30,Z
000d1b 940e 1cc6 	CALL SUBOPT_0xF
000d1d   +  	__PUTD1S 9
         ;    1215 				calc_temp = (unsigned long) n + (((unsigned long) BPB_BytsPerSec/2) * ((unsigned long) c - 1));
000d21   +  	__GETW1R 19,20
000d23 2766      	CLR  R22
000d24 2777      	CLR  R23
000d25 937f      	PUSH R23
000d26 936f      	PUSH R22
000d27 93ff      	PUSH R31
000d28 93ef      	PUSH R30
000d29   +  	__GETW1R 6,7
000d2b 2766      	CLR  R22
000d2c 2777      	CLR  R23
000d2d 940e 2225 	CALL __LSRD1
000d2f 01df      	MOVW R26,R30
000d30 01cb      	MOVW R24,R22
000d31 85ef      	LDD  R30,Y+15
000d32 89f8      	LDD  R31,Y+15+1
000d33 2766      	CLR  R22
000d34 2777      	CLR  R23
000d35   +  	__SUBD1N 1
000d39 940e 2241 	CALL __MULD12U
000d3b 91af      	POP  R26
000d3c 91bf      	POP  R27
000d3d 918f      	POP  R24
000d3e 919f      	POP  R25
000d3f 940e 21de 	CALL __ADDD12
000d41   +  	__PUTW1R 17,18
         ;    1216 				if (calc_clus==clus_no)
000d43 940e 1e5f 	CALL SUBOPT_0x3A
000d45 f4b1      	BRNE _0x128
         ;    1217 				{
         ;    1218 					if (calc_clus==0)
000d46   +  	__GETD1S 9
000d4a 940e 22e8 	CALL __CPD10
000d4c f461      	BRNE _0x129
         ;    1219 						_FF_n_temp = n;
000d4d   +  	__GETW1R 19,20
000d4f 2766      	CLR  R22
000d50 2777      	CLR  R23
000d51 93e0 0750 	STS  __FF_n_temp,R30
000d53 93f0 0751 	STS  __FF_n_temp+1,R31
000d55 9360 0752 	STS  __FF_n_temp+2,R22
000d57 9370 0753 	STS  __FF_n_temp+3,R23
         ;    1220 					return(calc_temp);
          _0x129:
000d59   +  	__GETW1R 17,18
000d5b c0b3      	RJMP _0x3E6
         ;    1221 				}
         ;    1222 				else if (calc_temp > DataClusTot)
          _0x128:
000d5c 91e0 0741 	LDS  R30,_DataClusTot
000d5e 91f0 0742 	LDS  R31,_DataClusTot+1
000d60 9160 0743 	LDS  R22,_DataClusTot+2
000d62 9170 0744 	LDS  R23,_DataClusTot+3
000d64   +  	__GETW2R 17,18
000d66 2788      	CLR  R24
000d67 2799      	CLR  R25
000d68 940e 22fa 	CALL __CPD12
000d6a f418      	BRSH _0x12B
         ;    1223 				{
         ;    1224 					_FF_error = DISK_FULL;
000d6b 940e 1e6a 	CALL SUBOPT_0x3B
         ;    1225 					return (0);
000d6d c0a1      	RJMP _0x3E6
         ;    1226 				}
         ;    1227 			}
          _0x12B:
000d6e   +  	__ADDWRN 19,20,1
000d70 cf92      	RJMP _0x126
          _0x127:
         ;    1228 			addr_temp += 0x200;
000d71 940e 1e70 	CALL SUBOPT_0x3C
         ;    1229 			c++;
000d73 940e 1e7d 	CALL SUBOPT_0x3D
         ;    1230 		}
         ;    1231 		#ifdef _FAT12_ON_
         ;    1232 		else if (BPB_FATType == 0x32)	// if FAT12
000d75 c096      	RJMP _0x12C
          _0x120:
000d76 e3e2      	LDI  R30,LOW(50)
000d77 15ee      	CP   R30,R14
000d78 f011      	BREQ PC+3
000d79 940c 0e09 	JMP _0x12D
         ;    1233 		{
         ;    1234 			if (read_flag)
000d7b 3000      	CPI  R16,0
000d7c f059      	BREQ _0x12E
         ;    1235 			{
         ;    1236 				if (_FF_read(addr_temp)==0)
000d7d   +  	__GETD1S 5
000d81 940e 1cae 	CALL SUBOPT_0xC
000d83 f419      	BRNE _0x12F
         ;    1237 					return (0);	// if the read fails return 0
000d84 e0e0      	LDI  R30,LOW(0)
000d85 e0f0      	LDI  R31,HIGH(0)
000d86 c088      	RJMP _0x3E6
         ;    1238 				read_flag = 0;
          _0x12F:
000d87 e000      	LDI  R16,LOW(0)
         ;    1239 			}
         ;    1240 			calc_temp = ((unsigned long) c * 3) / 2;
          _0x12E:
000d88 85ef      	LDD  R30,Y+15
000d89 89f8      	LDD  R31,Y+15+1
000d8a 2766      	CLR  R22
000d8b 2777      	CLR  R23
000d8c   +  	__GETD2N 0x3
000d90 940e 2241 	CALL __MULD12U
000d92 940e 2225 	CALL __LSRD1
000d94   +  	__PUTW1R 17,18
         ;    1241 			calc_temp %= BPB_BytsPerSec;
000d96   +  	__GETW1R 6,7
000d98   +  	__GETW2R 17,18
000d9a 940e 22a4 	CALL __MODW21U
000d9c   +  	__PUTW1R 17,18
         ;    1242 			calc_clus = _FF_buff[calc_temp++];
000d9e   +  	__GETW1R 17,18
000da0   +  	__ADDWRN 17,18,1
000da2 5fec      	SUBI R30,LOW(-__FF_buff)
000da3 4ffa      	SBCI R31,HIGH(-__FF_buff)
000da4 81e0      	LD   R30,Z
000da5 27ff      	CLR  R31
000da6 2766      	CLR  R22
000da7 2777      	CLR  R23
000da8   +  	__PUTD1S 9
         ;    1243 			if (calc_temp == BPB_BytsPerSec)
000dac   +  	__CPWRR 6,7,17,18
000dae f4a1      	BRNE _0x130
         ;    1244 			{	// Is the FAT12 record accross a sector?
         ;    1245 				addr_temp += 0x200;
000daf 940e 1e70 	CALL SUBOPT_0x3C
         ;    1246 				if (_FF_read(addr_temp)==0)
000db1   +  	__GETD1S 5
000db5 940e 1cae 	CALL SUBOPT_0xC
000db7 f419      	BRNE _0x131
         ;    1247 					return (0);
000db8 e0e0      	LDI  R30,LOW(0)
000db9 e0f0      	LDI  R31,HIGH(0)
000dba c054      	RJMP _0x3E6
         ;    1248 				calc_clus |= ((unsigned int) _FF_buff[0] << 8);
          _0x131:
000dbb 91f0 0504 	LDS  R31,__FF_buff
000dbd e0e0      	LDI  R30,LOW(0)
000dbe 940e 1e83 	CALL SUBOPT_0x3E
         ;    1249 				calc_temp = 0;
000dc0   +  	__GETWRN 17,18,0
         ;    1250 			}
         ;    1251 			else
000dc2 c008      	RJMP _0x132
          _0x130:
         ;    1252 				calc_clus |= ((unsigned int) _FF_buff[calc_temp++] << 8);
000dc3   +  	__GETW1R 17,18
000dc5   +  	__ADDWRN 17,18,1
000dc7 940e 1e5a 	CALL SUBOPT_0x39
000dc9 940e 1e83 	CALL SUBOPT_0x3E
         ;    1253                           	
         ;    1254 			if (c % 2)
          _0x132:
000dcb 85ef      	LDD  R30,Y+15
000dcc 89f8      	LDD  R31,Y+15+1
000dcd 70e1      	ANDI R30,LOW(0x1)
000dce f041      	BREQ _0x133
         ;    1255 				calc_clus >>= 4;
000dcf   +  	__GETD2S 9
000dd3 e0e4      	LDI  R30,LOW(4)
000dd4 940e 2207 	CALL __LSRD12
000dd6 c008      	RJMP _0x3F4
         ;    1256 			else
          _0x133:
         ;    1257 				calc_clus &= 0x0FFF;
000dd7   +  	__GETD1S 9
000ddb   +  	__ANDD1N 0xFFF
          _0x3F4:
000ddf   +  	__PUTD1S 9
         ;    1258 			
         ;    1259 			if (calc_clus == clus_no)
000de3 940e 1e5f 	CALL SUBOPT_0x3A
000de5 f419      	BRNE _0x135
         ;    1260 				return (c);
000de6 85ef      	LDD  R30,Y+15
000de7 89f8      	LDD  R31,Y+15+1
000de8 c026      	RJMP _0x3E6
         ;    1261 			else if (c > DataClusTot)
          _0x135:
000de9 91e0 0741 	LDS  R30,_DataClusTot
000deb 91f0 0742 	LDS  R31,_DataClusTot+1
000ded 9160 0743 	LDS  R22,_DataClusTot+2
000def 9170 0744 	LDS  R23,_DataClusTot+3
000df1 85af      	LDD  R26,Y+15
000df2 89b8      	LDD  R27,Y+15+1
000df3 2788      	CLR  R24
000df4 2799      	CLR  R25
000df5 940e 22fa 	CALL __CPD12
000df7 f418      	BRSH _0x137
         ;    1262 			{
         ;    1263 				_FF_error = DISK_FULL;
000df8 940e 1e6a 	CALL SUBOPT_0x3B
         ;    1264 				return (0);
000dfa c014      	RJMP _0x3E6
         ;    1265 			}
         ;    1266 			if ((calc_temp == BPB_BytsPerSec) && (c % 2))
          _0x137:
000dfb   +  	__CPWRR 6,7,17,18
000dfd f421      	BRNE _0x139
000dfe 85ef      	LDD  R30,Y+15
000dff 89f8      	LDD  R31,Y+15+1
000e00 70e1      	ANDI R30,LOW(0x1)
000e01 f409      	BRNE _0x13A
          _0x139:
000e02 c003      	RJMP _0x138
          _0x13A:
         ;    1267 			{
         ;    1268 				addr_temp += 0x200;
000e03 940e 1e70 	CALL SUBOPT_0x3C
         ;    1269 				read_flag = 1;
000e05 e001      	LDI  R16,LOW(1)
         ;    1270 			}                                                           
         ;    1271 			
         ;    1272 			c++;			
          _0x138:
000e06 940e 1e7d 	CALL SUBOPT_0x3D
         ;    1273 		}
         ;    1274 		#endif
         ;    1275 		else
000e08 c003      	RJMP _0x13B
          _0x12D:
         ;    1276 			return (0);
000e09 e0e0      	LDI  R30,LOW(0)
000e0a e0f0      	LDI  R31,HIGH(0)
000e0b c003      	RJMP _0x3E6
         ;    1277 	}
          _0x13B:
          _0x12C:
000e0c cea0      	RJMP _0x11D
          _0x11F:
         ;    1278 	_FF_error = DISK_FULL;
000e0d 940e 1e6a 	CALL SUBOPT_0x3B
         ;    1279 	return (0);
          _0x3E6:
000e0f 940e 230c 	CALL __LOADLOCR5
000e11 9663      	ADIW R28,19
000e12 9508      	RET
         ;    1280 }
         ;    1281 
         ;    1282 #ifndef _READ_ONLY_
         ;    1283 // Update cluster table to point to new cluster
         ;    1284 unsigned char write_clus_table(unsigned int current_cluster, unsigned int next_value, unsigned char mode)
         ;    1285 {
          _write_clus_table:
         ;    1286 	unsigned long addr_temp;
         ;    1287 	unsigned int calc_sec, calc_offset, calc_temp, calc_remainder;
         ;    1288 	unsigned char nibble[3];
         ;    1289 	
         ;    1290 	if (current_cluster <=1)		// Should never be writing to cluster 0 or 1
000e13 9729      	SBIW R28,9
000e14 940e 2304 	CALL __SAVELOCR6
         ;	current_cluster -> Y+18
         ;	next_value -> Y+16
         ;	mode -> Y+15
         ;	addr_temp -> Y+11
         ;	calc_sec -> R16,R17
         ;	calc_offset -> R18,R19
         ;	calc_temp -> R20,R21
         ;	calc_remainder -> Y+9
         ;	nibble -> Y+6
000e16 89aa      	LDD  R26,Y+18
000e17 89bb      	LDD  R27,Y+18+1
000e18 e0e1      	LDI  R30,LOW(1)
000e19 e0f0      	LDI  R31,HIGH(1)
000e1a 17ea      	CP   R30,R26
000e1b 07fb      	CPC  R31,R27
000e1c f010      	BRLO _0x13C
         ;    1291 	{
         ;    1292 		return (0);
000e1d e0e0      	LDI  R30,LOW(0)
000e1e c18e      	RJMP _0x3E5
         ;    1293 	}
         ;    1294 	if (BPB_FATType == 0x36)		// if FAT16
          _0x13C:
000e1f e3e6      	LDI  R30,LOW(54)
000e20 15ee      	CP   R30,R14
000e21 f011      	BREQ PC+3
000e22 940c 0e88 	JMP _0x13D
         ;    1295 	{
         ;    1296 		calc_sec = current_cluster / (BPB_BytsPerSec / 2) + BPB_RsvdSecCnt;
000e24 940e 1e90 	CALL SUBOPT_0x3F
000e26 940e 1da8 	CALL SUBOPT_0x29
         ;    1297 		calc_offset = 2 * (current_cluster % (BPB_BytsPerSec / 2));
000e28 940e 1e90 	CALL SUBOPT_0x3F
000e2a 940e 1daf 	CALL SUBOPT_0x2A
         ;    1298 		addr_temp = _FF_PART_ADDR + ((long) calc_sec*0x200);
000e2c 2766      	CLR  R22
000e2d 2777      	CLR  R23
000e2e   +  	__GETD2N 0x200
000e32 940e 1d94 	CALL SUBOPT_0x27
000e34 940e 1e97 	CALL SUBOPT_0x40
         ;    1299 		if (mode==SINGLE)
000e36 f451      	BRNE _0x13E
         ;    1300 		{	// Updating a single cluster (like writing or saving a file)
         ;    1301 			if (_FF_read(addr_temp)==0)
000e37   +  	__GETD1S 11
000e3b 940e 1cae 	CALL SUBOPT_0xC
000e3d f411      	BRNE _0x13F
         ;    1302 				return(0);
000e3e e0e0      	LDI  R30,LOW(0)
000e3f c16d      	RJMP _0x3E5
         ;    1303 		}
          _0x13F:
         ;    1304 		else if ((mode==CHAIN) || (mode==END_CHAIN))
000e40 c029      	RJMP _0x140
          _0x13E:
000e41 85af      	LDD  R26,Y+15
000e42 30a0      	CPI  R26,LOW(0x0)
000e43 f011      	BREQ _0x142
000e44 30a2      	CPI  R26,LOW(0x2)
000e45 f521      	BRNE _0x141
          _0x142:
         ;    1305 		{	// Multiple table access operation
         ;    1306 			if (addr_temp!=_FF_buff_addr)
000e46 940e 1e9e 	CALL SUBOPT_0x41
000e48 f109      	BREQ _0x144
         ;    1307 			{	// if the desired address is already in the buffer => skip loading buffer
         ;    1308 				if (_FF_buff_addr)	// if new table address, write buffered, and load new
000e49 91e0 073d 	LDS  R30,__FF_buff_addr
000e4b 91f0 073e 	LDS  R31,__FF_buff_addr+1
000e4d 9160 073f 	LDS  R22,__FF_buff_addr+2
000e4f 9170 0740 	LDS  R23,__FF_buff_addr+3
000e51 940e 22e8 	CALL __CPD10
000e53 f069      	BREQ _0x145
         ;    1309 				{
         ;    1310 					#ifdef _SECOND_FAT_ON_
         ;    1311 						if (_FF_buff_addr < _FF_FAT2_ADDR)
000e54 940e 1ddd 	CALL SUBOPT_0x2D
000e56 f428      	BRSH _0x146
         ;    1312 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000e57 940e 1df0 	CALL SUBOPT_0x2E
000e59 f411      	BRNE _0x147
         ;    1313 								return(0);
000e5a e0e0      	LDI  R30,LOW(0)
000e5b c151      	RJMP _0x3E5
         ;    1314 					#endif
         ;    1315 					if (_FF_write(_FF_buff_addr)==0)
          _0x147:
          _0x146:
000e5c 940e 1e12 	CALL SUBOPT_0x2F
000e5e f411      	BRNE _0x148
         ;    1316 						return(0);
000e5f e0e0      	LDI  R30,LOW(0)
000e60 c14c      	RJMP _0x3E5
         ;    1317 				}
          _0x148:
         ;    1318 				if (_FF_read(addr_temp)==0)
          _0x145:
000e61   +  	__GETD1S 11
000e65 940e 1cae 	CALL SUBOPT_0xC
000e67 f411      	BRNE _0x149
         ;    1319 					return(0);
000e68 e0e0      	LDI  R30,LOW(0)
000e69 c143      	RJMP _0x3E5
         ;    1320 			}
          _0x149:
         ;    1321 		}
          _0x144:
         ;    1322 				
         ;    1323 		_FF_buff[calc_offset+1] = (next_value >> 8); 
          _0x141:
          _0x140:
000e6a 940e 1ead 	CALL SUBOPT_0x42
000e6c 01df      	MOVW R26,R30
000e6d 89e9      	LDD  R30,Y+17
000e6e 70f0      	ANDI R31,HIGH(0x0)
000e6f 93ec      	ST   X,R30
         ;    1324 		_FF_buff[calc_offset] = (next_value & 0xFF);
000e70   +  	__GETW2R 18,19
000e72 5fac      	SUBI R26,LOW(-__FF_buff)
000e73 4fba      	SBCI R27,HIGH(-__FF_buff)
000e74 89e8      	LDD  R30,Y+16
000e75 89f9      	LDD  R31,Y+16+1
000e76 70f0      	ANDI R31,HIGH(0xFF)
000e77 940e 1eb3 	CALL SUBOPT_0x43
         ;    1325 		if ((mode==SINGLE) || (mode==END_CHAIN))
000e79 f019      	BREQ _0x14B
000e7a 85af      	LDD  R26,Y+15
000e7b 30a2      	CPI  R26,LOW(0x2)
000e7c f451      	BRNE _0x14A
          _0x14B:
         ;    1326 		{
         ;    1327 			#ifdef _SECOND_FAT_ON_
         ;    1328 				if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000e7d 940e 1eb7 	CALL SUBOPT_0x44
000e7f f411      	BRNE _0x14D
         ;    1329 					return(0);
000e80 e0e0      	LDI  R30,LOW(0)
000e81 c12b      	RJMP _0x3E5
         ;    1330 			#endif
         ;    1331 			if (_FF_write(addr_temp)==0)
          _0x14D:
000e82 940e 1ed5 	CALL SUBOPT_0x45
000e84 f411      	BRNE _0x14E
         ;    1332 			{
         ;    1333 				return(0);
000e85 e0e0      	LDI  R30,LOW(0)
000e86 c126      	RJMP _0x3E5
         ;    1334 			}
         ;    1335 		}
          _0x14E:
         ;    1336 	}
          _0x14A:
         ;    1337 	#ifdef _FAT12_ON_
         ;    1338 		else if (BPB_FATType == 0x32)		// if FAT12
000e87 c124      	RJMP _0x14F
          _0x13D:
000e88 e3e2      	LDI  R30,LOW(50)
000e89 15ee      	CP   R30,R14
000e8a f011      	BREQ PC+3
000e8b 940c 0faa 	JMP _0x150
         ;    1339 		{
         ;    1340 			calc_offset = (current_cluster * 3) / 2;
000e8d 940e 1edf 	CALL SUBOPT_0x46
000e8f 95f6      	LSR  R31
000e90 95e7      	ROR  R30
000e91   +  	__PUTW1R 18,19
         ;    1341 			calc_remainder = (current_cluster * 3) % 2;
000e93 940e 1edf 	CALL SUBOPT_0x46
000e95 70e1      	ANDI R30,LOW(0x1)
000e96 70f0      	ANDI R31,HIGH(0x1)
000e97 87e9      	STD  Y+9,R30
000e98 87fa      	STD  Y+9+1,R31
         ;    1342 			calc_sec = calc_offset / BPB_BytsPerSec + BPB_RsvdSecCnt;
000e99 940e 1e34 	CALL SUBOPT_0x33
         ;    1343 			calc_offset %= BPB_BytsPerSec;
000e9b 940e 1e39 	CALL SUBOPT_0x34
         ;    1344 			addr_temp = _FF_PART_ADDR + ((long) calc_sec * (long) BPB_BytsPerSec);
000e9d   +  	__GETW1R 16,17
000e9f 940e 1cbb 	CALL SUBOPT_0xE
000ea1 91a0 071e 	LDS  R26,__FF_PART_ADDR
000ea3 91b0 071f 	LDS  R27,__FF_PART_ADDR+1
000ea5 9180 0720 	LDS  R24,__FF_PART_ADDR+2
000ea7 9190 0721 	LDS  R25,__FF_PART_ADDR+3
000ea9 940e 21de 	CALL __ADDD12
000eab 940e 1e97 	CALL SUBOPT_0x40
         ;    1345 
         ;    1346 			if (mode==SINGLE)
000ead f451      	BRNE _0x151
         ;    1347 			{
         ;    1348 				if (_FF_read(addr_temp)==0)
000eae   +  	__GETD1S 11
000eb2 940e 1cae 	CALL SUBOPT_0xC
000eb4 f411      	BRNE _0x152
         ;    1349 					return(0);
000eb5 e0e0      	LDI  R30,LOW(0)
000eb6 c0f6      	RJMP _0x3E5
         ;    1350  			}
          _0x152:
         ;    1351  			else if ((mode==CHAIN) || (mode==END_CHAIN))
000eb7 c029      	RJMP _0x153
          _0x151:
000eb8 85af      	LDD  R26,Y+15
000eb9 30a0      	CPI  R26,LOW(0x0)
000eba f011      	BREQ _0x155
000ebb 30a2      	CPI  R26,LOW(0x2)
000ebc f521      	BRNE _0x154
          _0x155:
         ;    1352   			{
         ;    1353 				if (addr_temp!=_FF_buff_addr)
000ebd 940e 1e9e 	CALL SUBOPT_0x41
000ebf f109      	BREQ _0x157
         ;    1354 				{
         ;    1355 					if (_FF_buff_addr)
000ec0 91e0 073d 	LDS  R30,__FF_buff_addr
000ec2 91f0 073e 	LDS  R31,__FF_buff_addr+1
000ec4 9160 073f 	LDS  R22,__FF_buff_addr+2
000ec6 9170 0740 	LDS  R23,__FF_buff_addr+3
000ec8 940e 22e8 	CALL __CPD10
000eca f069      	BREQ _0x158
         ;    1356 					{
         ;    1357 					#ifdef _SECOND_FAT_ON_
         ;    1358 						if (_FF_buff_addr < _FF_FAT2_ADDR)
000ecb 940e 1ddd 	CALL SUBOPT_0x2D
000ecd f428      	BRSH _0x159
         ;    1359 							if (_FF_write(_FF_buff_addr+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000ece 940e 1df0 	CALL SUBOPT_0x2E
000ed0 f411      	BRNE _0x15A
         ;    1360 								return(0);
000ed1 e0e0      	LDI  R30,LOW(0)
000ed2 c0da      	RJMP _0x3E5
         ;    1361 					#endif
         ;    1362 						if (_FF_write(_FF_buff_addr)==0)
          _0x15A:
          _0x159:
000ed3 940e 1e12 	CALL SUBOPT_0x2F
000ed5 f411      	BRNE _0x15B
         ;    1363 							return(0);
000ed6 e0e0      	LDI  R30,LOW(0)
000ed7 c0d5      	RJMP _0x3E5
         ;    1364 					}
          _0x15B:
         ;    1365 					if (_FF_read(addr_temp)==0)
          _0x158:
000ed8   +  	__GETD1S 11
000edc 940e 1cae 	CALL SUBOPT_0xC
000ede f411      	BRNE _0x15C
         ;    1366 						return(0);
000edf e0e0      	LDI  R30,LOW(0)
000ee0 c0cc      	RJMP _0x3E5
         ;    1367 				}
          _0x15C:
         ;    1368 			}
          _0x157:
         ;    1369 			nibble[0] = next_value & 0x00F;
          _0x154:
          _0x153:
000ee1 89e8      	LDD  R30,Y+16
000ee2 89f9      	LDD  R31,Y+16+1
000ee3 70ef      	ANDI R30,LOW(0xF)
000ee4 70f0      	ANDI R31,HIGH(0xF)
000ee5 83ee      	STD  Y+6,R30
         ;    1370 			nibble[1] = (next_value >> 4) & 0x00F;
000ee6 89e8      	LDD  R30,Y+16
000ee7 89f9      	LDD  R31,Y+16+1
000ee8 940e 221c 	CALL __LSRW4
000eea 70ef      	ANDI R30,LOW(0xF)
000eeb 70f0      	ANDI R31,HIGH(0xF)
000eec 83ef      	STD  Y+7,R30
         ;    1371 			nibble[2] = (next_value >> 8) & 0x00F;
000eed 89e9      	LDD  R30,Y+17
000eee 70f0      	ANDI R31,HIGH(0x0)
000eef 70ef      	ANDI R30,LOW(0xF)
000ef0 70f0      	ANDI R31,HIGH(0xF)
000ef1 87e8      	STD  Y+8,R30
         ;    1372     	
         ;    1373 			if (calc_offset == (BPB_BytsPerSec-1))
000ef2 940e 1e42 	CALL SUBOPT_0x35
000ef4 f011      	BREQ PC+3
000ef5 940c 0f59 	JMP _0x15D
         ;    1374 			{	// Is the FAT12 record accross a sector?
         ;    1375 				if (calc_remainder)
000ef7 85e9      	LDD  R30,Y+9
000ef8 85fa      	LDD  R31,Y+9+1
000ef9 9730      	SBIW R30,0
000efa f169      	BREQ _0x15E
         ;    1376 				{	// Record table uses 1 nibble of last byte
         ;    1377 					calc_temp = _FF_buff[calc_offset] & 0x0F;	// Mask to add new value
000efb 940e 1e27 	CALL SUBOPT_0x31
000efd 940e 1ee6 	CALL SUBOPT_0x47
         ;    1378 					_FF_buff[calc_offset] = calc_temp | (nibble[0] << 4);	// store nibble in correct location
000eff 93ff      	PUSH R31
000f00 93ef      	PUSH R30
000f01 940e 1eef 	CALL SUBOPT_0x48
000f03 91af      	POP  R26
000f04 91bf      	POP  R27
000f05 93ec      	ST   X,R30
         ;    1379 					#ifdef _SECOND_FAT_ON_
         ;    1380 						if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000f06 940e 1eb7 	CALL SUBOPT_0x44
000f08 f411      	BRNE _0x15F
         ;    1381 							return(0);
000f09 e0e0      	LDI  R30,LOW(0)
000f0a c0a2      	RJMP _0x3E5
         ;    1382 					#endif
         ;    1383 					if (_FF_write(addr_temp)==0)
          _0x15F:
000f0b 940e 1ed5 	CALL SUBOPT_0x45
000f0d f411      	BRNE _0x160
         ;    1384 						return(0);
000f0e e0e0      	LDI  R30,LOW(0)
000f0f c09d      	RJMP _0x3E5
         ;    1385 					addr_temp += BPB_BytsPerSec;
          _0x160:
000f10 940e 1ef8 	CALL SUBOPT_0x49
         ;    1386 					if (_FF_read(addr_temp)==0)
000f12 f411      	BRNE _0x161
         ;    1387 						return(0);	// if the read fails return 0
000f13 e0e0      	LDI  R30,LOW(0)
000f14 c098      	RJMP _0x3E5
         ;    1388 					_FF_buff[0] = (nibble[2] << 4) | nibble[1];
          _0x161:
000f15 940e 1f07 	CALL SUBOPT_0x4A
000f17 940e 1f0d 	CALL SUBOPT_0x4B
         ;    1389 					if ((mode==SINGLE) || (mode==END_CHAIN))
000f19 f019      	BREQ _0x163
000f1a 85af      	LDD  R26,Y+15
000f1b 30a2      	CPI  R26,LOW(0x2)
000f1c f451      	BRNE _0x162
          _0x163:
         ;    1390 					{
         ;    1391 						#ifdef _SECOND_FAT_ON_
         ;    1392 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000f1d 940e 1eb7 	CALL SUBOPT_0x44
000f1f f411      	BRNE _0x165
         ;    1393 								return(0);
000f20 e0e0      	LDI  R30,LOW(0)
000f21 c08b      	RJMP _0x3E5
         ;    1394 						#endif
         ;    1395 						if (_FF_write(addr_temp)==0)
          _0x165:
000f22 940e 1ed5 	CALL SUBOPT_0x45
000f24 f411      	BRNE _0x166
         ;    1396 							return(0);
000f25 e0e0      	LDI  R30,LOW(0)
000f26 c086      	RJMP _0x3E5
         ;    1397 					}
          _0x166:
         ;    1398 				}
          _0x162:
         ;    1399 				else
000f27 c030      	RJMP _0x167
          _0x15E:
         ;    1400 				{	// Record table uses whole last byte
         ;    1401 					_FF_buff[calc_offset] = (nibble[1] << 4) | nibble[0];
000f28   +  	__GETW1R 18,19
000f2a 5fec      	SUBI R30,LOW(-__FF_buff)
000f2b 4ffa      	SBCI R31,HIGH(-__FF_buff)
000f2c 93ff      	PUSH R31
000f2d 93ef      	PUSH R30
000f2e 940e 1f12 	CALL SUBOPT_0x4C
000f30 91af      	POP  R26
000f31 91bf      	POP  R27
000f32 93ec      	ST   X,R30
         ;    1402 					#ifdef _SECOND_FAT_ON_
         ;    1403 						if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000f33 940e 1eb7 	CALL SUBOPT_0x44
000f35 f411      	BRNE _0x168
         ;    1404 							return(0);
000f36 e0e0      	LDI  R30,LOW(0)
000f37 c075      	RJMP _0x3E5
         ;    1405 					#endif
         ;    1406 					if (_FF_write(addr_temp)==0)
          _0x168:
000f38 940e 1ed5 	CALL SUBOPT_0x45
000f3a f411      	BRNE _0x169
         ;    1407 						return(0);
000f3b e0e0      	LDI  R30,LOW(0)
000f3c c070      	RJMP _0x3E5
         ;    1408 					addr_temp += BPB_BytsPerSec;
          _0x169:
000f3d 940e 1ef8 	CALL SUBOPT_0x49
         ;    1409 					if (_FF_read(addr_temp)==0)
000f3f f411      	BRNE _0x16A
         ;    1410 						return(0);	// if the read fails return 0
000f40 e0e0      	LDI  R30,LOW(0)
000f41 c06b      	RJMP _0x3E5
         ;    1411 					calc_temp = _FF_buff[0] & 0xF0;		// Mask to add new value
          _0x16A:
000f42 91e0 0504 	LDS  R30,__FF_buff
000f44 940e 1f18 	CALL SUBOPT_0x4D
         ;    1412 					_FF_buff[0] = calc_temp | nibble[2];	// store nibble in correct location
000f46 940e 1f1d 	CALL SUBOPT_0x4E
000f48 940e 1f0d 	CALL SUBOPT_0x4B
         ;    1413 					if ((mode==SINGLE) || (mode==END_CHAIN))
000f4a f019      	BREQ _0x16C
000f4b 85af      	LDD  R26,Y+15
000f4c 30a2      	CPI  R26,LOW(0x2)
000f4d f451      	BRNE _0x16B
          _0x16C:
         ;    1414 					{
         ;    1415 						#ifdef _SECOND_FAT_ON_
         ;    1416 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000f4e 940e 1eb7 	CALL SUBOPT_0x44
000f50 f411      	BRNE _0x16E
         ;    1417 								return(0);
000f51 e0e0      	LDI  R30,LOW(0)
000f52 c05a      	RJMP _0x3E5
         ;    1418 						#endif
         ;    1419 						if (_FF_write(addr_temp)==0)
          _0x16E:
000f53 940e 1ed5 	CALL SUBOPT_0x45
000f55 f411      	BRNE _0x16F
         ;    1420 							return(0);
000f56 e0e0      	LDI  R30,LOW(0)
000f57 c055      	RJMP _0x3E5
         ;    1421 					}
          _0x16F:
         ;    1422 				}
          _0x16B:
          _0x167:
         ;    1423 			}
         ;    1424 			else
000f58 c050      	RJMP _0x170
          _0x15D:
         ;    1425 			{
         ;    1426 				if (calc_remainder)
000f59 85e9      	LDD  R30,Y+9
000f5a 85fa      	LDD  R31,Y+9+1
000f5b 9730      	SBIW R30,0
000f5c f121      	BREQ _0x171
         ;    1427 				{	// Record table uses 1 nibble of current byte
         ;    1428 					calc_temp = _FF_buff[calc_offset] & 0x0F;	// Mask to add new value
000f5d 940e 1e27 	CALL SUBOPT_0x31
000f5f 940e 1ee6 	CALL SUBOPT_0x47
         ;    1429 					_FF_buff[calc_offset] = calc_temp | (nibble[0] << 4);	// store nibble in correct location
000f61 93ff      	PUSH R31
000f62 93ef      	PUSH R30
000f63 940e 1eef 	CALL SUBOPT_0x48
000f65 91af      	POP  R26
000f66 91bf      	POP  R27
000f67 93ec      	ST   X,R30
         ;    1430 					_FF_buff[calc_offset+1] = (nibble[2] << 4) | nibble[1];
000f68 940e 1ead 	CALL SUBOPT_0x42
000f6a 93ff      	PUSH R31
000f6b 93ef      	PUSH R30
000f6c 940e 1f07 	CALL SUBOPT_0x4A
000f6e 91af      	POP  R26
000f6f 91bf      	POP  R27
000f70 940e 1eb3 	CALL SUBOPT_0x43
         ;    1431 					if ((mode==SINGLE) || (mode==END_CHAIN))
000f72 f019      	BREQ _0x173
000f73 85af      	LDD  R26,Y+15
000f74 30a2      	CPI  R26,LOW(0x2)
000f75 f451      	BRNE _0x172
          _0x173:
         ;    1432 					{
         ;    1433 						#ifdef _SECOND_FAT_ON_
         ;    1434 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000f76 940e 1eb7 	CALL SUBOPT_0x44
000f78 f411      	BRNE _0x175
         ;    1435 								return(0);
000f79 e0e0      	LDI  R30,LOW(0)
000f7a c032      	RJMP _0x3E5
         ;    1436 						#endif
         ;    1437 						if (_FF_write(addr_temp)==0)
          _0x175:
000f7b 940e 1ed5 	CALL SUBOPT_0x45
000f7d f411      	BRNE _0x176
         ;    1438 							return(0);
000f7e e0e0      	LDI  R30,LOW(0)
000f7f c02d      	RJMP _0x3E5
         ;    1439 					}
          _0x176:
         ;    1440 				}
          _0x172:
         ;    1441 				else
000f80 c028      	RJMP _0x177
          _0x171:
         ;    1442 				{	// Record table uses whole current byte
         ;    1443 					_FF_buff[calc_offset] = (nibble[1] << 4) | nibble[0];
000f81   +  	__GETW1R 18,19
000f83 5fec      	SUBI R30,LOW(-__FF_buff)
000f84 4ffa      	SBCI R31,HIGH(-__FF_buff)
000f85 93ff      	PUSH R31
000f86 93ef      	PUSH R30
000f87 940e 1f12 	CALL SUBOPT_0x4C
000f89 91af      	POP  R26
000f8a 91bf      	POP  R27
000f8b 93ec      	ST   X,R30
         ;    1444 					calc_temp = _FF_buff[calc_offset+1] & 0xF0;		// Mask to add new value
000f8c 940e 1ead 	CALL SUBOPT_0x42
000f8e 81e0      	LD   R30,Z
000f8f 940e 1f18 	CALL SUBOPT_0x4D
         ;    1445 					_FF_buff[calc_offset+1] = calc_temp | nibble[2];	// store nibble in correct location
000f91 940e 1ead 	CALL SUBOPT_0x42
000f93 93ff      	PUSH R31
000f94 93ef      	PUSH R30
000f95 940e 1f1d 	CALL SUBOPT_0x4E
000f97 91af      	POP  R26
000f98 91bf      	POP  R27
000f99 940e 1eb3 	CALL SUBOPT_0x43
         ;    1446 					if ((mode==SINGLE) || (mode==END_CHAIN))
000f9b f019      	BREQ _0x179
000f9c 85af      	LDD  R26,Y+15
000f9d 30a2      	CPI  R26,LOW(0x2)
000f9e f451      	BRNE _0x178
          _0x179:
         ;    1447 					{
         ;    1448 						#ifdef _SECOND_FAT_ON_
         ;    1449 							if (_FF_write(addr_temp+(_FF_FAT2_ADDR-_FF_FAT1_ADDR))==0)
000f9f 940e 1eb7 	CALL SUBOPT_0x44
000fa1 f411      	BRNE _0x17B
         ;    1450 								return(0);
000fa2 e0e0      	LDI  R30,LOW(0)
000fa3 c009      	RJMP _0x3E5
         ;    1451 						#endif
         ;    1452 						if (_FF_write(addr_temp)==0)
          _0x17B:
000fa4 940e 1ed5 	CALL SUBOPT_0x45
000fa6 f411      	BRNE _0x17C
         ;    1453 							return(0);
000fa7 e0e0      	LDI  R30,LOW(0)
000fa8 c004      	RJMP _0x3E5
         ;    1454 					}
          _0x17C:
         ;    1455 				}
          _0x178:
          _0x177:
         ;    1456 			}
          _0x170:
         ;    1457 		}
         ;    1458 	#endif
         ;    1459 	else		// not FAT12 or FAT16, return 0
000fa9 c002      	RJMP _0x17D
          _0x150:
         ;    1460 		return (0);
000faa e0e0      	LDI  R30,LOW(0)
000fab c001      	RJMP _0x3E5
         ;    1461 		
         ;    1462 	return(1);	
          _0x17D:
          _0x14F:
000fac e0e1      	LDI  R30,LOW(1)
          _0x3E5:
000fad 940e 230b 	CALL __LOADLOCR6
000faf 9664      	ADIW R28,20
000fb0 9508      	RET
         ;    1463 }
         ;    1464 #endif
         ;    1465 
         ;    1466 #ifndef _READ_ONLY_
         ;    1467 // Save new entry data to FAT entry
         ;    1468 unsigned char append_toc(FILE *rp)
         ;    1469 {
          _append_toc:
         ;    1470 	unsigned long file_data;
         ;    1471 	unsigned char n;
         ;    1472 	unsigned char *fp;
         ;    1473 	unsigned int calc_temp, calc_date;
         ;    1474 	
         ;    1475 	if (rp==NULL)
000fb1 9726      	SBIW R28,6
000fb2 940e 2305 	CALL __SAVELOCR5
         ;	*rp -> Y+11
         ;	file_data -> Y+7
         ;	n -> R16
         ;	*fp -> R17,R18
         ;	calc_temp -> R19,R20
         ;	calc_date -> Y+5
000fb4 85eb      	LDD  R30,Y+11
000fb5 85fc      	LDD  R31,Y+11+1
000fb6 9730      	SBIW R30,0
000fb7 f411      	BRNE _0x17E
         ;    1476 		return (0);
000fb8 e0e0      	LDI  R30,LOW(0)
000fb9 c083      	RJMP _0x3E4
         ;    1477 
         ;    1478 	file_data = rp->length;
          _0x17E:
000fba 85ab      	LDD  R26,Y+11
000fbb 85bc      	LDD  R27,Y+11+1
000fbc 5ea4      	SUBI R26,LOW(-540)
000fbd 4fbd      	SBCI R27,HIGH(-540)
000fbe 940e 22c2 	CALL __GETD1P
000fc0   +  	__PUTD1S 7
         ;    1479 	if (_FF_read(rp->entry_sec_addr)==0)
000fc4 940e 1f24 	CALL SUBOPT_0x4F
000fc6 940e 07e8 	CALL __FF_read
000fc8 30e0      	CPI  R30,0
000fc9 f411      	BRNE _0x17F
         ;    1480 		return (0);
000fca e0e0      	LDI  R30,LOW(0)
000fcb c071      	RJMP _0x3E4
         ;    1481 	
         ;    1482 	// Update Starting Cluster 
         ;    1483 	fp = &_FF_buff[rp->entry_offset+0x1a];
          _0x17F:
000fcc 940e 1f2d 	CALL SUBOPT_0x50
000fce 967a      	ADIW R30,26
000fcf 5fec      	SUBI R30,LOW(-__FF_buff)
000fd0 4ffa      	SBCI R31,HIGH(-__FF_buff)
000fd1   +  	__PUTW1R 17,18
         ;    1484 	*fp++ = rp->clus_start & 0xFF;
000fd3 932f      	PUSH R18
000fd4 931f      	PUSH R17
000fd5   +  	__ADDWRN 17,18,1
000fd7 940e 1f33 	CALL SUBOPT_0x51
000fd9 70f0      	ANDI R31,HIGH(0xFF)
000fda 91af      	POP  R26
000fdb 91bf      	POP  R27
000fdc 93ec      	ST   X,R30
         ;    1485 	*fp++ = rp->clus_start >> 8;
000fdd 932f      	PUSH R18
000fde 931f      	PUSH R17
000fdf   +  	__ADDWRN 17,18,1
000fe1 940e 1f33 	CALL SUBOPT_0x51
000fe3 2fef      	MOV  R30,R31
000fe4 e0f0      	LDI  R31,0
000fe5 91af      	POP  R26
000fe6 91bf      	POP  R27
000fe7 93ec      	ST   X,R30
         ;    1486 	
         ;    1487 	// Update the File Size
         ;    1488 	for (n=0; n<4; n++)
000fe8 e000      	LDI  R16,LOW(0)
          _0x181:
000fe9 3004      	CPI  R16,4
000fea f430      	BRSH _0x182
         ;    1489 	{
         ;    1490 		*fp = file_data & 0xFF;
000feb 940e 1f39 	CALL SUBOPT_0x52
         ;    1491 		file_data >>= 8;
         ;    1492 		fp++;
000fed   +  	__ADDWRN 17,18,1
         ;    1493 	}
000fef 5f0f      	SUBI R16,-1
000ff0 cff8      	RJMP _0x181
          _0x182:
         ;    1494 	
         ;    1495 	
         ;    1496 	fp = &_FF_buff[rp->entry_offset+0x16];
000ff1 940e 1f2d 	CALL SUBOPT_0x50
000ff3 9676      	ADIW R30,22
000ff4 5fec      	SUBI R30,LOW(-__FF_buff)
000ff5 4ffa      	SBCI R31,HIGH(-__FF_buff)
000ff6   +  	__PUTW1R 17,18
         ;    1497 	#ifdef _RTC_ON_ 	// Date/Time Stamp file w/ RTC
         ;    1498 		rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
         ;    1499 		calc_temp = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
         ;    1500 		*fp++ = calc_temp&0x00FF;	// File create Time 
         ;    1501 		*fp++ = (calc_temp&0xFF00) >> 8;
         ;    1502 		calc_date = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
         ;    1503 		*fp++ = calc_date&0x00FF;	// File create Date
         ;    1504 		*fp++ = (calc_date&0xFF00) >> 8;
         ;    1505 	#else		// Increment Date Code, no RTC used 
         ;    1506 		file_data = 0;
000ff8   +  	__CLRD1S 7
         ;    1507 		for (n=0; n<4; n++)
000ffd e000      	LDI  R16,LOW(0)
          _0x184:
000ffe 3004      	CPI  R16,4
000fff f4f8      	BRSH _0x185
         ;    1508 		{
         ;    1509 			file_data <<= 8;
001000   +  	__GETD2S 7
001004 e0e8      	LDI  R30,LOW(8)
001005 940e 21fb 	CALL __LSLD12
001007   +  	__PUTD1S 7
         ;    1510 			file_data |= *fp;
00100b   +  	__GETW2R 17,18
00100d 91ec      	LD   R30,X
00100e   +  	__GETD2S 7
001012 27ff      	CLR  R31
001013 2766      	CLR  R22
001014 2777      	CLR  R23
001015 940e 21ed 	CALL __ORD12
001017   +  	__PUTD1S 7
         ;    1511 			fp--;
00101b   +  	__SUBWRN 17,18,1
         ;    1512 		}
00101d 5f0f      	SUBI R16,-1
00101e cfdf      	RJMP _0x184
          _0x185:
         ;    1513 		file_data++;
00101f   +  	__GETD1S 7
001023   +  	__SUBD1N -1
001027   +  	__PUTD1S 7
         ;    1514 		for (n=0; n<4; n++)
00102b e000      	LDI  R16,LOW(0)
          _0x187:
00102c 3004      	CPI  R16,4
00102d f430      	BRSH _0x188
         ;    1515 		{
         ;    1516 			fp++;
00102e   +  	__ADDWRN 17,18,1
         ;    1517 			*fp = file_data & 0xFF;
001030 940e 1f39 	CALL SUBOPT_0x52
         ;    1518 			file_data >>=8;
         ;    1519 		}
001032 5f0f      	SUBI R16,-1
001033 cff8      	RJMP _0x187
          _0x188:
         ;    1520 	#endif
         ;    1521 	if (_FF_write(rp->entry_sec_addr)==0)
001034 940e 1f24 	CALL SUBOPT_0x4F
001036 940e 0854 	CALL __FF_write
001038 30e0      	CPI  R30,0
001039 f411      	BRNE _0x189
         ;    1522 		return(0);
00103a e0e0      	LDI  R30,LOW(0)
00103b c001      	RJMP _0x3E4
         ;    1523 	
         ;    1524 	return(1);
          _0x189:
00103c e0e1      	LDI  R30,LOW(1)
          _0x3E4:
00103d 940e 230c 	CALL __LOADLOCR5
00103f 962d      	ADIW R28,13
001040 9508      	RET
         ;    1525 }
         ;    1526 #endif
         ;    1527 
         ;    1528 #ifndef _READ_ONLY_
         ;    1529 // Erase a chain of clusters (set table entries to 0 for clusters in chain)
         ;    1530 unsigned char erase_clus_chain(unsigned int start_clus)
         ;    1531 {
          _erase_clus_chain:
         ;    1532 	unsigned int clus_temp, clus_use;
         ;    1533 	
         ;    1534 	if (start_clus==0)
001041 940e 2306 	CALL __SAVELOCR4
         ;	start_clus -> Y+4
         ;	clus_temp -> R16,R17
         ;	clus_use -> R18,R19
001043 81ec      	LDD  R30,Y+4
001044 81fd      	LDD  R31,Y+4+1
001045 9730      	SBIW R30,0
001046 f411      	BRNE _0x18A
         ;    1535 		return (0);
001047 e0e0      	LDI  R30,LOW(0)
001048 c03d      	RJMP _0x3E3
         ;    1536 	clus_use = start_clus;
          _0x18A:
001049   +  	__GETWRS 18,19,4
         ;    1537 	_FF_buff_addr = 0;
00104b e0e0      	LDI  R30,0
00104c 93e0 073d 	STS  __FF_buff_addr,R30
00104e 93e0 073e 	STS  __FF_buff_addr+1,R30
001050 93e0 073f 	STS  __FF_buff_addr+2,R30
001052 93e0 0740 	STS  __FF_buff_addr+3,R30
         ;    1538 	while(clus_use <= 0xFFF8)
          _0x18B:
001054 efe8      	LDI  R30,LOW(65528)
001055 efff      	LDI  R31,HIGH(65528)
001056 17e2      	CP   R30,R18
001057 07f3      	CPC  R31,R19
001058 f0b8      	BRLO _0x18D
         ;    1539 	{
         ;    1540 		clus_temp = next_cluster(clus_use, CHAIN);
001059 940e 1f50 	CALL SUBOPT_0x53
00105b   +  	__PUTW1R 16,17
         ;    1541 		if ((clus_temp >= 0xFFF8) || (clus_temp == 0))
00105d   +  	__CPWRN 16,17,65528
001060 f420      	BRSH _0x18F
001061 2400      	CLR  R0
001062 1600      	CP   R0,R16
001063 0601      	CPC  R0,R17
001064 f409      	BRNE _0x18E
          _0x18F:
         ;    1542 			break;
001065 c00a      	RJMP _0x18D
         ;    1543 		if (write_clus_table(clus_use, 0, CHAIN) == 0)
          _0x18E:
001066 940e 1f56 	CALL SUBOPT_0x54
001068 940e 1f5d 	CALL SUBOPT_0x55
00106a f411      	BRNE _0x191
         ;    1544 			return (0);
00106b e0e0      	LDI  R30,LOW(0)
00106c c019      	RJMP _0x3E3
         ;    1545 		clus_use = clus_temp;
          _0x191:
00106d   +  	__MOVEWRR 18,19,16,17
         ;    1546 	}
00106f cfe4      	RJMP _0x18B
          _0x18D:
         ;    1547 	if (write_clus_table(clus_use, 0, END_CHAIN) == 0)
001070 940e 1f56 	CALL SUBOPT_0x54
001072 940e 1f63 	CALL SUBOPT_0x56
001074 f411      	BRNE _0x192
         ;    1548 		return (0);
001075 e0e0      	LDI  R30,LOW(0)
001076 c00f      	RJMP _0x3E3
         ;    1549 	clus_0_addr = 0;
          _0x192:
001077 e0e0      	LDI  R30,0
001078 93e0 074c 	STS  _clus_0_addr,R30
00107a 93e0 074d 	STS  _clus_0_addr+1,R30
00107c 93e0 074e 	STS  _clus_0_addr+2,R30
00107e 93e0 074f 	STS  _clus_0_addr+3,R30
         ;    1550 	c_counter = 0;
001080 e0e0      	LDI  R30,0
001081 93e0 0754 	STS  _c_counter,R30
001083 93e0 0755 	STS  _c_counter+1,R30
         ;    1551 	
         ;    1552 	return (1);	
001085 e0e1      	LDI  R30,LOW(1)
          _0x3E3:
001086 940e 230d 	CALL __LOADLOCR4
001088 9626      	ADIW R28,6
001089 9508      	RET
         ;    1553 }
         ;    1554 
         ;    1555 // Quickformat of a card (erase cluster table and root directory
         ;    1556 int fquickformat(void)
         ;    1557 {
         ;    1558 	long c;
         ;    1559 	
         ;    1560 	for (c=0; c<BPB_BytsPerSec; c++)
         ;	c -> Y+0
         ;    1561 		_FF_buff[c] = 0;
         ;    1562 	
         ;    1563 	c = _FF_FAT1_ADDR + 0x200;
         ;    1564 	while (c < (_FF_ROOT_ADDR + (0x400 * BPB_SecPerClus)))
         ;    1565 	{
         ;    1566 		if (_FF_write(c)==0)
         ;    1567 		{
         ;    1568 			_FF_error = WRITE_ERR;
         ;    1569 			return (EOF);
         ;    1570 		}
         ;    1571 		c += 0x200;
         ;    1572 	}	
         ;    1573 	_FF_buff[0] = 0xF8;
         ;    1574 	_FF_buff[1] = 0xFF;
         ;    1575 	_FF_buff[2] = 0xFF;
         ;    1576 	if (BPB_FATType == 0x36)
         ;    1577 		_FF_buff[3] = 0xFF;
         ;    1578 	if ((_FF_write(_FF_FAT1_ADDR)==0) || (_FF_write(_FF_FAT2_ADDR)==0))
         ;    1579 	{
         ;    1580 		_FF_error = WRITE_ERR;
         ;    1581 		return (EOF);
         ;    1582 	}
         ;    1583 	return (0);
         ;    1584 }
         ;    1585 #endif
         ;    1586 
         ;    1587 // function that checks for directory changes then gets into a working form
         ;    1588 int _FF_checkdir(char *F_PATH, unsigned long *SAVE_ADDR, char *path_temp)
         ;    1589 {
          __FF_checkdir:
         ;    1590 	unsigned char *sp, *qp;
         ;    1591     
         ;    1592     *SAVE_ADDR = _FF_DIR_ADDR;	// save local dir addr
00108a 940e 2306 	CALL __SAVELOCR4
         ;	*F_PATH -> Y+8
         ;	*SAVE_ADDR -> Y+6
         ;	*path_temp -> Y+4
         ;	*sp -> R16,R17
         ;	*qp -> R18,R19
00108c 91e0 0726 	LDS  R30,__FF_DIR_ADDR
00108e 91f0 0727 	LDS  R31,__FF_DIR_ADDR+1
001090 9160 0728 	LDS  R22,__FF_DIR_ADDR+2
001092 9170 0729 	LDS  R23,__FF_DIR_ADDR+3
001094 81ae      	LDD  R26,Y+6
001095 81bf      	LDD  R27,Y+6+1
001096 940e 22c8 	CALL __PUTDP1
         ;    1593     
         ;    1594     qp = F_PATH;
001098   +  	__GETWRS 18,19,8
         ;    1595     if (*qp=='\\')
00109a 940e 1f69 	CALL SUBOPT_0x57
00109c f491      	BRNE _0x19E
         ;    1596     {
         ;    1597     	_FF_DIR_ADDR = _FF_ROOT_ADDR;
00109d 91e0 0722 	LDS  R30,__FF_ROOT_ADDR
00109f 91f0 0723 	LDS  R31,__FF_ROOT_ADDR+1
0010a1 9160 0724 	LDS  R22,__FF_ROOT_ADDR+2
0010a3 9170 0725 	LDS  R23,__FF_ROOT_ADDR+3
0010a5 93e0 0726 	STS  __FF_DIR_ADDR,R30
0010a7 93f0 0727 	STS  __FF_DIR_ADDR+1,R31
0010a9 9360 0728 	STS  __FF_DIR_ADDR+2,R22
0010ab 9370 0729 	STS  __FF_DIR_ADDR+3,R23
         ;    1598 		qp++;
0010ad   +  	__ADDWRN 18,19,1
         ;    1599 	}
         ;    1600 
         ;    1601 	sp = path_temp;
          _0x19E:
0010af   +  	__GETWRS 16,17,4
         ;    1602 	while(*qp)
          _0x19F:
0010b1 940e 1f6e 	CALL SUBOPT_0x58
0010b3 f181      	BREQ _0x1A1
         ;    1603 	{
         ;    1604 		if ((valid_file_char(*qp)==0) || (*qp=='.'))
0010b4   +  	__GETW2R 18,19
0010b6 940e 1d25 	CALL SUBOPT_0x1B
0010b8 f029      	BREQ _0x1A3
0010b9   +  	__GETW2R 18,19
0010bb 91ac      	LD   R26,X
0010bc 32ae      	CPI  R26,LOW(0x2E)
0010bd f471      	BRNE _0x1A2
          _0x1A3:
         ;    1605 			*sp++ = toupper(*qp++);
0010be 931f      	PUSH R17
0010bf 930f      	PUSH R16
0010c0   +  	__ADDWRN 16,17,1
0010c2   +  	__GETW2R 18,19
0010c4   +  	__ADDWRN 18,19,1
0010c6 940e 1e4f 	CALL SUBOPT_0x37
0010c8 91af      	POP  R26
0010c9 91bf      	POP  R27
0010ca 93ec      	ST   X,R30
         ;    1606 		else if (*qp=='\\')
0010cb c017      	RJMP _0x1A5
          _0x1A2:
0010cc 940e 1f69 	CALL SUBOPT_0x57
0010ce f489      	BRNE _0x1A6
         ;    1607 		{
         ;    1608 			*sp = 0;	// terminate string
0010cf 940e 1f73 	CALL SUBOPT_0x59
         ;    1609 			if (_FF_chdir(path_temp))
0010d1 81ec      	LDD  R30,Y+4
0010d2 81fd      	LDD  R31,Y+4+1
0010d3 93fa      	ST   -Y,R31
0010d4 93ea      	ST   -Y,R30
0010d5 d016      	RCALL __FF_chdir
0010d6 9730      	SBIW R30,0
0010d7 f019      	BREQ _0x1A7
         ;    1610 			{
         ;    1611 				return (EOF);
0010d8 efef      	LDI  R30,LOW(65535)
0010d9 efff      	LDI  R31,HIGH(65535)
0010da c00d      	RJMP _0x3E2
         ;    1612 			}
         ;    1613 			sp = path_temp;
          _0x1A7:
0010db   +  	__GETWRS 16,17,4
         ;    1614 			qp++;
0010dd   +  	__ADDWRN 18,19,1
         ;    1615 		}
         ;    1616 		else
0010df c003      	RJMP _0x1A8
          _0x1A6:
         ;    1617 			return (EOF);
0010e0 efef      	LDI  R30,LOW(65535)
0010e1 efff      	LDI  R31,HIGH(65535)
0010e2 c005      	RJMP _0x3E2
         ;    1618 	}
          _0x1A8:
          _0x1A5:
0010e3 cfcd      	RJMP _0x19F
          _0x1A1:
         ;    1619 	
         ;    1620 	*sp = 0;		// terminate string
0010e4 940e 1f73 	CALL SUBOPT_0x59
         ;    1621 	return (0);
0010e6 e0e0      	LDI  R30,LOW(0)
0010e7 e0f0      	LDI  R31,HIGH(0)
          _0x3E2:
0010e8 940e 230d 	CALL __LOADLOCR4
0010ea 962a      	ADIW R28,10
0010eb 9508      	RET
         ;    1622 }
         ;    1623 
         ;    1624 #ifndef _READ_ONLY_
         ;    1625 int mkdir(char *F_PATH)
         ;    1626 {
         ;    1627 	unsigned char *sp, *qp;
         ;    1628 	unsigned char fpath[14];
         ;    1629 	unsigned int c, calc_temp, clus_temp, calc_time, calc_date;
         ;    1630 	int s;
         ;    1631 	unsigned long addr_temp, path_addr_temp;
         ;    1632     
         ;    1633     addr_temp = 0;	// save local dir addr
         ;	*F_PATH -> Y+38
         ;	*sp -> R16,R17
         ;	*qp -> R18,R19
         ;	fpath -> Y+24
         ;	c -> R20,R21
         ;	calc_temp -> Y+22
         ;	clus_temp -> Y+20
         ;	calc_time -> Y+18
         ;	calc_date -> Y+16
         ;	s -> Y+14
         ;	addr_temp -> Y+10
         ;	path_addr_temp -> Y+6
         ;    1634     
         ;    1635     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
         ;    1636 	{
         ;    1637 		_FF_DIR_ADDR = addr_temp;
         ;    1638 		return (EOF);
         ;    1639 	}
         ;    1640     
         ;    1641 	path_addr_temp = _FF_DIR_ADDR;
         ;    1642 	s = scan_directory(&path_addr_temp, fpath);
         ;    1643 	if ((s) || (path_addr_temp==0))
         ;    1644 	{
         ;    1645 		_FF_DIR_ADDR = addr_temp;
         ;    1646 		return (EOF);
         ;    1647 	}
         ;    1648 	clus_temp = prev_cluster(0);				
         ;    1649 	calc_temp = path_addr_temp % BPB_BytsPerSec;
         ;    1650 	path_addr_temp -= calc_temp;
         ;    1651 	if (_FF_read(path_addr_temp)==0)	
         ;    1652 	{
         ;    1653 		_FF_DIR_ADDR = addr_temp;
         ;    1654 		return (EOF);
         ;    1655 	}
         ;    1656 	
         ;    1657 	sp = &_FF_buff[calc_temp];
         ;    1658 	qp = fpath;
         ;    1659 
         ;    1660 	for (c=0; c<11; c++)	// Write Folder name
         ;    1661 	{
         ;    1662 	 	if (*qp)
         ;    1663 		 	*sp++ = *qp++;
         ;    1664 		else 
         ;    1665 			*sp++ = 0x20;	// '0' pad
         ;    1666 	}
         ;    1667 	*sp++ = 0x10;				// Attribute bit auto set to "Directory"
         ;    1668 	*sp++ = 0;					// Reserved for WinNT
         ;    1669 	*sp++ = 0;					// Mili-second stamp for create
         ;    1670 	for (c=0; c<4; c++)			// set create and modify time to '0'
         ;    1671 		*sp++ = 0;
         ;    1672 	*sp++ = 0;					// File access date (2 bytes)
         ;    1673 	*sp++ = 0;
         ;    1674 	*sp++ = 0;					// 0 for FAT12/16 (2 bytes)
         ;    1675 	*sp++ = 0;
         ;    1676 	#ifdef _RTC_ON_
         ;    1677 		rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
         ;    1678 		calc_time = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
         ;    1679 		*sp++ = calc_time&0x00FF;	// File modify Time 
         ;    1680 		*sp++ = (calc_time&0xFF00) >> 8;
         ;    1681 		calc_date = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
         ;    1682 		*sp++ = calc_date&0x00FF;	// File modify Date
         ;    1683 		*sp++ = (calc_date&0xFF00) >> 8;
         ;    1684 	#else
         ;    1685 		for (c=0; c<4; c++)			// set file create and modify time to '0'
         ;    1686 			*sp++ = 0;
         ;    1687 	#endif
         ;    1688 	
         ;    1689 	*sp++ = clus_temp & 0xFF;				// Starting cluster (2 bytes)
         ;    1690 	*sp++ = (clus_temp >> 8) & 0xFF;
         ;    1691 	for (c=0; c<4; c++)
         ;    1692 		*sp++ = 0;			// File length (0 for folder)
         ;    1693 
         ;    1694 	
         ;    1695 	if (_FF_write(path_addr_temp)==0)	// write entry to card
         ;    1696 	{
         ;    1697 		_FF_DIR_ADDR = addr_temp;
         ;    1698 		return (EOF);
         ;    1699 	}
         ;    1700 	if (write_clus_table(clus_temp, 0xFFFF, SINGLE)==0)
         ;    1701 	{
         ;    1702 		_FF_DIR_ADDR = addr_temp;
         ;    1703 		return (EOF);
         ;    1704 	}
         ;    1705 	if (_FF_read(_FF_DIR_ADDR)==0)	
         ;    1706 	{
         ;    1707 		_FF_DIR_ADDR = addr_temp;
         ;    1708 		return (EOF);
         ;    1709 	}
         ;    1710 	if (_FF_DIR_ADDR != _FF_ROOT_ADDR)
         ;    1711 	{
         ;    1712 		sp = &_FF_buff[0];
         ;    1713 		qp = &_FF_buff[0x20];
         ;    1714 		for (c=0; c<0x20; c++)
         ;    1715 			*qp++ = *sp++;
         ;    1716 		_FF_buff[1] = ' ';
         ;    1717 		for (c=0x3C; c<0x40; c++)
         ;    1718 			_FF_buff[c] = 0;
         ;    1719 	}
         ;    1720 	else
         ;    1721 	{
         ;    1722 		for (c=0x01; c<0x0B; c++)
         ;    1723 			_FF_buff[c] = 0x20;
         ;    1724 		for (c=0x0C; c<0x20; c++)
         ;    1725 			_FF_buff[c] = 0;
         ;    1726 		_FF_buff[0] = '.';
         ;    1727 		_FF_buff[0x0B] = 0x10;
         ;    1728 		#ifdef _RTC_ON_
         ;    1729 			_FF_buff[0x0E] = calc_time&0x00FF;	// File modify Time 
         ;    1730 			_FF_buff[0x0F] = (calc_time&0xFF00) >> 8;
         ;    1731 			_FF_buff[0x10] = calc_date&0x00FF;	// File modify Date
         ;    1732 			_FF_buff[0x11] = (calc_date&0xFF00) >> 8;
         ;    1733 			_FF_buff[0x16] = calc_time&0x00FF;	// File modify Time 
         ;    1734 			_FF_buff[0x17] = (calc_time&0xFF00) >> 8;
         ;    1735 			_FF_buff[0x18] = calc_date&0x00FF;	// File modify Date
         ;    1736 			_FF_buff[0x19] = (calc_date&0xFF00) >> 8;
         ;    1737 		#endif
         ;    1738 		for (c=0x3A; c<0x40; c++)
         ;    1739 			_FF_buff[c] = 0;
         ;    1740 	}
         ;    1741 	for (c=0x22; c<0x2B; c++)
         ;    1742 		_FF_buff[c] = 0x20;
         ;    1743 	#ifdef _RTC_ON_
         ;    1744 		_FF_buff[0x2E] = calc_time&0x00FF;	// File modify Time 
         ;    1745 		_FF_buff[0x2F] = (calc_time&0xFF00) >> 8;
         ;    1746 		_FF_buff[0x30] = calc_date&0x00FF;	// File modify Date
         ;    1747 		_FF_buff[0x31] = (calc_date&0xFF00) >> 8;
         ;    1748 		_FF_buff[0x36] = calc_time&0x00FF;	// File modify Time 
         ;    1749 		_FF_buff[0x37] = (calc_time&0xFF00) >> 8;
         ;    1750 		_FF_buff[0x38] = calc_date&0x00FF;	// File modify Date
         ;    1751 		_FF_buff[0x39] = (calc_date&0xFF00) >> 8;
         ;    1752 	#endif
         ;    1753 	_FF_buff[0x20] = '.';
         ;    1754 	_FF_buff[0x21] = '.';
         ;    1755 	_FF_buff[0x2B] = 0x10;
         ;    1756 
         ;    1757 	_FF_buff[0x1A] = clus_temp & 0xFF;				// Starting cluster (2 bytes)
         ;    1758 	_FF_buff[0x1B] = (clus_temp >> 8) & 0xFF;
         ;    1759 	for (c=0x40; c<BPB_BytsPerSec; c++)
         ;    1760 		_FF_buff[c] = 0;
         ;    1761 	path_addr_temp = clust_to_addr(clus_temp);
         ;    1762 
         ;    1763 	_FF_DIR_ADDR = addr_temp;	// reset dir addr
         ;    1764 	if (_FF_write(path_addr_temp)==0)	
         ;    1765 		return (EOF);
         ;    1766 	for (c=0; c<0x40; c++)
         ;    1767 		_FF_buff[c] = 0;
         ;    1768 	for (c=1; c<BPB_SecPerClus; c++)
         ;    1769 	{
         ;    1770 		if (_FF_write(path_addr_temp+((long)c*0x200))==0)	
         ;    1771 			return (EOF);
         ;    1772 	}
         ;    1773 	return (0);		
         ;    1774 }
         ;    1775 
         ;    1776 int rmdir(char *F_PATH)
         ;    1777 {
         ;    1778 	unsigned char *sp;
         ;    1779 	unsigned char fpath[14];
         ;    1780 	unsigned int c, n, calc_temp, clus_temp;
         ;    1781 	int s;
         ;    1782 	unsigned long addr_temp, path_addr_temp;
         ;    1783 	
         ;    1784 	addr_temp = 0;	// save local dir addr
         ;	*F_PATH -> Y+34
         ;	*sp -> R16,R17
         ;	fpath -> Y+20
         ;	c -> R18,R19
         ;	n -> R20,R21
         ;	calc_temp -> Y+18
         ;	clus_temp -> Y+16
         ;	s -> Y+14
         ;	addr_temp -> Y+10
         ;	path_addr_temp -> Y+6
         ;    1785     
         ;    1786     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
         ;    1787 	{
         ;    1788 		_FF_DIR_ADDR = addr_temp;
         ;    1789 		return (EOF);
         ;    1790 	}
         ;    1791 	if (fpath[0]==0)
         ;    1792 	{
         ;    1793 		_FF_DIR_ADDR = addr_temp;
         ;    1794 		return (EOF);
         ;    1795 	}
         ;    1796 
         ;    1797     path_addr_temp = _FF_DIR_ADDR;	// save addr for later
         ;    1798 	
         ;    1799 	if (_FF_chdir(fpath))	// Change directory to dir to be deleted
         ;    1800 	{	
         ;    1801 		_FF_DIR_ADDR = addr_temp;
         ;    1802 		return (EOF);
         ;    1803 	}
         ;    1804 	if ((_FF_DIR_ADDR==_FF_ROOT_ADDR)||(_FF_DIR_ADDR==addr_temp))
         ;    1805 	{	// if trying to delete root, or current dir error
         ;    1806 		_FF_DIR_ADDR = addr_temp;
         ;    1807 		return (EOF);
         ;    1808 	}
         ;    1809 	
         ;    1810 	for (c=0; c<BPB_SecPerClus; c++)
         ;    1811 	{	// scan through dir to see if it is empty
         ;    1812 		if (_FF_read(_FF_DIR_ADDR+((long)c*0x200))==0)
         ;    1813 		{	// read sectors 	
         ;    1814 			_FF_DIR_ADDR = addr_temp;
         ;    1815 			return (EOF);
         ;    1816 		}
         ;    1817 		for (n=0; n<0x10; n++)
         ;    1818 		{
         ;    1819 			if ((c==0)&&(n==0))	// skip first 2 entries 
         ;    1820 				n=2;
         ;    1821 			sp = &_FF_buff[n*0x20];
         ;    1822 			if (*sp==0)
         ;    1823 			{	// 
         ;    1824 				c = BPB_SecPerClus;
         ;    1825 				break;
         ;    1826 			}
         ;    1827 			while (valid_file_char(*sp)==0)
         ;    1828 			{
         ;    1829 				sp++;
         ;    1830 				if (sp == &_FF_buff[(n*0x20)+0x0A])
         ;    1831 				{	// a valid file or folder found
         ;    1832 					_FF_DIR_ADDR = addr_temp;
         ;    1833 					return (EOF);
         ;    1834 				}
         ;    1835 			}
         ;    1836 		}
         ;    1837 	}
         ;    1838 	// directory empty, delete dir
         ;    1839 	_FF_DIR_ADDR = path_addr_temp;	// go back to previous directory 
         ;    1840 
         ;    1841 	s = scan_directory(&path_addr_temp, fpath);
         ;    1842 
         ;    1843 	_FF_DIR_ADDR = addr_temp;	// reset address
         ;    1844 
         ;    1845 	if (s == 0)
         ;    1846 		return (EOF);
         ;    1847 	
         ;    1848 	calc_temp = path_addr_temp % BPB_BytsPerSec;
         ;    1849 	path_addr_temp -= calc_temp;
         ;    1850 
         ;    1851 	if (_FF_read(path_addr_temp)==0)	
         ;    1852 		return (EOF);
         ;    1853     
         ;    1854 	clus_temp = ((int) _FF_buff[calc_temp+0x1B] << 8) | _FF_buff[calc_temp+0x1A];
         ;    1855 	_FF_buff[calc_temp] = 0xE5;
         ;    1856 	
         ;    1857 	if (_FF_buff[calc_temp+0x0B]&0x02)
         ;    1858 		return (EOF);
         ;    1859 	if (_FF_write(path_addr_temp)==0) 
         ;    1860 		return (EOF);
         ;    1861 	if (erase_clus_chain(clus_temp)==0)
         ;    1862 		return (EOF);
         ;    1863 	
         ;    1864     return (0);
         ;    1865 }
         ;    1866 #endif
         ;    1867 
         ;    1868 int chdirc(char flash *F_PATH)
         ;    1869 {
         ;    1870 	unsigned char fpath[_FF_PATH_LENGTH];
         ;    1871 	int c;
         ;    1872 	
         ;    1873 	for (c=0; c<_FF_PATH_LENGTH; c++)
         ;	*F_PATH -> Y+102
         ;	fpath -> Y+2
         ;	c -> R16,R17
         ;    1874 	{
         ;    1875 		fpath[c] = F_PATH[c];
         ;    1876 		if (F_PATH[c]==0)
         ;    1877 			break;
         ;    1878 	}
         ;    1879 	return (chdir(fpath));
         ;    1880 }
         ;    1881 
         ;    1882 int chdir(char *F_PATH)
         ;    1883 {
         ;    1884 	unsigned char *qp, *sp, fpath[14], valid_flag;
         ;    1885 	unsigned int m, n, c, d, calc;
         ;    1886 	unsigned long addr_temp;
         ;    1887 
         ;    1888     
         ;    1889     addr_temp = 0;	// save local dir addr
         ;	*F_PATH -> Y+33
         ;	*qp -> R16,R17
         ;	*sp -> R18,R19
         ;	fpath -> Y+19
         ;	valid_flag -> R20
         ;	m -> Y+17
         ;	n -> Y+15
         ;	c -> Y+13
         ;	d -> Y+11
         ;	calc -> Y+9
         ;	addr_temp -> Y+5
         ;    1890     
         ;    1891 	if ((F_PATH[0]=='\\') && (F_PATH[1]==0))
         ;    1892 	{
         ;    1893 		_FF_DIR_ADDR = _FF_ROOT_ADDR;
         ;    1894 		_FF_FULL_PATH[1] = 0;
         ;    1895 		return (0);
         ;    1896 	}
         ;    1897 	
         ;    1898     if (_FF_checkdir(F_PATH, &addr_temp, fpath))
         ;    1899 	{
         ;    1900 		_FF_DIR_ADDR = addr_temp;
         ;    1901 		return (EOF);
         ;    1902 	}
         ;    1903 	if (fpath[0]==0)
         ;    1904 		return (EOF);
         ;    1905 
         ;    1906 	if ((fpath[0]=='.') && (fpath[1]=='.') && (fpath[2]==0))
         ;    1907 	{	// trying to get back to prev dir
         ;    1908 		if (_FF_DIR_ADDR == _FF_ROOT_ADDR)		// already as far back as can go
         ;    1909 			return (EOF);
         ;    1910 		if (_FF_read(_FF_DIR_ADDR)==0)
         ;    1911 			return (EOF);
         ;    1912 		m = ((unsigned int) _FF_buff[0x3B] << 8) | (unsigned int) _FF_buff[0x3A];
         ;    1913 		if (m)
         ;    1914 			_FF_DIR_ADDR = clust_to_addr(m);
         ;    1915 		else
         ;    1916 			_FF_DIR_ADDR = _FF_ROOT_ADDR;
         ;    1917 		
         ;    1918 					sp = F_PATH;
         ;    1919 					qp = _FF_FULL_PATH + strlen(_FF_FULL_PATH);
         ;    1920 					while (*sp)
         ;    1921 					{
         ;    1922 						if ((*sp=='.')&&(*(sp+1)=='.'))
         ;    1923 						{
         ;    1924 							#ifdef _ICCAVR_
         ;    1925 								qp = strrchr(_FF_FULL_PATH, '\\');
         ;    1926 								if (qp==0)
         ;    1927 								   return (EOF);
         ;    1928 								*qp = 0;
         ;    1929 								qp = strrchr(_FF_FULL_PATH, '\\');
         ;    1930 								if (qp==0)
         ;    1931 								   return (EOF);
         ;    1932 								qp++;
         ;    1933 							#endif
         ;    1934 							#ifdef _CVAVR_
         ;    1935 								_FF_FULL_PATH[strrpos(_FF_FULL_PATH, '\\')] = 0;
         ;    1936 							    c = strrpos(_FF_FULL_PATH, '\\');
         ;    1937 								if (c==EOF)
         ;    1938 									return (EOF);
         ;    1939 								qp = _FF_FULL_PATH + c;
         ;    1940 							#endif
         ;    1941 							*qp = 0;
         ;    1942 							sp += 2;
         ;    1943 						}
         ;    1944 						else 
         ;    1945 							*qp++ = toupper(*sp++);
         ;    1946 					}
         ;    1947 					*qp++ = '\\';
         ;    1948 					*qp = 0;
         ;    1949 
         ;    1950 		return (0);
         ;    1951 	}
         ;    1952 		
         ;    1953 	qp = fpath;
         ;    1954 	sp = fpath;
         ;    1955 	while(sp < (fpath+11))
         ;    1956 	{
         ;    1957 		if (*qp)
         ;    1958 			*sp++ = toupper(*qp++);
         ;    1959 		else	// (*qp==0)
         ;    1960 			*sp++ = 0x20;
         ;    1961 	}     
         ;    1962 	*sp = 0;
         ;    1963 
         ;    1964 	qp = fpath;
         ;    1965 	m = 0;
         ;    1966 	d = 0;
         ;    1967 	valid_flag = 0;
         ;    1968 	while (d<BPB_RootEntCnt)
         ;    1969 	{
         ;    1970     	_FF_read(_FF_DIR_ADDR+(m*0x200));
         ;    1971 		for (n=0; n<16; n++)
         ;    1972 		{
         ;    1973 			if (_FF_buff[n*0x20] == 0)	// no more entries in dir
         ;    1974 			{
         ;    1975 				_FF_DIR_ADDR = addr_temp;
         ;    1976 				return (EOF);
         ;    1977 			}
         ;    1978 			calc = (n*0x20);
         ;    1979 			for (c=0; c<11; c++)
         ;    1980 			{	// check for name match
         ;    1981 				if (fpath[c] == _FF_buff[calc+c])
         ;    1982 					valid_flag = 1;
         ;    1983 				else if (fpath[c] == 0)
         ;    1984 				{
         ;    1985 					if (_FF_buff[calc+c]==0x20)
         ;    1986 						break;
         ;    1987 				}
         ;    1988 				else
         ;    1989 				{
         ;    1990 					valid_flag = 0;	
         ;    1991 					break;
         ;    1992 				}
         ;    1993 		    }   
         ;    1994 		    if (valid_flag)
         ;    1995 	  		{
         ;    1996 	  			if (_FF_buff[calc+0xB] != 0x10)	// not a directory
         ;    1997 	  				valid_flag = 0;
         ;    1998 	  			else
         ;    1999 	  			{
         ;    2000 	  				c = ((int) _FF_buff[calc+0x1B] << 8) | ((int) _FF_buff[calc+0x1A]);
         ;    2001 					_FF_DIR_ADDR = clust_to_addr(c);
         ;    2002 					sp = F_PATH;
         ;    2003 					if (*sp=='\\')
         ;    2004 					{	// Restart String @root
         ;    2005 						qp = _FF_FULL_PATH + 1;
         ;    2006 						*qp = 0;
         ;    2007 						sp++;
         ;    2008 					}
         ;    2009 					else
         ;    2010 						qp = _FF_FULL_PATH + strlen(_FF_FULL_PATH);
         ;    2011 					while (*sp)
         ;    2012 					{
         ;    2013 						if ((*sp=='.')&&(*(sp+1)=='.'))
         ;    2014 						{
         ;    2015 							#ifdef _ICCAVR_
         ;    2016 								qp = strrchr(_FF_FULL_PATH, '\\');
         ;    2017 								if (qp==0)
         ;    2018 								   return (EOF);
         ;    2019 								*qp = 0;
         ;    2020 								qp = strrchr(_FF_FULL_PATH, '\\');
         ;    2021 								if (qp==0)
         ;    2022 								   return (EOF);
         ;    2023 								qp++;
         ;    2024 							#endif
         ;    2025 							#ifdef _CVAVR_
         ;    2026 								_FF_FULL_PATH[strrpos(_FF_FULL_PATH, '\\')] = 0;
         ;    2027 								c = strrpos(_FF_FULL_PATH, '\\');
         ;    2028 								if (c==EOF)
         ;    2029 								   return (EOF);
         ;    2030 								qp = _FF_FULL_PATH + c;
         ;    2031 							#endif
         ;    2032 							*qp = 0;
         ;    2033 							sp += 2;
         ;    2034 						}
         ;    2035 						else 
         ;    2036 							*qp++ = toupper(*sp++);
         ;    2037 					}
         ;    2038 					*qp++ = '\\';
         ;    2039 					*qp = 0;
         ;    2040 					return (0);
         ;    2041 				}
         ;    2042 			}
         ;    2043 		  	d++;		  		
         ;    2044 		}
         ;    2045 		m++;
         ;    2046 	}
         ;    2047 	_FF_DIR_ADDR = addr_temp;
         ;    2048 	return (EOF);
         ;    2049 }
         ;    2050 
         ;    2051 // Function to change directories one at a time, not effecting the working dir string
         ;    2052 int _FF_chdir(char *F_PATH)
         ;    2053 {
          __FF_chdir:
         ;    2054 	unsigned char *qp, *sp, valid_flag, fpath[14];
         ;    2055 	unsigned int m, n, c, d, calc;
         ;    2056     
         ;    2057 	if ((F_PATH[0]=='.') && (F_PATH[1]=='.') && (F_PATH[2]==0))
0010ec 9768      	SBIW R28,24
0010ed 940e 2305 	CALL __SAVELOCR5
         ;	*F_PATH -> Y+29
         ;	*qp -> R16,R17
         ;	*sp -> R18,R19
         ;	valid_flag -> R20
         ;	fpath -> Y+15
         ;	m -> Y+13
         ;	n -> Y+11
         ;	c -> Y+9
         ;	d -> Y+7
         ;	calc -> Y+5
0010ef 8dad      	LDD  R26,Y+29
0010f0 8dbe      	LDD  R27,Y+29+1
0010f1 91ac      	LD   R26,X
0010f2 32ae      	CPI  R26,LOW(0x2E)
0010f3 f461      	BRNE _0x232
0010f4 8dad      	LDD  R26,Y+29
0010f5 8dbe      	LDD  R27,Y+29+1
0010f6 9611      	ADIW R26,1
0010f7 91ac      	LD   R26,X
0010f8 32ae      	CPI  R26,LOW(0x2E)
0010f9 f431      	BRNE _0x232
0010fa 8dad      	LDD  R26,Y+29
0010fb 8dbe      	LDD  R27,Y+29+1
0010fc 9612      	ADIW R26,2
0010fd 91ac      	LD   R26,X
0010fe 30a0      	CPI  R26,LOW(0x0)
0010ff f009      	BREQ _0x233
          _0x232:
001100 c048      	RJMP _0x231
          _0x233:
         ;    2058 	{	// trying to get back to prev dir
         ;    2059 		if (_FF_DIR_ADDR == _FF_ROOT_ADDR)		// already as far back as can go
001101 91e0 0722 	LDS  R30,__FF_ROOT_ADDR
001103 91f0 0723 	LDS  R31,__FF_ROOT_ADDR+1
001105 9160 0724 	LDS  R22,__FF_ROOT_ADDR+2
001107 9170 0725 	LDS  R23,__FF_ROOT_ADDR+3
001109 91a0 0726 	LDS  R26,__FF_DIR_ADDR
00110b 91b0 0727 	LDS  R27,__FF_DIR_ADDR+1
00110d 9180 0728 	LDS  R24,__FF_DIR_ADDR+2
00110f 9190 0729 	LDS  R25,__FF_DIR_ADDR+3
001111 940e 22fa 	CALL __CPD12
001113 f419      	BRNE _0x234
         ;    2060 			return (EOF);
001114 efef      	LDI  R30,LOW(65535)
001115 efff      	LDI  R31,HIGH(65535)
001116 c0f5      	RJMP _0x3E1
         ;    2061 		if (_FF_read(_FF_DIR_ADDR)==0)
          _0x234:
001117 91e0 0726 	LDS  R30,__FF_DIR_ADDR
001119 91f0 0727 	LDS  R31,__FF_DIR_ADDR+1
00111b 9160 0728 	LDS  R22,__FF_DIR_ADDR+2
00111d 9170 0729 	LDS  R23,__FF_DIR_ADDR+3
00111f 940e 1cae 	CALL SUBOPT_0xC
001121 f419      	BRNE _0x235
         ;    2062 			return (EOF);
001122 efef      	LDI  R30,LOW(65535)
001123 efff      	LDI  R31,HIGH(65535)
001124 c0e7      	RJMP _0x3E1
         ;    2063 		m = ((unsigned int) _FF_buff[0x3B] << 8) | (unsigned int) _FF_buff[0x3A];
          _0x235:
001125   +  	__GETBRMN __FF_buff,59,27
001127 e0a0      	LDI  R26,LOW(0)
001128   +  	__GETB1MN __FF_buff,58
00112a e0f0      	LDI  R31,0
00112b 2bea      	OR   R30,R26
00112c 2bfb      	OR   R31,R27
00112d 87ed      	STD  Y+13,R30
00112e 87fe      	STD  Y+13+1,R31
         ;    2064 		if (m)
00112f 9730      	SBIW R30,0
001130 f029      	BREQ _0x236
         ;    2065 			_FF_DIR_ADDR = clust_to_addr(m);
001131 93fa      	ST   -Y,R31
001132 93ea      	ST   -Y,R30
001133 940e 0a53 	CALL _clust_to_addr
001135 c008      	RJMP _0x3F5
         ;    2066 		else
          _0x236:
         ;    2067 			_FF_DIR_ADDR = _FF_ROOT_ADDR;
001136 91e0 0722 	LDS  R30,__FF_ROOT_ADDR
001138 91f0 0723 	LDS  R31,__FF_ROOT_ADDR+1
00113a 9160 0724 	LDS  R22,__FF_ROOT_ADDR+2
00113c 9170 0725 	LDS  R23,__FF_ROOT_ADDR+3
          _0x3F5:
00113e 93e0 0726 	STS  __FF_DIR_ADDR,R30
001140 93f0 0727 	STS  __FF_DIR_ADDR+1,R31
001142 9360 0728 	STS  __FF_DIR_ADDR+2,R22
001144 9370 0729 	STS  __FF_DIR_ADDR+3,R23
         ;    2068 		return (0);
001146 e0e0      	LDI  R30,LOW(0)
001147 e0f0      	LDI  R31,HIGH(0)
001148 c0c3      	RJMP _0x3E1
         ;    2069 	}
         ;    2070 		
         ;    2071 	qp = F_PATH;
          _0x231:
001149   +  	__GETWRS 16,17,29
         ;    2072 	sp = fpath;
00114b 01fe      	MOVW R30,R28
00114c 963f      	ADIW R30,15
00114d   +  	__PUTW1R 18,19
         ;    2073 	while(sp < (fpath+11))
          _0x238:
00114f 01fe      	MOVW R30,R28
001150 967a      	ADIW R30,26
001151 172e      	CP   R18,R30
001152 073f      	CPC  R19,R31
001153 f518      	BRSH _0x23A
         ;    2074 	{
         ;    2075 		if (valid_file_char(*qp)==0)
001154   +  	__GETW2R 16,17
001156 940e 1d25 	CALL SUBOPT_0x1B
001158 f471      	BRNE _0x23B
         ;    2076 			*sp++ = toupper(*qp++);
001159 933f      	PUSH R19
00115a 932f      	PUSH R18
00115b   +  	__ADDWRN 18,19,1
00115d   +  	__GETW2R 16,17
00115f   +  	__ADDWRN 16,17,1
001161 940e 1e4f 	CALL SUBOPT_0x37
001163 91af      	POP  R26
001164 91bf      	POP  R27
001165 93ec      	ST   X,R30
         ;    2077 		else if (*qp==0)
001166 c00f      	RJMP _0x23C
          _0x23B:
001167   +  	__GETW2R 16,17
001169 91ec      	LD   R30,X
00116a 30e0      	CPI  R30,0
00116b f439      	BRNE _0x23D
         ;    2078 			*sp++ = 0x20;
00116c   +  	__GETW2R 18,19
00116e   +  	__ADDWRN 18,19,1
001170 e2e0      	LDI  R30,LOW(32)
001171 93ec      	ST   X,R30
         ;    2079 		else
001172 c003      	RJMP _0x23E
          _0x23D:
         ;    2080 			return (EOF);
001173 efef      	LDI  R30,LOW(65535)
001174 efff      	LDI  R31,HIGH(65535)
001175 c096      	RJMP _0x3E1
         ;    2081 	}     
          _0x23E:
          _0x23C:
001176 cfd8      	RJMP _0x238
          _0x23A:
         ;    2082 	*sp = 0;
001177   +  	__GETW2R 18,19
001179 e0e0      	LDI  R30,LOW(0)
00117a 93ec      	ST   X,R30
         ;    2083 	m = 0;
00117b e0e0      	LDI  R30,0
00117c 87ed      	STD  Y+13,R30
00117d 87ee      	STD  Y+13+1,R30
         ;    2084 	d = 0;
00117e e0e0      	LDI  R30,0
00117f 83ef      	STD  Y+7,R30
001180 87e8      	STD  Y+7+1,R30
         ;    2085 	valid_flag = 0;
001181 e040      	LDI  R20,LOW(0)
         ;    2086 	while (d<BPB_RootEntCnt)
          _0x23F:
001182 81af      	LDD  R26,Y+7
001183 85b8      	LDD  R27,Y+7+1
001184 15ac      	CP   R26,R12
001185 05bd      	CPC  R27,R13
001186 f010      	BRLO PC+3
001187 940c 120a 	JMP _0x241
         ;    2087 	{
         ;    2088     	_FF_read(_FF_DIR_ADDR+(m*0x200));
001189 85ed      	LDD  R30,Y+13
00118a 85fe      	LDD  R31,Y+13+1
00118b 940e 1f78 	CALL SUBOPT_0x5A
00118d 940e 07e8 	CALL __FF_read
         ;    2089 		for (n=0; n<16; n++)
00118f e0e0      	LDI  R30,0
001190 87eb      	STD  Y+11,R30
001191 87ec      	STD  Y+11+1,R30
          _0x243:
001192 85ab      	LDD  R26,Y+11
001193 85bc      	LDD  R27,Y+11+1
001194 31a0      	CPI  R26,LOW(0x10)
001195 e0e0      	LDI  R30,HIGH(0x10)
001196 07be      	CPC  R27,R30
001197 f010      	BRLO PC+3
001198 940c 1204 	JMP _0x244
         ;    2090 		{
         ;    2091 			calc = (n*0x20);
00119a 85eb      	LDD  R30,Y+11
00119b 85fc      	LDD  R31,Y+11+1
00119c 0fee      	LSL  R30
00119d 1fff      	ROL  R31
00119e 940e 2213 	CALL __LSLW4
0011a0 83ed      	STD  Y+5,R30
0011a1 83fe      	STD  Y+5+1,R31
         ;    2092 			if (_FF_buff[calc] == 0)	// no more entries in dir
0011a2 5fec      	SUBI R30,LOW(-__FF_buff)
0011a3 4ffa      	SBCI R31,HIGH(-__FF_buff)
0011a4 81e0      	LD   R30,Z
0011a5 30e0      	CPI  R30,0
0011a6 f419      	BRNE _0x245
         ;    2093 				return (EOF);
0011a7 efef      	LDI  R30,LOW(65535)
0011a8 efff      	LDI  R31,HIGH(65535)
0011a9 c062      	RJMP _0x3E1
         ;    2094 			for (c=0; c<11; c++)
          _0x245:
0011aa e0e0      	LDI  R30,0
0011ab 87e9      	STD  Y+9,R30
0011ac 87ea      	STD  Y+9+1,R30
          _0x247:
0011ad 85a9      	LDD  R26,Y+9
0011ae 85ba      	LDD  R27,Y+9+1
0011af 30ab      	CPI  R26,LOW(0xB)
0011b0 e0e0      	LDI  R30,HIGH(0xB)
0011b1 07be      	CPC  R27,R30
0011b2 f508      	BRSH _0x248
         ;    2095 			{	// check for name match
         ;    2096 				if (fpath[c] == _FF_buff[calc+c])
0011b3 85e9      	LDD  R30,Y+9
0011b4 85fa      	LDD  R31,Y+9+1
0011b5 01de      	MOVW R26,R28
0011b6 961f      	ADIW R26,15
0011b7 0fae      	ADD  R26,R30
0011b8 1fbf      	ADC  R27,R31
0011b9 91ec      	LD   R30,X
0011ba 93ef      	PUSH R30
0011bb 85e9      	LDD  R30,Y+9
0011bc 85fa      	LDD  R31,Y+9+1
0011bd 81ad      	LDD  R26,Y+5
0011be 81be      	LDD  R27,Y+5+1
0011bf 0fea      	ADD  R30,R26
0011c0 1ffb      	ADC  R31,R27
0011c1 5fec      	SUBI R30,LOW(-__FF_buff)
0011c2 4ffa      	SBCI R31,HIGH(-__FF_buff)
0011c3 81e0      	LD   R30,Z
0011c4 91af      	POP  R26
0011c5 17ea      	CP   R30,R26
0011c6 f411      	BRNE _0x249
         ;    2097 					valid_flag = 1;
0011c7 e041      	LDI  R20,LOW(1)
         ;    2098 				else
0011c8 c005      	RJMP _0x24A
          _0x249:
         ;    2099 				{
         ;    2100 					valid_flag = 0;	
0011c9 e040      	LDI  R20,LOW(0)
         ;    2101 					c = 11;
0011ca e0eb      	LDI  R30,LOW(11)
0011cb e0f0      	LDI  R31,HIGH(11)
0011cc 87e9      	STD  Y+9,R30
0011cd 87fa      	STD  Y+9+1,R31
         ;    2102 				}
          _0x24A:
         ;    2103 		    }   
0011ce 85e9      	LDD  R30,Y+9
0011cf 85fa      	LDD  R31,Y+9+1
0011d0 9631      	ADIW R30,1
0011d1 87e9      	STD  Y+9,R30
0011d2 87fa      	STD  Y+9+1,R31
0011d3 cfd9      	RJMP _0x247
          _0x248:
         ;    2104 		    if (valid_flag)
0011d4 3040      	CPI  R20,0
0011d5 f119      	BREQ _0x24B
         ;    2105 	  		{
         ;    2106 	  			if (_FF_buff[calc+0xB] != 0x10)	// not a directory
0011d6 81ed      	LDD  R30,Y+5
0011d7 81fe      	LDD  R31,Y+5+1
0011d8 940e 1f8b 	CALL SUBOPT_0x5B
0011da 31e0      	CPI  R30,LOW(0x10)
0011db f011      	BREQ _0x24C
         ;    2107 	  				valid_flag = 0;
0011dc e040      	LDI  R20,LOW(0)
         ;    2108 	  			else
0011dd c01b      	RJMP _0x24D
          _0x24C:
         ;    2109 	  			{
         ;    2110 	  				c = ((int) _FF_buff[calc+0x1B] << 8) | ((int) _FF_buff[calc+0x1A]);
0011de 81ed      	LDD  R30,Y+5
0011df 81fe      	LDD  R31,Y+5+1
0011e0 967b      	ADIW R30,27
0011e1 940e 1e5a 	CALL SUBOPT_0x39
0011e3 01df      	MOVW R26,R30
0011e4 81ed      	LDD  R30,Y+5
0011e5 81fe      	LDD  R31,Y+5+1
0011e6 940e 1f90 	CALL SUBOPT_0x5C
0011e8 87e9      	STD  Y+9,R30
0011e9 87fa      	STD  Y+9+1,R31
         ;    2111 					_FF_DIR_ADDR = clust_to_addr(c);
0011ea 93fa      	ST   -Y,R31
0011eb 93ea      	ST   -Y,R30
0011ec 940e 0a53 	CALL _clust_to_addr
0011ee 93e0 0726 	STS  __FF_DIR_ADDR,R30
0011f0 93f0 0727 	STS  __FF_DIR_ADDR+1,R31
0011f2 9360 0728 	STS  __FF_DIR_ADDR+2,R22
0011f4 9370 0729 	STS  __FF_DIR_ADDR+3,R23
         ;    2112 					return (0);
0011f6 e0e0      	LDI  R30,LOW(0)
0011f7 e0f0      	LDI  R31,HIGH(0)
0011f8 c013      	RJMP _0x3E1
         ;    2113 				}
          _0x24D:
         ;    2114 			}
         ;    2115 		  	d++;		  		
          _0x24B:
0011f9 81ef      	LDD  R30,Y+7
0011fa 85f8      	LDD  R31,Y+7+1
0011fb 9631      	ADIW R30,1
0011fc 83ef      	STD  Y+7,R30
0011fd 87f8      	STD  Y+7+1,R31
         ;    2116 		}
0011fe 85eb      	LDD  R30,Y+11
0011ff 85fc      	LDD  R31,Y+11+1
001200 9631      	ADIW R30,1
001201 87eb      	STD  Y+11,R30
001202 87fc      	STD  Y+11+1,R31
001203 cf8e      	RJMP _0x243
          _0x244:
         ;    2117 		m++;
001204 85ed      	LDD  R30,Y+13
001205 85fe      	LDD  R31,Y+13+1
001206 9631      	ADIW R30,1
001207 87ed      	STD  Y+13,R30
001208 87fe      	STD  Y+13+1,R31
         ;    2118 	}
001209 cf78      	RJMP _0x23F
          _0x241:
         ;    2119 	return (EOF);
00120a efef      	LDI  R30,LOW(65535)
00120b efff      	LDI  R31,HIGH(65535)
          _0x3E1:
00120c 940e 230c 	CALL __LOADLOCR5
00120e 966f      	ADIW R28,31
00120f 9508      	RET
         ;    2120 }
         ;    2121 
         ;    2122 #ifndef _SECOND_FAT_ON_
         ;    2123 // Function that clears the secondary FAT table
         ;    2124 int clear_second_FAT(void)
         ;    2125 {
         ;    2126 	unsigned int c, d;
         ;    2127 	unsigned long n;
         ;    2128 	
         ;    2129 	for (n=1; n<BPB_FATSz16; n++)
         ;    2130 	{
         ;    2131 		if (_FF_read(_FF_FAT2_ADDR+(n*0x200))==0)
         ;    2132 			return (EOF);
         ;    2133 		for (c=0; c<BPB_BytsPerSec; c++)
         ;    2134 		{
         ;    2135 			if (_FF_buff[c] != 0)
         ;    2136 			{
         ;    2137 				for (d=0; d<BPB_BytsPerSec; d++)
         ;    2138 					_FF_buff[d] = 0;
         ;    2139 				if (_FF_write(_FF_FAT2_ADDR+(n*0x200))==0)
         ;    2140 					return (EOF);
         ;    2141 				break;
         ;    2142 			}
         ;    2143 		}
         ;    2144 	}
         ;    2145 	for (d=2; d<BPB_BytsPerSec; d++)
         ;    2146 		_FF_buff[d] = 0;
         ;    2147 	_FF_buff[0] = 0xF8;
         ;    2148 	_FF_buff[1] = 0xFF;
         ;    2149 	_FF_buff[2] = 0xFF;
         ;    2150 	if (BPB_FATType == 0x36)
         ;    2151 		_FF_buff[3] = 0xFF;
         ;    2152 	if (_FF_write(_FF_FAT2_ADDR)==0)
         ;    2153 		return (EOF);
         ;    2154 	
         ;    2155 	return (1);
         ;    2156 }
         ;    2157 #endif
         ;    2158  
         ;    2159 // Open a file, name stored in string fileopen
         ;    2160 FILE *fopenc(unsigned char flash *NAMEC, unsigned char MODEC)
         ;    2161 {
         ;    2162 	unsigned char c, temp_data[12];
         ;    2163 	FILE *tp;
         ;    2164 	
         ;    2165 	for (c=0; c<12; c++)
         ;	*NAMEC -> Y+16
         ;	MODEC -> Y+15
         ;	c -> R16
         ;	temp_data -> Y+3
         ;	*tp -> R17,R18
         ;    2166 		temp_data[c] = NAMEC[c];
         ;    2167 	
         ;    2168 	tp = fopen(temp_data, MODEC);
         ;    2169 	return(tp);
         ;    2170 }
         ;    2171 
         ;    2172 FILE *fopen(unsigned char *NAME, unsigned char MODE)
         ;    2173 {
          _fopen:
         ;    2174 	unsigned char fpath[14];
         ;    2175 	unsigned int c, s, calc_temp;
         ;    2176 	unsigned char *sp, *qp;
         ;    2177 	unsigned long addr_temp, path_addr_temp;
         ;    2178 	FILE *rp;
         ;    2179 	
         ;    2180 	#ifdef _READ_ONLY_
         ;    2181 		if (MODE!=READ)
         ;    2182 			return (0);
         ;    2183 	#endif
         ;    2184 	
         ;    2185     addr_temp = 0;	// save local dir addr
001210 940e 1f98 	CALL SUBOPT_0x5D
         ;	*NAME -> Y+35
         ;	MODE -> Y+34
         ;	fpath -> Y+20
         ;	c -> R16,R17
         ;	s -> R18,R19
         ;	calc_temp -> R20,R21
         ;	*sp -> Y+18
         ;	*qp -> Y+16
         ;	addr_temp -> Y+12
         ;	path_addr_temp -> Y+8
         ;	*rp -> Y+6
         ;    2186     
         ;    2187     if (_FF_checkdir(NAME, &addr_temp, fpath))
001212 f019      	BREQ _0x251
         ;    2188 	{
         ;    2189 		_FF_DIR_ADDR = addr_temp;
001213 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2190 		return (0);
001215 c295      	RJMP _0x3E0
         ;    2191 	}
         ;    2192 	if (fpath[0]==0)
          _0x251:
001216 89ec      	LDD  R30,Y+20
001217 30e0      	CPI  R30,0
001218 f419      	BRNE _0x252
         ;    2193 	{
         ;    2194 		_FF_DIR_ADDR = addr_temp;
001219 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2195 		return (0);
00121b c28f      	RJMP _0x3E0
         ;    2196 	}
         ;    2197     
         ;    2198 	path_addr_temp = _FF_DIR_ADDR;
          _0x252:
00121c 940e 1fbf 	CALL SUBOPT_0x5F
         ;    2199 	s = scan_directory(&path_addr_temp, fpath);
         ;    2200 	if ((path_addr_temp==0) || (s==0))
00121e   +  	__GETD2S 8
001222 940e 22f4 	CALL __CPD02
001224 f021      	BREQ _0x254
001225 2400      	CLR  R0
001226 1602      	CP   R0,R18
001227 0603      	CPC  R0,R19
001228 f419      	BRNE _0x253
          _0x254:
         ;    2201 	{
         ;    2202 		_FF_DIR_ADDR = addr_temp;
001229 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2203 		return (0);
00122b c27f      	RJMP _0x3E0
         ;    2204 	}
         ;    2205 
         ;    2206 	rp = 0;
          _0x253:
00122c e0e0      	LDI  R30,0
00122d 83ee      	STD  Y+6,R30
00122e 83ef      	STD  Y+6+1,R30
         ;    2207 	rp = malloc(sizeof(FILE));
00122f e2e9      	LDI  R30,LOW(553)
001230 e0f2      	LDI  R31,HIGH(553)
001231 93fa      	ST   -Y,R31
001232 93ea      	ST   -Y,R30
001233 940e 1c25 	CALL _malloc
001235 940e 1fd8 	CALL SUBOPT_0x60
         ;    2208 	if (rp == 0)
001237 f431      	BRNE _0x256
         ;    2209 	{	// Could not allocate requested memory
         ;    2210 		_FF_error = ALLOC_ERR;
001238 e0e9      	LDI  R30,LOW(9)
001239 93e0 073c 	STS  __FF_error,R30
         ;    2211 		_FF_DIR_ADDR = addr_temp;
00123b 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2212 		return (0);
00123d c26d      	RJMP _0x3E0
         ;    2213 	}
         ;    2214 	rp->length = 0x46344456;
          _0x256:
00123e 81ae      	LDD  R26,Y+6
00123f 81bf      	LDD  R27,Y+6+1
001240 5ea4      	SUBI R26,LOW(-540)
001241 4fbd      	SBCI R27,HIGH(-540)
001242   +  	__GETD1N 0x46344456
001246 940e 22c8 	CALL __PUTDP1
         ;    2215 	rp->clus_start = 0xe4;
001248 81ae      	LDD  R26,Y+6
001249 81bf      	LDD  R27,Y+6+1
00124a 961c      	ADIW R26,12
00124b eee4      	LDI  R30,LOW(228)
00124c e0f0      	LDI  R31,HIGH(228)
00124d 93ed      	ST   X+,R30
00124e 93fc      	ST   X,R31
         ;    2216 	rp->position = 0x45664446;
00124f 81ae      	LDD  R26,Y+6
001250 81bf      	LDD  R27,Y+6+1
001251 5ea0      	SUBI R26,LOW(-544)
001252 4fbd      	SBCI R27,HIGH(-544)
001253   +  	__GETD1N 0x45664446
001257 940e 22c8 	CALL __PUTDP1
         ;    2217 
         ;    2218 	calc_temp = path_addr_temp % BPB_BytsPerSec;
001259 940e 1fdc 	CALL SUBOPT_0x61
         ;    2219 	path_addr_temp -= calc_temp;
00125b 940e 1fef 	CALL SUBOPT_0x62
         ;    2220 	if (_FF_read(path_addr_temp)==0)	
00125d f419      	BRNE _0x257
         ;    2221 	{
         ;    2222 		_FF_DIR_ADDR = addr_temp;
00125e 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2223 		return (0);
001260 c24a      	RJMP _0x3E0
         ;    2224 	}
         ;    2225 	
         ;    2226 	// Get the filename into a form we can use to compare
         ;    2227 	qp = file_name_conversion(fpath);
          _0x257:
001261 940e 1ff4 	CALL SUBOPT_0x63
         ;    2228 	if (qp==0)
001263 f419      	BRNE _0x258
         ;    2229 	{	// If File name entered is NOT valid, return 0
         ;    2230 		free(rp);
001264 940e 1ffe 	CALL SUBOPT_0x64
         ;    2231 		_FF_DIR_ADDR = addr_temp;
         ;    2232 		return (0);
001266 c244      	RJMP _0x3E0
         ;    2233 	}
         ;    2234 	
         ;    2235 	sp = &_FF_buff[calc_temp];
          _0x258:
001267 940e 2004 	CALL SUBOPT_0x65
         ;    2236 
         ;    2237 	if (s)
001269 f411      	BRNE PC+3
00126a 940c 1398 	JMP _0x259
         ;    2238 	{	// File exists, open 
         ;    2239 		if (((MODE==WRITE) || (MODE==APPEND)) && (_FF_buff[calc_temp+0x0B]&0x01))
00126c a1aa      	LDD  R26,Y+34
00126d 30a2      	CPI  R26,LOW(0x2)
00126e f011      	BREQ _0x25B
00126f 30a3      	CPI  R26,LOW(0x3)
001270 f431      	BRNE _0x25D
          _0x25B:
001271   +  	__GETW1R 20,21
001273 940e 1f8b 	CALL SUBOPT_0x5B
001275 70e1      	ANDI R30,LOW(0x1)
001276 f409      	BRNE _0x25E
          _0x25D:
001277 c003      	RJMP _0x25A
          _0x25E:
         ;    2240 		{	// if writing to file verify it is not "READ ONLY"
         ;    2241 			_FF_error = MODE_ERR;
001278 940e 200d 	CALL SUBOPT_0x66
         ;    2242 			free(rp);
         ;    2243 			_FF_DIR_ADDR = addr_temp;
         ;    2244 			return (0);
00127a c230      	RJMP _0x3E0
         ;    2245 		}
         ;    2246 		for (c=0; c<12; c++)	// Save Filename to Buffer
          _0x25A:
00127b   +  	__GETWRN 16,17,0
          _0x260:
00127d   +  	__CPWRN 16,17,12
001280 f498      	BRSH _0x261
         ;    2247 			rp->name[c] = FILENAME[c];
001281   +  	__GETW1R 16,17
001283 81ae      	LDD  R26,Y+6
001284 81bf      	LDD  R27,Y+6+1
001285 0fea      	ADD  R30,R26
001286 1ffb      	ADC  R31,R27
001287 93ff      	PUSH R31
001288 93ef      	PUSH R30
001289 ebaa      	LDI  R26,LOW(_FILENAME)
00128a e0b7      	LDI  R27,HIGH(_FILENAME)
00128b 0fa0      	ADD  R26,R16
00128c 1fb1      	ADC  R27,R17
00128d 91ec      	LD   R30,X
00128e 91af      	POP  R26
00128f 91bf      	POP  R27
001290 93ec      	ST   X,R30
         ;    2248 		// Save Starting Cluster
         ;    2249 		rp->clus_start = ((int) _FF_buff[calc_temp+0x1B] << 8) | (int) _FF_buff[calc_temp+0x1A];
001291   +  	__ADDWRN 16,17,1
001293 cfe9      	RJMP _0x260
          _0x261:
001294   +  	__GETW1R 20,21
001296 967b      	ADIW R30,27
001297 940e 1e5a 	CALL SUBOPT_0x39
001299 01df      	MOVW R26,R30
00129a   +  	__GETW1R 20,21
00129c 940e 1f90 	CALL SUBOPT_0x5C
00129e   +  	__PUTW1SNS 6,12
         ;    2250 		// Set Current Cluster
         ;    2251 		rp->clus_current = rp->clus_start;
0012a3 940e 2011 	CALL SUBOPT_0x67
0012a5   +  	__PUTW1SNS 6,14
         ;    2252 		// Set Previous Cluster to 0 (indicating @start)
         ;    2253 		rp->clus_prev = 0;
0012aa 81ae      	LDD  R26,Y+6
0012ab 81bf      	LDD  R27,Y+6+1
0012ac 940e 2017 	CALL SUBOPT_0x68
         ;    2254 		// Save file length
         ;    2255 		rp->length = 0;
0012ae 940e 201d 	CALL SUBOPT_0x69
         ;    2256 		sp = _FF_buff + calc_temp + 0x1F;
0012b0 940e 2028 	CALL SUBOPT_0x6A
         ;    2257 		for (c=0; c<4; c++)
0012b2   +  	__GETWRN 16,17,0
          _0x263:
0012b4   +  	__CPWRN 16,17,4
0012b7 f590      	BRSH _0x264
         ;    2258 		{
         ;    2259 			rp->length <<= 8;
0012b8 81ee      	LDD  R30,Y+6
0012b9 81ff      	LDD  R31,Y+6+1
0012ba 5ee4      	SUBI R30,LOW(-540)
0012bb 4ffd      	SBCI R31,HIGH(-540)
0012bc 93ff      	PUSH R31
0012bd 93ef      	PUSH R30
0012be 01df      	MOVW R26,R30
0012bf 940e 22c2 	CALL __GETD1P
0012c1 01df      	MOVW R26,R30
0012c2 01cb      	MOVW R24,R22
0012c3 e0e8      	LDI  R30,LOW(8)
0012c4 940e 21fb 	CALL __LSLD12
0012c6 91af      	POP  R26
0012c7 91bf      	POP  R27
0012c8 940e 22c8 	CALL __PUTDP1
         ;    2260 			rp->length |= *sp--;
0012ca 81ee      	LDD  R30,Y+6
0012cb 81ff      	LDD  R31,Y+6+1
0012cc 5ee4      	SUBI R30,LOW(-540)
0012cd 4ffd      	SBCI R31,HIGH(-540)
0012ce 93ff      	PUSH R31
0012cf 93ef      	PUSH R30
0012d0 01df      	MOVW R26,R30
0012d1 940e 22c2 	CALL __GETD1P
0012d3 937f      	PUSH R23
0012d4 936f      	PUSH R22
0012d5 93ff      	PUSH R31
0012d6 93ef      	PUSH R30
0012d7 940e 2030 	CALL SUBOPT_0x6B
0012d9 91ec      	LD   R30,X
0012da 91af      	POP  R26
0012db 91bf      	POP  R27
0012dc 918f      	POP  R24
0012dd 919f      	POP  R25
0012de 27ff      	CLR  R31
0012df 2766      	CLR  R22
0012e0 2777      	CLR  R23
0012e1 940e 21ed 	CALL __ORD12
0012e3 91af      	POP  R26
0012e4 91bf      	POP  R27
0012e5 940e 22c8 	CALL __PUTDP1
         ;    2261 		}
0012e7   +  	__ADDWRN 16,17,1
0012e9 cfca      	RJMP _0x263
          _0x264:
         ;    2262 		// Set Current Position to 0
         ;    2263 		rp->position = 0;
0012ea 81ae      	LDD  R26,Y+6
0012eb 81bf      	LDD  R27,Y+6+1
0012ec 5ea0      	SUBI R26,LOW(-544)
0012ed 4fbd      	SBCI R27,HIGH(-544)
0012ee   +  	__GETD1N 0x0
0012f2 940e 22c8 	CALL __PUTDP1
         ;    2264 		#ifndef _READ_ONLY_
         ;    2265 			if (MODE==WRITE)
0012f4 a1aa      	LDD  R26,Y+34
0012f5 30a2      	CPI  R26,LOW(0x2)
0012f6 f551      	BRNE _0x265
         ;    2266 			{	// Change file to blank
         ;    2267 				sp = _FF_buff + calc_temp + 0x1F;
0012f7 940e 2028 	CALL SUBOPT_0x6A
         ;    2268 				for (c=0; c<6; c++)
0012f9   +  	__GETWRN 16,17,0
          _0x267:
0012fb   +  	__CPWRN 16,17,6
0012fe f438      	BRSH _0x268
         ;    2269 					*sp-- = 0;
0012ff 940e 2030 	CALL SUBOPT_0x6B
001301 e0e0      	LDI  R30,LOW(0)
001302 93ec      	ST   X,R30
         ;    2270 				if (rp->length)
001303   +  	__ADDWRN 16,17,1
001305 cff5      	RJMP _0x267
          _0x268:
001306 940e 2037 	CALL SUBOPT_0x6C
001308 f0c1      	BREQ _0x269
         ;    2271 				{
         ;    2272 					if (_FF_write(_FF_DIR_ADDR + (0x200 * s))==0)
001309   +  	__GETW1R 18,19
00130b 940e 1f78 	CALL SUBOPT_0x5A
00130d 940e 0854 	CALL __FF_write
00130f 30e0      	CPI  R30,0
001310 f419      	BRNE _0x26A
         ;    2273 					{
         ;    2274 						free(rp);
001311 940e 1ffe 	CALL SUBOPT_0x64
         ;    2275 						_FF_DIR_ADDR = addr_temp;
         ;    2276 						return (0);
001313 c197      	RJMP _0x3E0
         ;    2277 					}
         ;    2278 					rp->length = 0;
          _0x26A:
001314 940e 201d 	CALL SUBOPT_0x69
         ;    2279 					erase_clus_chain(rp->clus_start);
001316 940e 2040 	CALL SUBOPT_0x6D
001318 940e 1041 	CALL _erase_clus_chain
         ;    2280 					rp->clus_start = 0;
00131a 81ae      	LDD  R26,Y+6
00131b 81bf      	LDD  R27,Y+6+1
00131c 961c      	ADIW R26,12
00131d e0e0      	LDI  R30,LOW(0)
00131e e0f0      	LDI  R31,HIGH(0)
00131f 93ed      	ST   X+,R30
001320 93fc      	ST   X,R31
         ;    2281 				}
         ;    2282 			}
          _0x269:
         ;    2283 		#endif
         ;    2284 		// Set and save next cluster #
         ;    2285 		rp->clus_next = next_cluster(rp->clus_current, SINGLE);
          _0x265:
001321 940e 2047 	CALL SUBOPT_0x6E
001323 940e 1d90 	CALL SUBOPT_0x26
001325   +  	__PUTW1SNS 6,16
         ;    2286 		if ((rp->length==0) && (rp->clus_start==0))
00132a 940e 2037 	CALL SUBOPT_0x6C
00132c f421      	BRNE _0x26C
00132d 940e 2011 	CALL SUBOPT_0x67
00132f 9730      	SBIW R30,0
001330 f009      	BREQ _0x26D
          _0x26C:
001331 c008      	RJMP _0x26B
          _0x26D:
         ;    2287 		{	// Check for Blank File 
         ;    2288 			if (MODE==READ)
001332 a1aa      	LDD  R26,Y+34
001333 30a1      	CPI  R26,LOW(0x1)
001334 f419      	BRNE _0x26E
         ;    2289 			{	// IF trying to open a blank file to read, ERROR
         ;    2290 				_FF_error = MODE_ERR;
001335 940e 200d 	CALL SUBOPT_0x66
         ;    2291 				free(rp);
         ;    2292 				_FF_DIR_ADDR = addr_temp;
         ;    2293 				return (0);
001337 c173      	RJMP _0x3E0
         ;    2294 			}
         ;    2295 			//Setup blank FILE characteristics
         ;    2296 			#ifndef _READ_ONLY_
         ;    2297 				MODE = WRITE; 
          _0x26E:
001338 e0e2      	LDI  R30,LOW(2)
001339 a3ea      	STD  Y+34,R30
         ;    2298 			#endif
         ;    2299 		}
         ;    2300 		// Save the file offset to read entry
         ;    2301 		rp->entry_sec_addr = path_addr_temp;
          _0x26B:
00133a   +  	__GETD1S 8
00133e   +  	__PUTD1SNS 6,22
         ;    2302 		rp->entry_offset =  calc_temp;
001343   +  	__GETW1R 20,21
001345   +  	__PUTW1SNS 6,26
         ;    2303 		// Set sector offset to 1
         ;    2304 		rp->sec_offset = 1;
00134a 940e 204e 	CALL SUBOPT_0x6F
         ;    2305 		if (MODE==APPEND)
00134c a1aa      	LDD  R26,Y+34
00134d 30a3      	CPI  R26,LOW(0x3)
00134e f479      	BRNE _0x26F
         ;    2306 		{
         ;    2307 			if (fseek(rp, 0,SEEK_END)==EOF)
00134f 81ee      	LDD  R30,Y+6
001350 81ff      	LDD  R31,Y+6+1
001351 940e 2056 	CALL SUBOPT_0x70
001353 e0e1      	LDI  R30,LOW(1)
001354 93ea      	ST   -Y,R30
001355 d3b5      	RCALL _fseek
001356 3fef      	CPI  R30,LOW(0xFFFF)
001357 efaf      	LDI  R26,HIGH(0xFFFF)
001358 07fa      	CPC  R31,R26
001359 f419      	BRNE _0x270
         ;    2308 			{
         ;    2309 				free(rp);
00135a 940e 1ffe 	CALL SUBOPT_0x64
         ;    2310 				_FF_DIR_ADDR = addr_temp;
         ;    2311 				return (0);
00135c c14e      	RJMP _0x3E0
         ;    2312 			}
         ;    2313 		}
          _0x270:
         ;    2314 		else
00135d c022      	RJMP _0x271
          _0x26F:
         ;    2315 		{	// Set pointer to the begining of the file
         ;    2316 			_FF_read(clust_to_addr(rp->clus_current));
00135e 940e 2047 	CALL SUBOPT_0x6E
001360 940e 0a53 	CALL _clust_to_addr
001362 940e 22d1 	CALL __PUTPARD1
001364 940e 07e8 	CALL __FF_read
         ;    2317 			for (c=0; c<BPB_BytsPerSec; c++)
001366   +  	__GETWRN 16,17,0
          _0x273:
001368   +  	__CPWRR 16,17,6,7
00136a f460      	BRSH _0x274
         ;    2318 				rp->buff[c] = _FF_buff[c];
00136b 940e 205f 	CALL SUBOPT_0x71
00136d 93ff      	PUSH R31
00136e 93ef      	PUSH R30
00136f 940e 2065 	CALL SUBOPT_0x72
001371 91af      	POP  R26
001372 91bf      	POP  R27
001373 93ec      	ST   X,R30
         ;    2319 			rp->pntr = &rp->buff[0];
001374   +  	__ADDWRN 16,17,1
001376 cff1      	RJMP _0x273
          _0x274:
001377 81ee      	LDD  R30,Y+6
001378 81ff      	LDD  R31,Y+6+1
001379 967c      	ADIW R30,28
00137a   +  	__PUTW1SN 6,551
         ;    2320 		}
          _0x271:
         ;    2321 		#ifndef _READ_ONLY_
         ;    2322 			#ifndef _SECOND_FAT_ON_
         ;    2323 				if ((MODE==WRITE) || (MODE==APPEND))
         ;    2324 					clear_second_FAT();
         ;    2325 			#endif
         ;    2326     	#endif
         ;    2327 		rp->mode = MODE;
001380 a1ea      	LDD  R30,Y+34
001381   +  	__PUTB1SN 6,548
         ;    2328 		_FF_error = NO_ERR;
001386 e0e0      	LDI  R30,LOW(0)
001387 93e0 073c 	STS  __FF_error,R30
         ;    2329 		_FF_DIR_ADDR = addr_temp;
001389   +  	__GETD1S 12
00138d 93e0 0726 	STS  __FF_DIR_ADDR,R30
00138f 93f0 0727 	STS  __FF_DIR_ADDR+1,R31
001391 9360 0728 	STS  __FF_DIR_ADDR+2,R22
001393 9370 0729 	STS  __FF_DIR_ADDR+3,R23
         ;    2330 		return(rp);
001395 81ee      	LDD  R30,Y+6
001396 81ff      	LDD  R31,Y+6+1
001397 c113      	RJMP _0x3E0
         ;    2331 	}
         ;    2332 	else
          _0x259:
         ;    2333 	{                          		
         ;    2334 		_FF_error = FILE_ERR;
001398 e0e2      	LDI  R30,LOW(2)
001399 93e0 073c 	STS  __FF_error,R30
         ;    2335 		free(rp);
00139b 940e 1ffe 	CALL SUBOPT_0x64
         ;    2336 		_FF_DIR_ADDR = addr_temp;
         ;    2337 		return(0);
00139d c10d      	RJMP _0x3E0
         ;    2338 	}
         ;    2339 }
00139e c10c      	RJMP _0x3E0
         ;    2340 
         ;    2341 #ifndef _READ_ONLY_
         ;    2342 // Create a file
         ;    2343 FILE *fcreatec(unsigned char flash *NAMEC, unsigned char MODE)
         ;    2344 {
          _fcreatec:
         ;    2345 	unsigned char sd_temp[12];
         ;    2346 	int c;
         ;    2347 
         ;    2348 	for (c=0; c<12; c++)
00139f 972c      	SBIW R28,12
0013a0 931a      	ST   -Y,R17
0013a1 930a      	ST   -Y,R16
         ;	*NAMEC -> Y+15
         ;	MODE -> Y+14
         ;	sd_temp -> Y+2
         ;	c -> R16,R17
0013a2   +  	__GETWRN 16,17,0
          _0x277:
0013a4   +  	__CPWRN 16,17,12
0013a7 f4ac      	BRGE _0x278
         ;    2349 		sd_temp[c] = NAMEC[c];
0013a8   +  	__GETW1R 16,17
0013aa 01de      	MOVW R26,R28
0013ab 9612      	ADIW R26,2
0013ac 0fea      	ADD  R30,R26
0013ad 1ffb      	ADC  R31,R27
0013ae 93ff      	PUSH R31
0013af 93ef      	PUSH R30
0013b0   +  	__GETW1R 16,17
0013b2 85af      	LDD  R26,Y+15
0013b3 89b8      	LDD  R27,Y+15+1
0013b4 0fea      	ADD  R30,R26
0013b5 1ffb      	ADC  R31,R27
0013b6 91e4      	LPM  R30,Z
0013b7 91af      	POP  R26
0013b8 91bf      	POP  R27
0013b9 93ec      	ST   X,R30
         ;    2350 	
         ;    2351 	return (fcreate(sd_temp, MODE));
0013ba   +  	__ADDWRN 16,17,1
0013bc cfe7      	RJMP _0x277
          _0x278:
0013bd 01fe      	MOVW R30,R28
0013be 9632      	ADIW R30,2
0013bf 93fa      	ST   -Y,R31
0013c0 93ea      	ST   -Y,R30
0013c1 89e8      	LDD  R30,Y+16
0013c2 93ea      	ST   -Y,R30
0013c3 d004      	RCALL _fcreate
0013c4 8119      	LDD  R17,Y+1
0013c5 8108      	LDD  R16,Y+0
0013c6 9661      	ADIW R28,17
0013c7 9508      	RET
         ;    2352 }
         ;    2353 
         ;    2354 FILE *fcreate(unsigned char *NAME, unsigned char MODE)
         ;    2355 {
          _fcreate:
         ;    2356 	unsigned char fpath[14];
         ;    2357 	unsigned int c, s, calc_temp;
         ;    2358 	unsigned char *sp, *qp;
         ;    2359 	unsigned long addr_temp, path_addr_temp;
         ;    2360 	FILE *temp_file_pntr;
         ;    2361 
         ;    2362     addr_temp = 0;	// save local dir addr
0013c8 940e 1f98 	CALL SUBOPT_0x5D
         ;	*NAME -> Y+35
         ;	MODE -> Y+34
         ;	fpath -> Y+20
         ;	c -> R16,R17
         ;	s -> R18,R19
         ;	calc_temp -> R20,R21
         ;	*sp -> Y+18
         ;	*qp -> Y+16
         ;	addr_temp -> Y+12
         ;	path_addr_temp -> Y+8
         ;	*temp_file_pntr -> Y+6
         ;    2363     
         ;    2364     if (_FF_checkdir(NAME, &addr_temp, fpath))
0013ca f031      	BREQ _0x279
         ;    2365 	{
         ;    2366 		_FF_error = PATH_ERR;
0013cb e0ee      	LDI  R30,LOW(14)
0013cc 93e0 073c 	STS  __FF_error,R30
         ;    2367 		_FF_DIR_ADDR = addr_temp;
0013ce 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2368 		return (0);
0013d0 c0da      	RJMP _0x3E0
         ;    2369 	}
         ;    2370 	if (fpath[0]==0)
          _0x279:
0013d1 89ec      	LDD  R30,Y+20
0013d2 30e0      	CPI  R30,0
0013d3 f419      	BRNE _0x27A
         ;    2371 	{
         ;    2372 		_FF_error = NAME_ERR; 
0013d4 940e 206b 	CALL SUBOPT_0x73
         ;    2373 		_FF_DIR_ADDR = addr_temp;
         ;    2374 		return (0);
0013d6 c0d4      	RJMP _0x3E0
         ;    2375 	}
         ;    2376     
         ;    2377 	path_addr_temp = _FF_DIR_ADDR;
          _0x27A:
0013d7 940e 1fbf 	CALL SUBOPT_0x5F
         ;    2378 	s = scan_directory(&path_addr_temp, fpath);
         ;    2379 	if (path_addr_temp==0)
0013d9   +  	__GETD1S 8
0013dd 940e 22e8 	CALL __CPD10
0013df f431      	BRNE _0x27B
         ;    2380 	{
         ;    2381 		_FF_error = NO_ENTRY_AVAL;
0013e0 e0ef      	LDI  R30,LOW(15)
0013e1 93e0 073c 	STS  __FF_error,R30
         ;    2382 		_FF_DIR_ADDR = addr_temp;
0013e3 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2383 		return (0);
0013e5 c0c5      	RJMP _0x3E0
         ;    2384 	}
         ;    2385 
         ;    2386 	calc_temp = path_addr_temp % BPB_BytsPerSec;
          _0x27B:
0013e6 940e 1fdc 	CALL SUBOPT_0x61
         ;    2387 	path_addr_temp -= calc_temp;
0013e8 940e 1fef 	CALL SUBOPT_0x62
         ;    2388 	if (_FF_read(path_addr_temp)==0)	
0013ea f431      	BRNE _0x27C
         ;    2389 	{
         ;    2390 		_FF_error = READ_ERR;
0013eb e0e4      	LDI  R30,LOW(4)
0013ec 93e0 073c 	STS  __FF_error,R30
         ;    2391 		_FF_DIR_ADDR = addr_temp;
0013ee 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2392 		return (0);
0013f0 c0ba      	RJMP _0x3E0
         ;    2393 	}
         ;    2394 
         ;    2395 	// Get the filename into a form we can use to compare
         ;    2396 	qp = file_name_conversion(fpath);
          _0x27C:
0013f1 940e 1ff4 	CALL SUBOPT_0x63
         ;    2397 	if (qp==0)
0013f3 f419      	BRNE _0x27D
         ;    2398 	{
         ;    2399 		_FF_error = NAME_ERR; 
0013f4 940e 206b 	CALL SUBOPT_0x73
         ;    2400 		_FF_DIR_ADDR = addr_temp;
         ;    2401 		return (0);
0013f6 c0b4      	RJMP _0x3E0
         ;    2402 	}
         ;    2403 	sp = &_FF_buff[calc_temp];
          _0x27D:
0013f7 940e 2004 	CALL SUBOPT_0x65
         ;    2404 	
         ;    2405 	if (s)
0013f9 f071      	BREQ _0x27E
         ;    2406 	{
         ;    2407 		if ((_FF_buff[calc_temp+0x0B]&0x1)==1)	// is file read only
0013fa   +  	__GETW1R 20,21
0013fc 940e 1f8b 	CALL SUBOPT_0x5B
0013fe 70e1      	ANDI R30,LOW(0x1)
0013ff 30e1      	CPI  R30,LOW(0x1)
001400 f431      	BRNE _0x27F
         ;    2408 		{
         ;    2409 			_FF_error = READONLY_ERR;
001401 e0e6      	LDI  R30,LOW(6)
001402 93e0 073c 	STS  __FF_error,R30
         ;    2410 			_FF_DIR_ADDR = addr_temp;
001404 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2411 			return (0);
001406 c0a4      	RJMP _0x3E0
         ;    2412 		}
         ;    2413 	}
          _0x27F:
         ;    2414 	else
001407 c05a      	RJMP _0x280
          _0x27E:
         ;    2415 	{
         ;    2416 		for (c=0; c<11; c++)	// Write Filename
001408   +  	__GETWRN 16,17,0
          _0x282:
00140a   +  	__CPWRN 16,17,11
00140d f480      	BRSH _0x283
         ;    2417 			*sp++ = *qp++;
00140e 940e 206f 	CALL SUBOPT_0x74
001410 9731      	SBIW R30,1
001411 93ff      	PUSH R31
001412 93ef      	PUSH R30
001413 89a8      	LDD  R26,Y+16
001414 89b9      	LDD  R27,Y+16+1
001415 91ed      	LD   R30,X+
001416 8ba8      	STD  Y+16,R26
001417 8bb9      	STD  Y+16+1,R27
001418 91af      	POP  R26
001419 91bf      	POP  R27
00141a 93ec      	ST   X,R30
         ;    2418 		*sp = 0x20;				// Attribute bit auto set to "ARCHIVE"
00141b   +  	__ADDWRN 16,17,1
00141d cfec      	RJMP _0x282
          _0x283:
00141e 89aa      	LDD  R26,Y+18
00141f 89bb      	LDD  R27,Y+18+1
001420 e2e0      	LDI  R30,LOW(32)
001421 93ec      	ST   X,R30
         ;    2419 		sp++;		
001422 940e 206f 	CALL SUBOPT_0x74
         ;    2420 		*sp++ = 0;				// Reserved for WinNT
001424 940e 2075 	CALL SUBOPT_0x75
         ;    2421 		*sp++ = 0;				// Mili-second stamp for create
001426 940e 2075 	CALL SUBOPT_0x75
         ;    2422 	
         ;    2423 		#ifdef _RTC_ON_
         ;    2424 			rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);	    			
         ;    2425     	    calc_temp = ((int)rtc_sec&0x1F) | (((int)rtc_min&0x3F)<<5) | (((int)rtc_hour&0x1F)<<11);
         ;    2426 			*sp++ = calc_temp&0x00FF;	// File create Time 
         ;    2427 			*sp++ = (calc_temp&0xFF00) >> 8;
         ;    2428 			calc_temp = ((int)rtc_date&0x1F) | (((int)rtc_month&0x0F)<<5) | (((rtc_year-1980)&0x7F)<<9);
         ;    2429 			*sp++ = calc_temp&0x00FF;	// File create Date
         ;    2430 			*sp++ = (calc_temp&0xFF00) >> 8;
         ;    2431 		#else
         ;    2432 			for (c=0; c<4; c++)
001428   +  	__GETWRN 16,17,0
          _0x285:
00142a   +  	__CPWRN 16,17,4
00142d f428      	BRSH _0x286
         ;    2433 				*sp++ = 0;
00142e 940e 2075 	CALL SUBOPT_0x75
         ;    2434 		#endif
         ;    2435 
         ;    2436 		*sp++ = 0;				// File access date (2 bytes)
001430   +  	__ADDWRN 16,17,1
001432 cff7      	RJMP _0x285
          _0x286:
001433 940e 2075 	CALL SUBOPT_0x75
         ;    2437 		*sp++ = 0;
001435 940e 2075 	CALL SUBOPT_0x75
         ;    2438 		*sp++ = 0;				// 0 for FAT12/16 (2 bytes)
001437 940e 2075 	CALL SUBOPT_0x75
         ;    2439 		*sp++ = 0;
001439 940e 2075 	CALL SUBOPT_0x75
         ;    2440 		for (c=0; c<4; c++)		// Modify time/date
00143b   +  	__GETWRN 16,17,0
          _0x288:
00143d   +  	__CPWRN 16,17,4
001440 f428      	BRSH _0x289
         ;    2441 			*sp++ = 0;
001441 940e 2075 	CALL SUBOPT_0x75
         ;    2442 		*sp++ = 0;				// Starting cluster (2 bytes)
001443   +  	__ADDWRN 16,17,1
001445 cff7      	RJMP _0x288
          _0x289:
001446 940e 2075 	CALL SUBOPT_0x75
         ;    2443 		*sp++ = 0;
001448 940e 2075 	CALL SUBOPT_0x75
         ;    2444 		for (c=0; c<4; c++)
00144a   +  	__GETWRN 16,17,0
          _0x28B:
00144c   +  	__CPWRN 16,17,4
00144f f428      	BRSH _0x28C
         ;    2445 			*sp++ = 0;			// File length (0 for new)
001450 940e 2075 	CALL SUBOPT_0x75
         ;    2446 	
         ;    2447 		if (_FF_write(path_addr_temp)==0)
001452   +  	__ADDWRN 16,17,1
001454 cff7      	RJMP _0x28B
          _0x28C:
001455   +  	__GETD1S 8
001459 940e 207e 	CALL SUBOPT_0x76
00145b f431      	BRNE _0x28D
         ;    2448 		{
         ;    2449 			_FF_error = WRITE_ERR;
00145c e0e3      	LDI  R30,LOW(3)
00145d 93e0 073c 	STS  __FF_error,R30
         ;    2450 			_FF_DIR_ADDR = addr_temp;
00145f 940e 1fb0 	CALL SUBOPT_0x5E
         ;    2451 			return (0);				
001461 c049      	RJMP _0x3E0
         ;    2452 		}
         ;    2453 	}
          _0x28D:
          _0x280:
         ;    2454 	_FF_DIR_ADDR = addr_temp;
001462   +  	__GETD1S 12
001466 93e0 0726 	STS  __FF_DIR_ADDR,R30
001468 93f0 0727 	STS  __FF_DIR_ADDR+1,R31
00146a 9360 0728 	STS  __FF_DIR_ADDR+2,R22
00146c 9370 0729 	STS  __FF_DIR_ADDR+3,R23
         ;    2455 	temp_file_pntr = fopen(NAME, WRITE);
00146e a1eb      	LDD  R30,Y+35
00146f a1fc      	LDD  R31,Y+35+1
001470 93fa      	ST   -Y,R31
001471 93ea      	ST   -Y,R30
001472 e0e2      	LDI  R30,LOW(2)
001473 93ea      	ST   -Y,R30
001474 940e 1210 	CALL _fopen
001476 940e 1fd8 	CALL SUBOPT_0x60
         ;    2456 	if (temp_file_pntr == 0)	// Will file open
001478 f419      	BRNE _0x28E
         ;    2457 		return (0);				
001479 e0e0      	LDI  R30,LOW(0)
00147a e0f0      	LDI  R31,HIGH(0)
00147b c02f      	RJMP _0x3E0
         ;    2458 	if (MODE)
          _0x28E:
00147c a1ea      	LDD  R30,Y+34
00147d 30e0      	CPI  R30,0
00147e f139      	BREQ _0x28F
         ;    2459 	{
         ;    2460 		if (_FF_read(addr_temp)==0)
00147f   +  	__GETD1S 12
001483 940e 1cae 	CALL SUBOPT_0xC
001485 f431      	BRNE _0x290
         ;    2461 		{
         ;    2462 			_FF_error = READ_ERR;
001486 e0e4      	LDI  R30,LOW(4)
001487 93e0 073c 	STS  __FF_error,R30
         ;    2463 			return (0);
001489 e0e0      	LDI  R30,LOW(0)
00148a e0f0      	LDI  R31,HIGH(0)
00148b c01f      	RJMP _0x3E0
         ;    2464 		}
         ;    2465 		_FF_buff[calc_temp+12] |= MODE;		
          _0x290:
00148c   +  	__GETW1R 20,21
00148e 963c      	ADIW R30,12
00148f 5fec      	SUBI R30,LOW(-__FF_buff)
001490 4ffa      	SBCI R31,HIGH(-__FF_buff)
001491 93ff      	PUSH R31
001492 93ef      	PUSH R30
001493 81e0      	LD   R30,Z
001494 a1aa      	LDD  R26,Y+34
001495 2bea      	OR   R30,R26
001496 91af      	POP  R26
001497 91bf      	POP  R27
001498 93ec      	ST   X,R30
         ;    2466 		if (_FF_write(addr_temp)==0)
001499   +  	__GETD1S 12
00149d 940e 207e 	CALL SUBOPT_0x76
00149f f431      	BRNE _0x291
         ;    2467 		{
         ;    2468 			_FF_error = WRITE_ERR;
0014a0 e0e3      	LDI  R30,LOW(3)
0014a1 93e0 073c 	STS  __FF_error,R30
         ;    2469 			return (0);
0014a3 e0e0      	LDI  R30,LOW(0)
0014a4 e0f0      	LDI  R31,HIGH(0)
0014a5 c005      	RJMP _0x3E0
         ;    2470 		}
         ;    2471 	}
          _0x291:
         ;    2472 	_FF_error = NO_ERR;
          _0x28F:
0014a6 e0e0      	LDI  R30,LOW(0)
0014a7 93e0 073c 	STS  __FF_error,R30
         ;    2473 	return (temp_file_pntr);
0014a9 81ee      	LDD  R30,Y+6
0014aa 81ff      	LDD  R31,Y+6+1
          _0x3E0:
0014ab 940e 230b 	CALL __LOADLOCR6
0014ad 96a5      	ADIW R28,37
0014ae 9508      	RET
         ;    2474 }
         ;    2475 #endif
         ;    2476 
         ;    2477 #ifndef _READ_ONLY_
         ;    2478 // Open a file, name stored in string fileopen
         ;    2479 int removec(unsigned char flash *NAMEC)
         ;    2480 {
         ;    2481 	int c;
         ;    2482 	unsigned char sd_temp[12];
         ;    2483 	
         ;    2484 	for (c=0; c<12; c++)
         ;	*NAMEC -> Y+14
         ;	c -> R16,R17
         ;	sd_temp -> Y+2
         ;    2485 		sd_temp[c] = NAMEC[c];
         ;    2486 	
         ;    2487 	c = remove(sd_temp);
         ;    2488 	return (c);
         ;    2489 }
         ;    2490 
         ;    2491 // Remove a file from the root directory
         ;    2492 int remove(unsigned char *NAME)
         ;    2493 {
         ;    2494 	unsigned char fpath[14];
         ;    2495 	unsigned int s, calc_temp;
         ;    2496 	unsigned long addr_temp, path_addr_temp;
         ;    2497 	
         ;    2498 	#ifndef _SECOND_FAT_ON_
         ;    2499 		clear_second_FAT();
         ;    2500     #endif
         ;    2501     
         ;    2502     addr_temp = 0;	// save local dir addr
         ;	*NAME -> Y+26
         ;	fpath -> Y+12
         ;	s -> R16,R17
         ;	calc_temp -> R18,R19
         ;	addr_temp -> Y+8
         ;	path_addr_temp -> Y+4
         ;    2503     
         ;    2504     if (_FF_checkdir(NAME, &addr_temp, fpath))
         ;    2505 	{
         ;    2506 		_FF_error = PATH_ERR;
         ;    2507 		_FF_DIR_ADDR = addr_temp;
         ;    2508 		return (EOF);
         ;    2509 	}
         ;    2510 	if (fpath[0]==0)
         ;    2511 	{
         ;    2512 		_FF_error = NAME_ERR; 
         ;    2513 		_FF_DIR_ADDR = addr_temp;
         ;    2514 		return (EOF);
         ;    2515 	}
         ;    2516     
         ;    2517 	path_addr_temp = _FF_DIR_ADDR;
         ;    2518 	s = scan_directory(&path_addr_temp, fpath);
         ;    2519 	if ((path_addr_temp==0) || (s==0))
         ;    2520 	{
         ;    2521 		_FF_error = NO_ENTRY_AVAL;
         ;    2522 		_FF_DIR_ADDR = addr_temp;
         ;    2523 		return (EOF);
         ;    2524 	}
         ;    2525 	_FF_DIR_ADDR = addr_temp;		// Reset current dir
         ;    2526 
         ;    2527 	calc_temp = path_addr_temp % BPB_BytsPerSec;
         ;    2528 	path_addr_temp -= calc_temp;
         ;    2529 	if (_FF_read(path_addr_temp)==0)	
         ;    2530 	{
         ;    2531 		_FF_error = READ_ERR;
         ;    2532 		return (EOF);
         ;    2533 	}
         ;    2534 	
         ;    2535 	// Erase entry (put 0xE5 into start of the filename
         ;    2536 	_FF_buff[calc_temp] = 0xE5;
         ;    2537 	if (_FF_write(path_addr_temp)==0)
         ;    2538 	{
         ;    2539 		_FF_error = WRITE_ERR;
         ;    2540 		return (EOF);
         ;    2541 	}
         ;    2542 	// Save Starting Cluster
         ;    2543 	calc_temp = ((int) _FF_buff[calc_temp+0x1B] << 8) | (int) _FF_buff[calc_temp+0x1A];
         ;    2544 	// Destroy cluster chain
         ;    2545 	if (calc_temp)
         ;    2546 		if (erase_clus_chain(calc_temp) == 0)
         ;    2547 			return (EOF);
         ;    2548 			
         ;    2549 	return (1);
         ;    2550 }
         ;    2551 #endif
         ;    2552 
         ;    2553 #ifndef _READ_ONLY_
         ;    2554 // Rename a file in the Root Directory
         ;    2555 int rename(unsigned char *NAME_OLD, unsigned char *NAME_NEW)
         ;    2556 {
         ;    2557 	unsigned char c;
         ;    2558 	unsigned int calc_temp;
         ;    2559 	unsigned long addr_temp, path_addr_temp;
         ;    2560 	unsigned char *sp, *qp;
         ;    2561 	unsigned char fpath[14];
         ;    2562 
         ;    2563 	// Get the filename into a form we can use to compare
         ;    2564 	qp = file_name_conversion(NAME_NEW);
         ;	*NAME_OLD -> Y+31
         ;	*NAME_NEW -> Y+29
         ;	c -> R16
         ;	calc_temp -> R17,R18
         ;	addr_temp -> Y+25
         ;	path_addr_temp -> Y+21
         ;	*sp -> R19,R20
         ;	*qp -> Y+19
         ;	fpath -> Y+5
         ;    2565 	if (qp==0)
         ;    2566 	{
         ;    2567 		_FF_error = NAME_ERR;
         ;    2568 		return (EOF);
         ;    2569 	}
         ;    2570 	
         ;    2571     addr_temp = 0;	// save local dir addr
         ;    2572     
         ;    2573     if (_FF_checkdir(NAME_OLD, &addr_temp, fpath))
         ;    2574 	{
         ;    2575 		_FF_error = PATH_ERR;
         ;    2576 		_FF_DIR_ADDR = addr_temp;
         ;    2577 		return (EOF);
         ;    2578 	}
         ;    2579 	if (fpath[0]==0)
         ;    2580 	{
         ;    2581 		_FF_error = NAME_ERR; 
         ;    2582 		_FF_DIR_ADDR = addr_temp;
         ;    2583 		return (EOF);
         ;    2584 	}
         ;    2585 
         ;    2586 	path_addr_temp = _FF_DIR_ADDR;
         ;    2587 	calc_temp = scan_directory(&path_addr_temp, NAME_NEW);
         ;    2588 	if (calc_temp)
         ;    2589 	{	// does new name alread exist?
         ;    2590 		_FF_DIR_ADDR = addr_temp;
         ;    2591 		_FF_error = EXIST_ERR;
         ;    2592 		return (EOF);
         ;    2593 	}
         ;    2594 
         ;    2595 	path_addr_temp = _FF_DIR_ADDR;
         ;    2596 	calc_temp = scan_directory(&path_addr_temp, fpath);
         ;    2597 	if ((path_addr_temp==0) || (calc_temp==0))
         ;    2598 	{
         ;    2599 		_FF_DIR_ADDR = addr_temp;
         ;    2600 		_FF_error = EXIST_ERR;
         ;    2601 		return (EOF);
         ;    2602 	}
         ;    2603 
         ;    2604 
         ;    2605 	_FF_DIR_ADDR = addr_temp;		// Reset current dir
         ;    2606 
         ;    2607 	calc_temp = path_addr_temp % BPB_BytsPerSec;
         ;    2608 	path_addr_temp -= calc_temp;
         ;    2609 	if (_FF_read(path_addr_temp)==0)	
         ;    2610 	{
         ;    2611 		_FF_error = READ_ERR;
         ;    2612 		return (EOF);
         ;    2613 	}
         ;    2614 	
         ;    2615 	// Rename entry
         ;    2616 	sp = &_FF_buff[calc_temp];
         ;    2617 	for (c=0; c<11; c++)
         ;    2618 		*sp++ = *qp++;
         ;    2619 	if (_FF_write(path_addr_temp)==0)
         ;    2620 		return (EOF);
         ;    2621 
         ;    2622 	return(0);
         ;    2623 }
         ;    2624 #endif
         ;    2625 
         ;    2626 #ifndef _READ_ONLY_
         ;    2627 // Save Contents of file, w/o closing
         ;    2628 int fflush(FILE *rp)	
         ;    2629 {
          _fflush:
         ;    2630 	unsigned int  n;
         ;    2631 	unsigned long addr_temp;
         ;    2632 	
         ;    2633 	if ((rp==NULL) || (rp->mode==READ))
0014af 940e 2084 	CALL SUBOPT_0x77
         ;	*rp -> Y+6
         ;	n -> R16,R17
         ;	addr_temp -> Y+2
0014b1 81ae      	LDD  R26,Y+6
0014b2 81bf      	LDD  R27,Y+6+1
0014b3 940e 22ec 	CALL __CPW02
0014b5 f021      	BREQ _0x2AB
0014b6 940e 2088 	CALL SUBOPT_0x78
0014b8 30a1      	CPI  R26,LOW(0x1)
0014b9 f419      	BRNE _0x2AA
          _0x2AB:
         ;    2634 		return (EOF);
0014ba efef      	LDI  R30,LOW(65535)
0014bb efff      	LDI  R31,HIGH(65535)
0014bc c038      	RJMP _0x3DF
         ;    2635 	
         ;    2636 	if ((rp->mode==WRITE) || (rp->mode==APPEND))
          _0x2AA:
0014bd 940e 2088 	CALL SUBOPT_0x78
0014bf 30a2      	CPI  R26,LOW(0x2)
0014c0 f021      	BREQ _0x2AE
0014c1 940e 2088 	CALL SUBOPT_0x78
0014c3 30a3      	CPI  R26,LOW(0x3)
0014c4 f571      	BRNE _0x2AD
          _0x2AE:
         ;    2637 	{
         ;    2638 		addr_temp = (clust_to_addr(rp->clus_current) + ((rp->sec_offset-1)*BPB_BytsPerSec));
0014c5 940e 2047 	CALL SUBOPT_0x6E
0014c7 940e 0a53 	CALL _clust_to_addr
0014c9 937f      	PUSH R23
0014ca 936f      	PUSH R22
0014cb 93ff      	PUSH R31
0014cc 93ef      	PUSH R30
0014cd 940e 208e 	CALL SUBOPT_0x79
0014cf 940e 2239 	CALL __MULW12U
0014d1 91af      	POP  R26
0014d2 91bf      	POP  R27
0014d3 918f      	POP  R24
0014d4 919f      	POP  R25
0014d5 940e 2094 	CALL SUBOPT_0x7A
         ;    2639 		for (n=0; n<BPB_BytsPerSec; n++)	// Save file buffer to SD buffer
0014d7   +  	__GETWRN 16,17,0
          _0x2B1:
0014d9   +  	__CPWRR 16,17,6,7
0014db f438      	BRSH _0x2B2
         ;    2640 			_FF_buff[n] = rp->buff[n];
0014dc 940e 209d 	CALL SUBOPT_0x7B
0014de 81e0      	LD   R30,Z
0014df 93ec      	ST   X,R30
         ;    2641 		if (_FF_write(addr_temp)==0)	// Write SD buffer to disk
0014e0   +  	__ADDWRN 16,17,1
0014e2 cff6      	RJMP _0x2B1
          _0x2B2:
0014e3   +  	__GETD1S 2
0014e7 940e 207e 	CALL SUBOPT_0x76
0014e9 f419      	BRNE _0x2B3
         ;    2642 			return (EOF);
0014ea efef      	LDI  R30,LOW(65535)
0014eb efff      	LDI  R31,HIGH(65535)
0014ec c008      	RJMP _0x3DF
         ;    2643 		if (append_toc(rp)==0)	// Update Entry or Error
          _0x2B3:
0014ed 940e 20a2 	CALL SUBOPT_0x7C
0014ef f419      	BRNE _0x2B4
         ;    2644 			return (EOF);
0014f0 efef      	LDI  R30,LOW(65535)
0014f1 efff      	LDI  R31,HIGH(65535)
0014f2 c002      	RJMP _0x3DF
         ;    2645 	}
          _0x2B4:
         ;    2646 	
         ;    2647 	return (0);
          _0x2AD:
0014f3 e0e0      	LDI  R30,LOW(0)
0014f4 e0f0      	LDI  R31,HIGH(0)
          _0x3DF:
0014f5 8119      	LDD  R17,Y+1
0014f6 8108      	LDD  R16,Y+0
0014f7 9628      	ADIW R28,8
0014f8 9508      	RET
         ;    2648 }
         ;    2649 #endif		
         ;    2650 
         ;    2651 
         ;    2652 // Close an open file
         ;    2653 int fclose(FILE *rp)	
         ;    2654 {
          _fclose:
         ;    2655 	#ifndef _READ_ONLY_
         ;    2656 	if (rp->mode!=READ)
0014f9 81a8      	LD   R26,Y
0014fa 81b9      	LDD  R27,Y+1
0014fb 940e 20aa 	CALL SUBOPT_0x7D
0014fd f069      	BREQ _0x2B5
         ;    2657 		if (fflush(rp)==EOF)
0014fe 81e8      	LD   R30,Y
0014ff 81f9      	LDD  R31,Y+1
001500 93fa      	ST   -Y,R31
001501 93ea      	ST   -Y,R30
001502 940e 14af 	CALL _fflush
001504 3fef      	CPI  R30,LOW(0xFFFF)
001505 efaf      	LDI  R26,HIGH(0xFFFF)
001506 07fa      	CPC  R31,R26
001507 f419      	BRNE _0x2B6
         ;    2658 			return (EOF);
001508 efef      	LDI  R30,LOW(65535)
001509 efff      	LDI  R31,HIGH(65535)
00150a c00b      	RJMP _0x3DE
         ;    2659 	#endif	
         ;    2660 	// Clear File Structure
         ;    2661 	free(rp);
          _0x2B6:
          _0x2B5:
00150b 81e8      	LD   R30,Y
00150c 81f9      	LDD  R31,Y+1
00150d 93fa      	ST   -Y,R31
00150e 93ea      	ST   -Y,R30
00150f 940e 1c44 	CALL _free
         ;    2662 	rp = 0;
001511 e0e0      	LDI  R30,0
001512 83e8      	STD  Y+0,R30
001513 83e9      	STD  Y+0+1,R30
         ;    2663 	return(0);
001514 e0e0      	LDI  R30,LOW(0)
001515 e0f0      	LDI  R31,HIGH(0)
          _0x3DE:
001516 9622      	ADIW R28,2
001517 9508      	RET
         ;    2664 }
         ;    2665 
         ;    2666 int ffreemem(FILE *rp)	
         ;    2667 {
         ;    2668 	// Clear File Structure
         ;    2669 	if (rp==0)
         ;    2670 		return (EOF);
         ;    2671 	free(rp);
         ;    2672 	return(0);
         ;    2673 }
         ;    2674 
         ;    2675 int fget_file_infoc(unsigned char flash *NAMEC, unsigned long *F_SIZE, unsigned char *F_CREATE,
         ;    2676 				unsigned char *F_MODIFY, unsigned char *F_ATTRIBUTE, unsigned int *F_CLUS_START)
         ;    2677 {
         ;    2678 	int c;
         ;    2679 	unsigned char sd_temp[12];
         ;    2680 	
         ;    2681 	for (c=0; c<12; c++)
         ;	*NAMEC -> Y+24
         ;	*F_SIZE -> Y+22
         ;	*F_CREATE -> Y+20
         ;	*F_MODIFY -> Y+18
         ;	*F_ATTRIBUTE -> Y+16
         ;	*F_CLUS_START -> Y+14
         ;	c -> R16,R17
         ;	sd_temp -> Y+2
         ;    2682 		sd_temp[c] = NAMEC[c];
         ;    2683 	
         ;    2684 	c = fget_file_info(sd_temp, F_SIZE, F_CREATE, F_MODIFY, F_ATTRIBUTE, F_CLUS_START);
         ;    2685 	return (c);
         ;    2686 }
         ;    2687 
         ;    2688 int fget_file_info(unsigned char *NAME, unsigned long *F_SIZE, unsigned char *F_CREATE,
         ;    2689 				unsigned char *F_MODIFY, unsigned char *F_ATTRIBUTE, unsigned int *F_CLUS_START)
         ;    2690 {
         ;    2691 	unsigned char n;
         ;    2692 	unsigned int s, calc_temp;
         ;    2693 	unsigned long addr_temp, file_calc_temp;
         ;    2694 	unsigned char *sp, *qp;
         ;    2695 	
         ;    2696 	// Get the filename into a form we can use to compare
         ;    2697 	qp = file_name_conversion(NAME);
         ;	*NAME -> Y+27
         ;	*F_SIZE -> Y+25
         ;	*F_CREATE -> Y+23
         ;	*F_MODIFY -> Y+21
         ;	*F_ATTRIBUTE -> Y+19
         ;	*F_CLUS_START -> Y+17
         ;	n -> R16
         ;	s -> R17,R18
         ;	calc_temp -> R19,R20
         ;	addr_temp -> Y+13
         ;	file_calc_temp -> Y+9
         ;	*sp -> Y+7
         ;	*qp -> Y+5
         ;    2698 	if (qp==0)
         ;    2699 	{
         ;    2700 		_FF_error = NAME_ERR;
         ;    2701 		return (EOF);
         ;    2702 	}
         ;    2703 	
         ;    2704 	for (s=0; s<BPB_BytsPerSec; s++)
         ;    2705 	{	// Scan through directory entries to find file
         ;    2706 		addr_temp = _FF_DIR_ADDR + (0x200 * s);
         ;    2707 		if (_FF_read(addr_temp)==0)
         ;    2708 			return (EOF);
         ;    2709 		for (n=0; n<16; n++)
         ;    2710 		{
         ;    2711 			calc_temp = (int) n * 0x20;
         ;    2712 			qp = &FILENAME[0];
         ;    2713 			sp = &_FF_buff[calc_temp];
         ;    2714 			if (*sp == 0)
         ;    2715 				return (EOF);
         ;    2716 			if (strncmp(qp, sp, 11)==0)		// Does this entry == Filename
         ;    2717 			{
         ;    2718 				*F_ATTRIBUTE = _FF_buff[calc_temp+11];	// Save ATTRIBUTE Byte to location
         ;    2719 				*F_SIZE = ((long) _FF_buff[calc_temp+31] << 24) | ((long) _FF_buff[calc_temp+30] << 16)
         ;    2720 							| ((long) _FF_buff[calc_temp+29] << 8) | ((long) _FF_buff[calc_temp+28]);
         ;    2721 							// Save SIZE of file to location
         ;    2722                 *F_CLUS_START = ((unsigned int) _FF_buff[calc_temp+27] << 8) | ((unsigned int) _FF_buff[calc_temp+26]);
         ;    2723 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+17] << 8) | ((unsigned int) _FF_buff[calc_temp+16]);
         ;    2724 				qp = F_CREATE;
         ;    2725 				*qp++ = (((file_calc_temp >> 5) & 0x0F) / 10) + '0';
         ;    2726 				*qp++ = (((file_calc_temp >> 5) & 0x0F) % 10) + '0';
         ;    2727 				*qp++ = '/';
         ;    2728 				*qp++ = ((file_calc_temp & 0x1F) / 10) + '0';
         ;    2729 				*qp++ = ((file_calc_temp & 0x1F) % 10) + '0';
         ;    2730 				*qp++ = '/';
         ;    2731 				file_calc_temp = ((file_calc_temp >> 9) & 0x7F) + 1980;
         ;    2732 				*qp++ = (file_calc_temp / 1000) + '0';
         ;    2733 				file_calc_temp %= 1000;
         ;    2734 				*qp++ = (file_calc_temp / 100) + '0';
         ;    2735 				file_calc_temp %= 100;
         ;    2736 				*qp++ = (file_calc_temp / 10) + '0';
         ;    2737 				*qp++ = (file_calc_temp % 10) + '0';
         ;    2738 				*qp++ = ' ';
         ;    2739 				*qp++ = ' ';
         ;    2740 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+15] << 8) | ((unsigned int) _FF_buff[calc_temp+14]);
         ;    2741 				*qp++ = (((file_calc_temp >> 11) & 0x1F) / 10) + '0';
         ;    2742 				*qp++ = (((file_calc_temp >> 11) & 0x1F) % 10) + '0';
         ;    2743 				*qp++ = ':';
         ;    2744 				*qp++ = (((file_calc_temp >> 5) & 0x3F) / 10) + '0';
         ;    2745 				*qp++ = (((file_calc_temp >> 5) & 0x3F) % 10) + '0';
         ;    2746 				*qp++ = ':';
         ;    2747 				*qp++ = (((file_calc_temp & 0x1F) * 2) / 10) + '0';
         ;    2748 				*qp++ = (((file_calc_temp & 0x1F) * 2) % 10) + '0';
         ;    2749 				*qp = 0;
         ;    2750 				
         ;    2751 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+25] << 8) | ((unsigned int) _FF_buff[calc_temp+24]);
         ;    2752 				qp = F_MODIFY;
         ;    2753 				*qp++ = (((file_calc_temp >> 5) & 0x0F) / 10) + '0';
         ;    2754 				*qp++ = (((file_calc_temp >> 5) & 0x0F) % 10) + '0';
         ;    2755 				*qp++ = '/';
         ;    2756 				*qp++ = ((file_calc_temp & 0x1F) / 10) + '0';
         ;    2757 				*qp++ = ((file_calc_temp & 0x1F) % 10) + '0';
         ;    2758 				*qp++ = '/';
         ;    2759 				file_calc_temp = ((file_calc_temp >> 9) & 0x7F) + 1980;
         ;    2760 				*qp++ = (file_calc_temp / 1000) + '0';
         ;    2761 				file_calc_temp %= 1000;
         ;    2762 				*qp++ = (file_calc_temp / 100) + '0';
         ;    2763 				file_calc_temp %= 100;
         ;    2764 				*qp++ = (file_calc_temp / 10) + '0';
         ;    2765 				*qp++ = (file_calc_temp % 10) + '0';
         ;    2766 				*qp++ = ' ';
         ;    2767 				*qp++ = ' ';
         ;    2768 				file_calc_temp = ((unsigned int) _FF_buff[calc_temp+23] << 8) | ((unsigned int) _FF_buff[calc_temp+22]);
         ;    2769 				*qp++ = (((file_calc_temp >> 11) & 0x1F) / 10) + '0';
         ;    2770 				*qp++ = (((file_calc_temp >> 11) & 0x1F) % 10) + '0';
         ;    2771 				*qp++ = ':';
         ;    2772 				*qp++ = (((file_calc_temp >> 5) & 0x3F) / 10) + '0';
         ;    2773 				*qp++ = (((file_calc_temp >> 5) & 0x3F) % 10) + '0';
         ;    2774 				*qp++ = ':';
         ;    2775 				*qp++ = (((file_calc_temp & 0x1F) * 2) / 10) + '0';
         ;    2776 				*qp++ = (((file_calc_temp & 0x1F) * 2) % 10) + '0';
         ;    2777 				*qp = 0;
         ;    2778 				
         ;    2779 				return (0);
         ;    2780 			}
         ;    2781 		}                          		
         ;    2782 	}
         ;    2783 	_FF_error = FILE_ERR;
         ;    2784 	return(EOF);
         ;    2785 }
         ;    2786 
         ;    2787 // Get File data and increment file pointer
         ;    2788 int fgetc(FILE *rp)
         ;    2789 {
         ;    2790 	unsigned char get_data;
         ;    2791 	unsigned int n;
         ;    2792 	unsigned long addr_temp;
         ;    2793 	
         ;    2794 	if (rp==NULL)
         ;	*rp -> Y+7
         ;	get_data -> R16
         ;	n -> R17,R18
         ;	addr_temp -> Y+3
         ;    2795 		return (EOF);
         ;    2796 
         ;    2797 	if (rp->position == rp->length)
         ;    2798 	{
         ;    2799 		rp->error = POS_ERR;
         ;    2800 		return (EOF);
         ;    2801 	}
         ;    2802 	
         ;    2803 	get_data = *rp->pntr;
         ;    2804 	
         ;    2805 	if ((rp->pntr)==(&rp->buff[BPB_BytsPerSec-1]))
         ;    2806 	{	// Check to see if pointer is at the end of a sector
         ;    2807 		#ifndef _READ_ONLY_
         ;    2808 		if ((rp->mode==WRITE) || (rp->mode==APPEND))
         ;    2809 		{	// if in write or append mode, update the current sector before loading next
         ;    2810 			for (n=0; n<BPB_BytsPerSec; n++)
         ;    2811 				_FF_buff[n] = rp->buff[n];
         ;    2812 			addr_temp = clust_to_addr(rp->clus_current) + (((rp->sec_offset)-1)*BPB_BytsPerSec);
         ;    2813 			if (_FF_write(addr_temp)==0)
         ;    2814 				return (EOF);
         ;    2815 		}
         ;    2816 		#endif
         ;    2817 		if (rp->sec_offset < BPB_SecPerClus)
         ;    2818 		{	// Goto next sector if not at the end of a cluster
         ;    2819 			addr_temp = clust_to_addr(rp->clus_current) + (rp->sec_offset*BPB_BytsPerSec);
         ;    2820 			rp->sec_offset++;
         ;    2821 		}
         ;    2822 		else
         ;    2823 		{	// End of Cluster, find next
         ;    2824 			if (rp->clus_next>=0xFFF8)	// No next cluster, EOF marker
         ;    2825 			{
         ;    2826 				rp->EOF_flag = 1;	// Set flag so Putchar knows to get new cluster
         ;    2827 				rp->position++;		// Only time doing this, position + 1 should equal length
         ;    2828 				return(get_data);
         ;    2829 			}
         ;    2830 			addr_temp = clust_to_addr(rp->clus_next);
         ;    2831 			rp->sec_offset = 1;
         ;    2832 			rp->clus_prev = rp->clus_current;
         ;    2833 			rp->clus_current = rp->clus_next;
         ;    2834 			rp->clus_next = next_cluster(rp->clus_current, SINGLE);
         ;    2835 		}
         ;    2836 		if (_FF_read(addr_temp)==0)
         ;    2837 			return (EOF);
         ;    2838 		for (n=0; n<BPB_BytsPerSec; n++)
         ;    2839 			rp->buff[n] = _FF_buff[n];
         ;    2840 		rp->pntr = &rp->buff[0];
         ;    2841 	}
         ;    2842 	else
         ;    2843 		rp->pntr++;
         ;    2844 	
         ;    2845 	rp->position++;	
         ;    2846 	return(get_data);		
         ;    2847 }
         ;    2848 
         ;    2849 char *fgets(char *buffer, int n, FILE *rp)
         ;    2850 {
         ;    2851 	int c, temp_data;
         ;    2852 	
         ;    2853 	for (c=0; c<n; c++)
         ;	*buffer -> Y+8
         ;	n -> Y+6
         ;	*rp -> Y+4
         ;	c -> R16,R17
         ;	temp_data -> R18,R19
         ;    2854 	{
         ;    2855 		temp_data = fgetc(rp);
         ;    2856 		*buffer = temp_data & 0xFF;
         ;    2857 		if (temp_data == '\n')
         ;    2858 			break;
         ;    2859 		else if (temp_data == EOF)
         ;    2860 			break;
         ;    2861 		buffer++;
         ;    2862 	}
         ;    2863 	if (c==n)
         ;    2864 		buffer++;
         ;    2865 	*buffer-- = '\0';
         ;    2866 	if (temp_data == EOF)
         ;    2867 		return (NULL);
         ;    2868 	return (buffer);
         ;    2869 }
         ;    2870 
         ;    2871 #ifndef _READ_ONLY_
         ;    2872 // Decrement file pointer, then get file data
         ;    2873 int ungetc(unsigned char file_data, FILE *rp)
         ;    2874 {
         ;    2875 	unsigned int n;
         ;    2876 	unsigned long addr_temp;
         ;    2877 	
         ;    2878 	if ((rp==NULL) || (rp->position==0))
         ;	file_data -> Y+8
         ;	*rp -> Y+6
         ;	n -> R16,R17
         ;	addr_temp -> Y+2
         ;    2879 		return (EOF);
         ;    2880 	if ((rp->mode!=APPEND) && (rp->mode!=WRITE))
         ;    2881 		return (EOF);	// needs to be in WRITE or APPEND mode
         ;    2882 
         ;    2883 	if (((rp->position) == rp->length) && (rp->EOF_flag))
         ;    2884 	{	// if the file posisition is equal to the length, return data, turn flag off
         ;    2885 		rp->EOF_flag = 0;
         ;    2886 		*rp->pntr = file_data;
         ;    2887 		return (*rp->pntr);
         ;    2888 	}
         ;    2889 	if ((rp->pntr)==(&rp->buff[0]))
         ;    2890 	{	// Check to see if pointer is at the beginning of a Sector
         ;    2891 		// Update the current sector before loading next
         ;    2892 		for (n=0; n<BPB_BytsPerSec; n++)
         ;    2893 			_FF_buff[n] = rp->buff[n];
         ;    2894 		addr_temp = clust_to_addr(rp->clus_current) + (((rp->sec_offset)-1)*BPB_BytsPerSec);
         ;    2895 		if (_FF_write(addr_temp)==0)
         ;    2896 			return (EOF);
         ;    2897 			
         ;    2898 		if (rp->sec_offset > 1)
         ;    2899 		{	// Goto previous sector if not at the beginning of a cluster
         ;    2900 			addr_temp = clust_to_addr(rp->clus_current) + ((rp->sec_offset-2)*BPB_BytsPerSec);
         ;    2901 			rp->sec_offset--;
         ;    2902 		}
         ;    2903 		else
         ;    2904 		{	// Beginning of Cluster, find previous
         ;    2905 			if (rp->clus_start==rp->clus_current)
         ;    2906 			{	// Positioned @ Beginning of File
         ;    2907 				_FF_error = SOF_ERR;
         ;    2908 				return(EOF);
         ;    2909 			}
         ;    2910 			rp->sec_offset = BPB_SecPerClus;	// Set sector offset to last sector
         ;    2911 			rp->clus_next = rp->clus_current;
         ;    2912 			rp->clus_current = rp->clus_prev;
         ;    2913 			if (rp->clus_current != rp->clus_start)
         ;    2914 				rp->clus_prev = prev_cluster(rp->clus_current);
         ;    2915 			else
         ;    2916 				rp->clus_prev = 0;
         ;    2917 			addr_temp = clust_to_addr(rp->clus_current) + (((long) BPB_SecPerClus-1) * (long) BPB_BytsPerSec);
         ;    2918 		}
         ;    2919 		_FF_read(addr_temp);
         ;    2920 		for (n=0; n<BPB_BytsPerSec; n++)
         ;    2921 			rp->buff[n] = _FF_buff[n];
         ;    2922 		rp->pntr = &rp->buff[511];
         ;    2923 	}
         ;    2924 	else
         ;    2925 		rp->pntr--;
         ;    2926 	
         ;    2927 	rp->position--;
         ;    2928 	*rp->pntr = file_data;	
         ;    2929 	return(*rp->pntr);	// Get data	
         ;    2930 }
         ;    2931 #endif
         ;    2932 
         ;    2933 #ifndef _READ_ONLY_
         ;    2934 int fputc(unsigned char file_data, FILE *rp)	
         ;    2935 {
          _fputc:
         ;    2936 	unsigned int n;
         ;    2937 	unsigned long addr_temp;
         ;    2938 	
         ;    2939 	if (rp==NULL)
001518 940e 2084 	CALL SUBOPT_0x77
         ;	file_data -> Y+8
         ;	*rp -> Y+6
         ;	n -> R16,R17
         ;	addr_temp -> Y+2
00151a 81ee      	LDD  R30,Y+6
00151b 81ff      	LDD  R31,Y+6+1
00151c 9730      	SBIW R30,0
00151d f419      	BRNE _0x2F6
         ;    2940 		return (EOF);
00151e efef      	LDI  R30,LOW(65535)
00151f efff      	LDI  R31,HIGH(65535)
001520 c1b1      	RJMP _0x3DD
         ;    2941 
         ;    2942 	if (rp->mode == READ)
          _0x2F6:
001521 940e 2088 	CALL SUBOPT_0x78
001523 30a1      	CPI  R26,LOW(0x1)
001524 f431      	BRNE _0x2F7
         ;    2943 	{
         ;    2944 		_FF_error = READONLY_ERR;
001525 e0e6      	LDI  R30,LOW(6)
001526 93e0 073c 	STS  __FF_error,R30
         ;    2945 		return(EOF);
001528 efef      	LDI  R30,LOW(65535)
001529 efff      	LDI  R31,HIGH(65535)
00152a c1a7      	RJMP _0x3DD
         ;    2946 	}
         ;    2947 	if (rp->length == 0)
          _0x2F7:
00152b 940e 2037 	CALL SUBOPT_0x6C
00152d f4e9      	BRNE _0x2F8
         ;    2948 	{	// Blank file start writing cluster table
         ;    2949 		rp->clus_start = prev_cluster(0);
00152e 940e 20af 	CALL SUBOPT_0x7E
001530   +  	__PUTW1SNS 6,12
         ;    2950 		rp->clus_next = 0xFFFF;
001535 940e 20b5 	CALL SUBOPT_0x7F
         ;    2951 		rp->clus_current = rp->clus_start;
001537 940e 2011 	CALL SUBOPT_0x67
001539   +  	__PUTW1SNS 6,14
         ;    2952 		if (write_clus_table(rp->clus_start, rp->clus_next, SINGLE)==0)
00153e 940e 2040 	CALL SUBOPT_0x6D
001540 940e 20bd 	CALL SUBOPT_0x80
001542 e0e1      	LDI  R30,LOW(1)
001543 93ea      	ST   -Y,R30
001544 940e 0e13 	CALL _write_clus_table
001546 30e0      	CPI  R30,0
001547 f419      	BRNE _0x2F9
         ;    2953 		{
         ;    2954 			return (EOF);
001548 efef      	LDI  R30,LOW(65535)
001549 efff      	LDI  R31,HIGH(65535)
00154a c187      	RJMP _0x3DD
         ;    2955 		}
         ;    2956 	}
          _0x2F9:
         ;    2957 	
         ;    2958 	if ((rp->position==rp->length) && (rp->EOF_flag))
          _0x2F8:
00154b 940e 20c4 	CALL SUBOPT_0x81
00154d 937f      	PUSH R23
00154e 936f      	PUSH R22
00154f 93ff      	PUSH R31
001550 93ef      	PUSH R30
001551 940e 20cb 	CALL SUBOPT_0x82
001553 91af      	POP  R26
001554 91bf      	POP  R27
001555 918f      	POP  R24
001556 919f      	POP  R25
001557 940e 22fa 	CALL __CPD12
001559 f419      	BRNE _0x2FB
00155a 940e 20d2 	CALL SUBOPT_0x83
00155c f409      	BRNE _0x2FC
          _0x2FB:
00155d c041      	RJMP _0x2FA
          _0x2FC:
         ;    2959 	{	// At end of file, and end of cluster, flagged
         ;    2960 		rp->clus_prev = rp->clus_current;
00155e 940e 20d9 	CALL SUBOPT_0x84
001560   +  	__PUTW1SNS 6,18
         ;    2961 		rp->clus_current = prev_cluster(0);	// Find first cluster pointing to '0'
001565 940e 20af 	CALL SUBOPT_0x7E
001567   +  	__PUTW1SNS 6,14
         ;    2962 		rp->clus_next = 0xFFFF;
00156c 940e 20b5 	CALL SUBOPT_0x7F
         ;    2963 		rp->sec_offset = 1;
00156e 940e 204e 	CALL SUBOPT_0x6F
         ;    2964 		if (write_clus_table(rp->clus_prev, rp->clus_current, CHAIN)==0)
001570 81ee      	LDD  R30,Y+6
001571 81ff      	LDD  R31,Y+6+1
001572 89a2      	LDD  R26,Z+18
001573 89b3      	LDD  R27,Z+19
001574 93ba      	ST   -Y,R27
001575 93aa      	ST   -Y,R26
001576 85e8      	LDD  R30,Y+8
001577 85f9      	LDD  R31,Y+8+1
001578 85a6      	LDD  R26,Z+14
001579 85b7      	LDD  R27,Z+15
00157a 93ba      	ST   -Y,R27
00157b 93aa      	ST   -Y,R26
00157c 940e 1f5d 	CALL SUBOPT_0x55
00157e f419      	BRNE _0x2FD
         ;    2965 		{
         ;    2966 			return (EOF);
00157f efef      	LDI  R30,LOW(65535)
001580 efff      	LDI  R31,HIGH(65535)
001581 c150      	RJMP _0x3DD
         ;    2967 		}
         ;    2968 		if (write_clus_table(rp->clus_current, rp->clus_next, END_CHAIN)==0)
          _0x2FD:
001582 940e 2047 	CALL SUBOPT_0x6E
001584 940e 20bd 	CALL SUBOPT_0x80
001586 940e 1f63 	CALL SUBOPT_0x56
001588 f419      	BRNE _0x2FE
         ;    2969 		{
         ;    2970 			return (EOF);
001589 efef      	LDI  R30,LOW(65535)
00158a efff      	LDI  R31,HIGH(65535)
00158b c146      	RJMP _0x3DD
         ;    2971 		}
         ;    2972 		if (append_toc(rp)==0)
          _0x2FE:
00158c 940e 20a2 	CALL SUBOPT_0x7C
00158e f419      	BRNE _0x2FF
         ;    2973 		{
         ;    2974 			return (EOF);
00158f efef      	LDI  R30,LOW(65535)
001590 efff      	LDI  R31,HIGH(65535)
001591 c140      	RJMP _0x3DD
         ;    2975 		}
         ;    2976 		rp->EOF_flag = 0;
          _0x2FF:
001592 81ae      	LDD  R26,Y+6
001593 81bf      	LDD  R27,Y+6+1
001594 940e 20df 	CALL SUBOPT_0x85
         ;    2977 		rp->pntr = &rp->buff[0];		
001596 81ee      	LDD  R30,Y+6
001597 81ff      	LDD  R31,Y+6+1
001598 967c      	ADIW R30,28
001599   +  	__PUTW1SN 6,551
         ;    2978 	}
         ;    2979 	
         ;    2980 	*rp->pntr = file_data;
          _0x2FA:
00159f 940e 20e4 	CALL SUBOPT_0x86
0015a1 85a8      	LDD  R26,Y+8
0015a2 83a0      	STD  Z+0,R26
         ;    2981 	
         ;    2982 	if (rp->pntr == &rp->buff[BPB_BytsPerSec-1])
0015a3 940e 20e4 	CALL SUBOPT_0x86
0015a5 93ff      	PUSH R31
0015a6 93ef      	PUSH R30
0015a7 81ae      	LDD  R26,Y+6
0015a8 81bf      	LDD  R27,Y+6+1
0015a9 940e 20eb 	CALL SUBOPT_0x87
0015ab 91af      	POP  R26
0015ac 91bf      	POP  R27
0015ad 17ea      	CP   R30,R26
0015ae 07fb      	CPC  R31,R27
0015af f011      	BREQ PC+3
0015b0 940c 16ac 	JMP _0x300
         ;    2983 	{	// This is on the Sector Limit
         ;    2984 		if (rp->position > rp->length)
0015b2 940e 20c4 	CALL SUBOPT_0x81
0015b4 937f      	PUSH R23
0015b5 936f      	PUSH R22
0015b6 93ff      	PUSH R31
0015b7 93ef      	PUSH R30
0015b8 940e 20cb 	CALL SUBOPT_0x82
0015ba 91af      	POP  R26
0015bb 91bf      	POP  R27
0015bc 918f      	POP  R24
0015bd 919f      	POP  R25
0015be 940e 22fa 	CALL __CPD12
0015c0 f430      	BRSH _0x301
         ;    2985 		{	// ERROR, position should never be greater than length
         ;    2986 			_FF_error = 0x10;		// file position ERROR
0015c1 e1e0      	LDI  R30,LOW(16)
0015c2 93e0 073c 	STS  __FF_error,R30
         ;    2987 			return (EOF); 
0015c4 efef      	LDI  R30,LOW(65535)
0015c5 efff      	LDI  R31,HIGH(65535)
0015c6 c10b      	RJMP _0x3DD
         ;    2988 		}
         ;    2989 		// Position is at end of a sector?
         ;    2990 		
         ;    2991 		addr_temp = (clust_to_addr(rp->clus_current) + ((rp->sec_offset-1)*BPB_BytsPerSec));
          _0x301:
0015c7 940e 2047 	CALL SUBOPT_0x6E
0015c9 940e 0a53 	CALL _clust_to_addr
0015cb 937f      	PUSH R23
0015cc 936f      	PUSH R22
0015cd 93ff      	PUSH R31
0015ce 93ef      	PUSH R30
0015cf 940e 208e 	CALL SUBOPT_0x79
0015d1 940e 2239 	CALL __MULW12U
0015d3 91af      	POP  R26
0015d4 91bf      	POP  R27
0015d5 918f      	POP  R24
0015d6 919f      	POP  R25
0015d7 940e 2094 	CALL SUBOPT_0x7A
         ;    2992 		for (n=0; n<BPB_BytsPerSec; n++)
0015d9   +  	__GETWRN 16,17,0
          _0x303:
0015db   +  	__CPWRR 16,17,6,7
0015dd f438      	BRSH _0x304
         ;    2993 			_FF_buff[n] = rp->buff[n];
0015de 940e 209d 	CALL SUBOPT_0x7B
0015e0 81e0      	LD   R30,Z
0015e1 93ec      	ST   X,R30
         ;    2994 		_FF_write(addr_temp);
0015e2   +  	__ADDWRN 16,17,1
0015e4 cff6      	RJMP _0x303
          _0x304:
0015e5   +  	__GETD1S 2
0015e9 940e 22d1 	CALL __PUTPARD1
0015eb 940e 0854 	CALL __FF_write
         ;    2995 			// Save MMC buffer to card, set pointer to begining of new buffer
         ;    2996 		if (rp->sec_offset < BPB_SecPerClus)
0015ed 81ee      	LDD  R30,Y+6
0015ee 81ff      	LDD  R31,Y+6+1
0015ef 89a4      	LDD  R26,Z+20
0015f0 89b5      	LDD  R27,Z+21
0015f1 2de8      	MOV  R30,R8
0015f2 e0f0      	LDI  R31,0
0015f3 17ae      	CP   R26,R30
0015f4 07bf      	CPC  R27,R31
0015f5 f4d8      	BRSH _0x305
         ;    2997 		{	// Are there more sectors in this cluster?
         ;    2998 			addr_temp = clust_to_addr(rp->clus_current) + (rp->sec_offset * BPB_BytsPerSec);
0015f6 940e 2047 	CALL SUBOPT_0x6E
0015f8 940e 0a53 	CALL _clust_to_addr
0015fa 937f      	PUSH R23
0015fb 936f      	PUSH R22
0015fc 93ff      	PUSH R31
0015fd 93ef      	PUSH R30
0015fe 81ee      	LDD  R30,Y+6
0015ff 81ff      	LDD  R31,Y+6+1
001600 89a4      	LDD  R26,Z+20
001601 89b5      	LDD  R27,Z+21
001602   +  	__GETW1R 6,7
001604 940e 2239 	CALL __MULW12U
001606 91af      	POP  R26
001607 91bf      	POP  R27
001608 918f      	POP  R24
001609 919f      	POP  R25
00160a 940e 2094 	CALL SUBOPT_0x7A
         ;    2999 			rp->sec_offset++;
00160c 81ae      	LDD  R26,Y+6
00160d 81bf      	LDD  R27,Y+6+1
00160e 940e 20f2 	CALL SUBOPT_0x88
         ;    3000 		}
         ;    3001 		else
001610 c055      	RJMP _0x306
          _0x305:
         ;    3002 		{	// Find next cluster, load first sector into file.buff
         ;    3003 			if (((rp->clus_next>=0xFFF8)&&(BPB_FATType==0x36)) ||
         ;    3004 				((rp->clus_next>=0xFF8)&&(BPB_FATType==0x32)))
001611 81ee      	LDD  R30,Y+6
001612 81ff      	LDD  R31,Y+6+1
001613 89a0      	LDD  R26,Z+16
001614 89b1      	LDD  R27,Z+17
001615 3fa8      	CPI  R26,LOW(0xFFF8)
001616 efef      	LDI  R30,HIGH(0xFFF8)
001617 07be      	CPC  R27,R30
001618 f018      	BRLO _0x308
001619 e3e6      	LDI  R30,LOW(54)
00161a 15ee      	CP   R30,R14
00161b f061      	BREQ _0x30A
          _0x308:
00161c 81ee      	LDD  R30,Y+6
00161d 81ff      	LDD  R31,Y+6+1
00161e 89a0      	LDD  R26,Z+16
00161f 89b1      	LDD  R27,Z+17
001620 3fa8      	CPI  R26,LOW(0xFF8)
001621 e0ef      	LDI  R30,HIGH(0xFF8)
001622 07be      	CPC  R27,R30
001623 f018      	BRLO _0x30B
001624 e3e2      	LDI  R30,LOW(50)
001625 15ee      	CP   R30,R14
001626 f009      	BREQ _0x30A
          _0x30B:
001627 c01a      	RJMP _0x307
          _0x30A:
         ;    3005 			{	// EOF, need to find new empty cluster
         ;    3006 				if (rp->position != rp->length)
001628 940e 20c4 	CALL SUBOPT_0x81
00162a 937f      	PUSH R23
00162b 936f      	PUSH R22
00162c 93ff      	PUSH R31
00162d 93ef      	PUSH R30
00162e 940e 20cb 	CALL SUBOPT_0x82
001630 91af      	POP  R26
001631 91bf      	POP  R27
001632 918f      	POP  R24
001633 919f      	POP  R25
001634 940e 22fa 	CALL __CPD12
001636 f031      	BREQ _0x30E
         ;    3007 				{	// if not equal there's an error
         ;    3008 					_FF_error = 0x20;		// EOF position error
001637 e2e0      	LDI  R30,LOW(32)
001638 93e0 073c 	STS  __FF_error,R30
         ;    3009 					return (EOF);
00163a efef      	LDI  R30,LOW(65535)
00163b efff      	LDI  R31,HIGH(65535)
00163c c095      	RJMP _0x3DD
         ;    3010 				}
         ;    3011 				rp->EOF_flag = 1;
          _0x30E:
00163d 81ae      	LDD  R26,Y+6
00163e 81bf      	LDD  R27,Y+6+1
00163f 940e 20f9 	CALL SUBOPT_0x89
         ;    3012 			}
         ;    3013 			else
001641 c01a      	RJMP _0x30F
          _0x307:
         ;    3014 			{	// Not EOF, find next cluster
         ;    3015 				rp->clus_prev = rp->clus_current;
001642 940e 20d9 	CALL SUBOPT_0x84
001644   +  	__PUTW1SNS 6,18
         ;    3016 				rp->clus_current = rp->clus_next;
001649 81ae      	LDD  R26,Y+6
00164a 81bf      	LDD  R27,Y+6+1
00164b 9650      	ADIW R26,16
00164c 940e 22be 	CALL __GETW1P
00164e   +  	__PUTW1SNS 6,14
         ;    3017 				rp->clus_next = next_cluster(rp->clus_current, SINGLE);
001653 940e 2047 	CALL SUBOPT_0x6E
001655 940e 1d90 	CALL SUBOPT_0x26
001657   +  	__PUTW1SNS 6,16
         ;    3018 			}
          _0x30F:
         ;    3019 			rp->sec_offset = 1;
00165c 940e 204e 	CALL SUBOPT_0x6F
         ;    3020 			addr_temp = clust_to_addr(rp->clus_current);
00165e 940e 2047 	CALL SUBOPT_0x6E
001660 940e 0a53 	CALL _clust_to_addr
001662   +  	__PUTD1S 2
         ;    3021 		}
          _0x306:
         ;    3022 		
         ;    3023 		if (rp->EOF_flag == 0)
001666 940e 20d2 	CALL SUBOPT_0x83
001668 f529      	BRNE _0x310
         ;    3024 		{
         ;    3025 			if (_FF_read(addr_temp)==0)
001669   +  	__GETD1S 2
00166d 940e 1cae 	CALL SUBOPT_0xC
00166f f419      	BRNE _0x311
         ;    3026 				return(EOF);
001670 efef      	LDI  R30,LOW(65535)
001671 efff      	LDI  R31,HIGH(65535)
001672 c05f      	RJMP _0x3DD
         ;    3027 			for (n=0; n<512; n++)
          _0x311:
001673   +  	__GETWRN 16,17,0
          _0x313:
001675   +  	__CPWRN 16,17,512
001678 f460      	BRSH _0x314
         ;    3028 				rp->buff[n] = _FF_buff[n];
001679 940e 205f 	CALL SUBOPT_0x71
00167b 93ff      	PUSH R31
00167c 93ef      	PUSH R30
00167d 940e 2065 	CALL SUBOPT_0x72
00167f 91af      	POP  R26
001680 91bf      	POP  R27
001681 93ec      	ST   X,R30
         ;    3029 			rp->pntr = &rp->buff[0];	// Set pointer to next location				
001682   +  	__ADDWRN 16,17,1
001684 cff0      	RJMP _0x313
          _0x314:
001685 81ee      	LDD  R30,Y+6
001686 81ff      	LDD  R31,Y+6+1
001687 967c      	ADIW R30,28
001688   +  	__PUTW1SN 6,551
         ;    3030 		}
         ;    3031 		if (rp->length==rp->position)
          _0x310:
00168e 940e 20cb 	CALL SUBOPT_0x82
001690 937f      	PUSH R23
001691 936f      	PUSH R22
001692 93ff      	PUSH R31
001693 93ef      	PUSH R30
001694 940e 20c4 	CALL SUBOPT_0x81
001696 91af      	POP  R26
001697 91bf      	POP  R27
001698 918f      	POP  R24
001699 919f      	POP  R25
00169a 940e 22fa 	CALL __CPD12
00169c f441      	BRNE _0x315
         ;    3032 			rp->length++;
00169d 940e 20cb 	CALL SUBOPT_0x82
00169f   +  	__SUBD1N -1
0016a3 940e 22c8 	CALL __PUTDP1
         ;    3033 		if (append_toc(rp)==0)
          _0x315:
0016a5 940e 20a2 	CALL SUBOPT_0x7C
0016a7 f419      	BRNE _0x316
         ;    3034 			return(EOF);
0016a8 efef      	LDI  R30,LOW(65535)
0016a9 efff      	LDI  R31,HIGH(65535)
0016aa c027      	RJMP _0x3DD
         ;    3035 	}
          _0x316:
         ;    3036 	else
0016ab c01c      	RJMP _0x317
          _0x300:
         ;    3037 	{
         ;    3038 		rp->pntr++;
0016ac 940e 20e4 	CALL SUBOPT_0x86
0016ae 9631      	ADIW R30,1
0016af 93ed      	ST   X+,R30
0016b0 93fc      	ST   X,R31
         ;    3039 		if (rp->length==rp->position)
0016b1 940e 20cb 	CALL SUBOPT_0x82
0016b3 937f      	PUSH R23
0016b4 936f      	PUSH R22
0016b5 93ff      	PUSH R31
0016b6 93ef      	PUSH R30
0016b7 940e 20c4 	CALL SUBOPT_0x81
0016b9 91af      	POP  R26
0016ba 91bf      	POP  R27
0016bb 918f      	POP  R24
0016bc 919f      	POP  R25
0016bd 940e 22fa 	CALL __CPD12
0016bf f441      	BRNE _0x318
         ;    3040 			rp->length++;
0016c0 940e 20cb 	CALL SUBOPT_0x82
0016c2   +  	__SUBD1N -1
0016c6 940e 22c8 	CALL __PUTDP1
         ;    3041 	}
          _0x318:
          _0x317:
         ;    3042 	rp->position++;
0016c8 940e 20c4 	CALL SUBOPT_0x81
0016ca   +  	__SUBD1N -1
0016ce 940e 22c8 	CALL __PUTDP1
         ;    3043 	return(file_data);
0016d0 85e8      	LDD  R30,Y+8
0016d1 e0f0      	LDI  R31,0
          _0x3DD:
0016d2 8119      	LDD  R17,Y+1
0016d3 8108      	LDD  R16,Y+0
0016d4 9629      	ADIW R28,9
0016d5 9508      	RET
         ;    3044 }
         ;    3045 
         ;    3046 int fputs(unsigned char *file_data, FILE *rp)
         ;    3047 {
         ;    3048 	while(*file_data)
         ;    3049 		if (fputc(*file_data++,rp) == EOF)
         ;    3050 			return (EOF);
         ;    3051 	if (fputc('\r',rp) == EOF)
         ;    3052 		return (EOF);
         ;    3053 	if (fputc('\n',rp) == EOF)
         ;    3054 		return (EOF);
         ;    3055 	return (0);
         ;    3056 }
         ;    3057 
         ;    3058 int fputsc(flash unsigned char *file_data, FILE *rp)
         ;    3059 {
         ;    3060 	while(*file_data)
         ;    3061 		if (fputc(*file_data++,rp) == EOF)
         ;    3062 			return (EOF);
         ;    3063 	if (fputc('\r',rp) == EOF)
         ;    3064 		return (EOF);
         ;    3065 	if (fputc('\n',rp) == EOF)
         ;    3066 		return (EOF);
         ;    3067 	return (0);
         ;    3068 }
         ;    3069 #endif
         ;    3070 
         ;    3071 #ifndef _READ_ONLY_
         ;    3072 #ifdef _CVAVR_
         ;    3073 void fprintf(FILE *rp, unsigned char flash *pstr, ...)
         ;    3074 {
          _fprintf:
0016d6 92ff      	PUSH R15
0016d7 2ef8      	MOV  R15,R24
         ;    3075 	va_list arglist;
         ;    3076 	unsigned char temp_buff[_FF_MAX_FPRINT], *fp;
         ;    3077 	
         ;    3078 	va_start(arglist, pstr);
0016d8 97ef      	SBIW R28,63
0016d9 97a5      	SBIW R28,37
0016da 940e 2306 	CALL __SAVELOCR4
         ;	*rp -> Y+106
         ;	*pstr -> Y+104
         ;	*arglist -> R16,R17
         ;	temp_buff -> Y+4
         ;	*fp -> R18,R19
0016dc 01de      	MOVW R26,R28
0016dd 59ac      	SUBI R26,LOW(-(100))
0016de 4fbf      	SBCI R27,HIGH(-(100))
0016df 940e 21da 	CALL __ADDW2R15
0016e1   +  	__PUTW2R 16,17
         ;    3079 	vsprintf(temp_buff, pstr, arglist);
0016e3 01fe      	MOVW R30,R28
0016e4 9634      	ADIW R30,4
0016e5 93fa      	ST   -Y,R31
0016e6 93ea      	ST   -Y,R30
0016e7 01de      	MOVW R26,R28
0016e8 59a6      	SUBI R26,LOW(-(106))
0016e9 4fbf      	SBCI R27,HIGH(-(106))
0016ea 940e 20fe 	CALL SUBOPT_0x8A
0016ec 931a      	ST   -Y,R17
0016ed 930a      	ST   -Y,R16
0016ee 940e 1b39 	CALL _vsprintf
         ;    3080 	va_end(arglist);
         ;    3081 	
         ;    3082 	fp = temp_buff;
0016f0 01fe      	MOVW R30,R28
0016f1 9634      	ADIW R30,4
0016f2   +  	__PUTW1R 18,19
         ;    3083 	while (*fp)
          _0x325:
0016f4 940e 1f6e 	CALL SUBOPT_0x58
0016f6 f071      	BREQ _0x327
         ;    3084 		fputc(*fp++, rp);	
0016f7   +  	__GETW2R 18,19
0016f9   +  	__ADDWRN 18,19,1
0016fb 91ec      	LD   R30,X
0016fc 93ea      	ST   -Y,R30
0016fd 01de      	MOVW R26,R28
0016fe 59a5      	SUBI R26,LOW(-(107))
0016ff 4fbf      	SBCI R27,HIGH(-(107))
001700 940e 20fe 	CALL SUBOPT_0x8A
001702 940e 1518 	CALL _fputc
         ;    3085 }
001704 cfef      	RJMP _0x325
          _0x327:
001705 940e 230d 	CALL __LOADLOCR4
001707 96ef      	ADIW R28,63
001708 96a9      	ADIW R28,41
001709 90ff      	POP  R15
00170a 9508      	RET
         ;    3086 #endif
         ;    3087 #ifdef _ICCAVR_
         ;    3088 void fprintf(FILE *rp, unsigned char flash *pstr, long var)
         ;    3089 {
         ;    3090 	unsigned char temp_buff[_FF_MAX_FPRINT], *fp;
         ;    3091 	
         ;    3092 	csprintf(temp_buff, pstr, var);
         ;    3093 	
         ;    3094 	fp = temp_buff;
         ;    3095 	while (*fp)
         ;    3096 		fputc(*fp++, rp);	
         ;    3097 }
         ;    3098 #endif
         ;    3099 #endif
         ;    3100 
         ;    3101 // Set file pointer to the end of the file
         ;    3102 int fend(FILE *rp)
         ;    3103 {
         ;    3104 	return (fseek(rp, 0, SEEK_END));	
         ;    3105 }
         ;    3106 
         ;    3107 // Goto position "off_set" of a file
         ;    3108 int fseek(FILE *rp, unsigned long off_set, unsigned char mode)
         ;    3109 {
          _fseek:
         ;    3110 	unsigned int n, clus_temp;
         ;    3111 	unsigned long length_check, addr_calc;
         ;    3112 	
         ;    3113 	if (rp==NULL)
00170b 9728      	SBIW R28,8
00170c 940e 2306 	CALL __SAVELOCR4
         ;	*rp -> Y+17
         ;	off_set -> Y+13
         ;	mode -> Y+12
         ;	n -> R16,R17
         ;	clus_temp -> R18,R19
         ;	length_check -> Y+8
         ;	addr_calc -> Y+4
00170e 89e9      	LDD  R30,Y+17
00170f 89fa      	LDD  R31,Y+17+1
001710 9730      	SBIW R30,0
001711 f431      	BRNE _0x328
         ;    3114 	{	// ERROR if FILE pointer is NULL
         ;    3115 		_FF_error = FILE_ERR;
001712 e0e2      	LDI  R30,LOW(2)
001713 93e0 073c 	STS  __FF_error,R30
         ;    3116 		return (EOF);
001715 efef      	LDI  R30,LOW(65535)
001716 efff      	LDI  R31,HIGH(65535)
001717 c150      	RJMP _0x3DC
         ;    3117 	}
         ;    3118 	if (mode==SEEK_CUR)
          _0x328:
001718 85ec      	LDD  R30,Y+12
001719 30e0      	CPI  R30,0
00171a f481      	BRNE _0x329
         ;    3119 	{	// Trying to position pointer to offset from current position
         ;    3120 		off_set += rp->position;
00171b 89a9      	LDD  R26,Y+17
00171c 89ba      	LDD  R27,Y+17+1
00171d 5ea0      	SUBI R26,LOW(-544)
00171e 4fbd      	SBCI R27,HIGH(-544)
00171f 940e 22c2 	CALL __GETD1P
001721   +  	__GETD2S 13
001725 940e 21de 	CALL __ADDD12
001727   +  	__PUTD1S 13
         ;    3121 	}
         ;    3122 	if (off_set > rp->length)
          _0x329:
00172b 940e 2105 	CALL SUBOPT_0x8B
00172d 940e 22fa 	CALL __CPD12
00172f f418      	BRSH _0x32A
         ;    3123 	{	// trying to position beyond or before file
         ;    3124 		rp->error = POS_ERR;
001730 940e 2110 	CALL SUBOPT_0x8C
         ;    3125 		_FF_error = POS_ERR;
         ;    3126 		return (EOF);
001732 c135      	RJMP _0x3DC
         ;    3127 	}
         ;    3128 	if (mode==SEEK_END)
          _0x32A:
001733 85ac      	LDD  R26,Y+12
001734 30a1      	CPI  R26,LOW(0x1)
001735 f441      	BRNE _0x32B
         ;    3129 	{	// Trying to position pointer to offset from EOF
         ;    3130 		off_set = rp->length - off_set;
001736 940e 2105 	CALL SUBOPT_0x8B
001738 940e 21e8 	CALL __SUBD12
00173a   +  	__PUTD1S 13
         ;    3131 	}
         ;    3132 	#ifndef _READ_ONLY_
         ;    3133 	if (rp->mode != READ)
          _0x32B:
00173e 89a9      	LDD  R26,Y+17
00173f 89ba      	LDD  R27,Y+17+1
001740 940e 20aa 	CALL SUBOPT_0x7D
001742 f059      	BREQ _0x32C
         ;    3134 		if (fflush(rp))
001743 89e9      	LDD  R30,Y+17
001744 89fa      	LDD  R31,Y+17+1
001745 93fa      	ST   -Y,R31
001746 93ea      	ST   -Y,R30
001747 940e 14af 	CALL _fflush
001749 9730      	SBIW R30,0
00174a f019      	BREQ _0x32D
         ;    3135 			return (EOF);
00174b efef      	LDI  R30,LOW(65535)
00174c efff      	LDI  R31,HIGH(65535)
00174d c11a      	RJMP _0x3DC
         ;    3136 	#endif
         ;    3137 	clus_temp = rp->clus_start;
          _0x32D:
          _0x32C:
00174e 89a9      	LDD  R26,Y+17
00174f 89ba      	LDD  R27,Y+17+1
001750 961c      	ADIW R26,12
001751 912d      	LD   R18,X+
001752 913c      	LD   R19,X
         ;    3138 	rp->clus_current = clus_temp;
001753   +  	__GETW1R 18,19
001755   +  	__PUTW1SNS 17,14
         ;    3139 	rp->clus_next = next_cluster(clus_temp, SINGLE);
00175a 933a      	ST   -Y,R19
00175b 932a      	ST   -Y,R18
00175c 940e 1d90 	CALL SUBOPT_0x26
00175e   +  	__PUTW1SNS 17,16
         ;    3140 	rp->clus_prev = 0;
001763 89a9      	LDD  R26,Y+17
001764 89ba      	LDD  R27,Y+17+1
001765 940e 2017 	CALL SUBOPT_0x68
         ;    3141 	
         ;    3142 	addr_calc = off_set / ((long) BPB_BytsPerSec * (long) BPB_SecPerClus);
001767 940e 1d4f 	CALL SUBOPT_0x20
001769   +  	__GETD2S 13
00176d 940e 2279 	CALL __DIVD21U
00176f   +  	__PUTD1S 4
         ;    3143 	length_check = off_set % ((long) BPB_BytsPerSec * (long) BPB_SecPerClus);
001773 940e 1d4f 	CALL SUBOPT_0x20
001775   +  	__GETD2S 13
001779 940e 22a7 	CALL __MODD21U
00177b   +  	__PUTD1S 8
         ;    3144 	rp->EOF_flag = 0;
00177f 89a9      	LDD  R26,Y+17
001780 89ba      	LDD  R27,Y+17+1
001781 940e 20df 	CALL SUBOPT_0x85
         ;    3145 
         ;    3146 	while (addr_calc)
          _0x32E:
001783   +  	__GETD1S 4
001787 940e 22e8 	CALL __CPD10
001789 f411      	BRNE PC+3
00178a 940c 17d9 	JMP _0x330
         ;    3147 	{
         ;    3148 		if (rp->clus_next >= 0xFFF8)
00178c 89e9      	LDD  R30,Y+17
00178d 89fa      	LDD  R31,Y+17+1
00178e 89a0      	LDD  R26,Z+16
00178f 89b1      	LDD  R27,Z+17
001790 3fa8      	CPI  R26,LOW(0xFFF8)
001791 efef      	LDI  R30,HIGH(0xFFF8)
001792 07be      	CPC  R27,R30
001793 f0e0      	BRLO _0x331
         ;    3149 		{	// trying to position beyond or before file
         ;    3150 			if ((addr_calc==1) && (length_check==0))
001794   +  	__GETD2S 4
001798   +  	__CPD2N 0x1
00179f f439      	BRNE _0x333
0017a0   +  	__GETD2S 8
0017a4 940e 22f4 	CALL __CPD02
0017a6 f009      	BREQ _0x334
          _0x333:
0017a7 c005      	RJMP _0x332
          _0x334:
         ;    3151 			{
         ;    3152 				rp->EOF_flag = 1;
0017a8 89a9      	LDD  R26,Y+17
0017a9 89ba      	LDD  R27,Y+17+1
0017aa 940e 20f9 	CALL SUBOPT_0x89
         ;    3153 				break;
0017ac c02c      	RJMP _0x330
         ;    3154 			}				
         ;    3155 			rp->error = POS_ERR;
          _0x332:
0017ad 940e 2110 	CALL SUBOPT_0x8C
         ;    3156 			_FF_error = POS_ERR;
         ;    3157 			return (EOF);
0017af c0b8      	RJMP _0x3DC
         ;    3158 		}
         ;    3159 		clus_temp = rp->clus_next;
          _0x331:
0017b0 89a9      	LDD  R26,Y+17
0017b1 89ba      	LDD  R27,Y+17+1
0017b2 9650      	ADIW R26,16
0017b3 912d      	LD   R18,X+
0017b4 913c      	LD   R19,X
         ;    3160 		rp->clus_prev = rp->clus_current;
0017b5 89a9      	LDD  R26,Y+17
0017b6 89ba      	LDD  R27,Y+17+1
0017b7 961e      	ADIW R26,14
0017b8 940e 22be 	CALL __GETW1P
0017ba   +  	__PUTW1SNS 17,18
         ;    3161 		rp->clus_current = clus_temp;
0017bf   +  	__GETW1R 18,19
0017c1   +  	__PUTW1SNS 17,14
         ;    3162 		rp->clus_next = next_cluster(clus_temp, CHAIN);
0017c6 940e 1f50 	CALL SUBOPT_0x53
0017c8   +  	__PUTW1SNS 17,16
         ;    3163 		addr_calc--;
0017cd   +  	__GETD1S 4
0017d1 9731      	SBIW R30,1
0017d2 4060      	SBCI R22,0
0017d3 4070      	SBCI R23,0
0017d4   +  	__PUTD1S 4
         ;    3164 	}
0017d8 cfaa      	RJMP _0x32E
          _0x330:
         ;    3165 	
         ;    3166 	addr_calc = clust_to_addr(rp->clus_current);
0017d9 89e9      	LDD  R30,Y+17
0017da 89fa      	LDD  R31,Y+17+1
0017db 85a6      	LDD  R26,Z+14
0017dc 85b7      	LDD  R27,Z+15
0017dd 93ba      	ST   -Y,R27
0017de 93aa      	ST   -Y,R26
0017df 940e 0a53 	CALL _clust_to_addr
0017e1   +  	__PUTD1S 4
         ;    3167 	rp->sec_offset = 1;			// Reset Reading Sector
0017e5 89a9      	LDD  R26,Y+17
0017e6 89ba      	LDD  R27,Y+17+1
0017e7 9654      	ADIW R26,20
0017e8 e0e1      	LDI  R30,LOW(1)
0017e9 e0f0      	LDI  R31,HIGH(1)
0017ea 93ed      	ST   X+,R30
0017eb 93fc      	ST   X,R31
         ;    3168 	while (length_check >= BPB_BytsPerSec)
          _0x335:
0017ec   +  	__GETW1R 6,7
0017ee   +  	__GETD2S 8
0017f2 2766      	CLR  R22
0017f3 2777      	CLR  R23
0017f4 940e 22ff 	CALL __CPD21
0017f6 f0f8      	BRLO _0x337
         ;    3169 	{
         ;    3170 		addr_calc += BPB_BytsPerSec;
0017f7   +  	__GETW1R 6,7
0017f9   +  	__GETD2S 4
0017fd 2766      	CLR  R22
0017fe 2777      	CLR  R23
0017ff 940e 21de 	CALL __ADDD12
001801   +  	__PUTD1S 4
         ;    3171 		length_check -= BPB_BytsPerSec;
001805   +  	__GETW1R 6,7
001807   +  	__GETD2S 8
00180b 940e 1ced 	CALL SUBOPT_0x14
00180d   +  	__PUTD1S 8
         ;    3172 		rp->sec_offset++;
001811 89a9      	LDD  R26,Y+17
001812 89ba      	LDD  R27,Y+17+1
001813 940e 20f2 	CALL SUBOPT_0x88
         ;    3173 	}
001815 cfd6      	RJMP _0x335
          _0x337:
         ;    3174 	
         ;    3175 	if (_FF_read(addr_calc)==0)		// Read Current Data Sector
001816   +  	__GETD1S 4
00181a 940e 1cae 	CALL SUBOPT_0xC
00181c f419      	BRNE _0x338
         ;    3176 		return(EOF);		// Read Error  
00181d efef      	LDI  R30,LOW(65535)
00181e efff      	LDI  R31,HIGH(65535)
00181f c048      	RJMP _0x3DC
         ;    3177 		
         ;    3178 	for (n=0; n<BPB_BytsPerSec; n++)
          _0x338:
001820   +  	__GETWRN 16,17,0
          _0x33A:
001822   +  	__CPWRR 16,17,6,7
001824 f478      	BRSH _0x33B
         ;    3179 		rp->buff[n] = _FF_buff[n];
001825 89e9      	LDD  R30,Y+17
001826 89fa      	LDD  R31,Y+17+1
001827 967c      	ADIW R30,28
001828 0fe0      	ADD  R30,R16
001829 1ff1      	ADC  R31,R17
00182a 93ff      	PUSH R31
00182b 93ef      	PUSH R30
00182c 940e 2065 	CALL SUBOPT_0x72
00182e 91af      	POP  R26
00182f 91bf      	POP  R27
001830 93ec      	ST   X,R30
         ;    3180     
         ;    3181     if ((rp->EOF_flag == 1) && (length_check == 0))
001831   +  	__ADDWRN 16,17,1
001833 cfee      	RJMP _0x33A
          _0x33B:
001834 89a9      	LDD  R26,Y+17
001835 89ba      	LDD  R27,Y+17+1
001836 5daa      	SUBI R26,LOW(-550)
001837 4fbd      	SBCI R27,HIGH(-550)
001838 91ac      	LD   R26,X
001839 30a1      	CPI  R26,LOW(0x1)
00183a f439      	BRNE _0x33D
00183b   +  	__GETD2S 8
00183f 940e 22f4 	CALL __CPD02
001841 f009      	BREQ _0x33E
          _0x33D:
001842 c00a      	RJMP _0x33C
          _0x33E:
         ;    3182     	rp->pntr = &rp->buff[BPB_BytsPerSec-1];
001843 89a9      	LDD  R26,Y+17
001844 89ba      	LDD  R27,Y+17+1
001845 940e 20eb 	CALL SUBOPT_0x87
001847   +  	__PUTW1SN 17,551
         ;    3183 	rp->pntr = &rp->buff[length_check];
          _0x33C:
00184d 89a9      	LDD  R26,Y+17
00184e 89ba      	LDD  R27,Y+17+1
00184f 965c      	ADIW R26,28
001850   +  	__GETD1S 8
001854 0fea      	ADD  R30,R26
001855 1ffb      	ADC  R31,R27
001856   +  	__PUTW1SN 17,551
         ;    3184 	rp->position = off_set;
00185c   +  	__GETD1S 13
001860   +  	__PUTD1SN 17,544
         ;    3185 		
         ;    3186 	return (0);	
001866 e0e0      	LDI  R30,LOW(0)
001867 e0f0      	LDI  R31,HIGH(0)
          _0x3DC:
001868 940e 230d 	CALL __LOADLOCR4
00186a 9663      	ADIW R28,19
00186b 9508      	RET
         ;    3187 }
         ;    3188 
         ;    3189 // Return the current position of the file rp with respect to the begining of the file
         ;    3190 long ftell(FILE *rp)
         ;    3191 {
         ;    3192 	if (rp==NULL)
         ;    3193 		return (EOF);
         ;    3194 	else
         ;    3195 		return (rp->position);
         ;    3196 }
         ;    3197 
         ;    3198 // Funtion that returns a '1' for @EOF, '0' otherwise
         ;    3199 int feof(FILE *rp)
         ;    3200 {
         ;    3201 	if (rp==NULL)
         ;    3202 		return (EOF);
         ;    3203 	
         ;    3204 	if (rp->length==rp->position)
         ;    3205 		return (1);
         ;    3206 	else
         ;    3207 		return (0);
         ;    3208 }
         ;    3209 		
         ;    3210 void dump_file_data_hex(FILE *rp)
         ;    3211 {
         ;    3212 	unsigned int n, c;
         ;    3213 	
         ;    3214 	if (rp==NULL)
         ;	*rp -> Y+4
         ;	n -> R16,R17
         ;	c -> R18,R19
         ;    3215 		return;
         ;    3216 
         ;    3217 	for (n=0; n<0x20; n++)
         ;    3218 	{   
         ;    3219 		printf("\n\r");
         ;    3220 		for (c=0; c<0x10; c++)
         ;    3221 			printf("%02X ", rp->buff[(n*0x20)+c]);
         ;    3222 	}
         ;    3223 }
         ;    3224 
         ;    3225 void dump_file_data_view(FILE *rp)
         ;    3226 {
         ;    3227 	unsigned int n;
         ;    3228 	
         ;    3229 	if (rp==NULL)
         ;	*rp -> Y+2
         ;	n -> R16,R17
         ;    3230 		return;
         ;    3231 
         ;    3232 	printf("\n\r");
         ;    3233 	for (n=0; n<512; n++)
         ;    3234 		putchar(rp->buff[n]);
         ;    3235 }
         ;    3236 
         ;    3237 
         ;    3238 #ifndef _UART_INT_
         ;    3239 	#define		rx_counter0		(UCSR0A & 0x80)
         ;    3240 	#define		tx_counter0		((!UCSR0A) & 0x40)
         ;    3241 	#define		rx_counter1		(UCSR1A & 0x80)
         ;    3242 	#define		tx_counter1		((!UCSR1A) & 0x40)
         ;    3243 #endif
         ;    3244 
         ;    3245 void port_init(void)
         ;    3246 {
          _port_init:
         ;    3247 	PORTA = 0xFF;		DDRA  = 0x00;
00186c efef      	LDI  R30,LOW(255)
00186d bbeb      	OUT  0x1B,R30
00186e e0e0      	LDI  R30,LOW(0)
00186f bbea      	OUT  0x1A,R30
         ;    3248 	PORTB = 0xFF;		DDRB  = 0xD0;
001870 efef      	LDI  R30,LOW(255)
001871 bbe8      	OUT  0x18,R30
001872 ede0      	LDI  R30,LOW(208)
001873 bbe7      	OUT  0x17,R30
         ;    3249 	PORTC = 0xFF; 		DDRC  = 0x00;	  //m103 output only
001874 efef      	LDI  R30,LOW(255)
001875 bbe5      	OUT  0x15,R30
001876 e0e0      	LDI  R30,LOW(0)
001877 bbe4      	OUT  0x14,R30
         ;    3250 	PORTD = 0xFF;		DDRD  = 0x00;
001878 efef      	LDI  R30,LOW(255)
001879 bbe2      	OUT  0x12,R30
00187a e0e0      	LDI  R30,LOW(0)
00187b bbe1      	OUT  0x11,R30
         ;    3251 	PORTE = 0xFF;		DDRE  = 0x00;
00187c efef      	LDI  R30,LOW(255)
00187d b9e3      	OUT  0x3,R30
00187e e0e0      	LDI  R30,LOW(0)
00187f b9e2      	OUT  0x2,R30
         ;    3252 	PORTF = 0xFF;		DDRF  = 0x00;
001880 efef      	LDI  R30,LOW(255)
001881 93e0 0062 	STS  0x62,R30
001883 e0e0      	LDI  R30,LOW(0)
001884 93e0 0061 	STS  0x61,R30
         ;    3253 	PORTG = 0x1F;		DDRG  = 0x00;
001886 e1ef      	LDI  R30,LOW(31)
001887 93e0 0065 	STS  0x65,R30
001889 e0e0      	LDI  R30,LOW(0)
00188a 93e0 0064 	STS  0x64,R30
         ;    3254 }
00188c 9508      	RET
         ;    3255 
         ;    3256 //UART0 initialisation
         ;    3257 // desired baud rate: 115200
         ;    3258 // actual: baud rate:115200 (0.0%)
         ;    3259 // char size: 8 bit
         ;    3260 // parity: Disabled
         ;    3261 void uart0_init(void)
         ;    3262 {
          _uart0_init:
         ;    3263 	UCSR0B = 0x00; //disable while setting baud rate
00188d e0e0      	LDI  R30,LOW(0)
00188e b9ea      	OUT  0xA,R30
         ;    3264 	UCSR0A = 0x00;
00188f b9eb      	OUT  0xB,R30
         ;    3265 	UCSR0C = 0x06;
001890 e0e6      	LDI  R30,LOW(6)
001891 93e0 0095 	STS  0x95,R30
         ;    3266 	UBRR0L = 0x07; //set baud rate lo
001893 e0e7      	LDI  R30,LOW(7)
001894 b9e9      	OUT  0x9,R30
         ;    3267 	UBRR0H = 0x00; //set baud rate hi
001895 e0e0      	LDI  R30,LOW(0)
001896 93e0 0090 	STS  0x90,R30
         ;    3268 	UCSR0B = 0x18;
001898 e1e8      	LDI  R30,LOW(24)
001899 b9ea      	OUT  0xA,R30
         ;    3269 }
00189a 9508      	RET
         ;    3270 
         ;    3271 
         ;    3272 //UART1 initialisation
         ;    3273 // desired baud rate:115200
         ;    3274 // actual baud rate:115200 (0.0%)
         ;    3275 // char size: 8 bit
         ;    3276 // parity: Disabled
         ;    3277 void uart1_init(void)
         ;    3278 {
          _uart1_init:
         ;    3279 	UCSR1B = 0x00; //disable while setting baud rate
00189b e0e0      	LDI  R30,LOW(0)
00189c 93e0 009a 	STS  0x9A,R30
         ;    3280 	UCSR1A = 0x00;
00189e 93e0 009b 	STS  0x9B,R30
         ;    3281 	UCSR1C = 0x06;
0018a0 e0e6      	LDI  R30,LOW(6)
0018a1 93e0 009d 	STS  0x9D,R30
         ;    3282 	UBRR1L = 0x07; //set baud rate lo
0018a3 e0e7      	LDI  R30,LOW(7)
0018a4 93e0 0099 	STS  0x99,R30
         ;    3283 	UBRR1H = 0x00; //set baud rate hi
0018a6 e0e0      	LDI  R30,LOW(0)
0018a7 93e0 0098 	STS  0x98,R30
         ;    3284 	UCSR1B = 0x18;
0018a9 e1e8      	LDI  R30,LOW(24)
0018aa 93e0 009a 	STS  0x9A,R30
         ;    3285 }
0018ac 9508      	RET
         ;    3286 
         ;    3287 
         ;    3288 //call this routine to initialise all peripherals
         ;    3289 void init_devices(void)
         ;    3290 {
          _init_devices:
         ;    3291 	//stop errant interrupts until set up
         ;    3292 	CLI(); //disable all interrupts
0018ad 94f8      	cli
         ;    3293 	XDIV  = 0x00; //xtal divider
0018ae e0e0      	LDI  R30,LOW(0)
0018af bfec      	OUT  0x3C,R30
         ;    3294 	XMCRA = 0x00; //external memory
0018b0 93e0 006d 	STS  0x6D,R30
         ;    3295 	port_init();
0018b2 940e 186c 	CALL _port_init
         ;    3296 	uart0_init();
0018b4 940e 188d 	CALL _uart0_init
         ;    3297 	uart1_init();
0018b6 940e 189b 	CALL _uart1_init
         ;    3298 
         ;    3299 	MCUCR = 0x00;
0018b8 e0e0      	LDI  R30,LOW(0)
0018b9 bfe5      	OUT  0x35,R30
         ;    3300 	EICRA = 0x00; //extended ext ints
0018ba 93e0 006a 	STS  0x6A,R30
         ;    3301 	EICRB = 0x00; //extended ext ints
0018bc bfea      	OUT  0x3A,R30
         ;    3302 	EIMSK = 0x00;
0018bd bfe9      	OUT  0x39,R30
         ;    3303 	TIMSK = 0x00; //timer interrupt sources
0018be bfe7      	OUT  0x37,R30
         ;    3304 	ETIMSK = 0x00; //extended timer interrupt sources
0018bf 93e0 007d 	STS  0x7D,R30
         ;    3305 	SEI(); //re-enable interrupts
0018c1 9478      	sei
         ;    3306 	//all peripherals are now initialised
         ;    3307 }
0018c2 9508      	RET
         ;    3308 
         ;    3309 // Declare your global variables here
         ;    3310 extern unsigned char rtc_hour, rtc_min, rtc_sec;
         ;    3311 extern unsigned char rtc_date, rtc_month;
         ;    3312 extern unsigned int rtc_year;
         ;    3313 #ifdef _ICCAVR_
         ;    3314 extern char _bss_end;
         ;    3315 #endif
         ;    3316 
         ;    3317 
         ;    3318 void main(void)
         ;    3319 {
          _main:
         ;    3320 	FILE *pntr1;
         ;    3321 	unsigned long c, n;
         ;    3322 
         ;    3323  	init_devices();
0018c3 9728      	SBIW R28,8
         ;	*pntr1 -> R16,R17
         ;	c -> Y+4
         ;	n -> Y+0
0018c4 940e 18ad 	CALL _init_devices
         ;    3324 
         ;    3325 	#ifdef _ICCAVR_
         ;    3326 		_NewHeap(&_bss_end + 1, &_bss_end + 1001);
         ;    3327 	#endif
         ;    3328 	
         ;    3329 	#ifdef _RTC_ON_
         ;    3330 		twi_setup();
         ;    3331 	#endif 
         ;    3332 
         ;    3333 
         ;    3334 	PORTB |= 0xD0;    
0018c6 b3e8      	IN   R30,0x18
0018c7 6de0      	ORI  R30,LOW(0xD0)
0018c8 bbe8      	OUT  0x18,R30
         ;    3335 	
         ;    3336 	// initialize the Secure Digital card
         ;    3337 	while (initialize_media()==0)
          _0x34F:
0018c9 940e 0378 	CALL _initialize_media
0018cb 30e0      	CPI  R30,0
0018cc f419      	BRNE _0x351
         ;    3338 	{	// Blink LED while waiting to initialize
         ;    3339 		PORTB ^= 0x40;
0018cd 940e 211b 	CALL SUBOPT_0x8D
         ;    3340 	}
0018cf cff9      	RJMP _0x34F
          _0x351:
         ;    3341 	PORTB &= 0x5F;
0018d0 b3e8      	IN   R30,0x18
0018d1 75ef      	ANDI R30,LOW(0x5F)
0018d2 bbe8      	OUT  0x18,R30
         ;    3342 
         ;    3343 	// Create File
         ;    3344 	
         ;    3345 	pntr1 = fcreatec("demo.dat", 0);
0018d3   +  	__POINTW1FN _0,625
0018d5 940e 2120 	CALL SUBOPT_0x8E
         ;    3346 	while (pntr1==0)
          _0x352:
0018d7 2e00      	MOV  R0,R16
0018d8 2a01      	OR   R0,R17
0018d9 f429      	BRNE _0x354
         ;    3347 		pntr1 = fcreatec("demo.dat", 0);
0018da   +  	__POINTW1FN _0,625
0018dc 940e 2120 	CALL SUBOPT_0x8E
         ;    3348 
         ;    3349 	// Write to file
         ;    3350 	#ifdef _RTC_ON_
         ;    3351 		// if real time clock enabled, get and print time and date to file
         ;    3352 		rtc_get_timeNdate(&rtc_hour, &rtc_min, &rtc_sec, &rtc_date, &rtc_month, (int *)&rtc_year);
         ;    3353 		fputc(0x22, pntr1);		// put a " in before time/date
         ;    3354 		if ((rtc_month/10)==0)
         ;    3355 			fputc('0', pntr1);
         ;    3356 		fprintf(pntr1, "%d/", rtc_month);
         ;    3357 		if ((rtc_date/10)==0)
         ;    3358 			fputc('0', pntr1);
         ;    3359 		fprintf(pntr1, "%d/", rtc_date);
         ;    3360 		fprintf(pntr1, "%d  ", rtc_year);
         ;    3361 		if ((rtc_hour/10)==0)
         ;    3362 			fputc('0', pntr1);
         ;    3363 		fprintf(pntr1, "%d:", rtc_hour);
         ;    3364 			if ((rtc_min/10)==0)
         ;    3365 			fputc('0', pntr1);
         ;    3366 		fprintf(pntr1, "%d:", rtc_min);
         ;    3367 		if ((rtc_sec/10)==0)
         ;    3368 			fputc('0', pntr1);
         ;    3369 		fprintf(pntr1, "%d", rtc_sec);
         ;    3370 		fputc(0x22, pntr1);	    // put a " in after time/date
         ;    3371 		fputsc("", pntr1);
         ;    3372 	#endif
         ;    3373 	
         ;    3374 	#ifdef _CVAVR_
         ;    3375 	fprintf(pntr1, "Column %d, Column %d, Column %d, Column %d, Column %d, Column %d, Column %d, Column %d, Column %d, Column %d,\r\n",
0018de cff8      	RJMP _0x352
          _0x354:
         ;    3376 		0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
0018df 931a      	ST   -Y,R17
0018e0 930a      	ST   -Y,R16
0018e1   +  	__POINTW1FN _0,634
0018e3 940e 2056 	CALL SUBOPT_0x70
0018e5   +  	__GETD1N 0x1
0018e9 940e 22d1 	CALL __PUTPARD1
0018eb   +  	__GETD1N 0x2
0018ef 940e 22d1 	CALL __PUTPARD1
0018f1   +  	__GETD1N 0x3
0018f5 940e 22d1 	CALL __PUTPARD1
0018f7   +  	__GETD1N 0x4
0018fb 940e 22d1 	CALL __PUTPARD1
0018fd   +  	__GETD1N 0x5
001901 940e 22d1 	CALL __PUTPARD1
001903   +  	__GETD1N 0x6
001907 940e 22d1 	CALL __PUTPARD1
001909   +  	__GETD1N 0x7
00190d 940e 22d1 	CALL __PUTPARD1
00190f   +  	__GETD1N 0x8
001913 940e 22d1 	CALL __PUTPARD1
001915   +  	__GETD1N 0x9
001919 940e 22d1 	CALL __PUTPARD1
00191b e288      	LDI  R24,40
00191c 940e 16d6 	CALL _fprintf
00191e 96ac      	ADIW R28,44
         ;    3377 	#endif
         ;    3378 	#ifdef _ICCAVR_
         ;    3379 	fputsc("Column 0, Column 1, Column 2, Column 3, Column 4, Column 5, Column 6, Column 7, Column 8, Column 9,", pntr1);
         ;    3380 	#endif
         ;    3381 	
         ;    3382 	
         ;    3383 	for (c=0; c<100; c++)
00191f   +  	__CLRD1S 4
          _0x356:
001924   +  	__GETD2S 4
001928   +  	__CPD2N 0x64
00192f f010      	BRLO PC+3
001930 940c 197b 	JMP _0x357
         ;    3384 	{	// print numbers separated by commas
         ;    3385 		for (n=0; n<10; n++)
001932   +  	__CLRD1S 0
          _0x359:
001937   +  	__GETD2S 0
00193b   +  	__CPD2N 0xA
001942 f548      	BRSH _0x35A
         ;    3386 			fprintf(pntr1, "%ld, ", (((long)c*10)+(long)n));
001943 931a      	ST   -Y,R17
001944 930a      	ST   -Y,R16
001945   +  	__POINTW1FN _0,746
001947 93fa      	ST   -Y,R31
001948 93ea      	ST   -Y,R30
001949   +  	__GETD2S 8
00194d   +  	__GETD1N 0xA
001951 940e 2261 	CALL __MULD12
001953   +  	__GETD2S 4
001957 940e 21de 	CALL __ADDD12
001959 940e 22d1 	CALL __PUTPARD1
00195b e084      	LDI  R24,4
00195c 940e 16d6 	CALL _fprintf
00195e 9628      	ADIW R28,8
         ;    3387 		if (fputc('\r', pntr1)==EOF)
00195f   +  	__GETD1S 0
001963   +  	__SUBD1N -1
001967   +  	__PUTD1S 0
00196b cfcb      	RJMP _0x359
          _0x35A:
00196c e0ed      	LDI  R30,LOW(13)
00196d 940e 2129 	CALL SUBOPT_0x8F
00196f f059      	BREQ _0x357
         ;    3388 			break;			// line feed/carriage return
         ;    3389 		if (fputc('\n', pntr1)==EOF)
001970 e0ea      	LDI  R30,LOW(10)
001971 940e 2129 	CALL SUBOPT_0x8F
001973 f039      	BREQ _0x357
         ;    3390 			break;			// line feed/carriage return
         ;    3391 		PORTB ^= 0x40;
001974 940e 211b 	CALL SUBOPT_0x8D
         ;    3392 		PORTB ^= 0x80;
001976 940e 2132 	CALL SUBOPT_0x90
         ;    3393 	}
001978 940e 2137 	CALL SUBOPT_0x91
00197a cfa9      	RJMP _0x356
          _0x357:
         ;    3394 
         ;    3395 	fclose(pntr1);
00197b 931a      	ST   -Y,R17
00197c 930a      	ST   -Y,R16
00197d 940e 14f9 	CALL _fclose
         ;    3396 
         ;    3397 	printf("\r\n\r\nDONE!!!");
00197f   +  	__POINTW1FN _0,752
001981 93fa      	ST   -Y,R31
001982 93ea      	ST   -Y,R30
001983 e080      	LDI  R24,0
001984 940e 1b51 	CALL _printf
001986 9622      	ADIW R28,2
         ;    3398 	PORTB &= 0xBF;	// Keep LED on when done
001987 98c6      	CBI  0x18,6
         ;    3399 	while (1)
          _0x35D:
         ;    3400 	{	// Blink LED when done
         ;    3401 		PORTB ^= 0x80;
001988 940e 2132 	CALL SUBOPT_0x90
         ;    3402 		for (c=0; c<100000; c++)
00198a   +  	__CLRD1S 4
          _0x361:
00198f   +  	__GETD2S 4
001993   +  	__CPD2N 0x186A0
00199a f418      	BRSH _0x362
         ;    3403 			;
00199b 940e 2137 	CALL SUBOPT_0x91
00199d cff1      	RJMP _0x361
          _0x362:
         ;    3404 	};
00199e cfe9      	RJMP _0x35D
         ;    3405 }
00199f 9628      	ADIW R28,8
          _0x363:
0019a0 cfff      	RJMP _0x363
         
          _getchar:
0019a1 9b5f           sbis usr,rxc
0019a2 cffe           rjmp _getchar
0019a3 b1ac           in   r26,udr
0019a4 9508      	RET
          _putchar:
0019a5 9b5d           sbis usr,udre
0019a6 cffe           rjmp _putchar
0019a7 81a8           ld   r26,y
0019a8 b9ac           out  udr,r26
0019a9 9621      	ADIW R28,1
0019aa 9508      	RET
          __put_G2:
          	put:
0019ab 81a8      	LD   R26,Y
0019ac 81b9      	LDD  R27,Y+1
0019ad 940e 22be 	CALL __GETW1P
0019af 9730      	SBIW R30,0
0019b0 f049      	BREQ _0x364
0019b1 940e 22be 	CALL __GETW1P
0019b3 9631      	ADIW R30,1
0019b4 93ed      	ST   X+,R30
0019b5 93fc      	ST   X,R31
0019b6 9731      	SBIW R30,1
0019b7 81aa      	LDD  R26,Y+2
0019b8 83a0      	STD  Z+0,R26
0019b9 c004      	RJMP _0x365
          _0x364:
0019ba 81ea      	LDD  R30,Y+2
0019bb 93ea      	ST   -Y,R30
0019bc 940e 19a5 	CALL _putchar
          _0x365:
0019be 9623      	ADIW R28,3
0019bf 9508      	RET
          __print_G2:
0019c0 972b      	SBIW R28,11
0019c1 940e 2304 	CALL __SAVELOCR6
0019c3 e000      	LDI  R16,0
          _0x366:
0019c4 d373      	RCALL SUBOPT_0x1D
0019c5 9731      	SBIW R30,1
0019c6 91e4      	LPM  R30,Z
0019c7 2f3e      	MOV  R19,R30
0019c8 30e0      	CPI  R30,0
0019c9 f411      	BRNE PC+3
0019ca 940c 1b35 	JMP _0x368
0019cc 2fe0      	MOV  R30,R16
0019cd 30e0      	CPI  R30,0
0019ce f431      	BRNE _0x36C
0019cf 3235      	CPI  R19,37
0019d0 f411      	BRNE _0x36D
0019d1 e001      	LDI  R16,LOW(1)
0019d2 c001      	RJMP _0x36E
          _0x36D:
0019d3 d770      	RCALL SUBOPT_0x92
          _0x36E:
0019d4 c15f      	RJMP _0x36B
          _0x36C:
0019d5 30e1      	CPI  R30,LOW(0x1)
0019d6 f4a9      	BRNE _0x36F
0019d7 3235      	CPI  R19,37
0019d8 f419      	BRNE _0x370
0019d9 d76a      	RCALL SUBOPT_0x92
0019da e000      	LDI  R16,LOW(0)
0019db c158      	RJMP _0x36B
          _0x370:
0019dc e002      	LDI  R16,LOW(2)
0019dd e050      	LDI  R21,LOW(0)
0019de e010      	LDI  R17,LOW(0)
0019df 323d      	CPI  R19,45
0019e0 f411      	BRNE _0x371
0019e1 e011      	LDI  R17,LOW(1)
0019e2 c151      	RJMP _0x36B
          _0x371:
0019e3 323b      	CPI  R19,43
0019e4 f411      	BRNE _0x372
0019e5 e25b      	LDI  R21,LOW(43)
0019e6 c14d      	RJMP _0x36B
          _0x372:
0019e7 3230      	CPI  R19,32
0019e8 f411      	BRNE _0x373
0019e9 e250      	LDI  R21,LOW(32)
0019ea c149      	RJMP _0x36B
          _0x373:
0019eb c002      	RJMP _0x374
          _0x36F:
0019ec 30e2      	CPI  R30,LOW(0x2)
0019ed f439      	BRNE _0x375
          _0x374:
0019ee e040      	LDI  R20,LOW(0)
0019ef e003      	LDI  R16,LOW(3)
0019f0 3330      	CPI  R19,48
0019f1 f411      	BRNE _0x376
0019f2 6810      	ORI  R17,LOW(128)
0019f3 c140      	RJMP _0x36B
          _0x376:
0019f4 c002      	RJMP _0x377
          _0x375:
0019f5 30e3      	CPI  R30,LOW(0x3)
0019f6 f4a1      	BRNE _0x378
          _0x377:
0019f7 3330      	CPI  R19,48
0019f8 f010      	BRLO _0x37A
0019f9 333a      	CPI  R19,58
0019fa f008      	BRLO _0x37B
          _0x37A:
0019fb c009      	RJMP _0x379
          _0x37B:
0019fc 2fa4      	MOV  R26,R20
0019fd e0ea      	LDI  R30,LOW(10)
0019fe 9fea      	MUL  R30,R26
0019ff 2de0      	MOV  R30,R0
001a00 2f4e      	MOV  R20,R30
001a01 2fe3      	MOV  R30,R19
001a02 53e0      	SUBI R30,LOW(48)
001a03 0f4e      	ADD  R20,R30
001a04 c12f      	RJMP _0x36B
          _0x379:
001a05 363c      	CPI  R19,108
001a06 f419      	BRNE _0x37C
001a07 6012      	ORI  R17,LOW(2)
001a08 e005      	LDI  R16,LOW(5)
001a09 c12a      	RJMP _0x36B
          _0x37C:
001a0a c004      	RJMP _0x37D
          _0x378:
001a0b 30e5      	CPI  R30,LOW(0x5)
001a0c f011      	BREQ PC+3
001a0d 940c 1b34 	JMP _0x36B
          _0x37D:
001a0f 2fe3      	MOV  R30,R19
001a10 36e3      	CPI  R30,LOW(0x63)
001a11 f421      	BRNE _0x382
001a12 d738      	RCALL SUBOPT_0x93
001a13 91ec      	LD   R30,X
001a14 d73d      	RCALL SUBOPT_0x94
001a15 c11d      	RJMP _0x383
          _0x382:
001a16 37e3      	CPI  R30,LOW(0x73)
001a17 f431      	BRNE _0x385
001a18 d732      	RCALL SUBOPT_0x93
001a19 d73f      	RCALL SUBOPT_0x95
001a1a 940e 2199 	CALL _strlen
001a1c 2f0e      	MOV  R16,R30
001a1d c008      	RJMP _0x386
          _0x385:
001a1e 37e0      	CPI  R30,LOW(0x70)
001a1f f459      	BRNE _0x388
001a20 d72a      	RCALL SUBOPT_0x93
001a21 d737      	RCALL SUBOPT_0x95
001a22 940e 21a3 	CALL _strlenf
001a24 2f0e      	MOV  R16,R30
001a25 6018      	ORI  R17,LOW(8)
          _0x386:
001a26 771f      	ANDI R17,LOW(127)
001a27 e0e0      	LDI  R30,LOW(0)
001a28 8be8      	STD  Y+16,R30
001a29 e020      	LDI  R18,LOW(0)
001a2a c073      	RJMP _0x389
          _0x388:
001a2b 36e4      	CPI  R30,LOW(0x64)
001a2c f011      	BREQ _0x38C
001a2d 36e9      	CPI  R30,LOW(0x69)
001a2e f411      	BRNE _0x38D
          _0x38C:
001a2f 6014      	ORI  R17,LOW(4)
001a30 c002      	RJMP _0x38E
          _0x38D:
001a31 37e5      	CPI  R30,LOW(0x75)
001a32 f4c1      	BRNE _0x38F
          _0x38E:
001a33 e0ea      	LDI  R30,LOW(10)
001a34 8be8      	STD  Y+16,R30
001a35 ff11      	SBRS R17,1
001a36 c00a      	RJMP _0x390
001a37   +  	__GETD1N 0x3B9ACA00
001a3b   +  	__PUTD1S 8
001a3f e00a      	LDI  R16,LOW(10)
001a40 c029      	RJMP _0x391
          _0x390:
001a41   +  	__GETD1N 0x2710
001a45   +  	__PUTD1S 8
001a49 e005      	LDI  R16,LOW(5)
001a4a c01f      	RJMP _0x391
          _0x38F:
001a4b 35e8      	CPI  R30,LOW(0x58)
001a4c f411      	BRNE _0x393
001a4d 6018      	ORI  R17,LOW(8)
001a4e c004      	RJMP _0x394
          _0x393:
001a4f 37e8      	CPI  R30,LOW(0x78)
001a50 f011      	BREQ PC+3
001a51 940c 1b33 	JMP _0x3C7
          _0x394:
001a53 e1e0      	LDI  R30,LOW(16)
001a54 8be8      	STD  Y+16,R30
001a55 ff11      	SBRS R17,1
001a56 c00a      	RJMP _0x396
001a57   +  	__GETD1N 0x10000000
001a5b   +  	__PUTD1S 8
001a5f e008      	LDI  R16,LOW(8)
001a60 c009      	RJMP _0x391
          _0x396:
001a61   +  	__GETD1N 0x1000
001a65   +  	__PUTD1S 8
001a69 e004      	LDI  R16,LOW(4)
          _0x391:
001a6a ff11      	SBRS R17,1
001a6b c008      	RJMP _0x397
001a6c d6de      	RCALL SUBOPT_0x93
001a6d 940e 22c2 	CALL __GETD1P
001a6f   +  	__PUTD1S 12
001a73 c011      	RJMP _0x398
          _0x397:
001a74 ff12      	SBRS R17,2
001a75 c006      	RJMP _0x399
001a76 d6d4      	RCALL SUBOPT_0x93
001a77 940e 22be 	CALL __GETW1P
001a79 940e 2234 	CALL __CWD1
001a7b c005      	RJMP _0x3F6
          _0x399:
001a7c d6ce      	RCALL SUBOPT_0x93
001a7d 940e 22be 	CALL __GETW1P
001a7f 2766      	CLR  R22
001a80 2777      	CLR  R23
          _0x3F6:
001a81   +  	__PUTD1S 12
          _0x398:
001a85 ff12      	SBRS R17,2
001a86 c017      	RJMP _0x39B
001a87   +  	__GETD2S 12
001a8b 940e 22f0 	CALL __CPD20
001a8d f45c      	BRGE _0x39C
001a8e   +  	__GETD1S 12
001a92 940e 21f2 	CALL __ANEGD1
001a94   +  	__PUTD1S 12
001a98 e25d      	LDI  R21,LOW(45)
          _0x39C:
001a99 3050      	CPI  R21,0
001a9a f011      	BREQ _0x39D
001a9b 5f0f      	SUBI R16,-LOW(1)
001a9c c001      	RJMP _0x39E
          _0x39D:
001a9d 7f1b      	ANDI R17,LOW(251)
          _0x39E:
          _0x39B:
          _0x389:
001a9e fd10      	SBRC R17,0
001a9f c010      	RJMP _0x39F
          _0x3A0:
001aa0 1704      	CP   R16,R20
001aa1 f470      	BRSH _0x3A2
001aa2 ff17      	SBRS R17,7
001aa3 c008      	RJMP _0x3A3
001aa4 ff12      	SBRS R17,2
001aa5 c004      	RJMP _0x3A4
001aa6 7f1b      	ANDI R17,LOW(251)
001aa7 2f35      	MOV  R19,R21
001aa8 5001      	SUBI R16,LOW(1)
001aa9 c001      	RJMP _0x3A5
          _0x3A4:
001aaa e330      	LDI  R19,LOW(48)
          _0x3A5:
001aab c001      	RJMP _0x3A6
          _0x3A3:
001aac e230      	LDI  R19,LOW(32)
          _0x3A6:
001aad d696      	RCALL SUBOPT_0x92
001aae 5041      	SUBI R20,LOW(1)
001aaf cff0      	RJMP _0x3A0
          _0x3A2:
          _0x39F:
001ab0 2f20      	MOV  R18,R16
001ab1 89e8      	LDD  R30,Y+16
001ab2 30e0      	CPI  R30,0
001ab3 f4c9      	BRNE _0x3A7
          _0x3A8:
001ab4 3020      	CPI  R18,0
001ab5 f0b1      	BREQ _0x3AA
001ab6 ff13      	SBRS R17,3
001ab7 c008      	RJMP _0x3AB
001ab8 81ee      	LDD  R30,Y+6
001ab9 81ff      	LDD  R31,Y+6+1
001aba 9631      	ADIW R30,1
001abb 83ee      	STD  Y+6,R30
001abc 83ff      	STD  Y+6+1,R31
001abd 9731      	SBIW R30,1
001abe 91e4      	LPM  R30,Z
001abf c005      	RJMP _0x3F7
          _0x3AB:
001ac0 81ae      	LDD  R26,Y+6
001ac1 81bf      	LDD  R27,Y+6+1
001ac2 91ed      	LD   R30,X+
001ac3 83ae      	STD  Y+6,R26
001ac4 83bf      	STD  Y+6+1,R27
          _0x3F7:
001ac5 93ea      	ST   -Y,R30
001ac6 d699      	RCALL SUBOPT_0x96
001ac7 3040      	CPI  R20,0
001ac8 f009      	BREQ _0x3AD
001ac9 5041      	SUBI R20,LOW(1)
          _0x3AD:
001aca 5021      	SUBI R18,LOW(1)
001acb cfe8      	RJMP _0x3A8
          _0x3AA:
001acc c05e      	RJMP _0x3AE
          _0x3A7:
          _0x3B0:
001acd   +  	__GETD1S 8
001ad1   +  	__GETD2S 12
001ad5 940e 2279 	CALL __DIVD21U
001ad7 2f3e      	MOV  R19,R30
001ad8 e0e9      	LDI  R30,LOW(9)
001ad9 17e3      	CP   R30,R19
001ada f430      	BRSH _0x3B2
001adb ff13      	SBRS R17,3
001adc c002      	RJMP _0x3B3
001add 5c39      	SUBI R19,-LOW(55)
001ade c001      	RJMP _0x3B4
          _0x3B3:
001adf 5a39      	SUBI R19,-LOW(87)
          _0x3B4:
001ae0 c001      	RJMP _0x3B5
          _0x3B2:
001ae1 5d30      	SUBI R19,-LOW(48)
          _0x3B5:
001ae2 fd14      	SBRC R17,4
001ae3 c022      	RJMP _0x3B7
001ae4 e3e0      	LDI  R30,LOW(48)
001ae5 17e3      	CP   R30,R19
001ae6 f060      	BRLO _0x3B9
001ae7   +  	__GETD2S 8
001aeb   +  	__CPD2N 0x1
001af2 f409      	BRNE _0x3B8
          _0x3B9:
001af3 c009      	RJMP _0x3BB
          _0x3B8:
001af4 1742      	CP   R20,R18
001af5 f010      	BRLO _0x3BD
001af6 ff10      	SBRS R17,0
001af7 c001      	RJMP _0x3BE
          _0x3BD:
001af8 c011      	RJMP _0x3BC
          _0x3BE:
001af9 e230      	LDI  R19,LOW(32)
001afa ff17      	SBRS R17,7
001afb c00a      	RJMP _0x3BF
001afc e330      	LDI  R19,LOW(48)
          _0x3BB:
001afd 6110      	ORI  R17,LOW(16)
001afe ff12      	SBRS R17,2
001aff c006      	RJMP _0x3C0
001b00 7f1b      	ANDI R17,LOW(251)
001b01 935a      	ST   -Y,R21
001b02 d65d      	RCALL SUBOPT_0x96
001b03 3040      	CPI  R20,0
001b04 f009      	BREQ _0x3C1
001b05 5041      	SUBI R20,LOW(1)
          _0x3C1:
          _0x3C0:
          _0x3BF:
          _0x3B7:
001b06 d63d      	RCALL SUBOPT_0x92
001b07 3040      	CPI  R20,0
001b08 f009      	BREQ _0x3C2
001b09 5041      	SUBI R20,LOW(1)
          _0x3C2:
          _0x3BC:
001b0a 5021      	SUBI R18,LOW(1)
001b0b   +  	__GETD1S 8
001b0f   +  	__GETD2S 12
001b13 940e 22a7 	CALL __MODD21U
001b15   +  	__PUTD1S 12
001b19 89e8      	LDD  R30,Y+16
001b1a   +  	__GETD2S 8
001b1e 27ff      	CLR  R31
001b1f 2766      	CLR  R22
001b20 2777      	CLR  R23
001b21 940e 2279 	CALL __DIVD21U
001b23   +  	__PUTD1S 8
001b27 940e 22e8 	CALL __CPD10
001b29 f009      	BREQ _0x3B1
001b2a cfa2      	RJMP _0x3B0
          _0x3B1:
          _0x3AE:
001b2b ff10      	SBRS R17,0
001b2c c006      	RJMP _0x3C3
          _0x3C4:
001b2d 3040      	CPI  R20,0
001b2e f021      	BREQ _0x3C6
001b2f 5041      	SUBI R20,LOW(1)
001b30 e2e0      	LDI  R30,LOW(32)
001b31 d620      	RCALL SUBOPT_0x94
001b32 cffa      	RJMP _0x3C4
          _0x3C6:
          _0x3C3:
          _0x3C7:
          _0x383:
001b33 e000      	LDI  R16,LOW(0)
          _0x36B:
001b34 ce8f      	RJMP _0x366
          _0x368:
001b35 940e 230b 	CALL __LOADLOCR6
001b37 9667      	ADIW R28,23
001b38 9508      	RET
          _vsprintf:
001b39 9722      	SBIW R28,2
001b3a 81ee      	LDD  R30,Y+6
001b3b 81ff      	LDD  R31,Y+6+1
001b3c 83e8      	ST   Y,R30
001b3d 83f9      	STD  Y+1,R31
001b3e 81ec      	LDD  R30,Y+4
001b3f 81fd      	LDD  R31,Y+4+1
001b40 93fa      	ST   -Y,R31
001b41 93ea      	ST   -Y,R30
001b42 81ec      	LDD  R30,Y+4
001b43 81fd      	LDD  R31,Y+4+1
001b44 93fa      	ST   -Y,R31
001b45 93ea      	ST   -Y,R30
001b46 01fe      	MOVW R30,R28
001b47 9634      	ADIW R30,4
001b48 93fa      	ST   -Y,R31
001b49 93ea      	ST   -Y,R30
001b4a de75      	RCALL __print_G2
001b4b 81a8      	LD   R26,Y
001b4c 81b9      	LDD  R27,Y+1
001b4d e0e0      	LDI  R30,LOW(0)
001b4e 93ec      	ST   X,R30
001b4f 9628      	ADIW R28,8
001b50 9508      	RET
          _printf:
001b51 92ff      	PUSH R15
001b52 2ef8      	MOV  R15,R24
001b53 9722      	SBIW R28,2
001b54 931a      	ST   -Y,R17
001b55 930a      	ST   -Y,R16
001b56 01de      	MOVW R26,R28
001b57 940e 21da 	CALL __ADDW2R15
001b59   +  	__PUTW2R 16,17
001b5b e0e0      	LDI  R30,0
001b5c 83ea      	STD  Y+2,R30
001b5d 83eb      	STD  Y+2+1,R30
001b5e 01de      	MOVW R26,R28
001b5f 9614      	ADIW R26,4
001b60 d59d      	RCALL SUBOPT_0x8A
001b61 931a      	ST   -Y,R17
001b62 930a      	ST   -Y,R16
001b63 01fe      	MOVW R30,R28
001b64 9636      	ADIW R30,6
001b65 93fa      	ST   -Y,R31
001b66 93ea      	ST   -Y,R30
001b67 de58      	RCALL __print_G2
001b68 8119      	LDD  R17,Y+1
001b69 8108      	LDD  R16,Y+0
001b6a 9624      	ADIW R28,4
001b6b 90ff      	POP  R15
001b6c 9508      	RET
          _allocate_block_G3:
001b6d 9722      	SBIW R28,2
001b6e 940e 2304 	CALL __SAVELOCR6
001b70   +  	__GETWRN 16,17,2084
001b72   +  	__GETW2R 16,17
001b74 e0e0      	LDI  R30,LOW(0)
001b75 e0f0      	LDI  R31,HIGH(0)
001b76 93ed      	ST   X+,R30
001b77 93fc      	ST   X,R31
          _0x3C8:
001b78 2e00      	MOV  R0,R16
001b79 2a01      	OR   R0,R17
001b7a f1c1      	BREQ _0x3CA
001b7b   +  	__GETW2R 16,17
001b7d 940e 22be 	CALL __GETW1P
001b7f 0fe0      	ADD  R30,R16
001b80 1ff1      	ADC  R31,R17
001b81 9634      	ADIW R30,4
001b82   +  	__PUTW1R 20,21
001b84 d5e1      	RCALL SUBOPT_0x97
001b85 9730      	SBIW R30,0
001b86 f019      	BREQ _0x3CB
001b87   +  	__PUTWSR 18,19,6
001b89 c004      	RJMP _0x3CC
          _0x3CB:
001b8a e0e0      	LDI  R30,LOW(4352)
001b8b e1f1      	LDI  R31,HIGH(4352)
001b8c 83ee      	STD  Y+6,R30
001b8d 83ff      	STD  Y+6+1,R31
          _0x3CC:
001b8e 81ee      	LDD  R30,Y+6
001b8f 81ff      	LDD  R31,Y+6+1
001b90 1be4      	SUB  R30,R20
001b91 0bf5      	SBC  R31,R21
001b92 01df      	MOVW R26,R30
001b93 85e8      	LDD  R30,Y+8
001b94 85f9      	LDD  R31,Y+8+1
001b95 9634      	ADIW R30,4
001b96 17ae      	CP   R26,R30
001b97 07bf      	CPC  R27,R31
001b98 f0b8      	BRLO _0x3CD
001b99   +  	__GETW1R 20,21
001b9b   +  	__PUTW1RNS 16,2
001b9f   +  	__GETW1R 18,19
001ba1   +  	__PUTW1RNS 20,2
001ba5 85e8      	LDD  R30,Y+8
001ba6 85f9      	LDD  R31,Y+8+1
001ba7   +  	__GETW2R 20,21
001ba9 93ed      	ST   X+,R30
001baa 93fc      	ST   X,R31
001bab   +  	__ADDWRN 20,21,4
001bad   +  	__GETW1R 20,21
001baf c005      	RJMP _0x3DB
          _0x3CD:
001bb0   +  	__MOVEWRR 16,17,18,19
001bb2 cfc5      	RJMP _0x3C8
          _0x3CA:
001bb3 e0e0      	LDI  R30,LOW(0)
001bb4 e0f0      	LDI  R31,HIGH(0)
          _0x3DB:
001bb5 940e 230b 	CALL __LOADLOCR6
001bb7 962a      	ADIW R28,10
001bb8 9508      	RET
          _find_prev_block_G3:
001bb9 940e 2306 	CALL __SAVELOCR4
001bbb   +  	__GETWRN 16,17,2084
          _0x3CE:
001bbd 2e00      	MOV  R0,R16
001bbe 2a01      	OR   R0,R17
001bbf f069      	BREQ _0x3D0
001bc0 d5a5      	RCALL SUBOPT_0x97
001bc1 01df      	MOVW R26,R30
001bc2 81ec      	LDD  R30,Y+4
001bc3 81fd      	LDD  R31,Y+4+1
001bc4 17ea      	CP   R30,R26
001bc5 07fb      	CPC  R31,R27
001bc6 f419      	BRNE _0x3D1
001bc7   +  	__GETW1R 16,17
001bc9 c005      	RJMP _0x3DA
          _0x3D1:
001bca   +  	__MOVEWRR 16,17,18,19
001bcc cff0      	RJMP _0x3CE
          _0x3D0:
001bcd e0e0      	LDI  R30,LOW(0)
001bce e0f0      	LDI  R31,HIGH(0)
          _0x3DA:
001bcf 940e 230d 	CALL __LOADLOCR4
001bd1 9626      	ADIW R28,6
001bd2 9508      	RET
          _realloc:
001bd3 9722      	SBIW R28,2
001bd4 940e 2304 	CALL __SAVELOCR6
001bd6 85ea      	LDD  R30,Y+10
001bd7 85fb      	LDD  R31,Y+10+1
001bd8 9730      	SBIW R30,0
001bd9 f411      	BRNE PC+3
001bda 940c 1c1f 	JMP _0x3D2
001bdc 9734      	SBIW R30,4
001bdd   +  	__PUTW1R 16,17
001bdf 931a      	ST   -Y,R17
001be0 930a      	ST   -Y,R16
001be1 dfd7      	RCALL _find_prev_block_G3
001be2   +  	__PUTW1R 18,19
001be4 9730      	SBIW R30,0
001be5 f1c9      	BREQ _0x3D3
001be6   +  	__GETW2R 16,17
001be8 9612      	ADIW R26,2
001be9 940e 22be 	CALL __GETW1P
001beb   +  	__PUTW1RNS 18,2
001bef 85e8      	LDD  R30,Y+8
001bf0 85f9      	LDD  R31,Y+8+1
001bf1 9730      	SBIW R30,0
001bf2 f161      	BREQ _0x3D4
001bf3 93fa      	ST   -Y,R31
001bf4 93ea      	ST   -Y,R30
001bf5 df77      	RCALL _allocate_block_G3
001bf6   +  	__PUTW1R 20,21
001bf8 9730      	SBIW R30,0
001bf9 f0f9      	BREQ _0x3D5
001bfa   +  	__GETW2R 16,17
001bfc 940e 22be 	CALL __GETW1P
001bfe 83ee      	STD  Y+6,R30
001bff 83ff      	STD  Y+6+1,R31
001c00 01df      	MOVW R26,R30
001c01 85e8      	LDD  R30,Y+8
001c02 85f9      	LDD  R31,Y+8+1
001c03 17ae      	CP   R26,R30
001c04 07bf      	CPC  R27,R31
001c05 f420      	BRSH _0x3D6
001c06 81ee      	LDD  R30,Y+6
001c07 81ff      	LDD  R31,Y+6+1
001c08 87e8      	STD  Y+8,R30
001c09 87f9      	STD  Y+8+1,R31
          _0x3D6:
001c0a 935a      	ST   -Y,R21
001c0b 934a      	ST   -Y,R20
001c0c 85ec      	LDD  R30,Y+12
001c0d 85fd      	LDD  R31,Y+12+1
001c0e 93fa      	ST   -Y,R31
001c0f 93ea      	ST   -Y,R30
001c10 85ec      	LDD  R30,Y+12
001c11 85fd      	LDD  R31,Y+12+1
001c12 93fa      	ST   -Y,R31
001c13 93ea      	ST   -Y,R30
001c14 940e 216e 	CALL _memmove
001c16   +  	__GETW1R 20,21
001c18 c008      	RJMP _0x3D9
          _0x3D5:
001c19   +  	__GETW1R 16,17
001c1b   +  	__PUTW1RNS 18,2
          _0x3D4:
          _0x3D3:
          _0x3D2:
001c1f e0e0      	LDI  R30,LOW(0)
001c20 e0f0      	LDI  R31,HIGH(0)
          _0x3D9:
001c21 940e 230b 	CALL __LOADLOCR6
001c23 962c      	ADIW R28,12
001c24 9508      	RET
          _malloc:
001c25 931a      	ST   -Y,R17
001c26 930a      	ST   -Y,R16
001c27   +  	__GETWRN 16,17,0
001c29 81ea      	LDD  R30,Y+2
001c2a 81fb      	LDD  R31,Y+2+1
001c2b 9730      	SBIW R30,0
001c2c f089      	BREQ _0x3D7
001c2d 93fa      	ST   -Y,R31
001c2e 93ea      	ST   -Y,R30
001c2f df3d      	RCALL _allocate_block_G3
001c30   +  	__PUTW1R 16,17
001c32 9730      	SBIW R30,0
001c33 f051      	BREQ _0x3D8
001c34 931a      	ST   -Y,R17
001c35 930a      	ST   -Y,R16
001c36 e0e0      	LDI  R30,LOW(0)
001c37 93ea      	ST   -Y,R30
001c38 81ed      	LDD  R30,Y+5
001c39 81fe      	LDD  R31,Y+5+1
001c3a 93fa      	ST   -Y,R31
001c3b 93ea      	ST   -Y,R30
001c3c 940e 218b 	CALL _memset
          _0x3D8:
          _0x3D7:
001c3e   +  	__GETW1R 16,17
001c40 8119      	LDD  R17,Y+1
001c41 8108      	LDD  R16,Y+0
001c42 9624      	ADIW R28,4
001c43 9508      	RET
          _free:
001c44 81e8      	LD   R30,Y
001c45 81f9      	LDD  R31,Y+1
001c46 93fa      	ST   -Y,R31
001c47 93ea      	ST   -Y,R30
001c48 e0e0      	LDI  R30,LOW(0)
001c49 e0f0      	LDI  R31,HIGH(0)
001c4a 93fa      	ST   -Y,R31
001c4b 93ea      	ST   -Y,R30
001c4c df86      	RCALL _realloc
001c4d 9622      	ADIW R28,2
001c4e 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x0:
001c4f 940e 0265 	CALL __FF_spi
001c51 85ae      	LDD  R26,Y+14
001c52 27bb      	CLR  R27
001c53 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x1:
001c54 0fea      	ADD  R30,R26
001c55 1ffb      	ADC  R31,R27
001c56 940e 22cd 	CALL __GETW1PF
001c58   +  	__PUTW1R 18,19
001c5a 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x2:
001c5b 940e 2207 	CALL __LSRD12
001c5d 2f0e      	MOV  R16,R30
001c5e 930a      	ST   -Y,R16
001c5f 940e 0265 	CALL __FF_spi
001c61   +  	__GETD1S 10
001c65 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x3:
001c66 2f0e      	MOV  R16,R30
001c67 930a      	ST   -Y,R16
001c68 940c 0265 	JMP  __FF_spi
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES
          SUBOPT_0x4:
001c6a 940e 0265 	CALL __FF_spi
001c6c efef      	LDI  R30,LOW(255)
001c6d 93ea      	ST   -Y,R30
001c6e 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 20 TIMES
          SUBOPT_0x5:
001c6f efef      	LDI  R30,LOW(255)
001c70 93ea      	ST   -Y,R30
001c71 940c 0265 	JMP  __FF_spi
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x6:
001c73 27ff      	CLR  R31
001c74 2766      	CLR  R22
001c75 2777      	CLR  R23
001c76   +  	__PUTD1S 6
001c7a   +  	__GETD2S 6
001c7e 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x7:
001c7f 27ff      	CLR  R31
001c80 2766      	CLR  R22
001c81 2777      	CLR  R23
001c82   +  	__PUTD1S 6
001c86 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x8:
001c87 91a0 0500 	LDS  R26,_OCR_REG
001c89 91b0 0501 	LDS  R27,_OCR_REG+1
001c8b 9180 0502 	LDS  R24,_OCR_REG+2
001c8d 9190 0503 	LDS  R25,_OCR_REG+3
001c8f 940e 21ed 	CALL __ORD12
001c91 93e0 0500 	STS  _OCR_REG,R30
001c93 93f0 0501 	STS  _OCR_REG+1,R31
001c95 9360 0502 	STS  _OCR_REG+2,R22
001c97 9370 0503 	STS  _OCR_REG+3,R23
001c99 cfd5      	RJMP SUBOPT_0x5
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x9:
001c9a efef      	LDI  R30,LOW(255)
001c9b 93ea      	ST   -Y,R30
001c9c cfcd      	RJMP SUBOPT_0x4
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0xA:
001c9d e5e0      	LDI  R30,LOW(80)
001c9e b9ed      	OUT  0xD,R30
001c9f e0e0      	LDI  R30,LOW(0)
001ca0 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
          SUBOPT_0xB:
001ca1   +  	__GETD1S 1
001ca5   +  	__SUBD1N -1
001ca9   +  	__PUTD1S 1
001cad 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 23 TIMES
          SUBOPT_0xC:
001cae 940e 22d1 	CALL __PUTPARD1
001cb0 940e 07e8 	CALL __FF_read
001cb2 30e0      	CPI  R30,0
001cb3 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0xD:
001cb4 de9c      	RCALL _printf
001cb5 9622      	ADIW R28,2
001cb6 e0e1      	LDI  R30,LOW(1)
001cb7 93e0 073c 	STS  __FF_error,R30
001cb9 e0e0      	LDI  R30,LOW(0)
001cba 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0xE:
001cbb 2766      	CLR  R22
001cbc 2777      	CLR  R23
001cbd 01df      	MOVW R26,R30
001cbe 01cb      	MOVW R24,R22
001cbf   +  	__GETW1R 6,7
001cc1 2766      	CLR  R22
001cc2 2777      	CLR  R23
001cc3 940e 2261 	CALL __MULD12
001cc5 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0xF:
001cc6 e0f0      	LDI  R31,0
001cc7 2bea      	OR   R30,R26
001cc8 2bfb      	OR   R31,R27
001cc9 2766      	CLR  R22
001cca 2777      	CLR  R23
001ccb 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x10:
001ccc 27ff      	CLR  R31
001ccd 2766      	CLR  R22
001cce 2777      	CLR  R23
001ccf 01df      	MOVW R26,R30
001cd0 01cb      	MOVW R24,R22
001cd1 e1e8      	LDI  R30,LOW(24)
001cd2 940e 21fb 	CALL __LSLD12
001cd4 01df      	MOVW R26,R30
001cd5 01cb      	MOVW R24,R22
001cd6 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x11:
001cd7 27ff      	CLR  R31
001cd8 2766      	CLR  R22
001cd9 2777      	CLR  R23
001cda 940e 222f 	CALL __LSLD16
001cdc 940e 21ed 	CALL __ORD12
001cde 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x12:
001cdf 27ff      	CLR  R31
001ce0 2766      	CLR  R22
001ce1 2777      	CLR  R23
001ce2 01df      	MOVW R26,R30
001ce3 01cb      	MOVW R24,R22
001ce4 e0e8      	LDI  R30,LOW(8)
001ce5 940e 21fb 	CALL __LSLD12
001ce7 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x13:
001ce8 9731      	SBIW R30,1
001ce9 01df      	MOVW R26,R30
001cea   +  	__GETW1R 6,7
001cec 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
          SUBOPT_0x14:
001ced 2766      	CLR  R22
001cee 2777      	CLR  R23
001cef 940e 22db 	CALL __SWAPD12
001cf1 940e 21e8 	CALL __SUBD12
001cf3 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x15:
001cf4 93ea      	ST   -Y,R30
001cf5   +  	__GETD1N 0x0
001cf9 940e 22d1 	CALL __PUTPARD1
001cfb 940e 026c 	CALL _send_cmd
001cfd 2f0e      	MOV  R16,R30
001cfe 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x16:
001cff e5e0      	LDI  R30,LOW(80)
001d00 b9ed      	OUT  0xD,R30
001d01 e0e1      	LDI  R30,LOW(1)
001d02 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x17:
001d03   +  	__GETW1R 6,7
001d05   +  	__GETD2S 5
001d09 2766      	CLR  R22
001d0a 2777      	CLR  R23
001d0b 940e 22a7 	CALL __MODD21U
001d0d 940e 22e8 	CALL __CPD10
001d0f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x18:
001d10 e0e4      	LDI  R30,LOW(4)
001d11 93e0 073c 	STS  __FF_error,R30
001d13 e0e0      	LDI  R30,LOW(0)
001d14 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x19:
001d15 93ea      	ST   -Y,R30
001d16   +  	__GETD1S 6
001d1a 940e 22d1 	CALL __PUTPARD1
001d1c 940e 026c 	CALL _send_cmd
001d1e 2f0e      	MOV  R16,R30
001d1f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x1A:
001d20 e0e3      	LDI  R30,LOW(3)
001d21 93e0 073c 	STS  __FF_error,R30
001d23 e0e0      	LDI  R30,LOW(0)
001d24 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x1B:
001d25 91ec      	LD   R30,X
001d26 93ea      	ST   -Y,R30
001d27 940e 08bb 	CALL _valid_file_char
001d29 9730      	SBIW R30,0
001d2a 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x1C:
001d2b 8def      	LDD  R30,Y+31
001d2c a1f8      	LDD  R31,Y+31+1
001d2d 9631      	ADIW R30,1
001d2e 8fef      	STD  Y+31,R30
001d2f a3f8      	STD  Y+31+1,R31
001d30 9731      	SBIW R30,1
001d31 01de      	MOVW R26,R28
001d32 9616      	ADIW R26,6
001d33 0fae      	ADD  R26,R30
001d34 1fbf      	ADC  R27,R31
001d35 e2e0      	LDI  R30,LOW(32)
001d36 93ec      	ST   X,R30
001d37 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x1D:
001d38 89ed      	LDD  R30,Y+21
001d39 89fe      	LDD  R31,Y+21+1
001d3a 9631      	ADIW R30,1
001d3b 8bed      	STD  Y+21,R30
001d3c 8bfe      	STD  Y+21+1,R31
001d3d 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x1E:
001d3e a1ab      	LDD  R26,Y+35
001d3f a1bc      	LDD  R27,Y+35+1
001d40   +  	__GETD1N 0x0
001d44 940e 22c8 	CALL __PUTDP1
001d46 efef      	LDI  R30,LOW(65535)
001d47 efff      	LDI  R31,HIGH(65535)
001d48 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x1F:
001d49 8def      	LDD  R30,Y+31
001d4a a1f8      	LDD  R31,Y+31+1
001d4b 9631      	ADIW R30,1
001d4c 8fef      	STD  Y+31,R30
001d4d a3f8      	STD  Y+31+1,R31
001d4e 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x20:
001d4f   +  	__GETW1R 6,7
001d51 2766      	CLR  R22
001d52 2777      	CLR  R23
001d53 01df      	MOVW R26,R30
001d54 01cb      	MOVW R24,R22
001d55 2de8      	MOV  R30,R8
001d56 27ff      	CLR  R31
001d57 2766      	CLR  R22
001d58 2777      	CLR  R23
001d59 940e 2261 	CALL __MULD12
001d5b 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
          SUBOPT_0x21:
001d5c 8def      	LDD  R30,Y+31
001d5d a1f8      	LDD  R31,Y+31+1
001d5e 2766      	CLR  R22
001d5f 2777      	CLR  R23
001d60 01df      	MOVW R26,R30
001d61 01cb      	MOVW R24,R22
001d62   +  	__GETW1R 6,7
001d64 2766      	CLR  R22
001d65 2777      	CLR  R23
001d66 940e 2241 	CALL __MULD12U
001d68 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
          SUBOPT_0x22:
001d69   +  	__GETW1R 20,21
001d6b 0fee      	LSL  R30
001d6c 1fff      	ROL  R31
001d6d 940e 2213 	CALL __LSLW4
001d6f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x23:
001d70 2766      	CLR  R22
001d71 2777      	CLR  R23
001d72 940e 21de 	CALL __ADDD12
001d74   +  	__PUTD1S 25
001d78 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x24:
001d79   +  	__GETD1S 25
001d7d a1ab      	LDD  R26,Y+35
001d7e a1bc      	LDD  R27,Y+35+1
001d7f 940e 22c8 	CALL __PUTDP1
001d81 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x25:
001d82 89ed      	LDD  R30,Y+21
001d83 89fe      	LDD  R31,Y+21+1
001d84 93fa      	ST   -Y,R31
001d85 93ea      	ST   -Y,R30
001d86 8de9      	LDD  R30,Y+25
001d87 8dfa      	LDD  R31,Y+25+1
001d88 93fa      	ST   -Y,R31
001d89 93ea      	ST   -Y,R30
001d8a e0eb      	LDI  R30,LOW(11)
001d8b 93ea      	ST   -Y,R30
001d8c 940e 21ae 	CALL _strncmp
001d8e 30e0      	CPI  R30,0
001d8f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x26:
001d90 e0e1      	LDI  R30,LOW(1)
001d91 93ea      	ST   -Y,R30
001d92 940c 0afd 	JMP  _next_cluster
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x27:
001d94 940e 2261 	CALL __MULD12
001d96 91a0 071e 	LDS  R26,__FF_PART_ADDR
001d98 91b0 071f 	LDS  R27,__FF_PART_ADDR+1
001d9a 9180 0720 	LDS  R24,__FF_PART_ADDR+2
001d9c 9190 0721 	LDS  R25,__FF_PART_ADDR+3
001d9e 940e 21de 	CALL __ADDD12
001da0 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x28:
001da1   +  	__GETW1R 6,7
001da3 95f6      	LSR  R31
001da4 95e7      	ROR  R30
001da5 85ad      	LDD  R26,Y+13
001da6 85be      	LDD  R27,Y+13+1
001da7 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x29:
001da8 940e 2266 	CALL __DIVW21U
001daa 0de9      	ADD  R30,R9
001dab 1dfa      	ADC  R31,R10
001dac   +  	__PUTW1R 16,17
001dae 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x2A:
001daf 940e 22a4 	CALL __MODW21U
001db1 0fee      	LSL  R30
001db2 1fff      	ROL  R31
001db3   +  	__PUTW1R 18,19
001db5   +  	__GETW1R 16,17
001db7 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x2B:
001db8 0fee      	LSL  R30
001db9 1fff      	ROL  R31
001dba 2ffe      	MOV  R31,R30
001dbb e0e0      	LDI  R30,0
001dbc 91a0 071e 	LDS  R26,__FF_PART_ADDR
001dbe 91b0 071f 	LDS  R27,__FF_PART_ADDR+1
001dc0 9180 0720 	LDS  R24,__FF_PART_ADDR+2
001dc2 9190 0721 	LDS  R25,__FF_PART_ADDR+3
001dc4 2766      	CLR  R22
001dc5 2777      	CLR  R23
001dc6 940e 21de 	CALL __ADDD12
001dc8   +  	__PUTD1S 6
001dcc 85ac      	LDD  R26,Y+12
001dcd 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x2C:
001dce 91e0 073d 	LDS  R30,__FF_buff_addr
001dd0 91f0 073e 	LDS  R31,__FF_buff_addr+1
001dd2 9160 073f 	LDS  R22,__FF_buff_addr+2
001dd4 9170 0740 	LDS  R23,__FF_buff_addr+3
001dd6   +  	__GETD2S 6
001dda 940e 22fa 	CALL __CPD12
001ddc 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
          SUBOPT_0x2D:
001ddd 91e0 072e 	LDS  R30,__FF_FAT2_ADDR
001ddf 91f0 072f 	LDS  R31,__FF_FAT2_ADDR+1
001de1 9160 0730 	LDS  R22,__FF_FAT2_ADDR+2
001de3 9170 0731 	LDS  R23,__FF_FAT2_ADDR+3
001de5 91a0 073d 	LDS  R26,__FF_buff_addr
001de7 91b0 073e 	LDS  R27,__FF_buff_addr+1
001de9 9180 073f 	LDS  R24,__FF_buff_addr+2
001deb 9190 0740 	LDS  R25,__FF_buff_addr+3
001ded 940e 22ff 	CALL __CPD21
001def 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
          SUBOPT_0x2E:
001df0 91a0 072a 	LDS  R26,__FF_FAT1_ADDR
001df2 91b0 072b 	LDS  R27,__FF_FAT1_ADDR+1
001df4 9180 072c 	LDS  R24,__FF_FAT1_ADDR+2
001df6 9190 072d 	LDS  R25,__FF_FAT1_ADDR+3
001df8 91e0 072e 	LDS  R30,__FF_FAT2_ADDR
001dfa 91f0 072f 	LDS  R31,__FF_FAT2_ADDR+1
001dfc 9160 0730 	LDS  R22,__FF_FAT2_ADDR+2
001dfe 9170 0731 	LDS  R23,__FF_FAT2_ADDR+3
001e00 940e 21e8 	CALL __SUBD12
001e02 91a0 073d 	LDS  R26,__FF_buff_addr
001e04 91b0 073e 	LDS  R27,__FF_buff_addr+1
001e06 9180 073f 	LDS  R24,__FF_buff_addr+2
001e08 9190 0740 	LDS  R25,__FF_buff_addr+3
001e0a 940e 21de 	CALL __ADDD12
001e0c 940e 22d1 	CALL __PUTPARD1
001e0e 940e 0854 	CALL __FF_write
001e10 30e0      	CPI  R30,0
001e11 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES
          SUBOPT_0x2F:
001e12 91e0 073d 	LDS  R30,__FF_buff_addr
001e14 91f0 073e 	LDS  R31,__FF_buff_addr+1
001e16 9160 073f 	LDS  R22,__FF_buff_addr+2
001e18 9170 0740 	LDS  R23,__FF_buff_addr+3
001e1a 940e 22d1 	CALL __PUTPARD1
001e1c 940e 0854 	CALL __FF_write
001e1e 30e0      	CPI  R30,0
001e1f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x30:
001e20   +  	__GETW1R 18,19
001e22 9631      	ADIW R30,1
001e23 5fec      	SUBI R30,LOW(-__FF_buff)
001e24 4ffa      	SBCI R31,HIGH(-__FF_buff)
001e25 81f0      	LD   R31,Z
001e26 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x31:
001e27 e0a4      	LDI  R26,LOW(__FF_buff)
001e28 e0b5      	LDI  R27,HIGH(__FF_buff)
001e29 0fa2      	ADD  R26,R18
001e2a 1fb3      	ADC  R27,R19
001e2b 91ec      	LD   R30,X
001e2c 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x32:
001e2d 85ad      	LDD  R26,Y+13
001e2e 85be      	LDD  R27,Y+13+1
001e2f e0e3      	LDI  R30,LOW(3)
001e30 e0f0      	LDI  R31,HIGH(3)
001e31 940e 2239 	CALL __MULW12U
001e33 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x33:
001e34   +  	__GETW1R 6,7
001e36   +  	__GETW2R 18,19
001e38 cf6f      	RJMP SUBOPT_0x29
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x34:
001e39   +  	__GETW1R 6,7
001e3b   +  	__GETW2R 18,19
001e3d 940e 22a4 	CALL __MODW21U
001e3f   +  	__PUTW1R 18,19
001e41 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x35:
001e42   +  	__GETW1R 6,7
001e44 9731      	SBIW R30,1
001e45 17e2      	CP   R30,R18
001e46 07f3      	CPC  R31,R19
001e47 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x36:
001e48 2fe0      	MOV  R30,R16
001e49 81aa      	LDD  R26,Y+2
001e4a 81bb      	LDD  R27,Y+2+1
001e4b e0f0      	LDI  R31,0
001e4c 0fae      	ADD  R26,R30
001e4d 1fbf      	ADC  R27,R31
001e4e 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x37:
001e4f 91ec      	LD   R30,X
001e50 93ea      	ST   -Y,R30
001e51 940c 21d3 	JMP  _toupper
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x38:
001e53 e0f0      	LDI  R31,0
001e54 54e6      	SUBI R30,LOW(-_FILENAME)
001e55 4ff8      	SBCI R31,HIGH(-_FILENAME)
001e56 01df      	MOVW R26,R30
001e57 e2e0      	LDI  R30,LOW(32)
001e58 93ec      	ST   X,R30
001e59 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x39:
001e5a 5fec      	SUBI R30,LOW(-__FF_buff)
001e5b 4ffa      	SBCI R31,HIGH(-__FF_buff)
001e5c 81f0      	LD   R31,Z
001e5d e0e0      	LDI  R30,LOW(0)
001e5e 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x3A:
001e5f 89e9      	LDD  R30,Y+17
001e60 89fa      	LDD  R31,Y+17+1
001e61   +  	__GETD2S 9
001e65 2766      	CLR  R22
001e66 2777      	CLR  R23
001e67 940e 22fa 	CALL __CPD12
001e69 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x3B:
001e6a e0ed      	LDI  R30,LOW(13)
001e6b 93e0 073c 	STS  __FF_error,R30
001e6d e0e0      	LDI  R30,LOW(0)
001e6e e0f0      	LDI  R31,HIGH(0)
001e6f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x3C:
001e70   +  	__GETD1S 5
001e74   +  	__ADDD1N 512
001e78   +  	__PUTD1S 5
001e7c 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x3D:
001e7d 85ef      	LDD  R30,Y+15
001e7e 89f8      	LDD  R31,Y+15+1
001e7f 9631      	ADIW R30,1
001e80 87ef      	STD  Y+15,R30
001e81 8bf8      	STD  Y+15+1,R31
001e82 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x3E:
001e83   +  	__GETD2S 9
001e87 2766      	CLR  R22
001e88 2777      	CLR  R23
001e89 940e 21ed 	CALL __ORD12
001e8b   +  	__PUTD1S 9
001e8f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x3F:
001e90   +  	__GETW1R 6,7
001e92 95f6      	LSR  R31
001e93 95e7      	ROR  R30
001e94 89aa      	LDD  R26,Y+18
001e95 89bb      	LDD  R27,Y+18+1
001e96 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x40:
001e97   +  	__PUTD1S 11
001e9b 85af      	LDD  R26,Y+15
001e9c 30a1      	CPI  R26,LOW(0x1)
001e9d 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x41:
001e9e 91e0 073d 	LDS  R30,__FF_buff_addr
001ea0 91f0 073e 	LDS  R31,__FF_buff_addr+1
001ea2 9160 073f 	LDS  R22,__FF_buff_addr+2
001ea4 9170 0740 	LDS  R23,__FF_buff_addr+3
001ea6   +  	__GETD2S 11
001eaa 940e 22fa 	CALL __CPD12
001eac 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x42:
001ead   +  	__GETW1R 18,19
001eaf 9631      	ADIW R30,1
001eb0 5fec      	SUBI R30,LOW(-__FF_buff)
001eb1 4ffa      	SBCI R31,HIGH(-__FF_buff)
001eb2 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x43:
001eb3 93ec      	ST   X,R30
001eb4 85af      	LDD  R26,Y+15
001eb5 30a1      	CPI  R26,LOW(0x1)
001eb6 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES
          SUBOPT_0x44:
001eb7 91a0 072a 	LDS  R26,__FF_FAT1_ADDR
001eb9 91b0 072b 	LDS  R27,__FF_FAT1_ADDR+1
001ebb 9180 072c 	LDS  R24,__FF_FAT1_ADDR+2
001ebd 9190 072d 	LDS  R25,__FF_FAT1_ADDR+3
001ebf 91e0 072e 	LDS  R30,__FF_FAT2_ADDR
001ec1 91f0 072f 	LDS  R31,__FF_FAT2_ADDR+1
001ec3 9160 0730 	LDS  R22,__FF_FAT2_ADDR+2
001ec5 9170 0731 	LDS  R23,__FF_FAT2_ADDR+3
001ec7 940e 21e8 	CALL __SUBD12
001ec9   +  	__GETD2S 11
001ecd 940e 21de 	CALL __ADDD12
001ecf 940e 22d1 	CALL __PUTPARD1
001ed1 940e 0854 	CALL __FF_write
001ed3 30e0      	CPI  R30,0
001ed4 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES
          SUBOPT_0x45:
001ed5   +  	__GETD1S 11
001ed9 940e 22d1 	CALL __PUTPARD1
001edb 940e 0854 	CALL __FF_write
001edd 30e0      	CPI  R30,0
001ede 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x46:
001edf 89aa      	LDD  R26,Y+18
001ee0 89bb      	LDD  R27,Y+18+1
001ee1 e0e3      	LDI  R30,LOW(3)
001ee2 e0f0      	LDI  R31,HIGH(3)
001ee3 940e 2239 	CALL __MULW12U
001ee5 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x47:
001ee6 70ef      	ANDI R30,LOW(0xF)
001ee7 e0f0      	LDI  R31,0
001ee8   +  	__PUTW1R 20,21
001eea   +  	__GETW1R 18,19
001eec 5fec      	SUBI R30,LOW(-__FF_buff)
001eed 4ffa      	SBCI R31,HIGH(-__FF_buff)
001eee 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x48:
001eef 81ee      	LDD  R30,Y+6
001ef0 95e2      	SWAP R30
001ef1 7fe0      	ANDI R30,0xF0
001ef2   +  	__GETW2R 20,21
001ef4 e0f0      	LDI  R31,0
001ef5 2bea      	OR   R30,R26
001ef6 2bfb      	OR   R31,R27
001ef7 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x49:
001ef8   +  	__GETW1R 6,7
001efa   +  	__GETD2S 11
001efe 2766      	CLR  R22
001eff 2777      	CLR  R23
001f00 940e 21de 	CALL __ADDD12
001f02   +  	__PUTD1S 11
001f06 cda7      	RJMP SUBOPT_0xC
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x4A:
001f07 85e8      	LDD  R30,Y+8
001f08 95e2      	SWAP R30
001f09 7fe0      	ANDI R30,0xF0
001f0a 81af      	LDD  R26,Y+7
001f0b 2bea      	OR   R30,R26
001f0c 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x4B:
001f0d 93e0 0504 	STS  __FF_buff,R30
001f0f 85af      	LDD  R26,Y+15
001f10 30a1      	CPI  R26,LOW(0x1)
001f11 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x4C:
001f12 81ef      	LDD  R30,Y+7
001f13 95e2      	SWAP R30
001f14 7fe0      	ANDI R30,0xF0
001f15 81ae      	LDD  R26,Y+6
001f16 2bea      	OR   R30,R26
001f17 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x4D:
001f18 7fe0      	ANDI R30,LOW(0xF0)
001f19 e0f0      	LDI  R31,0
001f1a   +  	__PUTW1R 20,21
001f1c 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x4E:
001f1d 85e8      	LDD  R30,Y+8
001f1e   +  	__GETW2R 20,21
001f20 e0f0      	LDI  R31,0
001f21 2bea      	OR   R30,R26
001f22 2bfb      	OR   R31,R27
001f23 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x4F:
001f24 85eb      	LDD  R30,Y+11
001f25 85fc      	LDD  R31,Y+11+1
001f26   +  	__GETD2Z 22
001f2a 940e 22d6 	CALL __PUTPARD2
001f2c 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x50:
001f2d 85ab      	LDD  R26,Y+11
001f2e 85bc      	LDD  R27,Y+11+1
001f2f 965a      	ADIW R26,26
001f30 940e 22be 	CALL __GETW1P
001f32 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x51:
001f33 85ab      	LDD  R26,Y+11
001f34 85bc      	LDD  R27,Y+11+1
001f35 961c      	ADIW R26,12
001f36 940e 22be 	CALL __GETW1P
001f38 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x52:
001f39   +  	__GETD1S 7
001f3d   +  	__ANDD1N 0xFF
001f41   +  	__GETW2R 17,18
001f43 93ec      	ST   X,R30
001f44   +  	__GETD2S 7
001f48 e0e8      	LDI  R30,LOW(8)
001f49 940e 2207 	CALL __LSRD12
001f4b   +  	__PUTD1S 7
001f4f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x53:
001f50 933a      	ST   -Y,R19
001f51 932a      	ST   -Y,R18
001f52 e0e0      	LDI  R30,LOW(0)
001f53 93ea      	ST   -Y,R30
001f54 940c 0afd 	JMP  _next_cluster
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x54:
001f56 933a      	ST   -Y,R19
001f57 932a      	ST   -Y,R18
001f58 e0e0      	LDI  R30,LOW(0)
001f59 e0f0      	LDI  R31,HIGH(0)
001f5a 93fa      	ST   -Y,R31
001f5b 93ea      	ST   -Y,R30
001f5c 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x55:
001f5d e0e0      	LDI  R30,LOW(0)
001f5e 93ea      	ST   -Y,R30
001f5f 940e 0e13 	CALL _write_clus_table
001f61 30e0      	CPI  R30,0
001f62 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x56:
001f63 e0e2      	LDI  R30,LOW(2)
001f64 93ea      	ST   -Y,R30
001f65 940e 0e13 	CALL _write_clus_table
001f67 30e0      	CPI  R30,0
001f68 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x57:
001f69   +  	__GETW2R 18,19
001f6b 91ac      	LD   R26,X
001f6c 35ac      	CPI  R26,LOW(0x5C)
001f6d 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x58:
001f6e   +  	__GETW2R 18,19
001f70 91ec      	LD   R30,X
001f71 30e0      	CPI  R30,0
001f72 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x59:
001f73   +  	__GETW2R 16,17
001f75 e0e0      	LDI  R30,LOW(0)
001f76 93ec      	ST   X,R30
001f77 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x5A:
001f78 0fee      	LSL  R30
001f79 1fff      	ROL  R31
001f7a 2ffe      	MOV  R31,R30
001f7b e0e0      	LDI  R30,0
001f7c 91a0 0726 	LDS  R26,__FF_DIR_ADDR
001f7e 91b0 0727 	LDS  R27,__FF_DIR_ADDR+1
001f80 9180 0728 	LDS  R24,__FF_DIR_ADDR+2
001f82 9190 0729 	LDS  R25,__FF_DIR_ADDR+3
001f84 2766      	CLR  R22
001f85 2777      	CLR  R23
001f86 940e 21de 	CALL __ADDD12
001f88 940e 22d1 	CALL __PUTPARD1
001f8a 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x5B:
001f8b 963b      	ADIW R30,11
001f8c 5fec      	SUBI R30,LOW(-__FF_buff)
001f8d 4ffa      	SBCI R31,HIGH(-__FF_buff)
001f8e 81e0      	LD   R30,Z
001f8f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x5C:
001f90 967a      	ADIW R30,26
001f91 5fec      	SUBI R30,LOW(-__FF_buff)
001f92 4ffa      	SBCI R31,HIGH(-__FF_buff)
001f93 81e0      	LD   R30,Z
001f94 e0f0      	LDI  R31,0
001f95 2bea      	OR   R30,R26
001f96 2bfb      	OR   R31,R27
001f97 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x5D:
001f98 976c      	SBIW R28,28
001f99 940e 2304 	CALL __SAVELOCR6
001f9b   +  	__CLRD1S 12
001fa0 a1eb      	LDD  R30,Y+35
001fa1 a1fc      	LDD  R31,Y+35+1
001fa2 93fa      	ST   -Y,R31
001fa3 93ea      	ST   -Y,R30
001fa4 01fe      	MOVW R30,R28
001fa5 963e      	ADIW R30,14
001fa6 93fa      	ST   -Y,R31
001fa7 93ea      	ST   -Y,R30
001fa8 01fe      	MOVW R30,R28
001fa9 9678      	ADIW R30,24
001faa 93fa      	ST   -Y,R31
001fab 93ea      	ST   -Y,R30
001fac 940e 108a 	CALL __FF_checkdir
001fae 9730      	SBIW R30,0
001faf 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 18 TIMES
          SUBOPT_0x5E:
001fb0   +  	__GETD1S 12
001fb4 93e0 0726 	STS  __FF_DIR_ADDR,R30
001fb6 93f0 0727 	STS  __FF_DIR_ADDR+1,R31
001fb8 9360 0728 	STS  __FF_DIR_ADDR+2,R22
001fba 9370 0729 	STS  __FF_DIR_ADDR+3,R23
001fbc e0e0      	LDI  R30,LOW(0)
001fbd e0f0      	LDI  R31,HIGH(0)
001fbe 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x5F:
001fbf 91e0 0726 	LDS  R30,__FF_DIR_ADDR
001fc1 91f0 0727 	LDS  R31,__FF_DIR_ADDR+1
001fc3 9160 0728 	LDS  R22,__FF_DIR_ADDR+2
001fc5 9170 0729 	LDS  R23,__FF_DIR_ADDR+3
001fc7   +  	__PUTD1S 8
001fcb 01fe      	MOVW R30,R28
001fcc 9638      	ADIW R30,8
001fcd 93fa      	ST   -Y,R31
001fce 93ea      	ST   -Y,R30
001fcf 01fe      	MOVW R30,R28
001fd0 9676      	ADIW R30,22
001fd1 93fa      	ST   -Y,R31
001fd2 93ea      	ST   -Y,R30
001fd3 940e 08e5 	CALL _scan_directory
001fd5   +  	__PUTW1R 18,19
001fd7 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x60:
001fd8 83ee      	STD  Y+6,R30
001fd9 83ff      	STD  Y+6+1,R31
001fda 9730      	SBIW R30,0
001fdb 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x61:
001fdc   +  	__GETW1R 6,7
001fde   +  	__GETD2S 8
001fe2 2766      	CLR  R22
001fe3 2777      	CLR  R23
001fe4 940e 22a7 	CALL __MODD21U
001fe6   +  	__PUTW1R 20,21
001fe8   +  	__GETW1R 20,21
001fea   +  	__GETD2S 8
001fee ccfe      	RJMP SUBOPT_0x14
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x62:
001fef   +  	__PUTD1S 8
001ff3 ccba      	RJMP SUBOPT_0xC
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x63:
001ff4 01fe      	MOVW R30,R28
001ff5 9674      	ADIW R30,20
001ff6 93fa      	ST   -Y,R31
001ff7 93ea      	ST   -Y,R30
001ff8 940e 0c25 	CALL _file_name_conversion
001ffa 8be8      	STD  Y+16,R30
001ffb 8bf9      	STD  Y+16+1,R31
001ffc 9730      	SBIW R30,0
001ffd 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES
          SUBOPT_0x64:
001ffe 81ee      	LDD  R30,Y+6
001fff 81ff      	LDD  R31,Y+6+1
002000 93fa      	ST   -Y,R31
002001 93ea      	ST   -Y,R30
002002 dc41      	RCALL _free
002003 cfac      	RJMP SUBOPT_0x5E
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x65:
002004   +  	__GETW1R 20,21
002006 5fec      	SUBI R30,LOW(-__FF_buff)
002007 4ffa      	SBCI R31,HIGH(-__FF_buff)
002008 8bea      	STD  Y+18,R30
002009 8bfb      	STD  Y+18+1,R31
00200a 2e02      	MOV  R0,R18
00200b 2a03      	OR   R0,R19
00200c 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x66:
00200d e0eb      	LDI  R30,LOW(11)
00200e 93e0 073c 	STS  __FF_error,R30
002010 cfed      	RJMP SUBOPT_0x64
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x67:
002011 81ae      	LDD  R26,Y+6
002012 81bf      	LDD  R27,Y+6+1
002013 961c      	ADIW R26,12
002014 940e 22be 	CALL __GETW1P
002016 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x68:
002017 9652      	ADIW R26,18
002018 e0e0      	LDI  R30,LOW(0)
002019 e0f0      	LDI  R31,HIGH(0)
00201a 93ed      	ST   X+,R30
00201b 93fc      	ST   X,R31
00201c 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x69:
00201d 81ae      	LDD  R26,Y+6
00201e 81bf      	LDD  R27,Y+6+1
00201f 5ea4      	SUBI R26,LOW(-540)
002020 4fbd      	SBCI R27,HIGH(-540)
002021   +  	__GETD1N 0x0
002025 940e 22c8 	CALL __PUTDP1
002027 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x6A:
002028   +  	__GETW1R 20,21
00202a 5fec      	SUBI R30,LOW(-__FF_buff)
00202b 4ffa      	SBCI R31,HIGH(-__FF_buff)
00202c 967f      	ADIW R30,31
00202d 8bea      	STD  Y+18,R30
00202e 8bfb      	STD  Y+18+1,R31
00202f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x6B:
002030 89aa      	LDD  R26,Y+18
002031 89bb      	LDD  R27,Y+18+1
002032 9711      	SBIW R26,1
002033 8baa      	STD  Y+18,R26
002034 8bbb      	STD  Y+18+1,R27
002035 9611      	ADIW R26,1
002036 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x6C:
002037 81ae      	LDD  R26,Y+6
002038 81bf      	LDD  R27,Y+6+1
002039 5ea4      	SUBI R26,LOW(-540)
00203a 4fbd      	SBCI R27,HIGH(-540)
00203b 940e 22c2 	CALL __GETD1P
00203d 940e 22e8 	CALL __CPD10
00203f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x6D:
002040 81ee      	LDD  R30,Y+6
002041 81ff      	LDD  R31,Y+6+1
002042 85a4      	LDD  R26,Z+12
002043 85b5      	LDD  R27,Z+13
002044 93ba      	ST   -Y,R27
002045 93aa      	ST   -Y,R26
002046 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES
          SUBOPT_0x6E:
002047 81ee      	LDD  R30,Y+6
002048 81ff      	LDD  R31,Y+6+1
002049 85a6      	LDD  R26,Z+14
00204a 85b7      	LDD  R27,Z+15
00204b 93ba      	ST   -Y,R27
00204c 93aa      	ST   -Y,R26
00204d 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x6F:
00204e 81ae      	LDD  R26,Y+6
00204f 81bf      	LDD  R27,Y+6+1
002050 9654      	ADIW R26,20
002051 e0e1      	LDI  R30,LOW(1)
002052 e0f0      	LDI  R31,HIGH(1)
002053 93ed      	ST   X+,R30
002054 93fc      	ST   X,R31
002055 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x70:
002056 93fa      	ST   -Y,R31
002057 93ea      	ST   -Y,R30
002058   +  	__GETD1N 0x0
00205c 940e 22d1 	CALL __PUTPARD1
00205e 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x71:
00205f 81ee      	LDD  R30,Y+6
002060 81ff      	LDD  R31,Y+6+1
002061 967c      	ADIW R30,28
002062 0fe0      	ADD  R30,R16
002063 1ff1      	ADC  R31,R17
002064 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x72:
002065 e0a4      	LDI  R26,LOW(__FF_buff)
002066 e0b5      	LDI  R27,HIGH(__FF_buff)
002067 0fa0      	ADD  R26,R16
002068 1fb1      	ADC  R27,R17
002069 91ec      	LD   R30,X
00206a 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x73:
00206b e0e5      	LDI  R30,LOW(5)
00206c 93e0 073c 	STS  __FF_error,R30
00206e cf41      	RJMP SUBOPT_0x5E
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x74:
00206f 89ea      	LDD  R30,Y+18
002070 89fb      	LDD  R31,Y+18+1
002071 9631      	ADIW R30,1
002072 8bea      	STD  Y+18,R30
002073 8bfb      	STD  Y+18+1,R31
002074 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES
          SUBOPT_0x75:
002075 89aa      	LDD  R26,Y+18
002076 89bb      	LDD  R27,Y+18+1
002077 9611      	ADIW R26,1
002078 8baa      	STD  Y+18,R26
002079 8bbb      	STD  Y+18+1,R27
00207a 9711      	SBIW R26,1
00207b e0e0      	LDI  R30,LOW(0)
00207c 93ec      	ST   X,R30
00207d 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x76:
00207e 940e 22d1 	CALL __PUTPARD1
002080 940e 0854 	CALL __FF_write
002082 30e0      	CPI  R30,0
002083 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x77:
002084 9724      	SBIW R28,4
002085 931a      	ST   -Y,R17
002086 930a      	ST   -Y,R16
002087 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x78:
002088 81ae      	LDD  R26,Y+6
002089 81bf      	LDD  R27,Y+6+1
00208a 5dac      	SUBI R26,LOW(-548)
00208b 4fbd      	SBCI R27,HIGH(-548)
00208c 91ac      	LD   R26,X
00208d 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x79:
00208e 81ae      	LDD  R26,Y+6
00208f 81bf      	LDD  R27,Y+6+1
002090 9654      	ADIW R26,20
002091 940e 22be 	CALL __GETW1P
002093 cc54      	RJMP SUBOPT_0x13
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x7A:
002094 2766      	CLR  R22
002095 2777      	CLR  R23
002096 940e 21de 	CALL __ADDD12
002098   +  	__PUTD1S 2
00209c 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x7B:
00209d   +  	__GETW2R 16,17
00209f 5fac      	SUBI R26,LOW(-__FF_buff)
0020a0 4fba      	SBCI R27,HIGH(-__FF_buff)
0020a1 cfbd      	RJMP SUBOPT_0x71
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x7C:
0020a2 81ee      	LDD  R30,Y+6
0020a3 81ff      	LDD  R31,Y+6+1
0020a4 93fa      	ST   -Y,R31
0020a5 93ea      	ST   -Y,R30
0020a6 940e 0fb1 	CALL _append_toc
0020a8 30e0      	CPI  R30,0
0020a9 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x7D:
0020aa 5dac      	SUBI R26,LOW(-548)
0020ab 4fbd      	SBCI R27,HIGH(-548)
0020ac 91ac      	LD   R26,X
0020ad 30a1      	CPI  R26,LOW(0x1)
0020ae 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x7E:
0020af e0e0      	LDI  R30,LOW(0)
0020b0 e0f0      	LDI  R31,HIGH(0)
0020b1 93fa      	ST   -Y,R31
0020b2 93ea      	ST   -Y,R30
0020b3 940c 0c6f 	JMP  _prev_cluster
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x7F:
0020b5 81ae      	LDD  R26,Y+6
0020b6 81bf      	LDD  R27,Y+6+1
0020b7 9650      	ADIW R26,16
0020b8 efef      	LDI  R30,LOW(65535)
0020b9 efff      	LDI  R31,HIGH(65535)
0020ba 93ed      	ST   X+,R30
0020bb 93fc      	ST   X,R31
0020bc 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x80:
0020bd 85e8      	LDD  R30,Y+8
0020be 85f9      	LDD  R31,Y+8+1
0020bf 89a0      	LDD  R26,Z+16
0020c0 89b1      	LDD  R27,Z+17
0020c1 93ba      	ST   -Y,R27
0020c2 93aa      	ST   -Y,R26
0020c3 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES
          SUBOPT_0x81:
0020c4 81ae      	LDD  R26,Y+6
0020c5 81bf      	LDD  R27,Y+6+1
0020c6 5ea0      	SUBI R26,LOW(-544)
0020c7 4fbd      	SBCI R27,HIGH(-544)
0020c8 940e 22c2 	CALL __GETD1P
0020ca 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES
          SUBOPT_0x82:
0020cb 81ae      	LDD  R26,Y+6
0020cc 81bf      	LDD  R27,Y+6+1
0020cd 5ea4      	SUBI R26,LOW(-540)
0020ce 4fbd      	SBCI R27,HIGH(-540)
0020cf 940e 22c2 	CALL __GETD1P
0020d1 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x83:
0020d2 81ae      	LDD  R26,Y+6
0020d3 81bf      	LDD  R27,Y+6+1
0020d4 5daa      	SUBI R26,LOW(-550)
0020d5 4fbd      	SBCI R27,HIGH(-550)
0020d6 91ec      	LD   R30,X
0020d7 30e0      	CPI  R30,0
0020d8 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x84:
0020d9 81ae      	LDD  R26,Y+6
0020da 81bf      	LDD  R27,Y+6+1
0020db 961e      	ADIW R26,14
0020dc 940e 22be 	CALL __GETW1P
0020de 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x85:
0020df 5daa      	SUBI R26,LOW(-550)
0020e0 4fbd      	SBCI R27,HIGH(-550)
0020e1 e0e0      	LDI  R30,LOW(0)
0020e2 93ec      	ST   X,R30
0020e3 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x86:
0020e4 81ae      	LDD  R26,Y+6
0020e5 81bf      	LDD  R27,Y+6+1
0020e6 5da9      	SUBI R26,LOW(-551)
0020e7 4fbd      	SBCI R27,HIGH(-551)
0020e8 940e 22be 	CALL __GETW1P
0020ea 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x87:
0020eb 965c      	ADIW R26,28
0020ec   +  	__GETW1R 6,7
0020ee 9731      	SBIW R30,1
0020ef 0fea      	ADD  R30,R26
0020f0 1ffb      	ADC  R31,R27
0020f1 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x88:
0020f2 9654      	ADIW R26,20
0020f3 940e 22be 	CALL __GETW1P
0020f5 9631      	ADIW R30,1
0020f6 93ed      	ST   X+,R30
0020f7 93fc      	ST   X,R31
0020f8 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x89:
0020f9 5daa      	SUBI R26,LOW(-550)
0020fa 4fbd      	SBCI R27,HIGH(-550)
0020fb e0e1      	LDI  R30,LOW(1)
0020fc 93ec      	ST   X,R30
0020fd 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES
          SUBOPT_0x8A:
0020fe 940e 21da 	CALL __ADDW2R15
002100 940e 22be 	CALL __GETW1P
002102 93fa      	ST   -Y,R31
002103 93ea      	ST   -Y,R30
002104 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x8B:
002105 89a9      	LDD  R26,Y+17
002106 89ba      	LDD  R27,Y+17+1
002107 5ea4      	SUBI R26,LOW(-540)
002108 4fbd      	SBCI R27,HIGH(-540)
002109 940e 22c2 	CALL __GETD1P
00210b   +  	__GETD2S 13
00210f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x8C:
002110 89a9      	LDD  R26,Y+17
002111 89ba      	LDD  R27,Y+17+1
002112 5dab      	SUBI R26,LOW(-549)
002113 4fbd      	SBCI R27,HIGH(-549)
002114 e0ea      	LDI  R30,LOW(10)
002115 93ec      	ST   X,R30
002116 93e0 073c 	STS  __FF_error,R30
002118 efef      	LDI  R30,LOW(65535)
002119 efff      	LDI  R31,HIGH(65535)
00211a 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x8D:
00211b b3e8      	IN   R30,0x18
00211c e4a0      	LDI  R26,LOW(64)
00211d 27ea      	EOR  R30,R26
00211e bbe8      	OUT  0x18,R30
00211f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x8E:
002120 93fa      	ST   -Y,R31
002121 93ea      	ST   -Y,R30
002122 e0e0      	LDI  R30,LOW(0)
002123 93ea      	ST   -Y,R30
002124 940e 139f 	CALL _fcreatec
002126   +  	__PUTW1R 16,17
002128 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x8F:
002129 93ea      	ST   -Y,R30
00212a 931a      	ST   -Y,R17
00212b 930a      	ST   -Y,R16
00212c 940e 1518 	CALL _fputc
00212e 3fef      	CPI  R30,LOW(0xFFFF)
00212f efaf      	LDI  R26,HIGH(0xFFFF)
002130 07fa      	CPC  R31,R26
002131 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x90:
002132 b3e8      	IN   R30,0x18
002133 e8a0      	LDI  R26,LOW(128)
002134 27ea      	EOR  R30,R26
002135 bbe8      	OUT  0x18,R30
002136 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x91:
002137   +  	__GETD1S 4
00213b   +  	__SUBD1N -1
00213f   +  	__PUTD1S 4
002143 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES
          SUBOPT_0x92:
002144 933a      	ST   -Y,R19
002145 89ea      	LDD  R30,Y+18
002146 89fb      	LDD  R31,Y+18+1
002147 93fa      	ST   -Y,R31
002148 93ea      	ST   -Y,R30
002149 940c 19ab 	JMP  __put_G2
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES
          SUBOPT_0x93:
00214b 89ab      	LDD  R26,Y+19
00214c 89bc      	LDD  R27,Y+19+1
00214d 9714      	SBIW R26,4
00214e 8bab      	STD  Y+19,R26
00214f 8bbc      	STD  Y+19+1,R27
002150 9614      	ADIW R26,4
002151 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x94:
002152 93ea      	ST   -Y,R30
002153 89ea      	LDD  R30,Y+18
002154 89fb      	LDD  R31,Y+18+1
002155 93fa      	ST   -Y,R31
002156 93ea      	ST   -Y,R30
002157 940c 19ab 	JMP  __put_G2
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x95:
002159 940e 22be 	CALL __GETW1P
00215b 83ee      	STD  Y+6,R30
00215c 83ff      	STD  Y+6+1,R31
00215d 93fa      	ST   -Y,R31
00215e 93ea      	ST   -Y,R30
00215f 9508      	RET
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x96:
002160 89ea      	LDD  R30,Y+18
002161 89fb      	LDD  R31,Y+18+1
002162 93fa      	ST   -Y,R31
002163 93ea      	ST   -Y,R30
002164 940c 19ab 	JMP  __put_G2
         
         ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES
          SUBOPT_0x97:
002166   +  	__GETW2R 16,17
002168 9612      	ADIW R26,2
002169 940e 22be 	CALL __GETW1P
00216b   +  	__PUTW1R 18,19
00216d 9508      	RET
         
          _memmove:
00216e 8199      	ldd  r25,y+1
00216f 8188      	ld   r24,y
002170 9600      	adiw r24,0
002171 f0a9      	breq __memmove3
002172 81bd      	ldd  r27,y+5
002173 81ac      	ldd  r26,y+4
002174 81fb      	ldd  r31,y+3
002175 81ea      	ldd  r30,y+2
002176 17ea      	cp   r30,r26
002177 07fb      	cpc  r31,r27
002178 f071      	breq __memmove3
002179 f02c      	brlt __memmove1
          __memmove0:
00217a 9161      	ld   r22,z+
00217b 936d      	st   x+,r22
00217c 9701      	sbiw r24,1
00217d f7e1      	brne __memmove0
00217e c008      	rjmp __memmove3
          __memmove1:
00217f 0fa8      	add  r26,r24
002180 1fb9      	adc  r27,r25
002181 0fe8      	add  r30,r24
002182 1ff9      	adc  r31,r25
          __memmove2:
002183 9162      	ld   r22,-z
002184 936e      	st   -x,r22
002185 9701      	sbiw r24,1
002186 f7e1      	brne __memmove2
          __memmove3:
002187 81fd      	ldd  r31,y+5
002188 81ec      	ldd  r30,y+4
002189 9626      	adiw r28,6
00218a 9508      	ret
         
          _memset:
00218b 81b9      	ldd  r27,y+1
00218c 81a8      	ld   r26,y
00218d 9610      	adiw r26,0
00218e f031      	breq __memset1
00218f 81fc      	ldd  r31,y+4
002190 81eb      	ldd  r30,y+3
002191 816a      	ldd  r22,y+2
          __memset0:
002192 9361      	st   z+,r22
002193 9711      	sbiw r26,1
002194 f7e9      	brne __memset0
          __memset1:
002195 81eb      	ldd  r30,y+3
002196 81fc      	ldd  r31,y+4
002197 9625      	adiw r28,5
002198 9508      	ret
         
          _strlen:
002199 91a9      	ld   r26,y+
00219a 91b9      	ld   r27,y+
00219b 27ee      	clr  r30
00219c 27ff      	clr  r31
          __strlen0:
00219d 916d      	ld   r22,x+
00219e 2366      	tst  r22
00219f f011      	breq __strlen1
0021a0 9631      	adiw r30,1
0021a1 cffb      	rjmp __strlen0
          __strlen1:
0021a2 9508      	ret
         
          _strlenf:
0021a3 27aa      	clr  r26
0021a4 27bb      	clr  r27
0021a5 91e9      	ld   r30,y+
0021a6 91f9      	ld   r31,y+
          __strlenf0:
0021a7 9005      	lpm  r0,z+
0021a8 2000      	tst  r0
0021a9 f011      	breq __strlenf1
0021aa 9611      	adiw r26,1
0021ab cffb      	rjmp __strlenf0
          __strlenf1:
0021ac 01fd      	movw r30,r26
0021ad 9508      	ret
         
          _strncmp:
0021ae 2766      	clr  r22
0021af 2777      	clr  r23
0021b0 9189      	ld   r24,y+
0021b1 91e9      	ld   r30,y+
0021b2 91f9      	ld   r31,y+
0021b3 91a9      	ld   r26,y+
0021b4 91b9      	ld   r27,y+
          __strncmp0:
0021b5 2388      	tst  r24
0021b6 f049      	breq __strncmp1
0021b7 958a      	dec  r24
0021b8 916d      	ld   r22,x+
0021b9 9171      	ld   r23,z+
0021ba 1767      	cp   r22,r23
0021bb f421      	brne __strncmp1
0021bc 2366      	tst  r22
0021bd f7b9      	brne __strncmp0
          __strncmp3:
0021be 27ee      	clr  r30
0021bf 9508      	ret
          __strncmp1:
0021c0 1b67      	sub  r22,r23
0021c1 f3e1      	breq __strncmp3
0021c2 e0e1      	ldi  r30,1
0021c3 f408      	brcc __strncmp2
0021c4 50e2      	subi r30,2
          __strncmp2:
0021c5 9508      	ret
         
          _strrpos:
0021c6 9169      	ld   r22,y+
0021c7 91a9      	ld   r26,y+
0021c8 91b9      	ld   r27,y+
0021c9 efef      	ldi  r30,-1
0021ca 27ff      	clr  r31
          __strrpos0:
0021cb 917d      	ld   r23,x+
0021cc 1767      	cp   r22,r23
0021cd f409      	brne __strrpos1
0021ce 2fef      	mov  r30,r31
          __strrpos1:
0021cf 95f3      	inc  r31
0021d0 2377      	tst  r23
0021d1 f7c9      	brne __strrpos0
0021d2 9508      	ret
         
          _toupper:
0021d3 91e9      	ld   r30,y+
0021d4 36e1      	cpi  r30,'a'
0021d5 f018      	brlo __toupper0
0021d6 37eb      	cpi  r30,'z'+1
0021d7 f408      	brcc __toupper0
0021d8 52e0      	subi r30,32
          __toupper0:
0021d9 9508      	ret
         
          __ADDW2R15:
0021da 2400      	CLR  R0
0021db 0daf      	ADD  R26,R15
0021dc 1db0      	ADC  R27,R0
0021dd 9508      	RET
         
          __ADDD12:
0021de 0fea      	ADD  R30,R26
0021df 1ffb      	ADC  R31,R27
0021e0 1f68      	ADC  R22,R24
0021e1 1f79      	ADC  R23,R25
0021e2 9508      	RET
         
          __ADDD21:
0021e3 0fae      	ADD  R26,R30
0021e4 1fbf      	ADC  R27,R31
0021e5 1f86      	ADC  R24,R22
0021e6 1f97      	ADC  R25,R23
0021e7 9508      	RET
         
          __SUBD12:
0021e8 1bea      	SUB  R30,R26
0021e9 0bfb      	SBC  R31,R27
0021ea 0b68      	SBC  R22,R24
0021eb 0b79      	SBC  R23,R25
0021ec 9508      	RET
         
          __ORD12:
0021ed 2bea      	OR   R30,R26
0021ee 2bfb      	OR   R31,R27
0021ef 2b68      	OR   R22,R24
0021f0 2b79      	OR   R23,R25
0021f1 9508      	RET
         
          __ANEGD1:
0021f2 95e0      	COM  R30
0021f3 95f0      	COM  R31
0021f4 9560      	COM  R22
0021f5 9570      	COM  R23
0021f6 5fef      	SUBI R30,-1
0021f7 4fff      	SBCI R31,-1
0021f8 4f6f      	SBCI R22,-1
0021f9 4f7f      	SBCI R23,-1
0021fa 9508      	RET
         
          __LSLD12:
0021fb 23ee      	TST  R30
0021fc 2e0e      	MOV  R0,R30
0021fd 01fd      	MOVW R30,R26
0021fe 01bc      	MOVW R22,R24
0021ff f031      	BREQ __LSLD12R
          __LSLD12L:
002200 0fee      	LSL  R30
002201 1fff      	ROL  R31
002202 1f66      	ROL  R22
002203 1f77      	ROL  R23
002204 940a      	DEC  R0
002205 f7d1      	BRNE __LSLD12L
          __LSLD12R:
002206 9508      	RET
         
          __LSRD12:
002207 23ee      	TST  R30
002208 2e0e      	MOV  R0,R30
002209 01fd      	MOVW R30,R26
00220a 01bc      	MOVW R22,R24
00220b f031      	BREQ __LSRD12R
          __LSRD12L:
00220c 9576      	LSR  R23
00220d 9567      	ROR  R22
00220e 95f7      	ROR  R31
00220f 95e7      	ROR  R30
002210 940a      	DEC  R0
002211 f7d1      	BRNE __LSRD12L
          __LSRD12R:
002212 9508      	RET
         
          __LSLW4:
002213 0fee      	LSL  R30
002214 1fff      	ROL  R31
          __LSLW3:
002215 0fee      	LSL  R30
002216 1fff      	ROL  R31
          __LSLW2:
002217 0fee      	LSL  R30
002218 1fff      	ROL  R31
002219 0fee      	LSL  R30
00221a 1fff      	ROL  R31
00221b 9508      	RET
         
          __LSRW4:
00221c 95f6      	LSR  R31
00221d 95e7      	ROR  R30
          __LSRW3:
00221e 95f6      	LSR  R31
00221f 95e7      	ROR  R30
          __LSRW2:
002220 95f6      	LSR  R31
002221 95e7      	ROR  R30
002222 95f6      	LSR  R31
002223 95e7      	ROR  R30
002224 9508      	RET
         
          __LSRD1:
002225 9576      	LSR  R23
002226 9567      	ROR  R22
002227 95f7      	ROR  R31
002228 95e7      	ROR  R30
002229 9508      	RET
         
          __LSRD16:
00222a 2fe6      	MOV  R30,R22
00222b 2ff7      	MOV  R31,R23
00222c e060      	LDI  R22,0
00222d e070      	LDI  R23,0
00222e 9508      	RET
         
          __LSLD16:
00222f 2f6e      	MOV  R22,R30
002230 2f7f      	MOV  R23,R31
002231 e0e0      	LDI  R30,0
002232 e0f0      	LDI  R31,0
002233 9508      	RET
         
          __CWD1:
002234 2f6f      	MOV  R22,R31
002235 0f66      	ADD  R22,R22
002236 0b66      	SBC  R22,R22
002237 2f76      	MOV  R23,R22
002238 9508      	RET
         
          __MULW12U:
002239 9ffa      	MUL  R31,R26
00223a 2df0      	MOV  R31,R0
00223b 9feb      	MUL  R30,R27
00223c 0df0      	ADD  R31,R0
00223d 9fea      	MUL  R30,R26
00223e 2de0      	MOV  R30,R0
00223f 0df1      	ADD  R31,R1
002240 9508      	RET
         
          __MULD12U:
002241 9f7a      	MUL  R23,R26
002242 2d70      	MOV  R23,R0
002243 9f6b      	MUL  R22,R27
002244 0d70      	ADD  R23,R0
002245 9ff8      	MUL  R31,R24
002246 0d70      	ADD  R23,R0
002247 9fe9      	MUL  R30,R25
002248 0d70      	ADD  R23,R0
002249 9f6a      	MUL  R22,R26
00224a 2d60      	MOV  R22,R0
00224b 0d71      	ADD  R23,R1
00224c 9ffb      	MUL  R31,R27
00224d 0d60      	ADD  R22,R0
00224e 1d71      	ADC  R23,R1
00224f 9fe8      	MUL  R30,R24
002250 0d60      	ADD  R22,R0
002251 1d71      	ADC  R23,R1
002252 2788      	CLR  R24
002253 9ffa      	MUL  R31,R26
002254 2df0      	MOV  R31,R0
002255 0d61      	ADD  R22,R1
002256 1f78      	ADC  R23,R24
002257 9feb      	MUL  R30,R27
002258 0df0      	ADD  R31,R0
002259 1d61      	ADC  R22,R1
00225a 1f78      	ADC  R23,R24
00225b 9fea      	MUL  R30,R26
00225c 2de0      	MOV  R30,R0
00225d 0df1      	ADD  R31,R1
00225e 1f68      	ADC  R22,R24
00225f 1f78      	ADC  R23,R24
002260 9508      	RET
         
          __MULD12:
002261 d049      	RCALL __CHKSIGND
002262 dfde      	RCALL __MULD12U
002263 f40e      	BRTC __MULD121
002264 df8d      	RCALL __ANEGD1
          __MULD121:
002265 9508      	RET
         
          __DIVW21U:
002266 2400      	CLR  R0
002267 2411      	CLR  R1
002268 e190      	LDI  R25,16
          __DIVW21U1:
002269 0faa      	LSL  R26
00226a 1fbb      	ROL  R27
00226b 1c00      	ROL  R0
00226c 1c11      	ROL  R1
00226d 1a0e      	SUB  R0,R30
00226e 0a1f      	SBC  R1,R31
00226f f418      	BRCC __DIVW21U2
002270 0e0e      	ADD  R0,R30
002271 1e1f      	ADC  R1,R31
002272 c001      	RJMP __DIVW21U3
          __DIVW21U2:
002273 60a1      	SBR  R26,1
          __DIVW21U3:
002274 959a      	DEC  R25
002275 f799      	BRNE __DIVW21U1
002276 01fd      	MOVW R30,R26
002277 01d0      	MOVW R26,R0
002278 9508      	RET
         
          __DIVD21U:
002279 933f      	PUSH R19
00227a 934f      	PUSH R20
00227b 935f      	PUSH R21
00227c 2400      	CLR  R0
00227d 2411      	CLR  R1
00227e 2733      	CLR  R19
00227f 2744      	CLR  R20
002280 e250      	LDI  R21,32
          __DIVD21U1:
002281 0faa      	LSL  R26
002282 1fbb      	ROL  R27
002283 1f88      	ROL  R24
002284 1f99      	ROL  R25
002285 1c00      	ROL  R0
002286 1c11      	ROL  R1
002287 1f33      	ROL  R19
002288 1f44      	ROL  R20
002289 1a0e      	SUB  R0,R30
00228a 0a1f      	SBC  R1,R31
00228b 0b36      	SBC  R19,R22
00228c 0b47      	SBC  R20,R23
00228d f428      	BRCC __DIVD21U2
00228e 0e0e      	ADD  R0,R30
00228f 1e1f      	ADC  R1,R31
002290 1f36      	ADC  R19,R22
002291 1f47      	ADC  R20,R23
002292 c001      	RJMP __DIVD21U3
          __DIVD21U2:
002293 60a1      	SBR  R26,1
          __DIVD21U3:
002294 955a      	DEC  R21
002295 f759      	BRNE __DIVD21U1
002296 01fd      	MOVW R30,R26
002297 01bc      	MOVW R22,R24
002298 01d0      	MOVW R26,R0
002299 2f83      	MOV  R24,R19
00229a 2f94      	MOV  R25,R20
00229b 915f      	POP  R21
00229c 914f      	POP  R20
00229d 913f      	POP  R19
00229e 9508      	RET
         
          __DIVD21:
00229f d00b      	RCALL __CHKSIGND
0022a0 dfd8      	RCALL __DIVD21U
0022a1 f40e      	BRTC __DIVD211
0022a2 df4f      	RCALL __ANEGD1
          __DIVD211:
0022a3 9508      	RET
         
          __MODW21U:
0022a4 dfc1      	RCALL __DIVW21U
0022a5 01fd      	MOVW R30,R26
0022a6 9508      	RET
         
          __MODD21U:
0022a7 dfd1      	RCALL __DIVD21U
0022a8 01fd      	MOVW R30,R26
0022a9 01bc      	MOVW R22,R24
0022aa 9508      	RET
         
          __CHKSIGND:
0022ab 94e8      	CLT
0022ac ff77      	SBRS R23,7
0022ad c002      	RJMP __CHKSD1
0022ae df43      	RCALL __ANEGD1
0022af 9468      	SET
          __CHKSD1:
0022b0 ff97      	SBRS R25,7
0022b1 c00b      	RJMP __CHKSD2
0022b2 2400      	CLR  R0
0022b3 95a0      	COM  R26
0022b4 95b0      	COM  R27
0022b5 9580      	COM  R24
0022b6 9590      	COM  R25
0022b7 9611      	ADIW R26,1
0022b8 1d80      	ADC  R24,R0
0022b9 1d90      	ADC  R25,R0
0022ba f800      	BLD  R0,0
0022bb 9403      	INC  R0
0022bc fa00      	BST  R0,0
          __CHKSD2:
0022bd 9508      	RET
         
          __GETW1P:
0022be 91ed      	LD   R30,X+
0022bf 91fc      	LD   R31,X
0022c0 9711      	SBIW R26,1
0022c1 9508      	RET
         
          __GETD1P:
0022c2 91ed      	LD   R30,X+
0022c3 91fd      	LD   R31,X+
0022c4 916d      	LD   R22,X+
0022c5 917c      	LD   R23,X
0022c6 9713      	SBIW R26,3
0022c7 9508      	RET
         
          __PUTDP1:
0022c8 93ed      	ST   X+,R30
0022c9 93fd      	ST   X+,R31
0022ca 936d      	ST   X+,R22
0022cb 937c      	ST   X,R23
0022cc 9508      	RET
         
          __GETW1PF:
0022cd 9005      	LPM  R0,Z+
0022ce 91f4      	LPM  R31,Z
0022cf 2de0      	MOV  R30,R0
0022d0 9508      	RET
         
          __PUTPARD1:
0022d1 937a      	ST   -Y,R23
0022d2 936a      	ST   -Y,R22
0022d3 93fa      	ST   -Y,R31
0022d4 93ea      	ST   -Y,R30
0022d5 9508      	RET
         
          __PUTPARD2:
0022d6 939a      	ST   -Y,R25
0022d7 938a      	ST   -Y,R24
0022d8 93ba      	ST   -Y,R27
0022d9 93aa      	ST   -Y,R26
0022da 9508      	RET
         
          __SWAPD12:
0022db 2e18      	MOV  R1,R24
0022dc 2f86      	MOV  R24,R22
0022dd 2d61      	MOV  R22,R1
0022de 2e19      	MOV  R1,R25
0022df 2f97      	MOV  R25,R23
0022e0 2d71      	MOV  R23,R1
         
          __SWAPW12:
0022e1 2e1b      	MOV  R1,R27
0022e2 2fbf      	MOV  R27,R31
0022e3 2df1      	MOV  R31,R1
         
          __SWAPB12:
0022e4 2e1a      	MOV  R1,R26
0022e5 2fae      	MOV  R26,R30
0022e6 2de1      	MOV  R30,R1
0022e7 9508      	RET
         
          __CPD10:
0022e8 9730      	SBIW R30,0
0022e9 4060      	SBCI R22,0
0022ea 4070      	SBCI R23,0
0022eb 9508      	RET
         
          __CPW02:
0022ec 2400      	CLR  R0
0022ed 160a      	CP   R0,R26
0022ee 060b      	CPC  R0,R27
0022ef 9508      	RET
         
          __CPD20:
0022f0 9710      	SBIW R26,0
0022f1 4080      	SBCI R24,0
0022f2 4090      	SBCI R25,0
0022f3 9508      	RET
         
          __CPD02:
0022f4 2400      	CLR  R0
0022f5 160a      	CP   R0,R26
0022f6 060b      	CPC  R0,R27
0022f7 0608      	CPC  R0,R24
0022f8 0609      	CPC  R0,R25
0022f9 9508      	RET
         
          __CPD12:
0022fa 17ea      	CP   R30,R26
0022fb 07fb      	CPC  R31,R27
0022fc 0768      	CPC  R22,R24
0022fd 0779      	CPC  R23,R25
0022fe 9508      	RET
         
          __CPD21:
0022ff 17ae      	CP   R26,R30
002300 07bf      	CPC  R27,R31
002301 0786      	CPC  R24,R22
002302 0797      	CPC  R25,R23
002303 9508      	RET
         
          __SAVELOCR6:
002304 935a      	ST   -Y,R21
          __SAVELOCR5:
002305 934a      	ST   -Y,R20
          __SAVELOCR4:
002306 933a      	ST   -Y,R19
          __SAVELOCR3:
002307 932a      	ST   -Y,R18
          __SAVELOCR2:
002308 931a      	ST   -Y,R17
002309 930a      	ST   -Y,R16
00230a 9508      	RET
         
          __LOADLOCR6:
00230b 815d      	LDD  R21,Y+5
          __LOADLOCR5:
00230c 814c      	LDD  R20,Y+4
          __LOADLOCR4:
00230d 813b      	LDD  R19,Y+3
          __LOADLOCR3:
00230e 812a      	LDD  R18,Y+2
          __LOADLOCR2:
00230f 8119      	LDD  R17,Y+1
002310 8108      	LD   R16,Y
002311 9508      	RET
         
         ;END OF CODE MARKER
          __END_OF_CODE:

Assembly complete with no errors.
